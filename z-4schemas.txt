Here’s how the files are logically structured, and what classes belong in each one based on their responsibilities.

1. admin_hostel_assignment.py
Responsibility: Everything about which admin is assigned to which hostel, including create/update/revoke and list views, plus per-admin / per-hostel assignment summaries.

Classes that should live here:

AdminHostelAssignment
Read model for a single admin–hostel assignment, with:

identity (assignment_id, admin_id, hostel_id)
permissions & permission level
activity metrics (access count, last_accessed, etc.)
revocation metadata
computed analytics (duration, activity_level, etc.)
AssignmentCreate
Write model for creating a new assignment:

admin_id, hostel_id, permission_level, permissions, is_primary
metadata: assignment_notes, effective_date
notification toggles: notify_admin, send_welcome_email
strong validation around LIMITED_ACCESS and effective dates.
AssignmentUpdate
Write model for updating an existing assignment:

updatable fields: permission_level, permissions, is_primary, is_active, assignment_notes, update_reason
validation that at least one field changes and that LIMITED_ACCESS has permissions.
BulkAssignment
Write model for bulk assigning a single admin to many hostels:

admin_id, hostel_ids, permission_level, permissions
primary_hostel_id, strategy flags (skip_existing, update_existing, force_primary)
shared notes & notifications.
validator for hostel_ids uniqueness, primary in list, and strategy consistency.
RevokeAssignment
Write model for revoking a single assignment:

assignment_id, revoke_reason
revocation timing (effective_date, immediate_revocation)
optional transfer_to_admin_id + handover_notes
notification & retention flags.
AssignmentList
Read model for all assignments of a single admin:

admin metadata
counts: total_hostels, active_hostels, inactive_hostels
primary hostel info
activity stats and performance metrics
full assignments: List[AdminHostelAssignment]
computed distribution and utilization metrics.
HostelAdminItem
Read model for a single admin in the context of one hostel:

who the admin is
assignment details and activity metrics
specific_permissions + computed performance score and permission summary.
HostelAdminList
Read model for all admins assigned to one hostel:

hostel metadata
admin counts & primary admin
coverage info, activity
admins: List[HostelAdminItem]
coverage & permission coverage analytics.
This file should remain focused on assignment lifecycle and lists, not UI-only selector or dashboard summaries.

2. admin_override.py
Responsibility: The admin override system – how admins override supervisor decisions, and analytics on that.

Classes that should live here:

AdminOverrideRequest
Write model for initiating an override:

who/what is being overridden (supervisor_id, hostel_id, entity_type, entity_id)
override_type, reason, original_action, override_action
notify_supervisor
validators for types, entity types, and minimal reason quality.
OverrideLog
Read model for a single historical override event:

who did it (admin_*) and which supervisor/hostel
override details
created_at
computed short_reason, override_category, hours_since_override.
OverrideReason
Static/config model of predefined reason codes:

reason_code, reason_text, category
flag for requires_detailed_explanation.
OverrideSummary
Aggregated override stats for a period for one admin:

admin_id, period_start, period_end
total_overrides
breakdowns: overrides_by_type, overrides_by_supervisor, overrides_by_hostel
trend (override_trend)
computed averages and concentration metrics.
SupervisorOverrideStats
Per-supervisor override analytics:

baseline counts (total_actions, total_overrides)
override_rate
overrides_by_type, common_override_reasons
recent_trend
consistency validator vs total_actions
computed flags like is_concerning, performance_indicator.
This module is purely about override events and their analytics.

3. admin_permissions.py
Responsibility: Permission modeling: what capabilities exist, what roles have them, and result of permission checks.

Classes that should live here:

AdminPermissions
Per-admin granular permission set (all the can_* flags) for one hostel.

convenience helpers: has_permission, get_granted_permissions, permission_count, etc.
PermissionMatrix
Mapping from role -> list of permission keys:

for UI, policy definition, and auth logic
methods: get_role_permissions, role_has_permission.
RolePermissions
Describes a single role’s permission set with description:

role: UserRole, permissions, description
permission_categories property to group by functional area.
PermissionCheck
Result model of a permission evaluation:

user_id, hostel_id, permission_key
has_permission, reason
validators ensure valid key and reason on denial
computed access_status and permission_category.
This file should stay focused on permission structure / checks, not assignment or UI.

4. hostel_context.py
Responsibility: Runtime “active hostel” context for an admin, plus context switching and history.

Classes that should live here:

HostelContext
Current active context/session:

active hostel metadata
permission info for that hostel
session timing, stats, revenue snapshot
computed session duration, health score, priority, etc.
HostelSwitchRequest
Write model for requesting a context switch:

hostel_id
flags like save_current_session, refresh_dashboard, etc.
navigation fields (return_url, switch_reason) with validation.
ActiveHostelResponse
Read model returned after a switch:

previous vs active hostel
permissions, quick stats, switch timing
UI guidance (message, dashboard_url, suggested_actions)
computed indicators.
ContextSwitch
Read model representing a single context switch record:

from/to hostel, timestamps, reason, trigger
activity metrics for that session
computed productivity & efficiency metrics.
ContextHistory
Aggregated history of context switches for an admin:

date range, list of switches
summary metrics (totals, averages)
computed patterns & recommendations.
This module is the session-level / context-level layer, not assignment or pure dashboard.

5. hostel_selector.py
Responsibility: Schemas for the hostel selector UI (dropdown/sidebar), plus recent and favorite hostels.

Classes that should live here:

HostelSelectorItem
One hostel row in a selector:

identity + basic info
flags: active, primary, favorite, recent
small stats (occupancy, beds, tasks, alerts)
permission summary and access metrics
computed UI helpers: requires_attention, status color, display_label, quick summary.
HostelSelectorResponse
Root response for the selector:

admin metadata
total/active counts
hostels: List[HostelSelectorItem]
ID lists: recent, favorites, primary, attention_required
summary totals and computed category splits & summary text.
RecentHostelItem
Per-hostel recent access item:

counts & timestamps
session duration averages
last occupancy & pending tasks
computed hours_since_access, access_frequency_score, is_frequent.
RecentHostels
Root recent-hostels response:

admin_id
hostels: List[RecentHostelItem]
total_recent_hostels, most_frequent_hostel_id, tracking_period_days
computed access_pattern_summary.
FavoriteHostelItem
A single favorite hostel with customization:

hostel info
added_to_favorites, custom_label, notes, display_order
quick stats and access tracking
computed days_in_favorites, display_name, is_recently_accessed.
FavoriteHostels
Root favorites list:

admin_id
hostels: List[FavoriteHostelItem]
total_favorites, max_favorites_allowed
computed can_add_more, favorites_by_city.
UpdateFavoriteRequest
Write model to add/remove favorites and modify metadata:

hostel_id, is_favorite, optional customization fields
validators clean text and strip customization when removing.
This file is UI/UX oriented, not hardcore business logic.

6. multi_hostel_dashboard.py
Responsibility: Read-only analytics for the multi-hostel admin dashboard – portfolio stats, per-hostel quick stats, cross-hostel comparisons.

Classes that should live here:

HostelQuickStats
Per-hostel quick card for dashboard:

capacity/occupancy, workload, financials, satisfaction
admin access info
computed financial_risk, requires_attention, status_indicator, etc.
AggregatedStats
Portfolio-level aggregated stats:

totals across hostels
occupancy averages
backlog & complaint counts
revenue/outstanding
satisfaction averages
computed utilization & financial health indicators.
HostelTaskSummary
Portfolio-wide task snapshot:

total/pending/overdue/urgent/completed tasks
optional tasks_by_hostel
computed ratios and health_status.
TopPerformer
Description of a top-performing hostel:

hostel identity + type
performance_score, rank, key_metric, key_metric_value
computed label.
BottomPerformer
Equivalent for worst-performing hostels.

HostelMetricComparison
For one metric:

metric_name, unit
portfolio average
best/worst hostel + values
computed spread and variation_index.
CrossHostelComparison
Wrapper grouping metric comparisons and performer lists:

metrics, top_performers, bottom_performers
computed has_significant_variation, metrics_by_name.
MultiHostelDashboard
Root dashboard response:

admin info, generated_at, period range
aggregated_stats, hostels: List[HostelQuickStats]
task_summary
optional cross_hostel_comparison
active_hostel_id for UI
computed period, attention-related indicators
validator ensures period & admin_id consistency.
This module should remain read-only / analytic, not used for mutations.

7. __init__.py
Responsibility: Export a clean public API surface for app.schemas.admin.


=======================================================================================================================================


Below is a clear, file‑by‑file map of what classes (and key enums) belong in each analytics schema file you shared.

booking_analytics.py
Public schemas (in __all__):

BookingKPI

KPIs for bookings: total/confirmed/cancelled/rejected/pending, conversion & cancellation rates, average lead time, approval & completion rates.
BookingTrendPoint

Per‑day booking metrics: total, statuses, revenue, and daily conversion rate.
BookingFunnel

Funnel from page views → form starts → submissions → confirmations; includes counts and conversion rates plus drop‑off analysis.
CancellationAnalytics

Cancellation counts, cancellation rate, breakdown by reason/status, timing (within 24h / week), and early cancellation rate.
BookingSourceMetrics

Per‑source booking performance: counts, conversion rate, revenue totals, averages, revenue per confirmed booking.
BookingAnalyticsSummary

Top‑level booking report combining: hostel info, period, BookingKPI, trend list, funnel, cancellations, bookings by source, detailed source metrics, and trend summary utilities.
Enums & helpers (non‑exported in __all__ but present):

Type aliases: DecimalPercentage, DecimalCurrency.
complaint_analytics.py
Public schemas (in __all__):

SLAMetrics

SLA coverage, met/breached counts, compliance rate, average SLA buffer, and at‑risk estimate.
ComplaintKPI

Core complaint KPIs: volumes by status, resolution times, SLA compliance, escalation & reopen rates, satisfaction score, resolution rate, backlog, and efficiency score.
ComplaintTrendPoint

Per‑day complaint snapshot: totals, open, resolved, escalated, SLA‑breached, and daily resolution rate.
ComplaintTrend

Time series of ComplaintTrendPoints: validates chronological order, overall trend direction, and peak complaint date.
CategoryBreakdown

Per‑category complaint stats: count, share of total, average resolution time, open/resolved counts, and resolution rate.
PriorityBreakdown

Per‑priority stats: count, share of total, resolution time, SLA compliance, and priority score for sorting.
ComplaintDashboard

Full complaint dashboard: hostel/period, KPIs, SLA metrics, trend, breakdowns, derived insights, and validations (e.g., category percentages sum ~100%).
Enums & helpers:

Type aliases: DecimalPercentage, DecimalNonNegative.
custom_reports.py
Public items (in __all__):

FilterOperator (Enum)

All supported filter operators (eq, ne, gt, in, between, is_null, date_before, etc.).
AggregationType (Enum)

Aggregations: sum, avg, min, max, count, count_distinct, none.
ReportFormat (Enum)

Output formats: table, csv, excel, json, pdf.
ReportModule (Enum)

Modules: bookings, payments, complaints, maintenance, attendance, etc.
CustomReportFilter

A single filter clause: field, operator, value(s), validation of operator/value compatibility, and a human‑readable filter_display.
CustomReportField

Field included in a report: name, display label, aggregation, display format, effective_label.
CustomReportRequest (inherits BaseCreateSchema)

Full report request: name, module, period, fields, filters, group_by, sorting, pagination, output options; validates grouping vs aggregation and sort field presence; provides to_sql_hint().
CustomReportDefinition (inherits BaseResponseSchema)

Saved report configuration with ownership, sharing, usage stats, timestamps, derived is_shared and complexity_score.
CustomReportResult

Executed report result: rows, counts, column definitions, summary, totals, charts, applied filters/grouping, pagination markers, and get_export_filename().
ReportExportRequest

Request for exporting an existing result: result id, format, include metadata/filters/summary flags.
ReportSchedule

Recurring schedule config: which report, frequency, time, day of week/month, recipients, format, status, run history; validates recipient emails.
dashboard_analytics.py
Public schemas (in __all__):

KPIResponse

A single dashboard KPI: name, key, value, trend vs previous, target, interpretation rules, formatting, color/icon hints, and derived is_on_target / performance_status plus format_value().
QuickStats

Snapshot metrics: hostels, students, visitors, today’s check‑ins/outs, complaints, maintenance, revenues, outstanding/overdue payments; plus occupancy, complaint urgency, and collection health statuses.
TimeseriesPoint

Generic time‑series point: date, value, optional label/metadata, with formatted date.
AlertNotification

Dashboard alert: severity, title, message, action link, timestamps, dismissed flag, and is_active logic.
DashboardWidget

Widget configuration: id, type, title, position, size, data source, refresh, visibility.
DashboardMetrics

Scope‑level dashboard: scope type/id/name, period, KPIs list, QuickStats, several time series (revenue, occupancy, bookings, complaints), alerts, widgets, timeseries ordering validation, and methods for active alert counts and KPI retrieval.
RoleSpecificDashboard

Role‑based dashboard: role, user, sections, per‑section DashboardMetrics/stats/KPIs, accessible features, preferences, total KPI count, has_critical_alerts, and helpers to get section metrics or aggregate alerts.
Helpers:

Type aliases: DecimalPercentage, DecimalNonNegative.
financial_analytics.py
Public schemas/enums (in __all__):

RevenueCategory (Enum)

Revenue types: booking, rent, mess, utilities, late_fees, security_deposit, other.
ExpenseCategory (Enum)

Expense categories: maintenance, staff_salaries, utilities, supplies, marketing, administrative, depreciation, insurance, taxes, other.
RevenueBreakdown

Revenue totals by main components and by hostel/payment type; billed/collected/pending amounts; validates that components sum to total; collection rate, primary source, concentration risk.
ExpenseBreakdown

Expense totals by category and hostel, detailed categories, fixed vs variable; validates sum of components; largest category and staff expense ratio.
FinancialRatios

Profitability, efficiency, collection, and cost ratios (margins, revenue per bed/student, collection efficiency, cost ratios) with derived profitability_status.
BudgetComparison

Budget vs actual per category: budgeted, actual, variance amount/percentage, plus is_favorable and variance severity.
TaxSummary

Taxable vs exempt revenue, GST collected/paid/payable, TDS, estimated income tax, and effective_tax_rate.
ProfitAndLossReport

P&L for hostel/platform: scope, period, revenue & expenses breakdowns, gross/operating/net profit and margins (plus legacy profit margin), ratios, tax summary, budget comparisons; validates net profit consistency; profitability flags and performance summary.
CashflowPoint

Per‑day cashflow: date, inflow, outflow, net flow, running balance; validates net calculation; is_positive_flow.
CashflowSummary

Cashflow statement: scope, balances, inflows/outflows (current and legacy), breakdowns, timeseries, liquidity metrics, consistency validation, chronological order, cashflow health, burn‑rate days, and operating cash ratio.
FinancialReport

Top‑level financial report: scope, period, embedded ProfitAndLossReport and CashflowSummary, key ratios (collection, overdue, revenue per student/bed, occupancy, ADR, YoY growth), derived financial_health_score, performance_grade, and an executive summary.
Helpers:

Type aliases: DecimalCurrency, DecimalPercentage, DecimalAmount, and common round_to_2_places.
occupancy_analytics.py
Public schemas/enums (in __all__):

ForecastModel (Enum)

Models: moving_average, exponential_smoothing, arima, linear_regression, simple_extrapolation, ml_based.
OccupancyKPI

Hostel‑level occupancy KPIs: current/average/peak/low %; total/occupied/available/reserved/maintenance beds; utilization rate, turnover rate; occupancy status, capacity pressure, vacancy rate.
OccupancyTrendPoint

Daily occupancy point: date, occupancy %, occupied & total beds, check‑ins/outs, and net change.
OccupancyByRoomType

Per room‑type occupancy: counts, percentage, rates and revenue metrics (average rate, total revenue, revenue per bed, available beds).
OccupancyByFloor

Per‑floor occupancy: floor id/name, room/bed counts, occupied beds, occupancy %.
ForecastPoint

Single forecast: date, predicted occupancy % and occupied beds, optional confidence bounds and level, with bounds validation.
SeasonalPattern

Seasonal pattern descriptor: name, months, average occupancy, variance, confidence, and is_high_season.
ForecastData

Forecast set: horizon, list of ForecastPoints, model info, training data info, seasonal patterns, timestamps; validates chronology and rough horizon match; average, peak, and low forecast dates.
OccupancyReport

Full occupancy report: hostel, period, OccupancyKPI, daily trend, breakdowns by room type/floor, legacy floor dict, forecast, seasonal patterns; validates trend order and provides best/worst room types, trend direction, and optimization insights.
Helpers:

Type aliases: DecimalPercentage, DecimalNonNegative, round_to_2_places.
platform_analytics.py
Public schemas/enums (in __all__):

TenantStatus (Enum)

trial, active, suspended, churned, inactive.
TenantMetrics

Per‑tenant metrics: subscription details (plan, status, start, MRR), usage (students, beds, occupancy), logins/DAU/MAU, payment status, health & churn risk scores, with is_at_risk, revenue per bed, and engagement status.
PlatformMetrics

Global platform counts: hostels by status, users by role, engagement metrics (DAU/MAU, peak sessions), capacity and occupancy, activation rate, trial conversion potential, and placeholder for user growth rate.
MonthlyMetric

Month‑wise metric: YYYY-MM, numeric value, label, and human‑friendly month_name.
GrowthMetrics

Growth KPIs across hostels, revenue, users, MRR; time series per month; validation of growth consistency; is_growing, a weighted growth_health_score, and optional CAGR.
ChurnAnalysis

Tenant churn metrics: churn count/rate, revenue lost, reasons, at‑risk segment and list, retention rate, and churn_risk_status.
SystemHealthMetrics

Infra health: uptime/downtime/incidents, response times percentiles, error rates, resource utilization, DB metrics; derived health_status and performance_grade.
RevenueMetrics

Platform revenue analytics: totals and breakdowns, MRR/ARR, revenue by plan, ARPU, LTV, new/expansion/churned revenue; revenue_diversity_score and net new MRR.
PlatformUsageAnalytics

Usage & performance: total requests/sessions, RPS, error rate, per‑module requests, feature adoption rates, response times, resource & storage usage; most_used_module, least adopted features, and platform_health_indicator.
Helpers:

Type aliases: DecimalPercentage, DecimalNonNegative, DecimalAmount, round_to_2_places.
supervisor_analytics.py
Public schemas (in __all__):

SupervisorWorkload

Current workload: counts of active complaints/maintenance/pending tasks, capacity, utilization, urgent/overdue; derived available capacity and workload status.
SupervisorPerformanceRating

Dimension scores (efficiency, quality, responsiveness, student satisfaction, reliability) and overall rating; derived grade, strengths, and improvement areas.
SupervisorKPI

Individual supervisor KPIs: supervisor & hostel identity, period, workloads for complaints & maintenance, attendance marking, time‑based metrics, SLA compliance, quality (reopens/escalations), feedback ratings, overall performance, optional SupervisorWorkload and SupervisorPerformanceRating; derived resolution/completion/reopen rates and performance status.
SupervisorTrendPoint

Periodic performance point: label, start/end dates, completed complaints/maintenance, performance score, feedback score, and total tasks completed.
SupervisorDashboardAnalytics

Per‑supervisor dashboard: identity, hostel, period, SupervisorKPI, trend list, complaint/maintenance breakdowns, targets, target achievement; enforces chronological trend and provides most common complaint category and improvement trend.
SupervisorComparison

Comparative view across supervisors: scope, period, list of SupervisorKPIs, rankings by various metrics, average stats; performance variance and top performer, plus method to get rank by metric.
TeamAnalytics

Team/hostel‑level metrics: supervisor counts, team tasks assigned/completed and completion rate, average performance/SLA, workload balance, top performer IDs, and qualitative team efficiency level.
Helpers:

Type aliases: DecimalPercentage, DecimalNonNegative, DecimalRating.
visitor_analytics.py
Public schemas/enums (in __all__):

FunnelStage (Enum)

Visitor stages: visit, search, view_hostel, compare, register, book, confirm.
TrafficSourceMetrics

Per‑source traffic metrics: visits/unique/page‑views, engagement (session duration, pages/session, bounce), conversions (registrations, bookings, confirmations), rates, revenue/costs, ROI; derived engagement & quality scores.
VisitorFunnel

Full visitor funnel: visits → search → views → registration → booking → confirmation; rates at each stage, drop‑offs, total drop‑offs, largest drop‑off stage, and funnel efficiency score.
TrafficSourceAnalytics

Aggregated traffic by source: visits and conversion counts/rates per source, plus list of TrafficSourceMetrics; identifies best converting, highest volume, and best ROI source.
SearchBehavior

Search usage: counts, top cities/keywords/amenities, filters and price ranges, result counts, zero‑result searches & rate; derived search effectiveness score.
EngagementMetrics

Engagement depth: hostels viewed, time on hostel pages, pages/session, feature usage (comparison, reviews, photos), CTA usage (inquiry form views/submissions, conversion); derived engagement level.
VisitorBehaviorAnalytics

Combined visitor behavior: period, SearchBehavior, EngagementMetrics, exit pages/reasons, bounce rate, session duration, return visitor rate; derived visitor quality score and get_optimization_recommendations().
ConversionPathAnalysis

Multi‑touch conversion paths: average touches & days to conversion, top paths, first & last touch attribution revenue; derived conversion complexity.
Helpers:

Type aliases: DecimalPercentage, DecimalNonNegative, round_to_2_places.
analytics/__init__.py
This file does not define new classes. It:

Imports and re‑exports all the main analytics schemas and enums from the modules above.
Defines the __all__ list so consumers can do:


====================================================================================================================================

Below is a clear, file‑by‑file map of what classes (and key enums) belong in each analytics schema file you shared.

booking_analytics.py
Public schemas (in __all__):

BookingKPI

KPIs for bookings: total/confirmed/cancelled/rejected/pending, conversion & cancellation rates, average lead time, approval & completion rates.
BookingTrendPoint

Per‑day booking metrics: total, statuses, revenue, and daily conversion rate.
BookingFunnel

Funnel from page views → form starts → submissions → confirmations; includes counts and conversion rates plus drop‑off analysis.
CancellationAnalytics

Cancellation counts, cancellation rate, breakdown by reason/status, timing (within 24h / week), and early cancellation rate.
BookingSourceMetrics

Per‑source booking performance: counts, conversion rate, revenue totals, averages, revenue per confirmed booking.
BookingAnalyticsSummary

Top‑level booking report combining: hostel info, period, BookingKPI, trend list, funnel, cancellations, bookings by source, detailed source metrics, and trend summary utilities.
Enums & helpers (non‑exported in __all__ but present):

Type aliases: DecimalPercentage, DecimalCurrency.
complaint_analytics.py
Public schemas (in __all__):

SLAMetrics

SLA coverage, met/breached counts, compliance rate, average SLA buffer, and at‑risk estimate.
ComplaintKPI

Core complaint KPIs: volumes by status, resolution times, SLA compliance, escalation & reopen rates, satisfaction score, resolution rate, backlog, and efficiency score.
ComplaintTrendPoint

Per‑day complaint snapshot: totals, open, resolved, escalated, SLA‑breached, and daily resolution rate.
ComplaintTrend

Time series of ComplaintTrendPoints: validates chronological order, overall trend direction, and peak complaint date.
CategoryBreakdown

Per‑category complaint stats: count, share of total, average resolution time, open/resolved counts, and resolution rate.
PriorityBreakdown

Per‑priority stats: count, share of total, resolution time, SLA compliance, and priority score for sorting.
ComplaintDashboard

Full complaint dashboard: hostel/period, KPIs, SLA metrics, trend, breakdowns, derived insights, and validations (e.g., category percentages sum ~100%).
Enums & helpers:

Type aliases: DecimalPercentage, DecimalNonNegative.
custom_reports.py
Public items (in __all__):

FilterOperator (Enum)

All supported filter operators (eq, ne, gt, in, between, is_null, date_before, etc.).
AggregationType (Enum)

Aggregations: sum, avg, min, max, count, count_distinct, none.
ReportFormat (Enum)

Output formats: table, csv, excel, json, pdf.
ReportModule (Enum)

Modules: bookings, payments, complaints, maintenance, attendance, etc.
CustomReportFilter

A single filter clause: field, operator, value(s), validation of operator/value compatibility, and a human‑readable filter_display.
CustomReportField

Field included in a report: name, display label, aggregation, display format, effective_label.
CustomReportRequest (inherits BaseCreateSchema)

Full report request: name, module, period, fields, filters, group_by, sorting, pagination, output options; validates grouping vs aggregation and sort field presence; provides to_sql_hint().
CustomReportDefinition (inherits BaseResponseSchema)

Saved report configuration with ownership, sharing, usage stats, timestamps, derived is_shared and complexity_score.
CustomReportResult

Executed report result: rows, counts, column definitions, summary, totals, charts, applied filters/grouping, pagination markers, and get_export_filename().
ReportExportRequest

Request for exporting an existing result: result id, format, include metadata/filters/summary flags.
ReportSchedule

Recurring schedule config: which report, frequency, time, day of week/month, recipients, format, status, run history; validates recipient emails.
dashboard_analytics.py
Public schemas (in __all__):

KPIResponse

A single dashboard KPI: name, key, value, trend vs previous, target, interpretation rules, formatting, color/icon hints, and derived is_on_target / performance_status plus format_value().
QuickStats

Snapshot metrics: hostels, students, visitors, today’s check‑ins/outs, complaints, maintenance, revenues, outstanding/overdue payments; plus occupancy, complaint urgency, and collection health statuses.
TimeseriesPoint

Generic time‑series point: date, value, optional label/metadata, with formatted date.
AlertNotification

Dashboard alert: severity, title, message, action link, timestamps, dismissed flag, and is_active logic.
DashboardWidget

Widget configuration: id, type, title, position, size, data source, refresh, visibility.
DashboardMetrics

Scope‑level dashboard: scope type/id/name, period, KPIs list, QuickStats, several time series (revenue, occupancy, bookings, complaints), alerts, widgets, timeseries ordering validation, and methods for active alert counts and KPI retrieval.
RoleSpecificDashboard

Role‑based dashboard: role, user, sections, per‑section DashboardMetrics/stats/KPIs, accessible features, preferences, total KPI count, has_critical_alerts, and helpers to get section metrics or aggregate alerts.
Helpers:

Type aliases: DecimalPercentage, DecimalNonNegative.
financial_analytics.py
Public schemas/enums (in __all__):

RevenueCategory (Enum)

Revenue types: booking, rent, mess, utilities, late_fees, security_deposit, other.
ExpenseCategory (Enum)

Expense categories: maintenance, staff_salaries, utilities, supplies, marketing, administrative, depreciation, insurance, taxes, other.
RevenueBreakdown

Revenue totals by main components and by hostel/payment type; billed/collected/pending amounts; validates that components sum to total; collection rate, primary source, concentration risk.
ExpenseBreakdown

Expense totals by category and hostel, detailed categories, fixed vs variable; validates sum of components; largest category and staff expense ratio.
FinancialRatios

Profitability, efficiency, collection, and cost ratios (margins, revenue per bed/student, collection efficiency, cost ratios) with derived profitability_status.
BudgetComparison

Budget vs actual per category: budgeted, actual, variance amount/percentage, plus is_favorable and variance severity.
TaxSummary

Taxable vs exempt revenue, GST collected/paid/payable, TDS, estimated income tax, and effective_tax_rate.
ProfitAndLossReport

P&L for hostel/platform: scope, period, revenue & expenses breakdowns, gross/operating/net profit and margins (plus legacy profit margin), ratios, tax summary, budget comparisons; validates net profit consistency; profitability flags and performance summary.
CashflowPoint

Per‑day cashflow: date, inflow, outflow, net flow, running balance; validates net calculation; is_positive_flow.
CashflowSummary

Cashflow statement: scope, balances, inflows/outflows (current and legacy), breakdowns, timeseries, liquidity metrics, consistency validation, chronological order, cashflow health, burn‑rate days, and operating cash ratio.
FinancialReport

Top‑level financial report: scope, period, embedded ProfitAndLossReport and CashflowSummary, key ratios (collection, overdue, revenue per student/bed, occupancy, ADR, YoY growth), derived financial_health_score, performance_grade, and an executive summary.
Helpers:

Type aliases: DecimalCurrency, DecimalPercentage, DecimalAmount, and common round_to_2_places.
occupancy_analytics.py
Public schemas/enums (in __all__):

ForecastModel (Enum)

Models: moving_average, exponential_smoothing, arima, linear_regression, simple_extrapolation, ml_based.
OccupancyKPI

Hostel‑level occupancy KPIs: current/average/peak/low %; total/occupied/available/reserved/maintenance beds; utilization rate, turnover rate; occupancy status, capacity pressure, vacancy rate.
OccupancyTrendPoint

Daily occupancy point: date, occupancy %, occupied & total beds, check‑ins/outs, and net change.
OccupancyByRoomType

Per room‑type occupancy: counts, percentage, rates and revenue metrics (average rate, total revenue, revenue per bed, available beds).
OccupancyByFloor

Per‑floor occupancy: floor id/name, room/bed counts, occupied beds, occupancy %.
ForecastPoint

Single forecast: date, predicted occupancy % and occupied beds, optional confidence bounds and level, with bounds validation.
SeasonalPattern

Seasonal pattern descriptor: name, months, average occupancy, variance, confidence, and is_high_season.
ForecastData

Forecast set: horizon, list of ForecastPoints, model info, training data info, seasonal patterns, timestamps; validates chronology and rough horizon match; average, peak, and low forecast dates.
OccupancyReport

Full occupancy report: hostel, period, OccupancyKPI, daily trend, breakdowns by room type/floor, legacy floor dict, forecast, seasonal patterns; validates trend order and provides best/worst room types, trend direction, and optimization insights.
Helpers:

Type aliases: DecimalPercentage, DecimalNonNegative, round_to_2_places.
platform_analytics.py
Public schemas/enums (in __all__):

TenantStatus (Enum)

trial, active, suspended, churned, inactive.
TenantMetrics

Per‑tenant metrics: subscription details (plan, status, start, MRR), usage (students, beds, occupancy), logins/DAU/MAU, payment status, health & churn risk scores, with is_at_risk, revenue per bed, and engagement status.
PlatformMetrics

Global platform counts: hostels by status, users by role, engagement metrics (DAU/MAU, peak sessions), capacity and occupancy, activation rate, trial conversion potential, and placeholder for user growth rate.
MonthlyMetric

Month‑wise metric: YYYY-MM, numeric value, label, and human‑friendly month_name.
GrowthMetrics

Growth KPIs across hostels, revenue, users, MRR; time series per month; validation of growth consistency; is_growing, a weighted growth_health_score, and optional CAGR.
ChurnAnalysis

Tenant churn metrics: churn count/rate, revenue lost, reasons, at‑risk segment and list, retention rate, and churn_risk_status.
SystemHealthMetrics

Infra health: uptime/downtime/incidents, response times percentiles, error rates, resource utilization, DB metrics; derived health_status and performance_grade.
RevenueMetrics

Platform revenue analytics: totals and breakdowns, MRR/ARR, revenue by plan, ARPU, LTV, new/expansion/churned revenue; revenue_diversity_score and net new MRR.
PlatformUsageAnalytics

Usage & performance: total requests/sessions, RPS, error rate, per‑module requests, feature adoption rates, response times, resource & storage usage; most_used_module, least adopted features, and platform_health_indicator.
Helpers:

Type aliases: DecimalPercentage, DecimalNonNegative, DecimalAmount, round_to_2_places.
supervisor_analytics.py
Public schemas (in __all__):

SupervisorWorkload

Current workload: counts of active complaints/maintenance/pending tasks, capacity, utilization, urgent/overdue; derived available capacity and workload status.
SupervisorPerformanceRating

Dimension scores (efficiency, quality, responsiveness, student satisfaction, reliability) and overall rating; derived grade, strengths, and improvement areas.
SupervisorKPI

Individual supervisor KPIs: supervisor & hostel identity, period, workloads for complaints & maintenance, attendance marking, time‑based metrics, SLA compliance, quality (reopens/escalations), feedback ratings, overall performance, optional SupervisorWorkload and SupervisorPerformanceRating; derived resolution/completion/reopen rates and performance status.
SupervisorTrendPoint

Periodic performance point: label, start/end dates, completed complaints/maintenance, performance score, feedback score, and total tasks completed.
SupervisorDashboardAnalytics

Per‑supervisor dashboard: identity, hostel, period, SupervisorKPI, trend list, complaint/maintenance breakdowns, targets, target achievement; enforces chronological trend and provides most common complaint category and improvement trend.
SupervisorComparison

Comparative view across supervisors: scope, period, list of SupervisorKPIs, rankings by various metrics, average stats; performance variance and top performer, plus method to get rank by metric.
TeamAnalytics

Team/hostel‑level metrics: supervisor counts, team tasks assigned/completed and completion rate, average performance/SLA, workload balance, top performer IDs, and qualitative team efficiency level.
Helpers:

Type aliases: DecimalPercentage, DecimalNonNegative, DecimalRating.
visitor_analytics.py
Public schemas/enums (in __all__):

FunnelStage (Enum)

Visitor stages: visit, search, view_hostel, compare, register, book, confirm.
TrafficSourceMetrics

Per‑source traffic metrics: visits/unique/page‑views, engagement (session duration, pages/session, bounce), conversions (registrations, bookings, confirmations), rates, revenue/costs, ROI; derived engagement & quality scores.
VisitorFunnel

Full visitor funnel: visits → search → views → registration → booking → confirmation; rates at each stage, drop‑offs, total drop‑offs, largest drop‑off stage, and funnel efficiency score.
TrafficSourceAnalytics

Aggregated traffic by source: visits and conversion counts/rates per source, plus list of TrafficSourceMetrics; identifies best converting, highest volume, and best ROI source.
SearchBehavior

Search usage: counts, top cities/keywords/amenities, filters and price ranges, result counts, zero‑result searches & rate; derived search effectiveness score.
EngagementMetrics

Engagement depth: hostels viewed, time on hostel pages, pages/session, feature usage (comparison, reviews, photos), CTA usage (inquiry form views/submissions, conversion); derived engagement level.
VisitorBehaviorAnalytics

Combined visitor behavior: period, SearchBehavior, EngagementMetrics, exit pages/reasons, bounce rate, session duration, return visitor rate; derived visitor quality score and get_optimization_recommendations().
ConversionPathAnalysis

Multi‑touch conversion paths: average touches & days to conversion, top paths, first & last touch attribution revenue; derived conversion complexity.
Helpers:

Type aliases: DecimalPercentage, DecimalNonNegative, round_to_2_places.
analytics/__init__.py
This file does not define new classes. It:

Imports and re‑exports all the main analytics schemas and enums from the modules above.
Defines the __all__ list so consumers can do:



==================================================================================================

file‑by‑file breakdown of what belongs where, and how to think about the classes/enums in each announcement schema module.

I’ll stick to: which classes/enums each file should contain and their roles, not re‑printing code.

1. announcement_base.py
Purpose: Core announcement data model + create/update/publish/unpublish commands.

Should contain:

Core base schema

AnnouncementBase
Shared fields for an announcement itself: hostel, title, content, category, priority, urgency, pinning, targeting fields (TargetAudience + room/student/floor lists), attachments, expires_at.
Validation of title/content, expiry in future, and consistent targeting vs. TargetAudience.
Create command

AnnouncementCreate (extends AnnouncementBase + BaseCreateSchema)
Adds created_by.
Adds delivery channel flags (send_email, send_sms, send_push).
Adds scheduling field scheduled_publish_at.
Adds acknowledgment logic (requires_acknowledgment, acknowledgment_deadline) and validations.
Ensures at least one delivery channel is enabled.
Update command

AnnouncementUpdate
Partial update: all fields optional.
Restricts to updatable aspects (title/content/category/priority/urgency/pinned/expires_at/attachments).
Validations that at least one field is supplied and that expiry is in the future.
Publish/unpublish commands

AnnouncementPublish
For publishing an existing draft: announcement_id, published_by, publish_immediately, optional scheduled_publish_at with timing validation.
AnnouncementUnpublish
For making an existing announcement invisible: announcement_id, unpublished_by, mandatory reason, notify_recipients.
In short: This file is about the canonical announcement model and basic lifecycle transitions (create, update, publish, unpublish).

2. announcement_response.py
Purpose: Read‑side views / DTOs for API responses.

Should contain:

Standard response

AnnouncementResponse
What you get back after create/fetch: hostel info, content, category/priority, visibility flags, creator, basic publication info, recipient counts, computed read_percentage and is_active.
Detailed view

AnnouncementDetail
Full detail page: includes targeting, attachments, scheduling, expiry, approval data, delivery flags/timestamps, acknowledgment settings, engagement counts and engagement_rate.
Computed fields: is_expired, is_scheduled, acknowledgment_rate, pending_acknowledgments, days_until_expiry.
List view item + list wrapper

AnnouncementListItem
Lightweight row: id, hostel, title, category/priority, urgent/pinned, creator, status, metrics, timestamps, student is_read, and computed read_percentage, is_active, display_priority.
AnnouncementList
Wrapper for paginated listing: hostel context, counts (total/active/pinned/urgent/pending_approval/scheduled), list of AnnouncementListItem, computed has_urgent.
Student‑focused view

StudentAnnouncementView
Minimal announcement for students: title/content/category/priority, urgent/pinned, attachments, creator, published/expires timestamps, student is_read/read_at, acknowledgment flags and timestamps, computed acknowledgment_overdue and requires_action.
Minimal preview

AnnouncementSummary
Very compact: id, title, category, priority, urgency, content_preview, published_at, created_by_name. Ideal for notifications / previews.
In short: This file is purely for read‑side models: different shapes of the same announcement for different consumers (admin list, detail, student, notification).

3. announcement_delivery.py
Purpose: Delivery configuration & runtime delivery state/analytics over channels.

Should contain:

Enums

DeliveryChannel (email, sms, push, in_app)
DeliveryStrategy (immediate, scheduled, batched)
DeliveryState (pending, processing, completed, failed, paused, cancelled)
Static configuration

DeliveryChannels
What channels are enabled, primary channel, fallback channels, validations that primary/fallbacks are actually enabled.
DeliveryConfig
Per‑announcement delivery setup: announcement_id, channels, strategy, batch settings, rate‑limiting, retries, with validations for batched strategy.
Runtime status & stats

ChannelDeliveryStats
Per‑channel stats: sent/delivered/failed/pending/bounced, delivery rate, timing metrics.
DeliveryStatus
Real‑time aggregate state across channels: totals per channel, global delivery state, rate, timeline, progress, estimated completion.
Failures & reports

FailedDelivery
Record of a single failed attempt: recipient, contact, channel, reason, codes, retry history, resolution.
DeliveryReport
Full analytics report: totals, rates, channel breakdown (map to ChannelDeliveryStats), limited list of FailedDelivery, timeline, report metadata.
Batch / control commands

BatchDelivery
Progress tracking of a batched job: batch counts, current batch stats, timing, status, paused state.
RetryDelivery
Command to retry: scope (failed only vs scope), channels, specific recipients, retry parameters.
DeliveryPause
Command to pause delivery: reason, optional auto‑resume with delay.
DeliveryResume
Command to resume: options like skipping failed or restarting the current batch.
In short: This file owns how announcements are delivered, their delivery lifecycle, and delivery analytics.

4. announcement_approval.py
Purpose: Approval workflow for announcements (supervisor → admin).

Should contain:

Enum

ApprovalStatus (pending, approved, rejected, not_required)
Commands

ApprovalRequest
Supervisor submits for approval: announcement_id, requested_by, optional justification, urgency, preferred approver, auto_publish_on_approval.
RejectionRequest
Admin rejects: announcement_id, rejected_by, required rejection_reason, optional suggestions, allow_resubmission.
BulkApproval
Approve/reject multiple: announcement_ids, approved, decided_by, notes, rejection_reason (if rejecting), publish_immediately, with unique‑ID and rejection‑reason validations.
Responses / views

ApprovalResponse
Result of approval/rejection: decision, approver info, timestamps, notes, auto_published flag, published_at, message.
ApprovalWorkflow
Full state of approval for an announcement: requirement, status, creator info, timeline, who it’s pending with, decision details, rejection details, can_resubmit, timing metrics.
PendingApprovalItem
Lightweight row for pending queue: id, title, category, creator, timing, urgency, content preview, targeting summary, estimated recipients, hours_pending.
SupervisorApprovalQueue
View for a supervisor: supervisor/hostel context, counts (total/urgent pending, approved/rejected today), list of PendingApprovalItem, avg approval time.
History

ApprovalHistory
Audit log entries: action (submitted/approved/rejected/resubmitted), from/to statuses, actor + role, notes, timestamp.
In short: This file is about who approves what, when, and tracking that workflow.

5. announcement_filters.py
Purpose: Query/search/export/bulk‑ops parameters for announcements.

Should contain:

Enums

ExportFormat (pdf, excel, csv, json)
AnnouncementSortField (created_at, updated_at, published_at, title, priority, engagement_rate, read_count)
Filter/query params

AnnouncementFilterParams

Rich filter for listing announcements: search text, hostel(s), category(ies)/exclusions, priority filters, boolean flags (published/urgent/pinned/ack_required), creator filters, date/expiry filters, approval filters, engagement thresholds, sorting and pagination. Includes validators for ID uniqueness, date ranges, and conflicting filters.
SearchRequest

Full‑text search: query, optional hostel, scope flags (title/content/attachments), category & published_only, date range, pagination, highlight_matches.
Archival/export/bulk actions

ArchiveRequest
Archive old announcements: hostel, actor, archive_before_date, booleans for expired/read/acknowledged only, exclusions (pinned/urgent/categories), dry_run, date‑in‑past validation.
AnnouncementExportRequest
Export with optional AnnouncementFilterParams, format, content options (content, engagement, recipient list, read receipts, acknowledgments), date range, optional send_to_email; date range validation.
BulkDeleteRequest
Delete multiple: list of unique announcement_ids, deleted_by, confirm_permanent, force_delete_published, with required confirmation.
AnnouncementStatsRequest
Analytics request: optional hostel, period start/end, group_by (hour/day/week/month), flags for which breakdowns to include, validations on range (end after start, max 1 year).
In short: This file defines input schemas for getting, searching, exporting, and bulk‑modifying announcements, not the announcements themselves.

6. announcement_scheduling.py
Purpose: Scheduling and recurrence of announcements.

Should contain:

Enums

RecurrencePattern (daily, weekly, biweekly, monthly)
ScheduleStatus (pending, published, cancelled, failed)
One‑off scheduling

ScheduleRequest

Schedule an existing announcement: announcement_id, scheduled_by, scheduled_publish_at, optional auto‑expiry (auto_expire, expire_after_hours), timezone, validations for future times and auto‑expire pairing.
ScheduleConfig

Current scheduling config for an announcement: flags for is_scheduled, scheduled_publish_at, schedule_status, recurrence info (is_recurring, pattern, end conditions, occurrences, next_publish_at), audit (scheduled_by, scheduled_at).
Recurring creation

RecurringAnnouncement
Create a recurring template: hostel, created_by, title/content, recurrence pattern, start_date, at least one end condition (end_date or max_occurrences), optional weekdays for weekly, publish_time, timezone, targeting (TargetAudience+room/floor), delivery flags. Validations on dates, weekdays, and end conditions.
Update/cancel/publish‑now commands

ScheduleUpdate
Reschedule: announcement_id, updated_by, new_scheduled_time, optional reason; validates future time.
ScheduleCancel
Cancel schedule: announcement_id, cancelled_by, cancellation_reason, delete_announcement (vs keep draft), cancel_all_future for recurring.
PublishNow
Override schedule: announcement_id, published_by, override_schedule, optional reason.
List representations

ScheduledAnnouncementItem
Lightweight row: announcement_id, title, scheduled_for, recurrence info, next_occurrence, occurrences_remaining, targeting summary, estimated_recipients, creator name, schedule_status.
ScheduledAnnouncementsList
Queue view: hostel context, counts (total_scheduled, upcoming_24h, recurring_count), list of ScheduledAnnouncementItem, next_scheduled.
In short: This file handles when announcements go live, both once and on a recurring schedule.

7. announcement_targeting.py
Purpose: Audience/recipient selection & targeting rules.

Should contain:

Enums

TargetType (all, specific_rooms, specific_floors, specific_students, custom)
CombineMode (union, intersection) – combining multiple targeting rules.
Targeting config models

TargetingConfig

A single targeting rule set: target_type, specific room/floor/student IDs, exclusions, with validations for required fields by type and for overlap between included/excluded IDs.
AudienceSelection

High‑level selection against a hostel’s students: flags for including all/active/inactive/notice‑period, filters (room_types, floors), specific inclusions and exclusions; ensures you don’t end up with nothing selected.
TargetRooms

Simple room‑based targeting command: announcement_id, room_ids (unique), and options for including all students, excluding checked‑out.
TargetFloors

Simple floor‑based targeting command: announcement_id, floor_numbers (validated/non‑negative/dedup), options for including all rooms, excluding maintenance rooms.
IndividualTargeting

Simple individual targeting command: announcement_id, list of unique student_ids (bounded in size).
Summaries & composites

TargetingSummary

Read‑side summary for an announcement: type, counts (recipients/students/rooms/floors, excluded), breakdowns by room/floor, and validation info (has_valid_recipients, warnings).
BulkTargeting

Apply multiple TargetingConfig rules for one announcement: list of rules, combine_mode, global exclusions, with validation around using ALL with INTERSECTION.
TargetingPreview

Pre‑create preview: hostel_id, a TargetingConfig, flags for including a limited list of student IDs, cap on max preview.
In short: This file defines who gets the announcement, via configurable rules and helper commands.

8. announcement_tracking.py
Purpose: Tracking reads, acknowledgments, engagement/analytics over time.

Should contain:

Enum

DeviceType (mobile, web, tablet, desktop)
Read & acknowledgment commands/responses

ReadReceipt

Command when a student reads: announcement_id, student_id, read_at, optional reading_time_seconds, device_type, scroll_percentage, source.
ReadReceiptResponse

Confirms read: includes requires_acknowledgment, acknowledged, optional deadline, message.
AcknowledgmentRequest

Student acknowledges: announcement_id, student_id, acknowledged (bool), optional note and action_taken.
AcknowledgmentResponse

Confirmation: announcement_id, student_id, acknowledged_at, on_time, message.
Per‑student pending & tracking

PendingAcknowledgment

For lists of students who haven’t acknowledged: student info, room/floor, when delivered, channel, read status, contacts, plus computed hours_since_delivery.
AcknowledgmentTracking

Announcement‑level overview: requirement, deadline, total recipients, acknowledged/pending, on‑time vs late counts, acknowledgment_rate, list of PendingAcknowledgment, timing stats, and computed flags about deadline status/hours until deadline.
Engagement metrics

EngagementMetrics

Announcement‑level metrics: recipients delivered, delivery_rate, read_count/read_rate, reading depth (time/scroll), acknowledgment metrics, timing metrics, overall engagement_score, comparison against hostel average.
ReadingTime

Distribution-level analysis of reading times: averages/median/min/max, quick/normal/thorough reader counts and percentages.
StudentEngagement

Per‑student interaction: delivery, read status, read time, device, acknowledgment details, computed time_to_read_hours.
EngagementTrend

Time‑series: reads and acknowledgments by hour/day, peak times, breakdowns by device and source.
AnnouncementAnalytics

“Dashboard” aggregate: announcement metadata, EngagementMetrics, ReadingTime, EngagementTrend, optional AcknowledgmentTracking, top engaged students (fastest_readers), and metadata about generation.
In short: This file encapsulates how recipients interacted with announcements and provides analytics/statistics.

9. __init__.py (package initializer)
Purpose: Central export of all announcement‑related schemas.

Should:

Import and re‑export the public classes/enums from all the above modules.
Maintain a clean __all__ that matches those public APIs:
Base: AnnouncementBase, AnnouncementCreate, AnnouncementUpdate, AnnouncementPublish, AnnouncementUnpublish
Response: AnnouncementResponse, AnnouncementDetail, AnnouncementList, AnnouncementListItem, StudentAnnouncementView, AnnouncementSummary
Targeting: TargetType, CombineMode, TargetingConfig, AudienceSelection, TargetRooms, TargetFloors, IndividualTargeting, TargetingSummary, BulkTargeting, TargetingPreview
Scheduling: RecurrencePattern, ScheduleStatus, ScheduleRequest, ScheduleConfig, RecurringAnnouncement, ScheduleUpdate, ScheduleCancel, PublishNow, ScheduledAnnouncementsList, ScheduledAnnouncementItem
Approval: ApprovalStatus, ApprovalRequest, ApprovalResponse, RejectionRequest, ApprovalWorkflow, SupervisorApprovalQueue, PendingApprovalItem, BulkApproval, ApprovalHistory
Delivery: DeliveryChannel, DeliveryStrategy, DeliveryState, DeliveryConfig, DeliveryChannels, DeliveryStatus, DeliveryReport, ChannelDeliveryStats, FailedDelivery, BatchDelivery, RetryDelivery, DeliveryPause, DeliveryResume
Tracking: DeviceType, ReadReceipt, ReadReceiptResponse, AcknowledgmentRequest, AcknowledgmentResponse, AcknowledgmentTracking, PendingAcknowledgment, EngagementMetrics, ReadingTime, AnnouncementAnalytics, StudentEngagement, EngagementTrend
Filters: ExportFormat, AnnouncementSortField, AnnouncementFilterParams, SearchRequest, ArchiveRequest, AnnouncementExportRequest, BulkDeleteRequest, AnnouncementStatsRequest

==================================================================================================================================================



Here’s a clear map of which classes belong in each file, and what each one is for. Think of this as the “contract” of your attendance schemas package.

1. attendance_alert.py
Purpose of file:
Schemas related to alerts about attendance issues: configuration, creation, listing, and summary.

Classes that should be here:

AttendanceAlert

Response model for a single alert record (with full lifecycle: triggered, acknowledged, resolved, escalated).
Used when you fetch/view an existing alert.
AlertConfig

Configuration model that defines how and when alerts are generated (thresholds, channels, suppression, escalation).
One per hostel (typically).
AlertTrigger

Request model for manually triggering an alert.
Used by endpoints like POST /alerts/manual.
AlertAcknowledgment

Request model for acknowledging an alert (possibly also resolving it and assigning follow‑up).
AlertList

Response model for a paginated list of alerts together with aggregated statistics (counts by status, type, severity).
AlertSummary

Compact, hostel-level summary for dashboards (totals, severities, trend, resolution times, affected students).
2. attendance_base.py
Purpose of file:
Core & reusable attendance models used internally and for CRUD operations (create/update, bulk, etc.).

Classes that should be here:

AttendanceBase

Shared base schema with core attendance fields (hostel, student, date, times, status, late info, notes).
Used as a base for other create/update schemas.
AttendanceCreate

Request model to create a single attendance record, extending AttendanceBase with location/device info.
AttendanceUpdate

Request model for partial update of an existing attendance record (all fields optional).
SingleAttendanceRecord

Lightweight model representing a single student’s record inside a bulk operation.
Not used alone in endpoints; embedded in bulk payloads.
BulkAttendanceCreate

Request model to create many attendance records for one hostel+date in a single call.
Contains attendance_date, hostel_id, marked_by, records: List[SingleAttendanceRecord].
3. attendance_filters.py
Purpose of file:
Schemas for filtering, querying, and exporting attendance data.

Classes that should be here:

AttendanceFilterParams

Query/filter model for fetching attendance records (hostel(s), student(s), date ranges, status, late-only, notes, etc.).
Typically drives list/search endpoints, e.g. GET /attendance.
DateRangeRequest

Generic validated date-range model used when API needs only a start/end date (e.g. reports, analytics).
AttendanceExportRequest

Request model for exporting attendance (CSV/Excel/PDF), with filters + format options + grouping/sorting.
4. attendance_policy.py
Purpose of file:
Schemas modeling attendance policy configuration and policy violations.

Classes that should be here:

AttendancePolicy

Response model representing the attendance policy applied to a hostel (min attendance, late rules, auto-mark, weekend/holiday handling, alert thresholds).
PolicyConfig

Secondary configuration model focused on how to calculate attendance (periods, leaves treatment, weekends, holidays, late penalties, rounding rules).
Often stored with or alongside AttendancePolicy.
PolicyUpdate

Request model for partial update of an existing AttendancePolicy.
PolicyViolation

Response model describing a specific violation instance for a student (type, severity, metrics, notifications, resolution).
5. attendance_record.py
Purpose of file:
Schemas for marking and correcting attendance (operational write-side models).

Classes that should be here:

AttendanceRecordRequest

Request model to mark attendance for a single student on a date (full record: times, status, late, notes).
StudentAttendanceRecord

Per-student sub-model for bulk marking (used inside BulkAttendanceRequest).
Allows overrides on default status/times.
BulkAttendanceRequest

Request to mark attendance for multiple students at once, with a default_status and per-student overrides.
Used for daily marking screens (batch operations).
AttendanceCorrection

Request to correct an already existing attendance record with a mandatory correction_reason (audit trail).
QuickAttendanceMarkAll

Request to quickly mark all students as present and then specify exceptions:
absent_student_ids
on_leave_student_ids
late_student_ids
6. attendance_report.py
Purpose of file:
Schemas for reporting, analytics, and trends.

Classes that should be here:

AttendanceSummary

Aggregated statistics over a period: counts, percentages, streaks, qualitative status, and policy compliance.
DailyAttendanceRecord

Detailed per-day record for reports (status, times, late info, notes, weekend/holiday flags).
WeeklyAttendance

Week-level aggregation (week number, dates, present/absent/late counts, weekly percentage).
MonthlyComparison

Per-month summary used for month-over-month comparison (e.g., for charts).
TrendAnalysis

Encapsulates weekly breakdown, optional monthly comparison, trend direction, improvement rate, predictive metrics.
AttendanceReport

Main composite report schema:
Metadata (hostel/student, period, generated_at, report_type)
summary: AttendanceSummary
daily_records: List[DailyAttendanceRecord]
trend_analysis: TrendAnalysis | None
StudentMonthlySummary

Per-student summary within a month: counts, percentage, requirement flag, attention flag, improvement from last month.
MonthlyReport

Hostel-wide monthly report:
Metadata (hostel, month/year)
student_summaries: List[StudentMonthlySummary]
Hostel-level averages and compliance numbers.
ComparisonItem

One row/entity in a comparative analysis (student/hostel/room), with rank and percentile.
AttendanceComparison

Comparative report across multiple entities (students/hostels/rooms) over a period:
comparison_type, period, optional hostel_id
comparisons: List[ComparisonItem]
Aggregate statistics (average, median, highest, lowest, std dev).
7. attendance_response.py
Purpose of file:
Schemas optimized for API responses (READ side): list items, detail views, daily summaries.

Classes that should be here:

AttendanceResponse

Standard response for a single attendance record in list/basic views (student, room, times, status, late, who marked).
AttendanceDetail

Full detail response: adds student contact info, attendance mode, supervisor, notes, location & device data, timestamps.
AttendanceListItem

Minimal record for large list views (ID, student, date, status, check-in, late flag, marked_by_name) with UI hint (badge color).
DailyAttendanceSummary

Hostel-level daily summary:
Totals by status
Attendance percentage
Marking status (completed/pending)
Derived quality indicator (excellent/good/…).
8. __init__.py (package export)
Purpose of file:
Central export point for the attendance package.

It should:

Import all the above classes from their respective modules.
Expose them via __all__ so they can be imported as:
Python

from app.schemas.attendance import AttendanceCreate, AttendanceResponse, AttendancePolicy, AttendanceReport, ...
Current __init__.py already correctly:

Imports all classes listed above from:
attendance_alert
attendance_base
attendance_filters
attendance_policy
attendance_record
attendance_report
attendance_response
Exposes them via the __all__ list.

================================================================================================================================================

Below is a file‑by‑file map of exactly which classes belong where, and what role each plays. This should give you a clear mental model of the audit schemas package.

app/schemas/audit/admin_override_log.py
Purpose: Everything specifically about admin overrides of supervisor decisions (logging, detail views, analytics).

Classes that should live here:

AdminOverrideBase

Core Pydantic schema containing all common fields for an admin override log entry.
Not used directly in requests/responses; acts as a base for other schemas.
AdminOverrideCreate

Payload used when creating a new override log entry.
Inherits from AdminOverrideBase and BaseCreateSchema.
Has factory helper for_complaint_override(...).
AdminOverrideLogResponse

“List item” / table row representation of an override entry.
Lightweight view: enough for lists and dashboards.
Includes display_text, severity_badge_color computed fields.
AdminOverrideDetail

Full detailed view for a single override record.
Used by “detail”/“view more” screens and investigations.
Includes extra fields like emails, approval info, follow‑up, etc.
AdminOverrideTimelinePoint

Aggregated, time‑bucketed data (per day/week/etc.) of overrides.
Used for trend charts and timelines.
SupervisorImpactAnalysis

Analytics per supervisor: how often they get overridden, severity, trends.
Used for performance feedback and training decisions.
AdminOverrideSummary

Period summary of overrides (optionally scoped to a supervisor/hostel).
Holds distributions and a list of SupervisorImpactAnalysis and AdminOverrideTimelinePoint.
AdminOverrideAnalytics

Top‑level analytics wrapper for overrides over a DateTimeRangeFilter.
Contains a summary (AdminOverrideSummary) + patterns, root causes, recommendations.
In short: all schemas whose primary concern is “admin override” (entry, list view, details, analytics) properly belong in this file.

app/schemas/audit/audit_filters.py
Purpose: Generic audit log querying/export parameters (filters, search, sorting, export options) for the main system‑wide audit log.

Classes that should live here:

AuditSortField (Enum)

Allowed sort fields for audit log queries.
AuditFilterParams

Comprehensive filter schema for audit log listing endpoints.
Covers actor, time, entity, action, status, severity, network, device, search, pagination, etc.
AuditSearchParams

Narrower schema for text search in audit logs.
Primary query plus a subset of filters and paging.
AuditExportParams

Parameters for exporting audit logs (csv/json/xlsx/pdf).
Wraps an AuditFilterParams + export options (fields, privacy controls, limits).
In short: all filter/search/export parameter schemas for the generic audit log belong here.

app/schemas/audit/audit_log_base.py
Purpose: Core building blocks for individual audit log entries (the generic, system‑wide audit log).

Classes that should live here:

AuditContext

Environment/request metadata: IP, UA, geo, device, API endpoint, HTTP method, etc.
Used inside audit log entries.
ChangeDetail

Per‑field change description: old/new values, change type, sensitivity.
Used for fine‑grained change tracking.
AuditLogBase

Canonical structure of an audit log entry.
Includes actor, action, entity, hostel, values, context, status, timestamps, compliance flags.
Has computed fields like severity_level, requires_review, changed_fields, and helpers like to_log_message().
AuditLogCreate

Payload used to create audit log entries.
Extends AuditLogBase for incoming data, adds factories:
from_request(...)
for_authentication(...)
In short: the fundamental “what is an audit log record?” schemas live here: base, context, change details, and create payloads.

app/schemas/audit/audit_log_response.py
Purpose: Presentation‑oriented views of audit log entries and their simple aggregations.

Classes that should live here:

AuditLogResponse

List/table row representation of a single audit log entry.
Minimal but useful fields for log tables.
UI‑focused computed fields: display_text, status_badge_color, category_icon.
AuditLogDetail

Full detailed view of a single audit log record, de‑normalized.
Includes actor, entity, network, device, API, change tracking, security info.
Helper methods like change_summary, location_summary, get_field_change().
AuditLogSummary

Aggregated statistics for a time period (for dashboards).
Counts, breakdowns, security and anomaly indicators.
Provides derived metrics: success_rate, security_score, requires_attention.
AuditLogTimeline

Time‑bucketed metrics for timelines (e.g., events per hour/day).
Contains bucket label, counts, severity, and a list of “notable events”.
In short: schemas whose primary job is “what do we send back to clients to show audit logs and simple stats” live here.

app/schemas/audit/audit_reports.py
Purpose: Higher‑level reporting & analytics on top of audit logs (compliance/security/executive reports, user/entity analytics, trends).

Classes that should live here:

ReportFormat (Enum)

Allowed formats for exporting full reports (json/csv/xlsx/pdf/html).
CategoryAnalytics

Metrics per AuditActionCategory (volume, status breakdown, top actions, trends).
UserActivitySummary

Aggregated activity for a single user over a period.
Counts, distributions, security/anomaly metrics, patterns, risk assessment.
AuditSummary

High‑level executive summary for an audit report over a DateRangeFilter.
More comprehensive than AuditLogSummary:
Multiple breakdowns (category, user role, device, geography).
Security health, login/authorization rates, top users, etc.
EntityChangeSummary

Summary per entity type: how often it changes, operations (create/update/delete/restore), volatility.
EntityChangeRecord

A single change event for an entity (one row in its change history).
EntityChangeHistory

Complete audit trail for one specific entity instance.
Holds lifecycle metadata + list of EntityChangeRecord.
ComplianceReport

Compliance‑oriented aggregation (GDPR, HIPAA, SOC2, etc.).
Access control, data access, change management, anomalies, compliance rate, findings.
SecurityAuditReport

Security‑focused aggregation: auth/authorization, data security, threats, risk score, findings.
AuditTrendAnalysis

Time‑series trend analysis for some metric (events, failures, etc.).
Holds data points and computed trend/volatility statistics.
AuditReport

Top‑level “everything in one” executive report.
Contains:
summary (AuditSummary)
entity_summaries
user_activities
optional compliance_report
optional security_report
trends, key findings, recommendations, action items, export formats.
Has executive_summary_text and overall_health_score.
In short: all rich, cross‑cutting reports and analytics (beyond simple list/summary endpoints) live here.

app/schemas/audit/supervisor_activity_log.py
Purpose: Everything specifically about supervisor activities (their own action log, filters, performance metrics, shift reports).

Classes that should live here:

SupervisorActionCategory (Enum)

Domain‑specific categories of supervisor actions (complaint, attendance, maintenance, etc.).
SupervisorActivityBase

Core schema for a supervisor activity log entry.
Actor, context, action, entity, metadata, outcome, performance hints.
SupervisorActivityCreate

Payload to create supervisor activity entries.
Inherits from SupervisorActivityBase + BaseCreateSchema.
Factory helpers:
for_complaint_action(...)
for_attendance_action(...)
SupervisorActivityLogResponse

List/table row view of a supervisor activity.
Minimal summary plus UI colors and text.
SupervisorActivityDetail

Full detailed view of one supervisor activity entry.
Includes related student/room, metadata, performance metrics, follow‑up, etc.
SupervisorActivityFilter

Filter schema for querying supervisor activities.
Actor, hostel, action, entity, status, priority, time, shift, performance thresholds, follow‑ups, search, paging.
SupervisorActivityTimelinePoint

Time‑bucket aggregation of activities (counts, statuses, averages).
Used for charts and workload/timeline views.
SupervisorPerformanceMetrics

Aggregated performance metrics per supervisor over a period.
Quality, efficiency, completion, complaint resolution, attendance accuracy, etc.
Provides overall_performance_score, performance_grade, productivity_rate.
SupervisorActivitySummary

Summary of a supervisor’s activity over a period.
Ties together counts, distributions, optional SupervisorPerformanceMetrics, timeline, highlights.
SupervisorShiftReport

End‑of‑shift report for a supervisor.
Shift metadata, all activities in shift, critical incidents, notes, pending tasks.
Provides productivity_rate, completion_rate.
In short: all schemas whose primary concern is “supervisor actions and performance” live here.

app/schemas/audit/__init__.py
Purpose: Public package interface: re‑exports all audit‑related schemas and enums from the above modules.

It should (and does) export:

Core audit log:

AuditLogBase, AuditLogCreate, AuditContext, ChangeDetail
Audit responses:

AuditLogResponse, AuditLogDetail, AuditLogSummary, AuditLogTimeline
Filters/search:

AuditFilterParams, AuditSearchParams, AuditExportParams, AuditSortField
Reports/analytics:

AuditReport, AuditSummary, UserActivitySummary,
EntityChangeHistory, EntityChangeRecord, EntityChangeSummary,
CategoryAnalytics, ComplianceReport, SecurityAuditReport,
AuditTrendAnalysis, ReportFormat
Supervisor activity:

SupervisorActivityBase, SupervisorActivityCreate,
SupervisorActivityLogResponse, SupervisorActivityDetail,
SupervisorActivityFilter, SupervisorActivitySummary,
SupervisorActivityTimelinePoint, SupervisorPerformanceMetrics,
SupervisorShiftReport, SupervisorActionCategory
Admin overrides:

AdminOverrideBase, AdminOverrideCreate, AdminOverrideLogResponse,
AdminOverrideDetail, AdminOverrideSummary, AdminOverrideTimelinePoint,
AdminOverrideAnalytics, SupervisorImpactAnalysis

================================================================================================================================================


Here’s a clear inventory of what belongs in each file under app/schemas/auth, and what each class is for.

login.py
This file should contain only login-related request/response schemas and lightweight token/user DTOs:

LoginRequest

Email + password login input.
Fields: email, password, remember_me.
Validation: email format, password length + not whitespace.
PhoneLoginRequest

Phone + password login input.
Fields: phone, password, remember_me.
Validation: phone pattern, normalization, password not whitespace.
TokenData

Minimal token payload used internally (e.g., in Depends(get_current_user)).
Fields: user_id, email, role, hostel_id.
UserLoginInfo

User object included in auth responses (safe subset of user profile).
Fields: id, email, full_name, role, is_email_verified, is_phone_verified, profile_image_url.
LoginResponse

Full login response.
Fields: access_token, refresh_token, token_type, expires_in, user (UserLoginInfo).
Nothing else is needed here.

otp.py
This file should contain all OTP-related request/response schemas:

OTPGenerateRequest

Input to generate/send OTP.
Fields: user_id (optional), email (optional), phone (optional), otp_type.
Validation: at least one of email or phone; normalize phone.
OTPVerifyRequest

Input to verify OTP.
Fields: user_id (optional), email (optional), phone (optional), otp_code, otp_type.
Validation: at least one contact method; OTP is exactly 6 digits.
OTPResponse

Response when OTP is generated/sent.
Fields: message, expires_in, sent_to (masked), otp_type, max_attempts.
OTPVerifyResponse

Response after OTP verification attempt.
Fields: is_valid, message, verified_at, user_id, remaining_attempts.
ResendOTPRequest

Input to resend an OTP.
Fields: user_id (optional), email (optional), phone (optional), otp_type.
Validation: at least one contact method.
Nothing beyond OTP flows should live here.

password.py
This file should contain password-related flows + a reusable validator utility:

PasswordValidator

Pure utility class (no Pydantic) encapsulating password rules.
Methods:
validate_strength(password) -> (bool, List[str])
calculate_strength_score(password) -> int
Constants: SPECIAL_CHARS, MIN_LENGTH, MAX_LENGTH.
PasswordResetRequest

“Forgot password” start.
Fields: email.
Validation: simple email normalization + basic validation.
PasswordResetConfirm

Complete reset via token.
Fields: token, new_password, confirm_password.
Validation: strength via PasswordValidator; new/confirm match.
PasswordChangeRequest

Change password for logged-in user.
Fields: current_password, new_password, confirm_password.
Validation: strength; new == confirm; new != current.
PasswordChangeResponse

Response after changing password.
Fields: message, user_id.
PasswordStrengthCheck

Input to check password strength (e.g. live frontend indicator).
Fields: password.
PasswordStrengthResponse

Output of strength analysis.
Fields: score, strength, has_minimum_length, has_uppercase, has_lowercase, has_digit, has_special_char, suggestions.
Classmethod: from_password(password) to build this from PasswordValidator.
No other domain logic should be in this file—only schemas + validator.

register.py
This file should hold self-registration and verification schemas:

RegisterRequest

User sign-up payload.
Fields: email, phone, password, confirm_password, full_name, role, gender, date_of_birth.
Validation:
Normalize email/phone.
Full name rules.
Age rules (13–120).
Password strength (basic rules).
Password == confirm.
Role restriction: only VISITOR or STUDENT allowed.
RegisterResponse

Response after registration.
Fields: user_id, email, full_name, role, message, verification_required.
VerifyEmailRequest

Verify email via 6-digit code.
Fields: user_id, verification_code.
Validation: code is 6 digits.
VerifyPhoneRequest

Verify phone via 6-digit code.
Fields: user_id, verification_code.
Validation: code is 6 digits.
ResendVerificationRequest

Resend email/phone verification code.
Fields: user_id, verification_type ("email" or "phone").
Validation: normalize verification_type to lowercase.
Registration + email/phone verification only.

social_auth.py
This file should contain social login schemas and provider-specific payloads:

SocialAuthRequest

Generic OAuth request (e.g. provider token).
Fields: access_token, provider (google|facebook|apple).
Validation: normalize provider; token not empty.
GoogleAuthRequest

Google-specific request using ID token.
Fields: id_token, access_token (optional).
Validation: strip whitespace; tokens non-empty if present.
FacebookAuthRequest

Facebook-specific request.
Fields: access_token, user_id.
Validation: both not empty/whitespace.
SocialUserInfo

Minimal user info returned by our API after social auth.
Fields: id, email, full_name, role, profile_image_url, is_email_verified.
SocialProfileData

Raw/profile data pulled from provider (internal use / debug / mapping).
Fields: provider_user_id, email, full_name, first_name, last_name, profile_picture_url, gender, locale.
Validation: normalize email.
SocialAuthResponse

Full response after social auth.
Fields: access_token, refresh_token, token_type, expires_in, user (SocialUserInfo), is_new_user.
Only social/OAuth-related payloads belong here.

token.py
This file should contain generic token schemas (JWT & refresh flows):

Token

Basic OAuth2 token response (common shorthand).
Fields: access_token, refresh_token, token_type, expires_in.
TokenPayload

Decoded JWT payload structure.
Fields: sub, user_id, email, role, hostel_id, exp, iat, jti.
Validation on exp & iat timestamps (not negative, not >100 years ahead).
RefreshTokenRequest

Input to obtain new access token via refresh token.
Fields: refresh_token.
Validation: not empty/whitespace.
RefreshTokenResponse

Response with rotated tokens.
Fields: access_token, refresh_token, token_type, expires_in.
TokenValidationRequest

Input to validate an arbitrary token.
Fields: token.
Validation: not empty.
TokenValidationResponse

Output of token validation.
Fields: is_valid, user_id, role, expires_at, error.
RevokeTokenRequest

Input to revoke a token or all tokens of a user.
Fields: token, revoke_all.
Validation: token not empty.
LogoutRequest

Input to log out.
Fields: refresh_token (optional), logout_all_devices.
Validation: if provided, refresh_token not empty.
This file is the central place for all token-related schemas.

__init__.py
This file should only re-export the schemas above for convenient imports:

From login.py:
LoginRequest, LoginResponse, PhoneLoginRequest, TokenData, UserLoginInfo
From register.py:
RegisterRequest, RegisterResponse, VerifyEmailRequest, VerifyPhoneRequest, ResendVerificationRequest
From token.py:
Token, TokenPayload, RefreshTokenRequest, RefreshTokenResponse,
TokenValidationRequest, TokenValidationResponse, RevokeTokenRequest, LogoutRequest
From password.py:
PasswordResetRequest, PasswordResetConfirm, PasswordChangeRequest,
PasswordChangeResponse, PasswordStrengthCheck, PasswordStrengthResponse,
PasswordValidator
From otp.py:
OTPGenerateRequest, OTPVerifyRequest, OTPResponse, OTPVerifyResponse, ResendOTPRequest
From social_auth.py:
SocialAuthRequest, SocialAuthResponse, GoogleAuthRequest,
FacebookAuthRequest, SocialUserInfo, SocialProfileData
And its __all__ should match exactly that list.

=================================================================================================================================================

Here’s a clear, structured map of what classes belong in each file under app/schemas/booking, and why. Think of each file as owning one “slice” of the booking lifecycle or feature-set.

1. booking_base.py – Core booking model
Purpose: Core/internal representation of a booking (domain model) and its admin-side updates.

Should contain:

BookingBase (BaseSchema)
Core fields that describe a booking itself:

visitor_id, hostel_id
room_type_requested, preferred_check_in_date, stay_duration_months
quoted_rent_monthly, total_amount, security_deposit, advance_amount
special_requests, dietary_preferences, has_vehicle, vehicle_details
source, referral_code
Plus validators and computed fields (expected_check_out_date, days_until_check_in, is_long_term_booking).
BookingCreate (BookingBase + BaseCreateSchema)
Extends BookingBase to add guest-facing information required at creation time:

guest_name, guest_email, guest_phone
optional guest_id_proof_type/number
emergency contact fields
institution_or_company, designation_or_course
Plus cross-field validation for emergency contact and ID proof consistency.
BookingUpdate (BaseUpdateSchema)
Admin-side partial updates for existing bookings:

room_type_requested, preferred_check_in_date, stay_duration_months
special_requests, dietary_preferences, has_vehicle, vehicle_details
booking_status
With validators for updated dates and cleaning text fields.
Rule of thumb: This file owns the core entity schema: what a “booking” is in your system, not how it is requested or displayed.

2. booking_request.py – Inbound booking requests
Purpose: Shapes of payloads coming into the system from guests/visitors, before there is a persisted booking entity.

Should contain:

GuestInformation (BaseSchema)
Reusable nested schema for guest personal details:

guest_name, guest_email, guest_phone
optional guest_id_proof_type/number
emergency_contact_* fields
institution_or_company, designation_or_course
With strong validation and cross-field consistency.
BookingRequest (BaseCreateSchema)
Full, rich booking request data from a guest:

hostel_id
room_type_requested, preferred_check_in_date, stay_duration_months
guest_info: GuestInformation
special_requests, dietary_preferences, has_vehicle, vehicle_details
referral_code
Validators for check-in date and vehicle details.
BookingInquiry (BaseCreateSchema)
Lightweight interest-only request, not a full booking:

hostel_id
visitor_name, visitor_email, visitor_phone
optional room_type_interest, preferred_check_in_date, message
QuickBookingRequest (BaseCreateSchema)
Minimal data for a “fast-track” booking:

hostel_id, room_type_requested
check_in_date, duration_months
basic name, email, phone
Rule of thumb: This file owns public-facing request payloads that initiate or express interest in bookings.

3. booking_response.py – Outbound booking responses
Purpose: Schemas used in API responses for bookings (summary, detail, confirmation).

Should contain:

BookingResponse (BaseResponseSchema)
Standard summary response for a single booking:

identifiers & hostel info
requested details & expected_check_out_date
guest basic info
price & payment state (quoted_rent_monthly, total_amount, security_deposit, advance_amount, advance_paid)
booking_status, booking_date, expires_at
Computed: days_until_check_in, is_expiring_soon, balance_amount.
BookingDetail (BaseResponseSchema)
Full, detailed view of a booking:

visitor + hostel details (including address/city/phone)
full assignment info (room/bed id & numbers)
all guest + emergency + institution info
all pricing + payment fields
approval/rejection/cancellation metadata
conversion-to-student details
source & referral_code
timelines (booking_date, expires_at)
Computed: is_assigned, days_until_check_in, balance_amount.
BookingListItem (BaseSchema)
Compact representation for list views:

id, booking_reference
guest_name, guest_phone
hostel_name, room_type_requested
preferred_check_in_date, stay_duration_months
total_amount, advance_paid, booking_status, booking_date
is_urgent, days_until_checkin
Computed: status_badge_color.
BookingConfirmation (BaseSchema)
Payload sent after successful booking creation/approval:

booking_id, booking_reference
hostel_name, room_type, check_in_date
total_amount, advance_amount, balance_amount
confirmation_message, next_steps
hostel_contact_phone, hostel_contact_email
Computed: payment_pending.
Rule of thumb: This file owns how bookings are presented back to clients.

4. booking_approval.py – Admin approval workflow
Purpose: Approve/reject bookings, configure approval behavior.

Should contain:

BookingApprovalRequest (BaseCreateSchema)
Admin’s action to approve a pending booking:

booking_id
room_id, bed_id
approved_check_in_date
final_rent_monthly, final_security_deposit, processing_fee
admin_notes, message_to_guest
advance_payment_required, advance_payment_percentage
With heavy financial & date validation.
ApprovalResponse (BaseSchema)
Response after approval:

booking_id, booking_reference, status
room_number, bed_number
monthly_rent, security_deposit, advance_amount, total_amount
approved_at, check_in_date
payment_pending, payment_deadline
message
RejectionRequest (BaseCreateSchema)
Admin’s action to reject a booking:

booking_id, rejection_reason
optionally suggest_alternative_dates, alternative_check_in_dates
suggest_alternative_room_types, alternative_room_types
message_to_guest
BulkApprovalRequest (BaseCreateSchema)
Approve many bookings at once:

booking_ids (with de-duplication and limits)
auto_assign_rooms, send_notifications
admin_notes (common)
ApprovalSettings (BaseSchema)
Per-hostel configuration for approval behavior:

hostel_id
auto_approve_enabled, auto_approve_conditions (dict)
approval_expiry_hours
require_advance_payment, advance_payment_percentage
Rule of thumb: This file owns approval-related commands and settings.

5. booking_assignment.py – Room & bed assignment
Purpose: Assign or reassign rooms/beds for existing bookings.

Should contain:

RoomAssignment (BaseSchema)
Represents a room assignment record:

booking_id, booking_reference
hostel_id, room_id, room_number, room_type
assigned_by, assigned_by_name, assigned_at
check_in_date
BedAssignment (BaseSchema)
Represents a bed assignment record:

booking_id, booking_reference
room_id, room_number
bed_id, bed_number
assigned_by, assigned_by_name, assigned_at
AssignmentRequest (BaseCreateSchema)
Manual assignment of a room/bed:

booking_id, room_id, bed_id
optional override_check_in_date, notes
SingleAssignment (BaseSchema)
Minimal per-item schema used inside bulk assignments:

booking_id, room_id, bed_id
BulkAssignmentRequest (BaseCreateSchema)
Batch assignment:

assignments: List[SingleAssignment]
auto_approve flag
AssignmentResponse (BaseSchema)
Outcome of an assignment:

booking_id, booking_reference
room_assigned, room_number, bed_number
message, next_steps
ReassignmentRequest (BaseCreateSchema)
Move a booking to different room/bed:

booking_id
current_room_id, new_room_id, new_bed_id
reason, notify_guest
Rule of thumb: This file owns assignment and reassignment of inventory (rooms/beds).

6. booking_calendar.py – Calendar & availability views
Purpose: Calendar-style and capacity-planning representations.

Should contain:

BookingEvent (BaseSchema)
Single booking event on calendar:

booking_id, booking_reference, guest_name
room_number, room_type, status
is_check_in, is_check_out
Computed: event_type_display, status_color.
DayBookings (BaseSchema)
All events for a specific day:

day_date
check_ins, check_outs, pending_bookings: List[BookingEvent]
available_beds, total_beds
Computed: total_events, occupancy_rate, is_fully_booked, is_high_activity_day.
CalendarView (BaseSchema)
Monthly booking calendar for a hostel:

hostel_id, month (YYYY-MM)
days: Dict[str, DayBookings] (keyed by date string)
total_check_ins, total_check_outs, peak_occupancy_date
available_rooms_by_date
Computed: total_events, busiest_week_start.
CalendarEvent (BaseSchema)
Generic event (not just bookings):

event_id, event_type, title
start_date, end_date (optional)
booking_id, room_id (optional)
color, is_all_day
Computed: duration_days, is_past_event.
DayAvailability (BaseSchema)
Availability snapshot per day:

day_date, total_beds, available_beds, booked_beds, is_fully_booked
active_bookings: List[UUID]
Computed: occupancy_rate, availability_level.
AvailabilityCalendar (BaseSchema)
Monthly availability:

hostel_id, optional room_id
month
availability: Dict[str, DayAvailability]
Computed: average_occupancy_rate, days_fully_booked, peak_occupancy_date.
BookingInfo (BaseSchema)
Minimal booking window info:

booking_id, student_name, check_in_date, check_out_date
Rule of thumb: This file owns time-based and capacity-based views, not the booking’s core data.

7. booking_cancellation.py – Cancellations & refunds
Purpose: Cancelling bookings and computing refunds based on policy.

Should contain:

CancellationRequest (BaseCreateSchema)
Input to cancel a booking:

booking_id
cancelled_by_role
cancellation_reason
request_refund
additional_comments
RefundCalculation (BaseSchema)
How refund amount was derived:

advance_paid
cancellation_charge, cancellation_charge_percentage
refundable_amount, refund_processing_time_days
refund_method, breakdown (dict)
With validation linking refundable_amount to advance - charge.
CancellationResponse (BaseSchema)
Outcome of a cancellation:

booking_id, booking_reference
cancelled, cancelled_at
refund: RefundCalculation
message, confirmation_sent
CancellationCharge (BaseSchema)
Single charge tier:

days_before_checkin
charge_percentage
description
CancellationPolicy (BaseSchema)
Per-hostel configuration:

hostel_id
cancellation_before_days: List[CancellationCharge] (ordered & validated)
no_show_charge_percentage
refund_processing_days
policy_text
BulkCancellation (BaseCreateSchema)
Cancel many bookings:

booking_ids
reason
process_refunds
Rule of thumb: This file owns cancellation and refund logic schemas, not generic update/approval.

8. booking_conversion.py – Booking → Student profile
Purpose: When a confirmed booking converts into a long-term student/resident record.

Should contain:

ConvertToStudentRequest (BaseCreateSchema)
Request to convert a booking into a student profile:

booking_id
actual_check_in_date
security_deposit_paid, first_month_rent_paid
optional student_id_number, guardian_address
id_proof_uploaded, photo_uploaded
notes
ConversionResponse (BaseSchema)
Outcome of conversion:

booking_id, student_profile_id
converted, conversion_date
room_number, bed_number
monthly_rent, security_deposit, next_payment_due_date
message, next_steps
ChecklistItem (BaseSchema)
Single requirement item:

item_name, description
is_completed, is_required
completed_at, notes
ConversionChecklist (BaseSchema)
Pre-conversion validation:

booking_id, booking_reference
checks: List[ChecklistItem]
all_checks_passed, can_convert
missing_items
BulkConversion (BaseCreateSchema)
Batch conversion of multiple bookings:

booking_ids
conversion_date
all_deposits_paid, all_first_rents_paid
ConversionRollback (BaseCreateSchema)
Emergency undo of a conversion:

student_profile_id
reason
delete_student_profile, restore_booking
Rule of thumb: This file owns transition from “booking” to “resident/student” and rollback.

9. booking_filters.py – Filtering, searching, sorting, analytics
Purpose: Parameter objects for listing/searching/exporting/analytics on bookings.

Should contain:

BookingFilterParams (BaseFilterSchema)
Rich filtering for listing endpoints:

search text
hostel_id / hostel_ids
status / statuses
date ranges (booking and check-in)
room_type, source
advance_paid, converted_to_student
expiring_soon, expired
BookingSearchRequest (BaseFilterSchema)
Search with pagination:

query
hostel_id
search_in_* flags (reference, name, email, phone)
status
page, page_size
BookingSortOptions (BaseFilterSchema)
Sorting configuration:

sort_by (booking_date, check_in_date, guest_name, status, total_amount)
sort_order (asc/desc)
BookingExportRequest (BaseFilterSchema)
Export configuration:

hostel_id
filters: BookingFilterParams
format (csv, excel, pdf)
include_* flags (guest_details, payment_details, assignment_details)
BookingAnalyticsRequest (BaseFilterSchema)
Aggregation request:

hostel_id
date_from, date_to (bounded to ≤ 365 days)
group_by (day, week, month)
Rule of thumb: This file owns query-like parameter objects for listing, searching, exporting, and analytics.

10. booking_modification.py – Changing existing bookings
Purpose: Change an existing booking’s properties (dates, duration, room type) and handle pricing impact/approval.

Should contain:

ModificationRequest (BaseCreateSchema)
General multi-aspect modification:

booking_id
modify_check_in_date + new_check_in_date
modify_duration + new_duration_months
modify_room_type + new_room_type
modification_reason
accept_price_change
With validation that at least one modification is chosen and required fields are present.
ModificationResponse (BaseSchema)
Result of applying modifications:

booking_id, booking_reference
modifications_applied: List[str]
original_total, new_total, price_difference
additional_payment_required, additional_amount
requires_admin_approval, auto_approved
message
DateChangeRequest (BaseCreateSchema)
Simplified change of check-in date:

booking_id, new_check_in_date, reason
DurationChangeRequest (BaseCreateSchema)
Simplified change of stay duration:

booking_id, new_duration_months, reason
RoomTypeChangeRequest (BaseCreateSchema)
Simplified change of room type:

booking_id, new_room_type, reason, accept_price_difference
ModificationApproval (BaseCreateSchema)
Admin action on a modification request:

modification_request_id
approved (bool)
optional adjusted_price (if overriding)
rejection_reason (required when not approved)
admin_notes
Rule of thumb: This file owns post-creation changes to booking terms, separate from initial request or cancellation.

11. booking_waitlist.py – Waitlist management
Purpose: Handle scenarios where hostels are full and guests go onto a waitlist.

Should contain:

WaitlistRequest (BaseCreateSchema)
Inbound request to join waitlist:

hostel_id, visitor_id
room_type, preferred_check_in_date
contact_email, contact_phone
notes
WaitlistResponse (BaseResponseSchema)
Response after joining waitlist:

hostel_id, hostel_name, visitor_id
room_type, preferred_check_in_date
contact_email, contact_phone
priority, status
estimated_availability_date
created_at
Computed: days_on_waitlist, is_top_priority.
WaitlistStatusInfo (BaseSchema)
Current status for one waitlist entry (visitor view):

waitlist_id, hostel_name, room_type
position, total_in_queue
status (string)
last_notification_sent, notification_count
estimated_wait_days
Computed: position_percentage, is_next_in_line.
WaitlistNotification (BaseSchema)
Notification when a room becomes available:

waitlist_id, visitor_id, hostel_id
message
available_room_id, available_bed_id
response_deadline
booking_link
Computed: hours_until_deadline, is_expiring_soon.
WaitlistConversion (BaseCreateSchema)
Visitor response to notification:

waitlist_id
accept
proceed_with_booking (if accept)
WaitlistCancellation (BaseCreateSchema)
Remove self from waitlist:

waitlist_id
optional cancellation_reason
WaitlistEntry (BaseSchema)
Admin-side view of a single entry:

waitlist_id, visitor_name, contact_email, contact_phone
preferred_check_in_date, priority, status
days_waiting, created_at
Computed: is_long_wait.
WaitlistManagement (BaseSchema)
Admin overview for a hostel + room type:

hostel_id, room_type
total_in_waitlist
entries: List[WaitlistEntry]
Computed: average_wait_days, longest_wait_days.
Rule of thumb: This file owns waitlist lifecycle, separate from confirmed bookings.

12. __init__.py – Public export surface
Purpose: Central place to re-export all booking-related schemas for easy import elsewhere.

Should contain:

Import and re-export (__all__) of all classes from:
booking_base
booking_request
booking_response
booking_approval
booking_assignment
booking_cancellation
booking_conversion
booking_filters
booking_modification
booking_calendar
booking_waitlist

===================================================================================================================================================



Here’s how to think about what should live in each of these files, and how to use them. I’ll treat what you already have as the target design and explain the intended role of each class and file, plus what should not go there.

1. Overall principle for app.schemas.common
This package is for cross-cutting, reusable building blocks, not domain-specific models.

It should contain:

Generic Pydantic bases (create/update/db/response/filter).
Cross-domain enums (roles, statuses, payment, booking, etc.).
Generic filters (date range, numeric range, text search).
Reusable mixins (address, contact info, media, audit).
Generic pagination models.
Generic API response wrappers.
It should NOT contain:

Hostel-specific, Room-specific, Student-specific schemas.
ORM models.
Business logic.
Those go into feature modules like app/schemas/hostel, app/schemas/booking, etc., and they use the common building blocks.

2. base.py – Core base classes & primitive mixins
This file should contain:

2.1. Global base schema
BaseSchema
Your root base class for all app-facing Pydantic models.
Centralizes config: from_attributes, populate_by_name, enum behavior, strip whitespace, assignment validation, etc.
Guideline: Almost every schema in the project should inherit from BaseSchema (directly or indirectly).
2.2. Generic mixins
TimestampMixin

Fields: created_at, updated_at.
Use where a model has those timestamps, but is not necessarily a full DB entity.
SoftDeleteMixin

Fields: deleted_at, is_deleted.
Use for models that support soft-deletion semantics.
UUIDMixin

Field: id: str.
A simple, generic ID mixin (string UUID or similar).
For schemas that represent a persisted entity with a primary key.
These mixins are field bundles you can use in DB- and response-oriented schemas.

2.3. Operation-oriented base schemas
These are templates you extend per domain:

BaseDBSchema(BaseSchema, UUIDMixin, TimestampMixin)

Represents DB-backed entities in Pydantic space (id + timestamps guaranteed).

Example:

Python

class HostelDB(BaseDBSchema):
    name: str
    # etc...
BaseCreateSchema(BaseSchema)

Base for “create” input models from client → server.
No automatic optionalization; you decide which fields are required.
BaseUpdateSchema(BaseSchema)

Base for “update” models.

Typically, subclasses mark fields as Optional[...] or give defaults for partial updates:

Python

class HostelUpdate(BaseUpdateSchema):
    name: Optional[str] = None
    status: Optional[HostelStatus] = None
BaseResponseSchema(BaseDBSchema)

Base for resource representations returned to the client, with id and timestamps present.

Example:

Python

class HostelResponse(BaseResponseSchema):
    name: str
    status: HostelStatus
BaseFilterSchema(BaseSchema)

Base class for all filter-query models (query parameters, search filters, etc.).
All filters in filters.py correctly inherit from this.
What should be in base.py:

Exactly these sorts of primitive base classes & mixins used across domains.
No domain-specific fields or logic.
3. enums.py – All cross-domain enums
This file should contain:

All enums that describe domain concepts that are reused across the app, including:
User & auth: UserRole, Gender.
Hostel & room: HostelType, HostelStatus, RoomType, RoomStatus, BedStatus.
Booking & payment: BookingStatus, BookingSource, PaymentStatus, PaymentMethod, PaymentType, FeeType, ChargeType.
Complaints, maintenance, attendance, leave, etc.
Communication & notifications, subscriptions, students/supervisors, announcements, meals, ID proofs.
Referral, reviews, votes, inquiries, waitlist, OTP types, audit categories.
Guidelines:

Put enums here when:

The concept is widely used across multiple modules (e.g., StudentStatus, HostelStatus).
It’s a core domain vocabulary: statuses, types, categories, modes.
Do not put here:

Enums used only in a very narrow feature; those can live in that feature’s schema module if you want to keep common lighter.
Enums that are purely internal to one micro-area.
As written, your enums.py is a solid centralized vocabulary file.

4. filters.py – Generic filter schemas
This file should contain reusable filter models (for query parameters and search/filter endpoints).

Current classes and their roles:

DateRangeFilter

start_date, end_date with validation that end ≥ start.
DateTimeRangeFilter

start_datetime, end_datetime with similar validation.
TimeRangeFilter

start_time, end_time (no range validation currently; you may add similar check if you want).
PriceRangeFilter

min_price, max_price (≥ 0, and max ≥ min).
SearchFilter

search_query: short simple search string.
For basic “search” query params.
SortOptions

sort_by: field name.
sort_order: "asc" / "desc" normalized to lowercase.
StatusFilter

statuses: include statuses.
exclude_statuses: exclude statuses.
Status values are str so can be used with any enum’s .value.
NumericRangeFilter

min_value, max_value with max ≥ min check.
LocationFilter

latitude, longitude, radius_km, city, state, pincode.
For geography-based filtering.
MultiSelectFilter

include, exclude lists of strings.
BooleanFilter

value: Optional[bool] (None means “don’t filter”).
TextSearchFilter

query: full-text query.
fields: which fields to search in.
fuzzy: enable fuzzy search.
boost: per-field weight mapping.
Guidelines:

Put here only generic, reusable filter shapes, not domain-specific filters.
Domain filters should compose these:

Python

class HostelListFilters(DateRangeFilter, StatusFilter, LocationFilter):
    min_beds: Optional[int] = None
    max_beds: Optional[int] = None
5. mixins.py – Reusable field bundles
This file should contain Pydantic BaseModel mixins that group common fields, used across many schemas.

Existing mixins:

AddressMixin

address_line1, address_line2, city, state, pincode, country.
For hostels, users, offices, etc.
ContactMixin

contact_phone, alternate_phone, contact_email.
LocationMixin

latitude, longitude.
MediaMixin

images, videos, documents as lists of HttpUrl.
EmergencyContactMixin

emergency_contact_name, phone, relation.
AuditMixin

created_by, updated_by (UUIDs of users).
ApprovalMixin

approved_by, approved_at, rejection_reason.
SEOMixin

meta_title, meta_description, meta_keywords.
How to use them:

Example for a hostel resource:

Python

class HostelDB(BaseDBSchema, AddressMixin, ContactMixin, LocationMixin, MediaMixin, SEOMixin):
    name: str
    type: HostelType
    status: HostelStatus
What should be here:

Only generic, cross-cutting field groups that are reusable in many domain schemas.
6. pagination.py – Pagination parameters & wrappers
This file should define generic pagination input and output models.

Existing classes:

PaginationParams

Query params: page, page_size with validation and computed:
offset
limit
Use in list endpoints that are page-based.
PaginationMeta

Response metadata: total_items, total_pages, current_page, page_size, has_next, has_previous.
PaginatedResponse[T]

Generic wrapper: items: List[T], meta: PaginationMeta.
create(...) classmethod to compute metadata and instantiate.
Example:

Python

items = [HostelResponse(...), ...]
resp = PaginatedResponse[HostelResponse].create(
    items=items,
    total_items=total,
    page=params.page,
    page_size=params.page_size,
)
CursorPaginationParams

For cursor/infinite scroll: cursor, limit.
CursorPaginationMeta

next_cursor, has_more.
CursorPaginatedResponse[T]

items: List[T], meta: CursorPaginationMeta.
What should be in pagination.py:

Only generic pagination primitives for any resource (no domain-specific logic).
7. response.py – Standard API response envelopes
This file should define how your API shapes success and error responses.

Current classes:

SuccessResponse[T]

Fields: success: True, message, data: Optional[T].
Generic wrapper around a resource (or list, or anything).
Use for normal 2xx responses.
create(message, data) helper.
ErrorDetail

field, message, code, location.
Represents a single detailed error; used inside error responses.
ErrorResponse

Base error shape: success: False, message, errors, error_code, timestamp, path.
create(message, errors, error_code) helper.
MessageResponse

Just message; for simple non-data responses (e.g., “Ping OK”).
BulkOperationResponse

total, successful, failed, errors, details.
For bulk insert/update/delete outcomes.
Specialized error responses (extend ErrorResponse with extra context):

ValidationErrorResponse

Adds validation_errors: List[ErrorDetail].
NotFoundResponse

Adds resource_type, resource_id.
UnauthorizedResponse

Adds auth_scheme (e.g., "Bearer").
ForbiddenResponse

Adds required_permission, user_permissions.
ConflictResponse

Adds conflicting_resource.
RateLimitResponse

Adds retry_after, limit, window.
Typical usage:

Normal GET by ID:

Python

return SuccessResponse[HostelResponse].create(
    message="Hostel fetched successfully",
    data=hostel,
)
List endpoint with pagination:

Python

data = PaginatedResponse[HostelResponse].create(...)
return SuccessResponse[PaginatedResponse[HostelResponse]].create(
    message="Hostels listed successfully",
    data=data,
)
Error handler:

Python

raise HTTPException(
    status_code=404,
    detail=NotFoundResponse.create(
        message="Hostel not found",
        error_code="HOSTEL_NOT_FOUND",
        # plus resource_type/id if desired
    ).model_dump()
)
What belongs here:

Only generic response envelopes, not resource-specific fields.


============================================================================================================================================================

Here’s how the package is logically structured and which classes “belong” in each file, with their roles. This reflects both what you already have and how it should be organized conceptually.

---

## 1. `complaint_base.py` – Core complaint input/update models

**Purpose:** Define the core complaint fields and validate them; handle create/update and status-change payloads.

**Classes that should live here:**

1. **`ComplaintBase`** (`BaseSchema`)
   - Core shape of a complaint: hostel, raised_by, title, description, category, priority, room/location, attachments.
   - Contains most “business rules” for field validation (title/description quality, attachment count, location normalization).

2. **`ComplaintCreate`** (`ComplaintBase`, `BaseCreateSchema`)
   - Request payload for **creating** a complaint.
   - Inherits all fields/validators from `ComplaintBase`.
   - Adds create-specific business rules (e.g., high/urgent priority must have location or room).

3. **`ComplaintUpdate`** (`BaseUpdateSchema`)
   - **Partial update** payload for an existing complaint (PATCH-like).
   - All fields optional: title, description, category, priority, location, attachments, status.
   - Enforces “at least one field must be provided” and reuses business rules for text/attachments.

4. **`ComplaintStatusUpdate`** (`BaseUpdateSchema`)
   - Dedicated payload for **status changes only**.
   - Required `status` + optional `notes`.
   - Enforces that certain status transitions (`REJECTED`, `ON_HOLD`, `CLOSED`, `REOPENED`) require notes.

---

## 2. `complaint_response.py` – Complaint output/view models

**Purpose:** What the API returns when fetching complaints (list/detail/stats).

**Classes that should live here:**

1. **`ComplaintResponse`** (`BaseResponseSchema`)
   - Standard response for **list views / basic complaint info**.
   - Key fields: complaint_number, hostel info, raised_by info, category/priority/status, assignment, timestamps, SLA breach, age.
   - Computed field `is_overdue` based on priority SLA thresholds and status.

2. **`ComplaintDetail`** (`BaseResponseSchema`)
   - **Full detailed view** of a single complaint.
   - Includes:
     - Full complainant details (email, phone).
     - Student & room details.
     - Full description, sub-category, attachments.
     - Assignment history snapshots (current assignee, assigned_by, reassigned_count).
     - Workflow timestamps: opened/in-progress/resolved/closed.
     - Resolution details & attachments.
     - Feedback fields (rating, feedback, submitted_at).
     - SLA breach, escalation, admin overrides.
     - Engagement metrics (total_comments).
     - Time metrics (age_hours, time_to_resolve_hours).
   - Computed fields:
     - `is_active` – is complaint in an active workflow status.
     - `resolution_efficiency` – maps resolution time vs priority into `excellent/good/average/poor`.

3. **`ComplaintListItem`** (`BaseSchema`)
   - Lightweight item for **table/grid** list endpoints.
   - Minimal fields: id, complaint_number, title, category (as string), priority (as string), status, raised_by_name, room_number, assigned_to_name, opened_at, age_hours, sla_breach.
   - Computed fields:
     - `status_color` – color code for UI badge.
     - `priority_weight` – numeric weight for sorting.

4. **`ComplaintSummary`** (`BaseSchema`)
   - Dashboard-style **summary for a hostel**.
   - Counts: total, open, in-progress, resolved, high/urgent, SLA breached.
   - Average resolution time.
   - Computed:
     - `resolution_rate` (% resolved).
     - `sla_compliance_rate` (% within SLA).

5. **`ComplaintStats`** (`BaseSchema`)
   - **Extended statistics/analytics** (still at “stats” level, not full analytics dashboard).
   - Fields:
     - `total`.
     - Breakdowns: `by_status`, `by_priority`, `by_category` (dicts).
     - Time metrics: `avg_resolution_hours`, `median_resolution_hours`.
     - Performance percentages: `sla_compliance_percentage`, `resolution_percentage`.

---

## 3. `complaint_assignment.py` – Assignment workflow models

**Purpose:** All models related to assigning/unassigning/reassigning complaints and tracking assignment history.

**Classes that should live here:**

1. **`AssignmentRequest`** (`BaseCreateSchema`)
   - Request to **assign** complaint to a user.
   - Fields: `complaint_id`, `assigned_to`, optional `estimated_resolution_time`, `assignment_notes`.
   - Validations: future estimated time, normalized notes.

2. **`AssignmentResponse`** (`BaseSchema`)
   - Response after assignment.
   - Fields: `complaint_id`, `complaint_number`, assignee/assigner IDs & names, `assigned_at`, confirmation `message`.

3. **`ReassignmentRequest`** (`BaseCreateSchema`)
   - Request to **reassign** to another user.
   - Fields: `complaint_id`, `new_assigned_to`, `reassignment_reason`, `notify_previous_assignee`.
   - Validations: non-empty reason with minimum word count.

4. **`BulkAssignment`** (`BaseCreateSchema`)
   - Request to assign **multiple complaints** to one assignee.
   - Fields: `complaint_ids` (1–50, unique), `assigned_to`, optional notes.
   - Validations: unique IDs, max count, cleaned notes.

5. **`UnassignRequest`** (`BaseCreateSchema`)
   - Request to **unassign** from current assignee.
   - Fields: `complaint_id`, `reason` (required, min words).

6. **`AssignmentHistory`** (`BaseSchema`)
   - Single **history entry** of assignment/unassignment for audit.
   - Fields: complaint_id, assignee/assigner IDs & names, `assigned_at`, optional `unassigned_at`, `reason`, `duration_hours`.

---

## 4. `complaint_resolution.py` – Resolution / reopen / close models

**Purpose:** Capture resolution/closure lifecycle and related updates.

**Classes that should live here:**

1. **`ResolutionRequest`** (`BaseCreateSchema`)
   - Request to **mark as resolved**.
   - Fields:
     - `complaint_id`.
     - `resolution_notes`, `resolution_attachments`.
     - Optional `actual_resolution_time`.
     - Follow-up: `follow_up_required`, `follow_up_date`, `follow_up_notes`.
   - Validations:
     - Resolution notes min word count.
     - Max 10 attachments.
     - Follow-up date must be in the future when set.
     - If `follow_up_required`, follow_up_date is mandatory.

2. **`ResolutionResponse`** (`BaseSchema`)
   - Response after successful marking as resolved.
   - Fields: complaint ID/number, resolved flag, resolved_at, resolved_by name/id, resolution_notes, `time_to_resolve_hours`, `sla_met`, confirmation `message`.

3. **`ResolutionUpdate`** (`BaseCreateSchema`)
   - Update **resolution details** for a resolved complaint.
   - Fields: complaint_id, optional updated resolution_notes, resolution_attachments, follow_up_notes.
   - Validations:
     - Notes quality if provided.
     - Attachment limit.
     - At least one field (other than complaint_id) must be provided.

4. **`ReopenRequest`** (`BaseCreateSchema`)
   - Request to **reopen** a resolved/closed complaint.
   - Fields: complaint_id, `reopen_reason`, optional `additional_issues`, `new_attachments`.
   - Validations: reopen_reason quality, attachments limit.

5. **`CloseRequest`** (`BaseCreateSchema`)
   - Request to **close** complaint (final state).
   - Fields: complaint_id, optional `closure_notes`, `student_confirmed`.
   - Validation: normalize closure_notes.

---

## 5. `complaint_escalation.py` – Escalation workflow models

**Purpose:** Manual and automatic escalation flows plus escalation history.

**Classes that should live here:**

1. **`EscalationRequest`** (`BaseCreateSchema`)
   - Request to **escalate** a complaint.
   - Fields: complaint_id, `escalate_to`, `escalation_reason`, `increase_priority`, `is_urgent`.
   - Validations: detailed, non-trivial escalation_reason.

2. **`EscalationResponse`** (`BaseSchema`)
   - Response after escalation.
   - Fields: complaint id/number, escalated flag, target IDs/names, who escalated, when, `new_priority`, confirmation `message`.

3. **`EscalationEntry`** (`BaseResponseSchema`)
   - Single **escalation event** in history.
   - Fields:
     - escalated_to/by IDs and names; timestamp.
     - `reason`.
     - `status_before`, `priority_before`, `priority_after`.
     - `response_time_hours` (optional), `resolved_after_escalation`.

4. **`EscalationHistory`** (`BaseSchema`)
   - **Full escalation history** for a complaint.
   - Fields: complaint id/number, `escalations` list, `total_escalations`.

5. **`AutoEscalationRule`** (`BaseSchema`)
   - Configuration of **auto-escalation rules** per hostel.
   - Fields:
     - `hostel_id`.
     - Time thresholds (`escalate_after_hours`, priority-specific hours).
     - `escalate_on_sla_breach`.
     - Escalation chain: `first_escalation_to`, optional `second_escalation_to`.
     - `is_active`.
   - Validator ensures: `urgent < high < medium` thresholds.

---

## 6. `complaint_comments.py` – Comments / notes on complaints

**Purpose:** Comment creation, listing, updates, and mention notifications.

**Classes that should live here:**

1. **`CommentCreate`** (`BaseCreateSchema`)
   - Payload to **add a comment**.
   - Fields: complaint_id, `comment_text`, `is_internal`, attachments (max 5).
   - Validations: comment text quality, attachments limit.

2. **`CommentResponse`** (`BaseResponseSchema`)
   - Representation of a **single comment**.
   - Fields:
     - complaint_id.
     - commenter IDs/names/role.
     - comment_text, is_internal, attachments.
     - created_at, updated_at, `is_edited`.

3. **`CommentList`** (`BaseSchema`)
   - Wrapper for **all comments on a complaint**.
   - Fields: complaint id/number, `total_comments`, `public_comments`, `internal_notes`, `comments` list.

4. **`CommentUpdate`** (`BaseCreateSchema`)
   - Payload to **update comment text**.
   - Fields: comment_id, `comment_text`.
   - Validation: same quality checks as create.

5. **`CommentDelete`** (`BaseCreateSchema`)
   - Payload to **delete a comment**.
   - Fields: comment_id, optional `reason`.
   - Validation: normalized reason.

6. **`MentionNotification`** (`BaseSchema`)
   - Event model when someone is **@mentioned** in a comment.
   - Fields: comment_id, complaint_id/number, mentioned_by IDs/names, `comment_excerpt`, `comment_url`.

---

## 7. `complaint_feedback.py` – Feedback & satisfaction models

**Purpose:** Feedback submission and analytics tied to resolved complaints.

**Classes that should live here:**

1. **`FeedbackRequest`** (`BaseCreateSchema`)
   - Payload to **submit feedback** for a resolved complaint.
   - Fields: complaint_id, `rating` (1–5), optional `feedback`, several satisfaction booleans, optional `would_recommend`.
   - Validation: clean feedback text; advisory check for low ratings (non-blocking).

2. **`FeedbackResponse`** (`BaseResponseSchema`)
   - Response after submitting feedback.
   - Fields: complaint id/number, rating, feedback, submitted_by, submitted_at, confirmation message.

3. **`FeedbackSummary`** (`BaseSchema`)
   - Aggregated feedback metrics for an **entity** (hostel or supervisor).
   - Fields:
     - `entity_id`, `entity_type` ("hostel" or "supervisor").
     - period_start/end.
     - `total_feedbacks`, `average_rating`.
     - rating distribution counts (1–5).
     - satisfaction rates (resolution, response time, staff helpfulness).
     - `recommendation_rate`.
     - sentiment: positive/negative counts, `common_themes`.

4. **`RatingTrendPoint`** (`BaseSchema`)
   - Single **time-series point** for ratings.
   - Fields: period label, `average_rating`, `feedback_count`.

5. **`FeedbackAnalysis`** (`BaseSchema`)
   - Detailed **feedback analytics** for a hostel over time.
   - Fields:
     - hostel_id, period_start/end.
     - `rating_trend` list of `RatingTrendPoint`.
     - `feedback_by_category` (avg rating per category).
     - `feedback_by_priority` (avg rating per priority).
     - `avg_rating_quick_response` vs `avg_rating_slow_response`.

---

## 8. `complaint_filters.py` – Filtering/search/sort/export DTOs

**Purpose:** Input models for query parameters and export requests.

**Classes that should live here:**

1. **`ComplaintFilterParams`** (`BaseFilterSchema`)
   - Rich filter set for **list endpoints**.
   - Fields:
     - Text search, hostel filters (single/multiple), raised_by, student_id.
     - Assignment filters: `assigned_to`, `unassigned_only`.
     - Category/priority/status (single & multiple).
     - Date ranges: opened/resolved from/to.
     - Special flags: `sla_breached_only`, `escalated_only`.
     - `room_id`.
     - Age in hours min/max.
   - Validations: non-empty search, list lengths, logical ranges.

2. **`ComplaintSearchRequest`** (`BaseFilterSchema`)
   - **Full-text search** payload.
   - Fields:
     - `query`, optional hostel_id.
     - booleans: search_in_title/description/number.
     - Optional filters: status, priority.
     - Pagination: `page`, `page_size`.
   - Validation: normalized non-empty query.

3. **`ComplaintSortOptions`** (`BaseFilterSchema`)
   - Sorting configuration.
   - Fields:
     - `sort_by` (one of `opened_at|priority|status|category|age|updated_at|resolved_at`).
     - `sort_order` (`asc|desc`).
   - Validation: normalize to lowercase.

4. **`ComplaintExportRequest`** (`BaseFilterSchema`)
   - Payload to **export complaints** (CSV/Excel/PDF).
   - Fields:
     - optional hostel_id.
     - optional `filters: ComplaintFilterParams`.
     - `format` (`csv|excel|pdf`).
     - include flags: comments, resolution details, feedback.
   - Validation: normalize format.

---

## 9. `complaint_analytics.py` – Advanced analytics & dashboards

**Purpose:** Higher-level analytical views, beyond simple stats.

**Classes that should live here:**

1. **`ResolutionMetrics`** (`BaseSchema`)
   - Resolution performance metrics: total_resolved, average/median/fastest/slowest resolution times, resolution rate, same-day resolution, escalation rate, reopen rate.

2. **`CategoryMetrics`** (`BaseSchema`)
   - Metrics for a **single category**: total/open/resolved counts, average resolution time, resolution_rate, percentage_of_total.

3. **`CategoryAnalysis`** (`BaseSchema`)
   - **Category-wise analysis**:
     - `categories`: list of `CategoryMetrics`.
     - `most_common_category`, `most_problematic_category`.

4. **`ComplaintTrendPoint`** (`BaseSchema`)
   - Time-series point for complaint counts.
   - Fields: period label, total/open/resolved counts, per-priority counts (urgent/high/medium/low).

5. **`StaffPerformance`** (`BaseSchema`)
   - Performance metrics per **staff member**:
     - staff_id/name/role.
     - complaints_assigned/resolved.
     - average_resolution_time, resolution_rate, optional average_rating.

6. **`RoomComplaintCount`** (`BaseSchema`)
   - Complaint counts per **room**:
     - room_id, room_number, complaint_count, most_common_category.

7. **`ComplaintHeatmap`** (`BaseSchema`)
   - **Temporal/spatial patterns**:
     - `hostel_id`.
     - `complaints_by_hour` (0–23), `complaints_by_day`.
     - `complaints_by_room` (list of `RoomComplaintCount`).
     - `complaints_by_floor`.
   - Validator ensures `complaints_by_hour` keys are 0–23.

8. **`ComplaintAnalytics`** (`BaseSchema`)
   - Top-level **analytics dashboard** model.
   - Fields:
     - hostel_id (or None for global), period_start/end.
     - total/open/resolved/closed.
     - `resolution_metrics: ResolutionMetrics`.
     - `category_analysis: CategoryAnalysis`.
     - `priority_distribution` (dict).
     - `complaint_trend` (list of `ComplaintTrendPoint`).
     - SLA metrics: `sla_compliance_rate`, `sla_breached_count`.
     - `top_resolvers`: list of `StaffPerformance` (top 10).
   - Validator: period_end ≥ period_start.

---

## 10. `__init__.py` – Package exports

**Purpose:** Re-export all complaint-related schema classes with a clean public API.

**What should be exported here:**

From each submodule:

- From `complaint_base`:
  - `ComplaintBase`, `ComplaintCreate`, `ComplaintUpdate`, `ComplaintStatusUpdate`.

- From `complaint_response`:
  - `ComplaintResponse`, `ComplaintDetail`, `ComplaintListItem`, `ComplaintSummary`, `ComplaintStats`.

- From `complaint_assignment`:
  - `AssignmentRequest`, `AssignmentResponse`, `ReassignmentRequest`, `BulkAssignment`, `UnassignRequest`, `AssignmentHistory`.

- From `complaint_resolution`:
  - `ResolutionRequest`, `ResolutionResponse`, `ResolutionUpdate`, `ReopenRequest`, `CloseRequest`.

- From `complaint_escalation`:
  - `EscalationRequest`, `EscalationResponse`, `EscalationHistory`, `EscalationEntry`, `AutoEscalationRule`.

- From `complaint_feedback`:
  - `FeedbackRequest`, `FeedbackResponse`, `FeedbackSummary`, `FeedbackAnalysis`, `RatingTrendPoint`.

- From `complaint_comments`:
  - `CommentCreate`, `CommentResponse`, `CommentList`, `CommentUpdate`, `CommentDelete`, `MentionNotification`.

- From `complaint_filters`:
  - `ComplaintFilterParams`, `ComplaintSearchRequest`, `ComplaintSortOptions`, `ComplaintExportRequest`.

- From `complaint_analytics`:
  - `ComplaintAnalytics`, `ResolutionMetrics`, `CategoryAnalysis`, `CategoryMetrics`, `ComplaintTrendPoint`, `StaffPerformance`, `ComplaintHeatmap`, `RoomComplaintCount`.

============================================================================================================================================================
Here’s the clear breakdown of which classes belong in which file in app/schemas/file, and what each group is responsible for.

1. document_upload.py – Document-specific upload, info, verification & expiry
Purpose:
Everything specifically about documents (ID proofs, agreements, invoices, etc.): their upload init, validation, info, listing, verification, OCR, and expiry alerts.

Classes in this file:

DocumentUploadInitRequest

Request schema to initialize a document upload.
Includes filename/content-type/size + document-specific classification, metadata, dates, and processing options (OCR, auto-verify, redact).
Validates filename, expiry date, and issue/expiry consistency.
DocumentUploadInitResponse

Response schema extending FileUploadInitResponse for document uploads.
Adds:
document_type
flags: will_perform_ocr, will_auto_verify
estimated_processing_time_seconds.
DocumentValidationResult

Backend validation result for a document (after upload, before use).
Contains validation status, score, checks passed/failed, warnings, reasons, and extracted metadata.
DocumentInfo

Main document info / view model (read model).
Used to show a single document: IDs, URLs, ownership, classification, file metadata, verification status, OCR flags/text, timestamps, and computed expiry info.
DocumentList

Aggregated list of DocumentInfo for an owner (student/hostel/user/system).
Includes counts (total, verified, pending, expired, expiring_soon) and per-type breakdown, with a computed verification_rate.
DocumentVerificationRequest

Request schema used by admins to approve/reject a document.
Includes verification status, notes, rejection reason, and corrected extracted fields (reference number, issue/expiry dates).
Validates that rejection_reason is provided when status is rejected.
DocumentVerificationResponse

Response schema confirming verification action and final status.
Contains doc ID, verifier info, timestamp, and confirmation message.
DocumentOCRResult

Result of OCR processing on a document.
Holds OCR status, confidence, full extracted text, structured fields (name, ID, DOB, address), processing metadata, and error message if any.
DocumentExpiryAlert

Schema for expiry alerts/notifications about documents.
Includes owner info, expiry date, days until expiry, alert type/severity, notification flags.
Computed fields: is_expired, urgency_level.
2. file_filters.py – Filtering, searching, sorting
Purpose:
Schemas used to query/filter/search/sort files and documents/images.

Classes in this file:

FileFilterParams

General-purpose file filtering parameters.
Filters by search text, owner, MIME/content type, size, dates, public/deleted, virus scan status, tags, categories.
Validates logical ranges for size and dates.
FileSearchRequest

Full-text search request for files.
Contains query string, scope switches (filename/tags/metadata/OCR text), optional hostel/content_type filters, and pagination.
FileSortOptions

Sorting options for file lists.
Fields: sort_by (created_at, updated_at, filename, size_bytes, access_count), sort_order (asc/desc).
DocumentFilterParams

Document-specific filtering params (on top of general file dimensions).
Filters by document_type(s), subtype, verified/verification_status, expiry (is_expired, expiring_within_days, expiry ranges), OCR completion, student_id, hostel_id.
ImageFilterParams

Image-specific filters.
Filters by usage (hostel_cover, avatar, etc.), dimensions ranges, orientation, variants/optimization, image format, and hostel_id.
Validates dimension ranges.
3. file_response.py – File metadata, info, lists, stats & access logs
Purpose:
Read-oriented schemas describing stored files, lists, stats, and access logs.

Classes in this file:

FileMetadata

Technical and business metadata for a file.
Fields: content_type, size_bytes, checksum, original filename, extension, dimensions/duration, category, tags, custom_metadata, processing status.
Computed: size_mb, is_image, is_video, is_audio, is_document.
FileInfo

Main file record view model (read model).
Contains IDs, storage_key, ownership (uploaded_by, hostel, student), access control (is_public, is_deleted), URLs, metadata (FileMetadata), virus scan status, access_count, timestamps.
Computed: age_days, is_recent.
FileURL

Schema for a single access URL, typically a signed URL.
Fields: url, url_type, expires_at, is_permanent.
Computed: is_expired, time_until_expiry_minutes.
FileListResponse

Paginated listing of files.
Fields: items (List[FileInfo]), total_items, page, page_size, total_pages, total_size_bytes.
Computed: has_next, has_previous, total_size_mb.
FileStats

Aggregated storage statistics for a user/hostel/system.
Counts by visibility and type; total size; optional quota; time-based counts (today/this week/this month).
Computed: total_size_gb, storage_used_percentage, is_near_quota.
FileAccessLog

Audit log entry for file access.
Contains who accessed what, how (method/type), from where (IP, UA, referrer, geo), when, and whether it was successful.
4. file_upload.py – Generic file upload flows (single & multipart)
Purpose:
Schemas used during file upload lifecycle: init, complete, multipart.

Classes in this file:

FileUploadInitRequest

Input to start a generic file upload.
Fields: filename, content_type, size_bytes, folder, ownership (uploaded_by, hostel, student), classification (category, tags), access control, virus_scan, auto_optimize.
Validates filename, content_type, folder, tags, and size per content type.
FileUploadInitResponse

Response from upload init.
Fields: upload_id, storage_key, upload_url/method/headers, filename, content_type, size_bytes, is_public, public_url, expires_at, max_file_size, will_scan_virus, will_optimize.
FileUploadCompleteRequest

Request to indicate upload finished.
Confirms with upload_id, storage_key, uploader, checksum, etag, and optional actual_size_bytes.
Validates checksum/etag as hex-like strings.
FileUploadCompleteResponse

Response after successful completion.
Fields: file_id, storage_key, URLs, filename, content_type, size_bytes, processing_status, virus_scan_status, uploaded_at, message.
MultipartUploadInitRequest

Init a multipart upload for large files.
Fields: filename, content_type, total_size_bytes, part_size_bytes, uploaded_by_user_id, hostel_id, category, is_public.
Validates filename and size ranges for multipart.
MultipartUploadPart

Represents a single multipart upload part.
Fields: part_number, upload_url, size_bytes, expires_at.
MultipartUploadCompleteRequest

Final step to complete multipart upload.
Fields: upload_id, storage_key, uploaded_by_user_id, parts (list of dicts with part_number, etag).
Validates that each part dict has proper part_number and etag.
5. image_upload.py – Image-specific upload & processing
Purpose:
Schemas dedicated to images: upload init, generated variants, processing results, options, and image metadata.

Classes in this file:

ImageUploadInitRequest

Request to initialize an image upload with context and processing options.
Fields: filename, image-specific content_type pattern, size_bytes, uploader, hostel/student, usage, generate_variants, auto_optimize, convert_to_webp, quality, add_watermark.
Validates image filename extension and applies special rules for SVG (no variants/optimize).
ImageVariant

Info about a generated image variant (thumbnail, medium, etc.).
Fields: variant_name, url, width, height, size_bytes, format, is_optimized, quality.
Computed: aspect_ratio, megapixels.
ImageUploadInitResponse

Extends FileUploadInitResponse with image-specific hints.
Fields: variants_planned, will_optimize, will_convert_format, target_format.
ImageProcessingResult

Result of post-upload image processing.
Fields: file_id, storage_key, original URL/dimensions/size, list of variants, processing_status, processing_time_seconds, processing_error, was_optimized, size_reduction_percentage.
Computed: total_variants, total_storage_bytes.
ImageProcessingOptions

Configurable processing rules for images.
Variant max sizes, quality per size, preferred format, flags (preserve_exif, strip_metadata, auto_orient), and watermark settings.
ImageMetadata

Extended image-specific metadata (beyond generic FileMetadata).
Width/height/format/mode, alpha, color space, EXIF-like fields (camera, date_taken, GPS).
Computed: aspect_ratio, megapixels, orientation.
6. __init__.py – Public export surface
Purpose:
Re-export all the above so other modules can import from app.schemas.file without worrying about submodule paths.

Exports:

From file_upload.py:

FileUploadInitRequest
FileUploadInitResponse
FileUploadCompleteRequest
FileUploadCompleteResponse
MultipartUploadInitRequest
MultipartUploadPart
MultipartUploadCompleteRequest
From file_response.py:

FileInfo
FileMetadata
FileURL
FileListResponse
FileStats
FileAccessLog
From file_filters.py:

FileFilterParams
FileSearchRequest
FileSortOptions
DocumentFilterParams
ImageFilterParams
From image_upload.py:

ImageUploadInitRequest
ImageUploadInitResponse
ImageVariant
ImageProcessingResult
ImageProcessingOptions
ImageMetadata
From document_upload.py:

DocumentUploadInitRequest
DocumentUploadInitResponse
DocumentValidationResult
DocumentInfo
DocumentList
DocumentVerificationRequest
DocumentVerificationResponse
DocumentOCRResult
DocumentExpiryAlert
This matches your current structure and is a clean separation by concern:

Generic file upload & lifecycle: file_upload.py
File views/stats/logs: file_response.py
Filtering/searching: file_filters.py
Images: image_upload.py
Documents: document_upload.py
Unified imports: __init__.py

============================================================================================================================================================

Here’s how the hostel schema package is logically organized, and exactly which classes belong in which file, based on your current design.

1. hostel_base.py – Core hostel entity & admin-editable fields
Purpose:
Canonical “hostel” definition and admin-editable base fields (create/update + media + SEO).

Classes in this file:

HostelBase

Base model with core hostel properties:
Name, slug, description.
Type (HostelType).
Website.
Pricing (starting_price_monthly, currency).
Amenities / facilities / security_features.
Policies (rules, check-in/out, visitor/late-entry policy).
Location info (nearby_landmarks, connectivity_info).
Inherits AddressMixin, ContactMixin, LocationMixin.
Validators for slug, name, lists, currency, landmarks, and check-in/out consistency.
HostelCreate

Input schema for creating a hostel.
Extends HostelBase + BaseCreateSchema.
Re-enforces required fields: name, hostel_type, contact_phone, address_line1, city, state, pincode.
HostelUpdate

Input schema for partial updates (PATCH).
Extends BaseUpdateSchema.
All fields optional mirrors many from HostelBase and mixins:
Basic info, address, contact, coordinates, pricing, lists, policies, location info, media, status.
Reuses validators from HostelBase for slug, name, lists, currency, and normalizes phone numbers.
HostelMediaUpdate

Focused update for media / visual content:
cover_image_url, gallery_images, virtual_tour_url, video_urls.
Validates gallery images (cleaning, dedupe, max 20).
HostelSEOUpdate

Focused update for SEO metadata:
meta_title, meta_description, meta_keywords, og_*.
Cleans and limits meta_keywords.
2. hostel_admin.py – Admin views & operational settings
Purpose:
Admin-facing view and mutation schemas: dashboard, settings, capacity, status.

Classes in this file:

HostelAdminView

Admin dashboard view of a hostel:
Identity (id, name, slug).
Status & flags (status, is_active, is_public, is_featured, is_verified).
Capacity & occupancy stats (rooms/beds, occupancy_percentage, students).
Financials (total_revenue_this_month, outstanding_payments).
Pending counts (bookings, complaints, maintenance).
Subscription data (plan, status, expiry).
Review metrics (average_rating, total_reviews).
HostelSettings

Configurable operational settings:
Visibility/active flags.
Booking settings (auto_approve, advance %, max/min duration).
Payment settings (due day, grace, penalty %).
Attendance settings.
Notification toggles.
Mess settings.
Security time windows.
HostelVisibilityUpdate

Narrow DTO for visibility controls:
is_public, is_featured, is_verified.
HostelCapacityUpdate

Admin-only capacity changes:
total_rooms, total_beds.
Validator ensuring beds are between rooms and rooms * 8.
HostelStatusUpdate

Admin-only operational status update:
status, is_active, reason, effective_date.
Validator requiring reason when deactivating or setting to maintenance/closed.
3. hostel_response.py – API response/view models
Purpose:
Read-oriented schemas used as API responses for internal (non-public) views.

Classes in this file:

HostelResponse

“Basic” response for hostel:
Name, slug, type, city/state, starting_price_monthly, rating, reviews, capacity summary, visibility flags, cover_image_url, status.
HostelDetail

Detailed internal view for hostel detail pages (admin/owner side):
Everything: contact + full address + coordinates + pricing + capacity + features + policies + location info + media + status + SEO fields.
HostelListItem

Lightweight entry for list views:
ID, name, slug, type, city/state, starting_price_monthly, rating, reviews, available_beds, cover image, featured flag, distance_km.
HostelStats

Key statistics summary for a hostel:
Occupancy, revenue, students, complaints, bookings, reviews, updated_at.
4. hostel_public.py – Public/visitor-facing models
Purpose:
Schemas returned to unauthenticated users / visitors: cards for listings and full public profiles.

Classes in this file:

PublicHostelCard

Compact info for public search/listing cards:
ID, name, slug, type, city/state, starting_price_monthly, currency, rating, reviews, available_beds, cover_image_url, is_featured, top amenities (max 5), distance_km.
PublicRoomType

Public room-type-specific details:
room_type, price_monthly/quarterly/yearly, availability/capacity, room_amenities, images, room_size_sqft.
PublicHostelProfile

Full public hostel profile for detail pages:
Identity, description, type.
Public contact + address + coordinates.
Pricing, availability & capacity.
Ratings & distributions.
Features (amenities/facilities/security).
Policies, location info, media.
Room types (list of PublicRoomType).
Additional info (established_year, total_rooms).
PublicHostelList

Paginated public listing response:
hostels: List[PublicHostelCard].
total_count, filters_applied, page, page_size, total_pages.
5. hostel_filter.py – Backoffice filtering & sorting
Purpose:
Admin/owner facing filter schemas for listing and bulk operations.

Classes in this file:

HostelFilterParams

General filter params for hostel lists:
Search text, location, hostel_type(s), status/visibility flags.
Price range, min_rating.
Availability (has_availability, min_available_beds).
Amenities filter.
Admin-specific filters (admin_id, has_subscription).
Validates price_min/price_max relationship.
HostelSortOptions

Sorting options:
sort_by: name|city|price|rating|occupancy|created_at|updated_at.
sort_order: asc|desc.
AdvancedFilters

Extra advanced filters:
Created_after/before.
occupancy_min/max.
min_reviews.
min/max_rooms.
revenue_min/max (admin only).
Validates date, occupancy ranges.
BulkFilterParams

For bulk operations:
Either explicit hostel_ids (max 100, unique).
Or use_filters=True with embedded HostelFilterParams.
6. hostel_search.py – Public search & facets
Purpose:
Schemas for public search API, including request filters, facets, and result wrapper.

Classes in this file:

HostelSearchRequest

Search request with:
Text query.
City/state/pincode.
Radius search (lat/lon/radius_km with validation).
hostel_type, min/max price, room_type.
amenities, available_beds_min.
min_rating.
verified_only, featured_only.
sort_by (relevance|price_low|price_high|rating|distance|newest).
pagination.
FacetItem

Single generic facet item:
value, label, count.
PriceRangeFacet

Price range facet:
min_price, max_price, label, count.
RatingFacet

Rating facet:
min_rating, label, count.
SearchFacets

Aggregation of facets:
cities, hostel_types, price_ranges, amenities, ratings.
HostelSearchResponse

Top-level search response:
results: List[PublicHostelCard].
total_results, total_pages, current_page.
filters_applied, facets.
HostelSearchFilters

Additional refinement filters:
gender (boys/girls/co_ed).
boolean flags for facilities (wifi, ac, laundry, parking, gym, mess).
security (cctv, security_guard).
allow_visitors.
check_in_date (validated not in the past).
7. hostel_analytics.py – Analytics & reporting
Purpose:
All analytics/metrics-related schemas: occupancy, revenue, bookings, complaints, reviews; plus overall dashboard and revenue stats.

Classes in this file:

OccupancyDataPoint – single date occupancy snapshot.
OccupancyAnalytics – aggregated occupancy metrics + trend + prediction.
RevenueDataPoint – date-based revenue/collected/pending.
RevenueAnalytics – aggregated revenue metrics + trend + comparisons + avg per bed.
BookingDataPoint – date-based bookings (total/approved/rejected).
BookingAnalytics – totals, rates, sources, trend, avg booking value.
ComplaintAnalytics – counts, resolution stats, distributions, SLA metrics.
RatingDataPoint – month-based rating stats.
ReviewAnalytics – rating totals, distribution, aspect ratings, trends, sentiment.
HostelAnalytics – dashboard aggregation:
hostel info, period, and nested occupancy, revenue, bookings, complaints, reviews.
RoomTypeOccupancy – occupancy by room type.
HostelOccupancyStats – detailed occupancy stats:
overall, by room type, history, projections.
MonthlyRevenue – per-month revenue, collected, pending, student_count, avg per student.
HostelRevenueStats – financial stats over a DateRangeFilter:
totals, profit, breakdowns, collection, monthly_revenue, growth stats.
AnalyticsRequest – input for generating analytics:
hostel_id, start_date, end_date, include_predictions, granularity; with date-range validation.
8. hostel_comparison.py – Cross-hostel comparison
Purpose:
Schemas for side-by-side comparison of multiple hostels.

Classes in this file:

HostelComparisonRequest

Request to compare 2–4 hostels (hostel_ids, uniqueness validated).
RoomTypeComparison

Room-type level details per hostel:
room_type, price, capacity, amenities.
ComparisonItem

Full comparison view of one hostel:
Identity, location, distance_from_center_km.
Pricing & price_range, security_deposit.
Capacity, ratings & breakdown.
Amenities/facilities/security_features.
room_types_available + room_type_details.
Policies, media, highlights (unique_features, pros/cons).
PriceComparison

Summary of pricing across compared hostels:
lowest/highest/average price, price_difference_percentage.
AmenityComparison

Summary of amenities:
common_amenities.
unique_to_hostel[hostel_id] = [amenities].
total_unique_amenities.
ComparisonSummary

High-level recommendations:
best_for_budget, best_rated, best_location, most_amenities, best_availability (all as hostel IDs).
Embedded PriceComparison and AmenityComparison.
ComparisonResult

Full comparison response:
hostels: List[ComparisonItem].
comparison_criteria.
summary: ComparisonSummary.
generated_at.
9. __init__.py – Public exports
Purpose:
Expose a clean import surface, re-exporting classes from the above modules so the rest of the app can use:

Python

from app.schemas.hostel import HostelCreate, PublicHostelCard, HostelAnalytics, ...
Exports match the grouping above:

Base: HostelBase, HostelCreate, HostelUpdate, HostelMediaUpdate, HostelSEOUpdate
Response: HostelResponse, HostelDetail, HostelListItem, HostelStats
Public: PublicHostelProfile, PublicHostelList, PublicHostelCard, PublicRoomType
Admin: HostelAdminView, HostelSettings, HostelVisibilityUpdate, HostelCapacityUpdate, HostelStatusUpdate
Search: HostelSearchRequest, HostelSearchResponse, HostelSearchFilters, SearchFacets
Filter: HostelFilterParams, HostelSortOptions, AdvancedFilters, BulkFilterParams
Analytics: HostelAnalytics, OccupancyAnalytics, RevenueAnalytics, BookingAnalytics, ComplaintAnalytics, ReviewAnalytics, HostelOccupancyStats, HostelRevenueStats, AnalyticsRequest
Comparison: HostelComparisonRequest, ComparisonResult, ComparisonItem

============================================================================================================================================================
Here’s the clear, file‑by‑file mapping of what classes belong where in the `inquiry` schema package and what each group is responsible for.

---

## 1. `inquiry_base.py` – Core inquiry entity + create/update DTOs

**Purpose:**  
Defines the canonical inquiry shape and the models used to create or update an inquiry record.

**Classes in this file:**

1. **`InquiryBase`**
   - Core, reusable schema describing a visitor inquiry:
     - Target hostel: `hostel_id`.
     - Visitor contact: `visitor_name`, `visitor_email`, `visitor_phone`.
     - Preferences: `preferred_check_in_date`, `stay_duration_months`, `room_type_preference`.
     - Message: `message`.
     - Metadata: `inquiry_source`, `status`.
   - Has validation for:
     - `visitor_name` (no digits, min length, trimming).
     - `visitor_phone` (normalize and ensure length).
     - `preferred_check_in_date` (sanity checks but permissive).
     - `message` (trim, enforce length).
   - Computed flags:
     - `has_date_preference`, `has_duration_preference`, `has_room_preference`, `is_detailed_inquiry`.

2. **`InquiryCreate`**
   - Used when **creating** a new inquiry.
   - Extends `InquiryBase` + `BaseCreateSchema`.
   - Overrides `status` to always start as `InquiryStatus.NEW` (validator forces this, even if a different value is passed).

3. **`InquiryUpdate`**
   - Used for **partial updates** of an existing inquiry.
   - Extends `BaseUpdateSchema`.
   - All fields optional and focused on fields that can realistically change:
     - Visitor contact fields (name/email/phone).
     - Preferences (check‑in date, duration, room_type_preference).
     - Message.
     - Status (although often updated by a dedicated status endpoint).
   - Has validators to:
     - Clean/validate name if provided.
     - Normalize phone if provided.
     - Clean message if provided.

**Summary:**  
This file should only contain the *core inquiry shape* and the **create/update** request models.

---

## 2. `inquiry_filters.py` – Filtering, searching, sorting, exporting

**Purpose:**  
Schemas used to **query** inquiry data: filtering, full‑text search, sorting, and export requests.

**Classes in this file:**

1. **`InquiryFilterParams`**
   - Comprehensive **filter parameters** for listing inquiries:
     - Text search in visitor identifiers.
     - `hostel_id` / `hostel_ids`.
     - `status` / `statuses`.
     - `source` / `sources`.
     - Date filters (`created_from/to`, `check_in_from/to`).
     - Room type filter.
     - Assignment filters (`assigned_to`, `is_assigned`).
     - Contact flags (`is_contacted`).
     - Urgency flags (`is_urgent`, `is_stale`).
   - Validates created and check‑in date ranges.

2. **`InquirySearchRequest`**
   - Full‑text **search request** with pagination:
     - `query` string (required).
     - Optional `hostel_id`.
     - Booleans to select fields to search (name/email/phone/message).
     - Optional `status` filter.
     - `page` and `page_size`.

3. **`InquirySortOptions`**
   - Defines how to **sort inquiries**:
     - `sort_by`: `created_at|visitor_name|status|check_in_date`.
     - `sort_order`: `asc|desc`.
   - Normalizes sort fields to lowercase.

4. **`InquiryExportRequest`**
   - Request to **export** inquiries:
     - Scope: `hostel_id` and/or embedded `InquiryFilterParams`.
     - Export `format`: `csv|excel|pdf`.
     - Toggles: `include_message`, `include_notes`, `include_timeline`.

**Summary:**  
All **querying/selection/export** related DTOs live here.

---

## 3. `inquiry_response.py` – Read/view models for API responses

**Purpose:**  
Schemas used to **return inquiries** from the API: basic response, detailed view, list item, and stats.

**Classes in this file:**

1. **`InquiryResponse`**
   - Standard, compact **read model** for a single inquiry.
   - Fields:
     - Hostel info (id + hostel_name).
     - Visitor info.
     - Preferences.
     - `status`, `created_at`.
   - Computed:
     - `age_days`.
     - `is_new` (less than 24h).
     - `is_stale` (older than 7 days and still NEW).
     - `urgency_level` ("high"/"medium"/"low").

2. **`InquiryDetail`**
   - Full **detail view** of an inquiry:
     - Everything in `InquiryResponse`.
     - Message, source, status.
     - Contact information (who contacted, when).
     - Assignment info (assigned_to, when).
     - Internal `notes`.
     - `created_at`, `updated_at`.
   - Computed:
     - `age_days`.
     - `has_been_contacted`.
     - `is_assigned`.
     - `response_time_hours`.
     - `days_since_contact`.

3. **`InquiryListItem`**
   - Lightweight **list row** for summary views:
     - id, hostel_name, visitor_name/phone.
     - Preferences.
     - `status`, `created_at`.
     - Quick flags: `is_urgent`, `is_assigned`.
   - Computed:
     - `age_days`.
     - `status_badge_color` (hex color per status).

4. **`InquiryStats`**
   - Aggregate **statistics** for inquiries:
     - Counts: total, new, contacted, converted.
     - Average response time.
     - Conversion & interest rates (%).
     - `inquiries_by_source` breakdown.
   - Computed:
     - `pending_action_count` (new + contacted).
     - `response_rate` (% contacted of total).

**Summary:**  
This file is strictly **response/view models** for frontend usage and dashboards.

---

## 4. `inquiry_status.py` – Status, assignment, follow‑up, timeline, conversions

**Purpose:**  
Schemas for **mutating** and tracking the lifecycle of inquiries: status changes, assignments, follow‑ups, conversion, and bulk updates.

**Classes in this file:**

1. **`InquiryStatusUpdate`**
   - Input to **change status** of a single inquiry.
   - Fields: `inquiry_id`, `new_status`, `notes`, `updated_by`.
   - Cleans notes and contains a (soft) model validator for logical transitions (current status check is done at service layer).

2. **`InquiryAssignment`**
   - Input to **assign** an inquiry to an admin/staff:
     - `inquiry_id`, `assigned_to`, `assigned_by`, `assignment_notes`, `follow_up_due`.
   - Validates follow_up_due is not in the past and cleans notes.

3. **`InquiryFollowUp`**
   - Input to **record a follow‑up** interaction:
     - `inquiry_id`, `followed_up_by`.
     - `contact_method`, `contact_outcome`.
     - `notes` (required, meaningful).
     - `next_follow_up_date` (must not be in the past).
   - Used to build contact history and drive workflows.

4. **`InquiryTimelineEntry`**
   - Read model representing a **timeline event** for an inquiry:
     - Event type (status_change, assignment, follow_up, note_added, conversion).
     - Optional `status` at that point.
     - timestamp, changed_by, changed_by_name, notes.
     - Additional `metadata` dict.

5. **`InquiryConversion`**
   - Input to **record conversion** of an inquiry to a booking:
     - `inquiry_id`, `booking_id`, `converted_by`, `conversion_notes`.
   - Cleans conversion notes.

6. **`BulkInquiryStatusUpdate`**
   - Input for **batch status updates**:
     - `inquiry_ids` (1–100, deduped).
     - `new_status`, `notes`, `updated_by`.
   - Validates list length and cleans notes.

**Summary:**  
All **status & lifecycle operations** (single/bulk) plus timeline entries live here.

---

## 5. `__init__.py` – Public exports

**Purpose:**  
Provides a unified import surface for all inquiry-related schemas.

**Exports:**

From `inquiry_base.py`:
- `InquiryBase`
- `InquiryCreate`
- `InquiryUpdate`

From `inquiry_response.py`:
- `InquiryResponse`
- `InquiryDetail`
- `InquiryListItem`
- `InquiryStats`

From `inquiry_status.py`:
- `InquiryStatusUpdate`
- `InquiryAssignment`
- `InquiryFollowUp`
- `InquiryTimelineEntry`
- `InquiryConversion`
- `BulkInquiryStatusUpdate`

From `inquiry_filters.py`:
- `InquiryFilterParams`
- `InquirySearchRequest`
- `InquirySortOptions`
- `InquiryExportRequest`

This matches your current structure and cleanly separates:

- **Entity + create/update** → `inquiry_base.py`  
- **Filters/search/sort/export** → `inquiry_filters.py`  
- **Read/view models** → `inquiry_response.py`  
- **Lifecycle & status management** → `inquiry_status.py`  
- **Unified imports** → `__init__.py`

============================================================================================================================================================

Here’s the clear, file‑by‑file breakdown of which classes belong in the `leave` schema package and what each group is responsible for.

---

## 1. `leave_base.py` – Core leave entity + create/update DTOs

**Purpose:**  
Canonical leave application model and the admin/service‑facing create/update schemas.

**Classes in this file:**

1. **`LeaveBase`**
   - Core representation of a leave application as stored/managed in the system:
     - Identity link: `student_id`, `hostel_id`.
     - Business fields: `leave_type`, `from_date`, `to_date`, `total_days`, `reason`.
     - Contact: `contact_during_leave`, `emergency_contact`.
     - Supporting docs: `supporting_document_url`.
   - Validation:
     - `from_date` not > 30 days in past or > 1 year in future.
     - `reason` meaningful (min length, non‑nonsense).
     - Phone normalization.
     - Date consistency: `to_date >= from_date`, `total_days` matches date range; max duration per `leave_type`.
     - Document requirements: sick leave > 3 days and any leave > 15 days must have docs.

2. **`LeaveCreate`**
   - Input schema to **create** a leave record.
   - Extends `LeaveBase` + `BaseCreateSchema`.
   - Overrides `total_days` to be optional; auto‑calculates if omitted based on `from_date`/`to_date`.

3. **`LeaveUpdate`**
   - **Partial update** schema (PATCH).
   - Extends `BaseUpdateSchema`.
   - Optional fields: `leave_type`, dates, `total_days`, `reason`, contacts, supporting_document_url, `status`.
   - Validation:
     - Reason cleaned and re‑validated if provided.
     - Phone normalization.
     - If both dates provided, ensure `to_date >= from_date`; auto‑recompute `total_days` when needed.

**This file is the foundation for leave records used by internal logic and admin APIs.**

---

## 2. `leave_application.py` – Student‑facing application & cancellation

**Purpose:**  
Student‑initiated flows: applying for leave and requesting cancellation. These are more UX‑oriented DTOs than the internal `LeaveBase`.

**Classes in this file:**

1. **`LeaveApplicationRequest`**
   - Schema students use to **apply for leave**.
   - Fields:
     - `student_id`, `hostel_id`, `leave_type`, `from_date`, `to_date`, `reason`.
     - Optional contacts, emergency_contact + relation.
     - `supporting_document_url`, `destination_address`, `expected_return_date`.
   - Validation:
     - `from_date` within −7 to +30 days relative to today (limited backdating & advance).
     - Reason must be meaningful and not just placeholder/test text.
     - Phone normalization.
     - Destination cleaned.
     - Model‑level validation:
       - `to_date >= from_date`.
       - Duration rules per `leave_type` (same limits as base but from another perspective).
       - Document and contact requirements based on duration (e.g., >3 days sick, >7 days contact, >15 days emergency contact).
       - `expected_return_date` logic relative to `to_date`.

2. **`LeaveCancellationRequest`**
   - Student request to **cancel a leave** (pending or approved).
   - Fields:
     - `leave_id`, `student_id`, `cancellation_reason`, `immediate_return`, `actual_return_date`.
   - Validation:
     - Reason meaningful.
     - Model‑level:
       - If `immediate_return` is True, `actual_return_date` cannot be in the future.
       - If `actual_return_date` set, cannot be in future or more than 30 days in past.

**This file is specifically for student‑side endpoints, separated from core entity logic.**

---

## 3. `leave_approval.py` – Admin approval decisions & responses

**Purpose:**  
Schemas for supervisors/admins to approve/reject/modify leave and for representing the approval decision.

**Classes in this file:**

1. **`LeaveApprovalRequest`**
   - Simple **approve/reject** schema:
     - `leave_id`, `approver_id`, `approve` (bool).
     - Optional `approval_notes`, `rejection_reason`, `conditions`.
     - Notification flags: `notify_student`, `notify_guardian`.
   - Validation:
     - Trim text fields.
     - If rejecting: `rejection_reason` required and min length; `conditions` must not be set.
     - If approving: `rejection_reason` must not be set.

2. **`LeaveApprovalAction`**
   - More flexible **workflow action** schema:
     - `action`: `approve|reject|request_changes|escalate`.
     - `comments` (required, meaningful).
     - `requested_changes` when `request_changes`.
     - `escalate_to` when `escalate`.
     - `conditions` only allowed with `approve`.
   - Validator enforces requirements based on `action`.

3. **`LeaveApprovalResponse`**
   - **Read model** describing the outcome of an approval decision:
     - `leave_id`, `student_id`, `student_name`.
     - `status`, `previous_status`.
     - Approval details: `approved_*`, `approval_notes`, `conditions`.
     - Rejection details: `rejected_*`, `rejection_reason`.
     - Response metadata: `message`, `notifications_sent`, `notification_recipients`.
   - Model‑level consistency:
     - For `APPROVED`: must have approval details and no rejection details.
     - For `REJECTED`: must have rejection details and no approval details.

**This file is tightly scoped to approval workflows.**

---

## 4. `leave_balance.py` – Balances, quotas & usage analytics

**Purpose:**  
Everything related to leave entitlements/balances and analytical usage detail.

**Classes in this file:**

1. **`LeaveBalance`**
   - Balance for a specific `LeaveType`:
     - `allocated_per_year`, `allocated_per_semester`, `used_days`, `pending_days`, `remaining_days`, `carry_forward_days`, `max_consecutive_days`, `requires_approval`.
   - Validation:
     - `remaining_days` must match formula: allocated + carry_forward − used − pending (tolerates ±1).
   - Computed:
     - `usage_percentage`.
     - `is_exhausted`.
     - `utilization_status` (minimal/low/moderate/high/critical).

2. **`LeaveBalanceSummary`**
   - Aggregated **per‑student** summary across leave types:
     - Student + hostel info, academic year start/end, current_semester.
     - `balances: List[LeaveBalance]`.
     - Totals: allocated/used/pending/remaining.
     - `last_updated`.
   - Validation:
     - `academic_year_end > academic_year_start`.
   - Computed:
     - `overall_usage_percentage`.
     - `days_until_year_end`.
     - `has_pending_applications`.

3. **`LeaveQuota`**
   - Policy‑level **quota configuration** for a hostel and `LeaveType`:
     - `annual_quota`, optional semester/monthly quotas.
     - `max_consecutive_days`, `min_notice_days`.
     - `requires_document_after_days`.
     - Carry‑forward flags and settings.
   - Validation:
     - `carry_forward_max_days` can only be set if `allow_carry_forward` is True.

4. **`LeaveUsageDetail`**
   - Granular per‑leave **usage record** for reporting:
     - Student, leave_id, leave_type.
     - from/to, total_days, applied_at, approved_at.
     - `days_notice`, `was_backdated`, `had_supporting_document`.
   - Computed:
     - `approval_turnaround_days`.

**This file encapsulates leave economics: entitlements, consumption, and reports.**

---

## 5. `leave_response.py` – API response/view models

**Purpose:**  
Read models used by APIs/clients: list responses, detailed views, and summary metrics.

**Classes in this file:**

1. **`LeaveResponse`**
   - Standard response for **list/detail** where only essential fields are needed:
     - Student + hostel info.
     - leave_type, from/to, total_days, status, applied_at.
     - optional terse `reason`.
   - Computed:
     - `status_display` (friendly text).
     - `leave_type_display`.
     - `is_active` (currently ongoing & approved).
     - `days_remaining` (if active).

2. **`LeaveDetail`**
   - Full **detailed view** for a single leave:
     - Full student & hostel context.
     - Complete leave data (reason, contacts, dest, docs).
     - All workflow timestamps and user IDs/names for approval, rejection, cancellation.
     - Last modification info.
   - Computed:
     - `is_active`, `is_upcoming`, `is_past`.
     - `can_be_cancelled` (business rule: can cancel pending/approved future/ongoing).

3. **`LeaveListItem`**
   - Minimal row for **paginated lists**:
     - id, student_id, student_name, room_number.
     - leave_type, from/to, total_days, status, applied_at.
   - Computed:
     - `status_badge_color`.
     - `is_urgent` (pending leaves starting soon).

4. **`LeaveSummary`**
   - Aggregated **summary stats** over a period:
     - Optional `student_id` or `hostel_id`.
     - period_start/end.
     - Status counts: total/pending/approved/rejected/cancelled.
     - Type counts: casual/sick/emergency/vacation.
     - Day aggregates: total_days_requested, total_days_approved, active_leaves.
   - Computed:
     - `approval_rate` (% approvals among decided applications).

**This file is dedicated to what the frontend / clients see when reading leave data.**

---

## 6. `__init__.py` – Public exports

**Purpose:**  
Provide a single import point for all leave‑related schemas.

**Exports:**

From `leave_base.py`:
- `LeaveBase`
- `LeaveCreate`
- `LeaveUpdate`

From `leave_response.py`:
- `LeaveResponse`
- `LeaveDetail`
- `LeaveListItem`
- `LeaveSummary`

From `leave_application.py`:
- `LeaveApplicationRequest`
- `LeaveCancellationRequest`

From `leave_approval.py`:
- `LeaveApprovalRequest`
- `LeaveApprovalAction`
- `LeaveApprovalResponse`

From `leave_balance.py`:
- `LeaveBalance`
- `LeaveBalanceSummary`
- `LeaveQuota`
- `LeaveUsageDetail`

This cleanly separates:

- Core entity & CRUD: `leave_base.py`
- Student‑side flows: `leave_application.py`
- Approvals: `leave_approval.py`
- Balances & quotas: `leave_balance.py`
- Read/view models: `leave_response.py`
- Unified exports: `__init__.py`

============================================================================================================================================================

Here’s a clear map of what classes belong in each maintenance schema file, based on the structure you’ve shown and the responsibilities implied by the filenames.

I’ll go file by file and list the classes that should live there, plus what each is for. This also implicitly tells you what *shouldn’t* be moved across files if you want to keep a clean separation of concerns.

---

## `maintenance_base.py`
**Purpose:** Core maintenance request model(s) used internally for CRUD operations.

**Classes that should be here:**

1. `MaintenanceBase`  
   - Base schema with core maintenance fields (hostel, requested_by, title, description, category, priority, issue_type, location, photos) and core validation.
2. `MaintenanceCreate`  
   - Extends `MaintenanceBase` + creation-specific fields (preferred completion date, notify_on_completion, allow_cost_estimation).
3. `MaintenanceUpdate`  
   - Partial update schema for existing requests (optional fields for title, description, category, priority, location, floor, area, status, cost, estimated completion date).
4. `MaintenanceStatusUpdate`  
   - Focused status-change schema (status, notes, notify_requester, updated_by) with logic about which statuses require notes.

---

## `maintenance_request.py`
**Purpose:** Request submission entry points (what end-users/supervisors submit).

**Classes that should be here:**

1. `MaintenanceRequest`  
   - Standard/simple request submission (students/residents).
2. `RequestSubmission`  
   - Supervisor-level submission with cost estimation, vendors, timelines, approval flags.
3. `EmergencyRequest`  
   - Emergency-only submission with extra safety / authority fields.

These are higher-level input forms distinct from the internal base/create/update models in `maintenance_base.py`.

---

## `maintenance_response.py`
**Purpose:** Read/API response views of maintenance requests.

**Classes that should be here:**

1. `MaintenanceResponse`  
   - Lightweight list/summary response (used in general listings).
2. `MaintenanceDetail`  
   - Full detail view (all metadata, workflow, vendor, cost, quality, preventive info).
3. `RequestListItem`  
   - Minimal list item for high-performance lists (ID, title, key flags/badges).
4. `MaintenanceSummary`  
   - Aggregated stats for a hostel dashboard (counts, costs, performance, quality).

All of these extend response/base schemas and are “read” DTOs only.

---

## `maintenance_assignment.py`
**Purpose:** Assignment of maintenance tasks to staff/vendors and related history.

**Classes that should be here:**

1. `TaskAssignment`  
   - Single assignment to internal staff (who, when, deadline, priority, instructions).
2. `VendorAssignment`  
   - Outsourced assignment to external vendor/contractor (quote, contract, warranty, compliance, etc.).
3. `AssignmentUpdate`  
   - Changes to existing assignment (reassignments, new deadline, instructions, priority).
4. `BulkAssignment`  
   - Assign multiple maintenance IDs to a single assignee in bulk.
5. `AssignmentEntry`  
   - A single assignment history entry (one assignee period with completion/reassignment tracking).
6. `AssignmentHistory`  
   - Whole assignment history for a maintenance request (list of `AssignmentEntry` + summary metrics).

---

## `maintenance_approval.py`
**Purpose:** Approval workflow around maintenance costs/requests.

**Classes that should be here:**

1. `ApprovalRequest`  
   - Payload to request approval (estimated cost, breakdown, justification, urgency).
2. `ApprovalResponse`  
   - Decision payload (approved/rejected details, amounts, conditions, reasons).
3. `ThresholdConfig`  
   - Per-hostel approval thresholds and rules (supervisor/admin/senior mgmt limits, auto-approve, quotes).
4. `ApprovalWorkflow`  
   - Current approval state for a particular maintenance request (required level, pending with whom, overdue, history).
5. `RejectionRequest`  
   - Structured payload to reject an approval request with guidance and possible resubmission conditions.

These are tightly focused on approval/authorization logic.

---

## `maintenance_completion.py`
**Purpose:** Completion of work, materials, quality checks, and certificates.

**Classes that should be here:**

1. `MaterialItem`  
   - Single material used (name, quantity, unit cost, total cost, supplier, warranty).
2. `CompletionRequest`  
   - Payload to mark a job as completed (work notes, labor, materials, cost breakdown, follow-up, warranty).
3. `ChecklistItem`  
   - A single qualitative checklist item for quality checking (description, pass/fail, notes).
4. `QualityCheck`  
   - Quality inspection of completed work (checklist items, rating, rework, feedback).
5. `CompletionResponse`  
   - API response summarizing completion (cost variance, quality status, follow-up flags).
6. `CompletionCertificate`  
   - Formal, printable completion certificate (work details, parties, dates, warranty, signatures).

---

## `maintenance_cost.py`
**Purpose:** Cost tracking, budgets, invoices, and cost analytics.

**Classes that should be here:**

1. `CostTracking`  
   - Per-request cost tracking (estimated/approved/actual, breakdown, variance).
2. `CategoryBudget`  
   - Budget for a single maintenance category (allocated/spent/remaining, utilization).
3. `BudgetAllocation`  
   - Hostel-level/fiscal-year budget with category breakdown and projections.
4. `MonthlyExpense`  
   - Summary of expenses for one month (totals, counts, averages, budget variance).
5. `ExpenseItem`  
   - Per-maintenance expense row for reports (title, category, estimated/actual/variance, completion date, vendor).
6. `ExpenseReport`  
   - Comprehensive expense report for a period (summary, breakdowns, monthly list, top expenses, vendors).
7. `InvoiceLineItem`  
   - Single line item in a vendor invoice (qty, unit price, tax).
8. `VendorInvoice`  
   - Full vendor invoice payload (header, line items, totals, tax, terms).
9. `CostAnalysis`  
   - Analytical cost insights (trend, highest cost categories, per-student/room, comparisons, recommendations).

---

## `maintenance_filters.py`
**Purpose:** Filtering/search/export parameter schemas for querying maintenance data.

**Classes that should be here:**

1. `MaintenanceFilterParams`  
   - General filter set for listing/querying maintenance data (hostel, room, category, status, dates, costs, flags).
2. `SearchRequest`  
   - Text-based search request (query, search_in_* flags, basic filters, pagination).
3. `AdvancedFilterParams`  
   - Extends `MaintenanceFilterParams` with advanced analytics/performance/quality/cost/warranty/vendor filters and sorting.
4. `MaintenanceExportRequest`  
   - Export configuration (format, fields, content options, grouping, date range, max records).

These are all *input* schemas for querying or exporting, not data entities.

---

## `maintenance_analytics.py`
**Purpose:** Higher-level analytics/insights around maintenance operations.

**Classes that should be here:**

1. `TrendPoint`  
   - Generic trend point (per-period counts, completion, pending, avg completion days).
2. `CostTrendPoint`  
   - Cost trend per period (total cost, average cost, budget, variance, utilization).
3. `CategoryBreakdown`  
   - Detailed metrics per maintenance category (counts, cost, time, priority mix, quality).
4. `VendorPerformance`  
   - Vendor-level performance metrics (jobs, timeliness, cost competitiveness, quality, satisfaction, reliability, tier).
5. `PerformanceMetrics`  
   - Overall maintenance performance metrics for a period/hostel (KPIs, cost, quality, response, priority distribution).
6. `ProductivityMetrics`  
   - Staff/team productivity metrics (assignments, jobs/day, utilization, on-time, quality, specialization).
7. `MaintenanceAnalytics`  
   - Top-level analytics dashboard object aggregating summary, breakdowns, trends, vendors, and insights.

---

## `maintenance_schedule.py`
**Purpose:** Preventive/scheduled maintenance and execution history.

**Classes that should be here:**

1. `ScheduleChecklistItem`  
   - Checklist item definition for preventive schedules.
2. `PreventiveSchedule`  
   - Read/response model of a schedule (hostel, recurrence, next due date, assignment, summary stats).
3. `ScheduleCreate`  
   - Input schema to create a preventive schedule (title, category, recurrence, dates, checklist, behavior).
4. `RecurrenceConfig`  
   - Advanced recurrence rules (weekly/monthly/yearly specifics, intervals, skip weekends/holidays).
5. `ChecklistResult`  
   - Execution-time result of a single checklist item.
6. `ScheduleExecution`  
   - Input schema to record one execution of a preventive schedule (date, executor, cost, duration, checklist results, rescheduling).
7. `ScheduleUpdate`  
   - Partial update to a schedule (title, recurrence, cost/duration, activity, priority, next_due_date).
8. `ExecutionHistoryItem`  
   - Single execution history record (dates, executor, outcome, cost, delay, quality).
9. `ScheduleHistory`  
   - Full execution history aggregate for a schedule (execution list, totals, averages, completion/on-time rates).

---

## `maintenance_completion.py` (already covered above)
(just noting again: completion/materials/quality/certificates)

---

## `maintenance_response.py` (already covered above)
(standard/detailed/list/summary responses)

---

## `maintenance_assignment.py` (already covered above)
(assignments & assignment history)

---

## `maintenance_approval.py` (already covered above)
(approval workflows & thresholds)

---

## `maintenance_cost.py` (already covered above)
(costs, budgets, invoices, cost analytics)

---

## `maintenance_filters.py` (already covered above)
(filter/search/export schemas)

---

## `maintenance_request.py` (already covered above)
(request submission inputs)

---

## `maintenance_analytics.py` (already covered above)
(analytics metrics & dashboards)

---

## `__init__.py`
**Purpose:** Package facade/re-export.

- Should only do imports and define `__all__` for:
  - Base & core: `MaintenanceBase`, `MaintenanceCreate`, `MaintenanceUpdate`, `MaintenanceStatusUpdate`
  - Requests: `MaintenanceRequest`, `RequestSubmission`, `EmergencyRequest`
  - Responses: `MaintenanceResponse`, `MaintenanceDetail`, `RequestListItem`, `MaintenanceSummary`
  - Assignment: `TaskAssignment`, `VendorAssignment`, `AssignmentUpdate`, `BulkAssignment`, `AssignmentEntry`, `AssignmentHistory`
  - Approval: `ApprovalRequest`, `ApprovalResponse`, `ApprovalWorkflow`, `RejectionRequest`, `ThresholdConfig`
  - Completion: `CompletionRequest`, `CompletionResponse`, `CompletionCertificate`, `MaterialItem`, `QualityCheck`, `ChecklistItem`
  - Schedule: `PreventiveSchedule`, `ScheduleCreate`, `ScheduleUpdate`, `ScheduleChecklistItem`, `RecurrenceConfig`, `ScheduleExecution`, `ChecklistResult`, `ScheduleHistory`, `ExecutionHistoryItem`
  - Cost: `CostTracking`, `BudgetAllocation`, `CategoryBudget`, `ExpenseReport`, `MonthlyExpense`, `ExpenseItem`, `VendorInvoice`, `InvoiceLineItem`, `CostAnalysis`
  - Filters: `MaintenanceFilterParams`, `AdvancedFilterParams`, `SearchRequest`, `MaintenanceExportRequest`
  - Analytics: `MaintenanceAnalytics`, `TrendPoint`, `CostTrendPoint`, `CategoryBreakdown`, `VendorPerformance`, `PerformanceMetrics`, `ProductivityMetrics`

Which matches the `__all__` you already have.

============================================================================================================================================================
Here’s a clear, file‑by‑file map of what classes belong where, and what role each one plays. You can treat this as the “intended contract” for `app/schemas/mess`.

---

## 1. `meal_items.py`

**Purpose:** Define *item-level* schemas: individual dishes, their categories, allergens, nutrition, and master item lists.

**Classes that should be in this file:**

1. **`MenuItem`**  
   - A single dish/food item.
   - Contains: name, category, meal type, dietary flags (veg/vegan/Jain/gluten‑free/etc.), allergen flags, spice level, popularity/seasonal flags, serving size.
   - Validation focuses on dietary/allergen consistency and spice level sanity.

2. **`MealItems`**  
   - A group of `MenuItem` objects for a specific `MealType` (e.g., breakfast, lunch).
   - Contains: `meal_type`, optional `meal_name`, list of `items`, optional serving time window.
   - Ensures no duplicate `item_name` within one meal.

3. **`DietaryOptions`**  
   - Hostel‑level configuration of what dietary menus are available (veg, non‑veg, vegan, Jain, gluten‑free, lactose‑free).
   - Also controls: customization permissions, special request behavior, allergen declaration policy, preference tracking/auto‑suggest.

4. **`AllergenInfo`**  
   - Per‑item detailed allergen record.
   - Contains: item name, allergen name, allergen type (dairy/nuts/soy/etc.), severity (trace/contains/may_contain), extra details.

5. **`NutritionalInfo`**  
   - Nutritional facts per serving of an item.
   - Contains: calories, macros (protein, carbs, fat, etc.), micros (sodium, vitamins, minerals), serving info, ingredients, preparation method.
   - Validates calories vs calories from fat, specific fats vs total fat, and rounds decimals to 2 places.

6. **`ItemCategory`**  
   - Logical grouping of related items (e.g., “Breads”, “Desserts”).
   - Contains: category id, name, description, item names, display order, active flag.

7. **`ItemMasterList`**  
   - Master catalog of all items for a hostel.
   - Contains: hostel id, list name/version, list of `ItemCategory`, total_items, last_updated.
   - Auto‑computes `total_items` from the categories.

---

## 2. `menu_approval.py`

**Purpose:** Approval workflow around menus: requests, responses, workflow tracking, bulk operations, and history.

**Classes that should be in this file:**

1. **`MenuApprovalRequest`**  
   - Payload used by supervisor to request approval for a menu.
   - Contains: menu id, requester id, urgency, cost estimates, expected students, special procurement, special items, justification.
   - Validates cost logic (high cost requires justification, per‑person vs total cost consistency).

2. **`MenuApprovalResponse`**  
   - The admin’s decision payload.
   - Contains: menu id/date, hostel id, approved flag, approval_status, approver details, timestamps, notes, conditions/rejection_reason, budget info, message, next‑step flags.
   - Ensures consistency between `approved` and `rejection_reason`.

3. **`ApprovalWorkflow`**  
   - Current workflow state of a menu.
   - Contains: menu id/date, hostel id, requires_approval, approval_status, current_stage, timestamps (created/submitted/approved/rejected/published), pending_with, deadlines, revision tracking.
   - Provides computed metrics: `days_pending`, `time_to_approval_hours`.

4. **`BulkApproval`**  
   - Command to approve/reject many menus at once.
   - Contains: list of menu IDs, approved flag, approver id, common notes/reason/conditions, optional budget per menu.
   - Validates that rejection has a reason and that reason isn’t provided when approving.

5. **`ApprovalAttempt`**  
   - One submission/revision cycle record.
   - Contains: attempt number, submitter info, submission time, reviewer info, review time, decision, feedback, changes made.

6. **`ApprovalHistory`**  
   - Full audit trail for a menu.
   - Contains: menu id/date, total_submissions, list of `ApprovalAttempt`, current_status, final_approver.

---

## 3. `menu_duplication.py`

**Purpose:** Schema for copying/creating menus across dates and hostels, with configuration for cloning behavior.

**Classes that should be in this file:**

1. **`DuplicateMenuRequest`**  
   - Duplicate a single existing menu to one new date.
   - Contains: source_menu_id, target_date, which meals to copy, optional modifications, flags for preserving special status, auto‑publish, created_by.
   - Validates target_date timing and at least one meal to copy.

2. **`BulkMenuCreate`**  
   - Generate menus across a date range from a template/pattern/source menu.
   - Contains: hostel_id, start/end dates, source_type, source identifiers or patterns (template_id, source_menu_id, weekly_pattern, rotation_items), skip/override options, weekends/holidays flags, auto_publish, created_by.
   - Validates date span, source‑type specific requirements, and skip vs override conflict.

3. **`DuplicateResponse`**  
   - Result of a duplication/bulk creation operation.
   - Contains: source_menu_id/date, list of created menu ids and dates, counts (total_created, skipped, failed), message, warnings, errors.
   - Computed `success_rate` (percentage success).

4. **`CrossHostelDuplication`**  
   - Copy a menu from one hostel to multiple target hostels.
   - Contains: source_menu_id, source_hostel_id, list of target_hostel_ids, target_date, adaptation/ substitution settings, budget adjustment flag, skip_existing, created_by.
   - Validates uniqueness of target_hostel_ids and that source_hostel_id isn’t in that list.

5. **`MenuCloneConfig`**  
   - Reusable config object describing cloning rules.
   - Contains: preserve flags (special occasions, timings, dietary options), removal flags (seasonal/expensive items), cost thresholds, auto‑adjust options, naming suffix rules.
   - Rounds decimal thresholds.

---

## 4. `menu_feedback.py`

**Purpose:** Feedback capture, per‑item ratings, aggregated statistics, sentiment, and analysis for improvements.

**Classes that should be in this file:**

1. **`FeedbackRequest`**  
   - Student submits feedback for a particular menu and meal type.
   - Contains: menu_id, student_id, meal_type, overall rating, optional comments, detailed aspect ratings, liked/disliked items, suggestions, would_recommend.
   - Enforces meaningful comments on low ratings and normalizes item lists.

2. **`FeedbackResponse`**  
   - API response when feedback is submitted/fetched.
   - Contains: menu_id/date, student info, meal_type, rating, comments, submitted_at, verification flag, helpful_count.
   - Computed `rating_display` as star representation.

3. **`ItemRating`**  
   - Aggregated rating for a specific dish.
   - Contains: item_name, category, average_rating, feedback_count, liked/disliked counts, popularity_score, last_served.
   - Computed `sentiment` and `like_ratio`.

4. **`RatingsSummary`**  
   - Full ratings summary for a single menu.
   - Contains: menu_id/date, hostel_id, total_feedbacks, overall/median rating, per‑meal ratings & counts, rating distribution (1–5), aspect averages, would_recommend_percentage.
   - Computed `participation_rate` (placeholder) and `satisfaction_level` buckets.

5. **`SentimentAnalysis`**  
   - Aggregate sentiment metrics over text comments for one menu.
   - Contains: menu_id, total_comments, sentiment counts, positive/negative percentages, top positive/negative keywords.

6. **`QualityMetrics`**  
   - Hostel‑level quality metrics over a period.
   - Contains: hostel_id/name, period_start/end, overall_rating, total_feedbacks, total_menus_rated, rating_trend, trend_percentage, lists of best/worst/most popular `ItemRating`, ratings by day, best/worst day/meal type, satisfaction/dissatisfaction rates.
   - Computed `quality_score` (0–100).

7. **`FeedbackAnalysis`**  
   - Holistic analysis for a hostel over a date range.
   - Contains: hostel_id, analysis_period (DateRangeFilter), generated_at, sentiment percentages, common complaints/compliments, recurring issues, item‑level actions (keep/improve/remove/introduce), improvement suggestions, cost‑benefit items, dietary trends, requested cuisines, timing insights.

---

## 5. `menu_planning.py`

**Purpose:** Forward planning: daily/weekly/monthly plans, special menus, templates, and AI suggestions.

**Classes that should be in this file:**

1. **`DailyMenuPlan`**  
   - Per‑day structure of items for breakfast/lunch/snacks/dinner.
   - Contains: item lists, special flags (is_special, special_occasion), notes.
   - Validates item lists and special_occasion requirement.

2. **`MenuPlanRequest`**  
   - High‑level “plan menus for this period” request.
   - Contains: hostel_id, start/end dates, template usage, variety rules, dietary requirements, budget constraints, nutrition goals, preference flags.
   - Validates date span, template usage, cost relations.

3. **`WeeklyPlan`**  
   - Fully specified weekly plan (7 `DailyMenuPlan` objects).
   - Contains: hostel_id, week_start_date, week_number, year, all 7 days, creator, plan_name, notes, estimated_total_cost.
   - Ensures week_start_date is Monday and rounds cost.

4. **`SpecialDayMenu`**  
   - One special day within a monthly plan.
   - Contains: menu_date, occasion info, `DailyMenuPlan` for that day, budget, expected_guests.

5. **`MonthlyPlan`**  
   - A full month’s planning object.
   - Contains: hostel_id, month (YYYY‑MM), month_name, year, list of `WeeklyPlan`, list of `SpecialDayMenu`, total_budget, creator/approver, notes.
   - Validates uniqueness of special_days dates.

6. **`SpecialMenu`**  
   - Standalone special‑occasion menu (not just planning).
   - Contains: hostel_id, occasion_date, name, type, detailed items per meal plus extra/special/desserts, budgets, expected_attendees, presentation/serving details, instructions, notifications.
   - Validates occasion_date bounds, and rounds cost fields.

7. **`MenuTemplate`**  
   - Reusable pattern for menus (weekly, seasonal, festival, etc.).
   - Contains: hostel_id, name/code/description, template_type, season, `daily_menus` mapping keys to `DailyMenuPlan`, creator, flags (active/default), usage_count, average_rating, estimated_daily_cost, tags.
   - Validates that `daily_menus` has at least one valid key and rounds decimals.

8. **`MenuSuggestion`**  
   - AI/system‑generated suggestion for a specific date.
   - Contains: hostel_id, suggestion_date, suggested meal item lists, rationale, factors (`based_on`), scores (variety/nutrition/cost/popularity/overall), seasonal count, estimated cost/calories, generated_at, algorithm_version.
   - Rounds scores and cost; computed `recommendation_strength` label.

---

## 6. `mess_menu_base.py`

**Purpose:** Core command‑side menu schemas: the base entity and create/update models with heavy validation.

**Classes that should be in this file:**

1. **`MessMenuBase`**  
   - Canonical base schema for a single menu for a hostel & date.
   - Contains: hostel_id, menu_date, day_of_week; item lists for each meal; serving times; special flags and notes; dietary availability flags.
   - Validates: date constraints (no past; <= 90 days ahead), day_of_week consistency, item list normalization, special menu requirements, logical meal time ordering, at least one dietary option.

2. **`MessMenuCreate`**  
   - Creation schema for menus.
   - Inherits from `MessMenuBase` and `BaseCreateSchema`.
   - Adds: created_by, auto_publish, send_notification.
   - Validates that at least two main meals (breakfast/lunch/dinner) have items.

3. **`MessMenuUpdate`**  
   - Partial update schema.
   - All fields optional; used to patch existing menu data.
   - Covers: meal items, meal times, special flags/info, dietary flags.
   - Re‑applies item validation/normalization where provided.

---

## 7. `mess_menu_response.py`

**Purpose:** Read‑side / API response schemas for different views (detail, summary, weekly, monthly, today, list).

**Classes that should be in this file:**

1. **`MenuResponse`**  
   - Lightweight response for list/basic views.
   - Contains: hostel info, menu_date, day_of_week, meal item lists, special flag, occasion, publication flag, average_rating.
   - Computed: `total_items_count`, `is_complete`.

2. **`MenuDetail`**  
   - Full detail view.
   - Contains: all items + serving times, dietary availability, special info, creator/approver/publisher metadata, ratings and breakdown, timestamps.
   - Computed: `approval_status`, `has_ratings`.

3. **`DailyMenuSummary`**  
   - Compact per‑day summary for weekly/monthly grids.
   - Contains: menu_id/date, day_of_week, simplified items (top few), special flag, rating, publication status.
   - Computed: `has_complete_menu`, `rating_stars`.

4. **`WeeklyMenu`**  
   - Weekly overview.
   - Contains: hostel info, week metadata, date range, list of `DailyMenuSummary`, total_menus, special_days_count, average_weekly_rating.
   - Computed: `completion_percentage`, `is_complete`.

5. **`MonthlyMenu`**  
   - Monthly calendar view.
   - Contains: hostel info, month metadata, `menus_by_date` mapping date strings to `DailyMenuSummary`, total_days, menus_created/published, special_days, average_rating, total_feedbacks.
   - Computed: `completion_rate`, `publication_rate`.

6. **`TodayMenu`**  
   - Student‑facing “today’s menu”.
   - Contains: hostel info, date/day, items & formatted timings per meal, special flags/message, dietary/allergen notes, feedback flags.
   - Computed: `next_meal` based on current time and meal times.

7. **`MenuListItem`**  
   - Minimal list item for back‑office list pages.
   - Contains: id, menu_date/day_of_week, hostel_name, total_items, is_special, is_published, average_rating, feedback_count.
   - Computed: `status_badge_color`, `rating_badge_color` for UI.

---

## 8. `__init__.py`

**Purpose:** Public export surface for `app.schemas.mess`.

**What it should expose:**

- All “main” schemas from the files above:
  - Base: `MessMenuBase`, `MessMenuCreate`, `MessMenuUpdate`
  - Responses: `MenuResponse`, `MenuDetail`, `MenuListItem`, `WeeklyMenu`, `DailyMenuSummary`, `MonthlyMenu`, `TodayMenu`
  - Items: `MealItems`, `MenuItem`, `DietaryOptions`, `NutritionalInfo`, `AllergenInfo`, `ItemMasterList`, `ItemCategory`
  - Planning: `MenuPlanRequest`, `WeeklyPlan`, `DailyMenuPlan`, `MonthlyPlan`, `SpecialMenu`, `SpecialDayMenu`, `MenuTemplate`, `MenuSuggestion`
  - Feedback: `FeedbackRequest`, `FeedbackResponse`, `RatingsSummary`, `ItemRating`, `QualityMetrics`, `FeedbackAnalysis`, `SentimentAnalysis`
  - Approval: `MenuApprovalRequest`, `MenuApprovalResponse`, `ApprovalWorkflow`, `BulkApproval`, `ApprovalHistory`, `ApprovalAttempt`
  - Duplication: `DuplicateMenuRequest`, `BulkMenuCreate`, `DuplicateResponse`, `CrossHostelDuplication`, `MenuCloneConfig`

If your goal is to verify structure: each file currently contains the classes listed above, and they are grouped in a way that aligns with their responsibilities (items, approval, duplication, feedback, planning, command‑side menu, response‑side menu).




============================================================================================================================================================

Here’s how the `app.schemas.notification` package is logically structured, and which classes belong in which file. I’ll treat this as the “intended design” so you have a clear mental model for where to put or look for things.

---

## 1. Package-level intent

The `notification` schemas are split along **concerns**:

- **Channel-specific**: email, SMS, push.
- **Core notification lifecycle**: base/create/update, responses, queue, routing, escalation.
- **Templates**: generic templates and channel-specific templates.
- **User settings**: preferences, quiet hours, frequency.
- **Aggregation**: `__init__.py` re-exports everything.

All models are Pydantic v2 schemas, using:

- `BaseSchema` – generic base for read / internal models.
- `BaseCreateSchema` – for create/request bodies.
- `BaseUpdateSchema` – for partial updates.
- `BaseResponseSchema` – for API responses that include id, timestamps, etc.

---

## 2. File-by-file breakdown

### `email_notification.py`

**Purpose:** Everything specific to **email** as a channel: sending, configuration, templates, tracking, schedules, stats.

**Classes that should live here:**

1. **`EmailAttachment` (BaseSchema)**  
   - Structure of an email attachment (filename, URL, MIME type, size).
   - Used inside EmailRequest and possibly tracking.

2. **`EmailRequest` (BaseCreateSchema)**  
   - Request body for **sending a single email** (direct or template-based).
   - Fields: recipients, subject, HTML/text body, attachments, template_code/variables, tracking flags, priority, scheduling, metadata.
   - Contains validations for:
     - Unique CC/BCC.
     - Future `send_at`.
     - Either content or template.
     - Total attachment size limit.

3. **`EmailConfig` (BaseSchema)**  
   - Configuration model for **email service provider** (SendGrid, SES, SMTP, Mailgun, Postmark).
   - Contains:
     - Provider selection.
     - SMTP config (host/port/username/TLS).
     - API key for API providers.
     - Default from/reply-to.
     - Rate limits and tracking defaults.
     - Bounce webhook.
   - Validates that relevant fields are present depending on provider type.

4. **`EmailTracking` (BaseSchema)**  
   - Per-email **delivery & engagement tracking record**.
   - Fields: status (sent/delivered/bounced/...), timestamps, opens, clicks, clicked links, bounce info, provider IDs, spam reports.

5. **`EmailTemplate` (BaseSchema)**  
   - **Email-specific template configuration** (richer than generic notification templates).
   - Fields: template_code, subject/html/text bodies, branding (header image, footer, primary_color), variables, preheader.

6. **`BulkEmailRequest` (BaseCreateSchema)**  
   - Request body for **bulk email send**.
   - Fields: list of recipients, subject/body, optional shared template_code, optional per-recipient variables, batch settings, tracking, tags.
   - Validates:
     - Unique recipients.
     - Optional recipient_variables coverage.

7. **`EmailStats` (BaseSchema)**  
   - Aggregated **campaign / reporting statistics** for email.
   - Counts: sent, delivered, bounced, failed, opened, clicked, spam, unsubscribes.
   - Percentages: delivery_rate, bounce_rate, open_rate, click_rate, click_to_open_rate, spam_rate, unsubscribe_rate.
   - Time period: period_start / period_end.

8. **`EmailSchedule` (BaseCreateSchema)**  
   - For scheduling **future / recurring email** sends.
   - Wraps an `EmailRequest` plus scheduling details: scheduled_for, timezone, is_recurring, recurrence_pattern, recurrence_end_date.
   - Validates scheduled time is future, recurrence config consistency.

---

### `notification_base.py`

**Purpose:** Core/invariant schema for **notifications regardless of channel** (email/SMS/push), and simple operations like create/update/delete/mark-read.

**Classes that should live here:**

1. **`NotificationBase` (BaseSchema)**  
   - Shared notification fields:
     - Recipients (user_id, email, phone — at least one required).
     - `notification_type` (EMAIL/SMS/PUSH).
     - Optional template_code, subject, message_body.
     - Priority, optional scheduled_at.
     - Metadata, related hostel_id.
   - Validations:
     - Basic email/phone format.
     - scheduled_at is in future.
     - At least one recipient.
     - Subject required for EMAIL/PUSH.
     - SMS body length constraint.

2. **`NotificationCreate` (NotificationBase, BaseCreateSchema)**  
   - Create DTO for a new notification.
   - Adds metadata size limit validation.

3. **`NotificationUpdate` (BaseUpdateSchema)**  
   - For **partial updates** to existing notification:
     - scheduled_at, priority, status.
   - Validates future scheduled_at, and ensures at least one field is provided.

4. **`MarkAsRead` (BaseCreateSchema)**  
   - Request body to **mark a single notification as read**:
     - notification_id, user_id, read_at.

5. **`BulkMarkAsRead` (BaseCreateSchema)**  
   - Request body for marking **multiple notifications** as read:
     - notification_ids, user_id, read_at.
   - Validates unique notification_ids.

6. **`NotificationDelete` (BaseCreateSchema)**  
   - Delete request:
     - notification_id, user_id performing it, permanent flag, optional deletion_reason.

---

### `notification_preferences.py`

**Purpose:** User-level **notification preferences**, frequency, quiet hours, per-channel toggles, unsubscribe mechanics.

**Classes that should live here:**

1. **`FrequencySettings` (BaseSchema)**  
   - Global frequency options: immediate vs batch, batch interval, daily/weekly digests (with times/days).
   - Validates digest settings consistency.

2. **`QuietHours` (BaseSchema)**  
   - Quiet-hours config: enabled, start/end times, weekdays/weekends flags, allow_urgent, timezone.
   - Validates that times exist when enabled.

3. **`EmailPreferences` (BaseSchema)**  
   - Email-specific toggles:
     - Enabled, digest options.
     - Category flags (payment, booking, complaints, etc.).
     - Marketing opt-in, format preferences.

4. **`SMSPreferences` (BaseSchema)**  
   - SMS-specific toggles:
     - Enabled.
     - urgent_only.
     - Categories (payment, booking, emergency, OTP).
     - `max_sms_per_day`.

5. **`PushPreferences` (BaseSchema)**  
   - Push-specific toggles:
     - Enabled.
     - Sound/vibration/badge/preview/lock-screen.
     - Category flags.

6. **`ChannelPreferences` (BaseSchema)**  
   - Per-user container aggregating **email/sms/push preferences**:
     - user_id, and nested EmailPreferences, SMSPreferences, PushPreferences.

7. **`UserPreferences` (BaseSchema)**  
   - Higher-level master preferences:
     - notifications_enabled (master switch).
     - channel toggles (email_enabled, sms_enabled, push_enabled).
     - FrequencySettings, QuietHours.
     - Global category toggles (payment, booking, etc.).
     - preferred_language, timezone.

8. **`PreferenceUpdate` (BaseUpdateSchema)**  
   - Partial update DTO for `UserPreferences`:
     - optional toggles for master, channels, quiet hours, categories, frequency booleans, language, timezone.

9. **`UnsubscribeRequest` (BaseSchema)**  
   - Request to **unsubscribe**:
     - user_id, unsubscribe_token, unsubscribe_type (all/email/sms/push/marketing/specific_category), category, reason.
   - Validates token format and that category is present when needed.

---

### `notification_queue.py`

**Purpose:** Models for **queue state**, queued notifications, batches, queue statistics, health, and priority behavior.

**Classes that should live here:**

1. **`QueueStatus` (BaseSchema)**  
   - Snapshot of overall queue state:
     - total_queued/processing/failed.
     - By priority (urgent/high/medium/low).
     - By type (email/sms/push).
     - Performance (avg_processing_time_seconds, throughput_per_minute).
     - Health (is_healthy, oldest_queued_age_minutes, checked_at).
     - Computed: `total_in_system`, `queue_utilization_percent`.

2. **`QueuedNotification` (BaseSchema)**  
   - Single item in the queue:
     - notification_id, type, priority, status.
     - recipient identifier.
     - scheduled_at, queued_at, processing_started_at.
     - retry_count, max_retries, next_retry_at.
     - estimated_send_time, queue_position, last_error.
     - Computed: `age_minutes`, `can_retry`.

3. **`BatchProcessing` (BaseSchema)**  
   - Bulk send / campaign batch status:
     - batch_id, batch_name, notification_type.
     - total_notifications, processed, successful, failed, pending.
     - status (queued/processing/paused/completed/failed/cancelled).
     - timing (created_at, started_at, completed_at).
     - estimates & performance metrics.
     - error_summary.
     - Computed: `progress_percentage`, `success_rate`, `failure_rate`, `is_complete`.

4. **`QueueStats` (BaseSchema)**  
   - More analytical, time-bounded statistics:
     - Current queue size, oldest age.
     - Today’s processed/successful/failed.
     - Success/failure percentages.
     - Performance metrics (avg queue time, processing time, total time).
     - Throughput metrics.
     - Type & priority breakdowns.
     - Retry stats & worker counts.
     - Computed: `total_workers`, `worker_utilization_percent`.

5. **`QueueHealth` (BaseSchema)**  
   - Health diagnostics:
     - is_healthy, health_score.
     - Component health (queue, workers, DB, external services).
     - Issues, warnings, recommendations.
     - backlog, overload/underutilized flags.
     - Resource usage (CPU/memory).
     - Checked_at.
     - Computed: `has_critical_issues`, `needs_attention`.

6. **`QueuePriority` (BaseSchema)**  
   - Per-priority configuration & metrics:
     - priority_level, processing_weight, max_concurrent.
     - queued_count, processing_count.
     - average_wait_time_seconds, throughput.
     - SLA target_processing_time_seconds, sla_compliance_rate.
     - Computed: `is_meeting_sla`.

---

### `notification_response.py`

**Purpose:** **Read-side / API response** schemas for notifications: single, detailed, list, summary, unread counts.

**Classes that should live here:**

1. **`NotificationResponse` (BaseResponseSchema)**  
   - Standard single-notification response / list item.
   - Fields: recipients, notification_type, subject, message_body, priority, status, scheduled_at, sent_at, created_at.
   - Computed: `is_sent`, `is_pending`.

2. **`NotificationDetail` (BaseResponseSchema)**  
   - Extended, detailed response:
     - Everything in NotificationResponse, plus:
     - template_code, delivered_at, failed_at, failure_reason.
     - retry_count, max_retries.
     - engagement (read_at, clicked_at).
     - metadata, hostel_id.
     - updated_at.
     - Computed: `is_read`, `can_retry`, `delivery_duration_seconds`.

3. **`NotificationListItem` (BaseSchema)**  
   - Lightweight list row:
     - id, notification_type, subject, message_preview.
     - priority, status, is_read, read_at, created_at.
     - action_url, icon, category.
     - Computed: `is_urgent`.

4. **`NotificationList` (BaseSchema)**  
   - Paginated/list response for a user:
     - user_id, total_notifications, unread_count.
     - notifications: List[NotificationListItem].
     - Computed: `read_count`, `has_unread`.

5. **`UnreadCount` (BaseSchema)**  
   - Breakdown of **unread** counts:
     - total_unread.
     - By type (email/sms/push/in_app).
     - By priority (urgent/high).
     - last_checked_at.

6. **`NotificationSummary` (BaseSchema)**  
   - Aggregate statistics for a user:
     - total_notifications, unread_notifications.
     - last_notification_at, last_read_at.
     - breakdowns by type/status/priority.
     - summary_period_days.
     - Computed: `read_percentage`, `has_recent_activity`.

---

### `notification_routing.py`

**Purpose:** Configuration & runtime results of **routing and escalation**: rules, conditions, hierarchy, final routes.

**Classes that should live here:**

1. **`RoutingCondition` (BaseSchema)**  
   - Rule matching conditions:
     - event_type / event_category.
     - priority / min_priority.
     - hostel_id, room_id.
     - time-of-day window.
     - arbitrary custom_attributes.

2. **`RoutingRule` (BaseSchema)**  
   - Single routing rule:
     - rule_id, rule_name, description.
     - rule_priority (for ordering).
     - conditions: RoutingCondition.
     - recipient_roles, specific_users, recipient_groups.
     - channels (validated).
     - template_code, is_active, stop_on_match.
     - Validates: at least one recipient.

3. **`RoutingConfig` (BaseSchema)**  
   - Per-hostel routing config:
     - hostel_id.
     - rules: List[RoutingRule], auto sorted by rule_priority desc.
     - default_recipient_roles, default_channels.
     - escalation settings (enable_escalation, escalation_timeout_hours).
     - is_active.

4. **`EscalationLevel` (BaseSchema)**  
   - One step in an escalation chain:
     - level, level_name.
     - recipients, recipient_roles.
     - escalate_after_hours.
     - channels (validated).
     - optional template_code.

5. **`HierarchicalRouting` (BaseSchema)**  
   - High-level “hierarchy” routing (primary/secondary/tertiary recipients):
     - hostel_id, event_type.
     - primary/secondary/tertiary recipients lists.
     - timings: escalate_to_secondary_after_hours, escalate_to_tertiary_after_hours.
     - channels per level.
     - is_active.

6. **`EscalationRouting` (BaseCreateSchema)**  
   - Per-notification escalation plan/state:
     - notification_id.
     - escalation_chain: List[EscalationLevel].
     - current_level, last_escalated_at.
     - auto_escalate, is_resolved.
     - Validations:
       - chain exists.
       - levels are sequential 1..N.
       - escalate_after_hours strictly increasing.

7. **`NotificationRoute` (BaseSchema)**  
   - Final computed routing for a notification:
     - notification_id.
     - matched_rule_id, matched_rule_name.
     - primary_recipients, cc_recipients.
     - recipient_channels: per-recipient channel list (validated).
     - template_code.
     - escalation_enabled, escalation_path (EscalationLevel list).
     - routing_metadata, routed_at.

---

### `notification_template.py`

**Purpose:** Generic, channel-agnostic **notification templates** and rendering/preview support.

**Classes that should live here:**

1. **`TemplateCreate` (BaseCreateSchema)**  
   - DTO to create a new **notification template**:
     - template_code, template_name, template_type (NotificationType).
     - subject (if email/push), body_template.
     - variables / optional_variables lists.
     - category, tags, is_active, description, language.
   - Validates:
     - template_code naming rules.
     - variable names.
     - tags.
     - subject required for EMAIL/PUSH.
     - variables declared vs used in templates.

2. **`TemplateUpdate` (BaseUpdateSchema)**  
   - Partial update DTO:
     - template_name, subject, body_template, variables, optional_variables.
     - category, tags, is_active, description.

3. **`TemplateResponse` (BaseResponseSchema)**  
   - Full template data for responses:
     - template_code, template_name, template_type, subject, body_template.
     - variables/optional_variables.
     - category, tags, language.
     - is_active, description.
     - usage_count, last_used_at.
     - created_at, updated_at, created_by.

4. **`VariableMapping` (BaseSchema)**  
   - For rendering a template:
     - template_code and variables mapping (name → value).
     - Validates non-empty string values.

5. **`TemplatePreview` (BaseCreateSchema)**  
   - Request to preview a rendered template:
     - template_code, variables, use_defaults.

6. **`TemplatePreviewResponse` (BaseSchema)**  
   - Result of preview rendering:
     - template_code, subject, rendered_body.
     - flags and lists: all_variables_provided, missing_variables, unused_variables.
     - lengths and SMS-segment estimation.

7. **`TemplateList` (BaseSchema)**  
   - Summarized list of templates:
     - total_templates, active_templates.
     - templates_by_type.
     - templates: List[TemplateResponse].

8. **`TemplateCategory` (BaseSchema)**  
   - Templates grouped by category:
     - category_name, category_description.
     - template_count, templates.

9. **`TemplateCopyRequest` (BaseCreateSchema)**  
   - Request to copy one template to a new one:
     - source_template_code.
     - new_template_code, new_template_name.
     - copy_metadata flag.

---

### `push_notification.py`

**Purpose:** Everything specific to **push notifications**: devices, configs, templates, requests, delivery status, stats.

**Classes that should live here:**

1. **`PushAction` (BaseSchema)**  
   - Definition of an action button on a push notification:
     - action_id, title, optional url/icon.

2. **`PushRequest` (BaseCreateSchema)**  
   - Request body to send a **single push notification**:
     - Targeting: user_id OR device_token OR device_tokens OR segment (mutually exclusive, at least one).
     - Content: title, body, image_url, icon.
     - Data payload (JSON), action_url, actions (PushAction list).
     - Badge settings, sound, sound_volume.
     - priority, ttl, collapse_key, thread_id.
     - Android & iOS-specific fields.
     - Scheduling: send_at.
     - tags, metadata.
   - Validations:
     - Exactly one targeting strategy.
     - data payload size <= 4KB.
     - send_at in future.

3. **`PushConfig` (BaseSchema)**  
   - Config for push services:
     - Firebase: project_id, server_key, optional service_account_json.
     - APNs: flags and required fields when enabled.
     - Default sound/priority/TTL, collapse_key, auto_increment_badge.
     - Rate limiting.

4. **`DeviceToken` (BaseResponseSchema)**  
   - Registered device token info:
     - user_id, device_token, device_type.
     - device details (name/model/os/app version).
     - timezone, locale.
     - active status, last_used_at, registered_at, current_badge_count.

5. **`DeviceRegistration` (BaseCreateSchema)**  
   - Register a device (store or update token):
     - user_id, device_token, device_type, optional device info, timezone, locale.

6. **`DeviceUnregistration` (BaseCreateSchema)**  
   - Unregister device token:
     - device_token, optional user_id, optional reason.

7. **`PushTemplate` (BaseSchema)**  
   - Push-specific template definition:
     - template_code.
     - title/body with {{variables}}.
     - default icon/sound/image.
     - required/optional_variables.
     - default action_url/actions.
     - default android_channel_id / ios_category.

8. **`PushDeliveryStatus` (BaseSchema)**  
   - Per-device delivery record:
     - notification_id, device_token.
     - status (queued/sent/delivered/failed/expired/clicked).
     - sent/delivered/clicked/failed times.
     - error code/message.
     - provider_message_id, provider_response.
     - engagement flags (was_clicked, action_taken).

9. **`PushStats` (BaseSchema)**  
   - Aggregated push stats:
     - totals: sent/delivered/failed.
     - delivery_rate.
     - platform breakdown (iOS/Android/Web) sent & delivered.
     - engagement: total_opened, open_rate.
     - action engagement.
     - period_start / period_end.

10. **`BulkPushRequest` (BaseCreateSchema)**  
    - Bulk push send:
      - recipients: user_ids OR device_tokens OR segment (at least one).
      - content: title, body, optional template_code.
      - per-user variables.
      - default settings: image_url, icon, sound, priority.
      - batch_size, delay_between_batches_seconds.
      - campaign_name, tags.
    - Validates presence of at least one recipient group.

---

### `sms_notification.py`

**Purpose:** Everything specific to **SMS**: send, config, delivery status, templates, bulk sends, costs, quotas.

**Classes that should live here:**

1. **`SMSRequest` (BaseCreateSchema)**  
   - Request body to send **single SMS**:
     - recipient_phone (E.164).
     - message OR template_code+template_variables.
     - sender_id, priority, DLT fields.
     - send_at, track_delivery.
     - tags, metadata.
   - Validations:
     - message length (<= 1600).
     - normalize phone to E.164.
     - send_at in future.
     - content or template requirement.

2. **`SMSConfig` (BaseSchema)**  
   - SMS gateway configuration:
     - service_provider (Twilio, AWS SNS, Msg91, etc.).
     - credentials (account_sid/auth_token/api_key).
     - default_sender_id.
     - rate limits (per hour/day/per recipient).
     - country settings (default + allowed codes).
     - DLT settings.
     - delivery report webhook.
     - cost_per_sms, currency.

3. **`DeliveryStatus` (BaseSchema)**  
   - Single SMS delivery lifecycle:
     - sms_id, recipient_phone, status.
     - queued/sent/delivered/failed times.
     - error_code/message, provider IDs/status.
     - segment count, character_count, encoding.
     - cost & currency, retry_count.

4. **`SMSTemplate` (BaseSchema)**  
   - SMS-specific template:
     - template_code.
     - message_template with {{variables}}.
     - required/optional_variables.
     - estimated_length/segments.
     - DLT info (template_id, approved, approval_date).
     - category (transactional/promotional/otp/alert).

5. **`BulkSMSRequest` (BaseCreateSchema)**  
   - Bulk SMS send:
     - recipients (phone list).
     - message OR template_code.
     - recipient_variables (phone→vars).
     - sender_id.
     - batch_size, delay_between_batches_seconds.
     - send_at.
     - DLT template ID, campaign_name, tags.
   - Validations:
     - unique recipients.
     - phone format for each recipient.

6. **`SMSStats` (BaseSchema)**  
   - Aggregated SMS analytics:
     - totals: sent/delivered/failed/pending.
     - delivery_rate, failure_rate.
     - total_cost, avg_cost_per_sms, currency.
     - segments: total_segments, avg_segments_per_sms.
     - breakdown counts by status.
     - period_start / period_end.

7. **`SMSQuota` (BaseSchema)**  
   - Quota and usage tracking:
     - hourly/daily/monthly quotas & usage & remaining.
     - reset times.
     - is_quota_exceeded flag.

---

### `__init__.py`

**Purpose:** Public export surface for the `notification` package.

It should:

- Import and re-export all the relevant classes from the above modules.
- Define `__all__` with:
  - Base/CRUD: NotificationBase/Create/Update/Delete, MarkAsRead, BulkMarkAsRead.
  - Response types: NotificationResponse/Detail/List/ListItem/UnreadCount/Summary.
  - Template types: TemplateCreate/Update/Response/List/Preview/etc.
  - Email/SMS/Push-specific schemas.
  - Queue, Preferences, Routing classes.


-

============================================================================================================================================================


Here’s a clear map of **what belongs in each file** and **what each class is for**, based on the code you shared. You can treat this as the “intended contract” for your payment schema package.

---

## 1. `payment_base.py`  
**Purpose:** Core payment models used internally (create / update) and as building blocks.

**Classes that should be here:**

- `PaymentBase` (`BaseSchema`)  
  - Shared base fields for payments (type, amount, currency, method).  
  - Validation / normalization for `amount` and `currency`.

- `PaymentCreate` (`BaseCreateSchema`)  
  - Schema for **creating** a payment record in your system.  
  - Includes references (hostel, student, booking, payer), payment details, gateway info, transaction IDs, period, due date, status, notes.  
  - Stricter amount validation (`> 0`) and currency normalization.

- `PaymentUpdate` (`BaseUpdateSchema`)  
  - Schema for **updating** an existing payment (status, transaction ID, timestamps, failure info, gateway response, notes).  
  - Validation on `failure_reason`.

Nothing else needs to live here; these are the core internal CRUD schemas.

---

## 2. `payment_filters.py`  
**Purpose:** Parameters for listing/searching/exporting/analyzing payments (input-side only: filters, sorting, reporting).

**Enums:**

- `PaymentSortField`  
  - Fields you can sort by: `created_at`, `paid_at`, `amount`, etc.

- `SortOrder`  
  - `ASC`, `DESC`.

- `ExportFormat`  
  - `csv`, `excel`, `pdf`, `json`.

**Classes that should be here:**

- `PaymentFilterParams` (`BaseSchema`)  
  - Filter payments by entity (hostel, student, payer, booking), attributes (type, status, method), amount range, date ranges, overdue/receipt/refunded flags, and pagination.  
  - Validates ranges (amount, dates, due dates).

- `PaymentSearchRequest` (`BaseSchema`)  
  - Text search query + search fields + optional `PaymentFilterParams`.  
  - Validates query length and allowed search fields.

- `PaymentSortOptions` (`BaseSchema`)  
  - Defines primary and optional secondary sort (field + order).  
  - Ensures secondary field is not same as primary, fills secondary order if omitted.

- `PaymentReportRequest` (`BaseSchema`)  
  - Request to generate a report over a period, with optional hostel/payment-type/status filters.  
  - Toggles for summary/analytics/charts, and `group_by` (day/week/month/payment_type/payment_method/hostel).  
  - Validates period and caps length (≤ 365 days).

- `PaymentExportRequest` (`BaseSchema`)  
  - Request to export payments (format + filters + optional sort + selected fields + max_records).  
  - Validates requested fields against allowed set.

- `PaymentAnalyticsRequest` (`BaseSchema`)  
  - Request for analytics over a period, with optional hostel and payment types.  
  - Flags controlling trends, comparisons, forecasts, breakdowns; `granularity` (day/week/month).  
  - Period validation (1–730 days).

---

## 3. `payment_gateway.py`  
**Purpose:** Schemas specifically for integration with external payment gateways (initiation, webhooks, callbacks, refunds, verification).

**Classes that should be here:**

- `GatewayRequest` (`BaseSchema`)  
  - What your backend sends to a gateway: internal payment ID, order ID, amount, currency, customer details, description, notes, callback/cancel URLs.  
  - Validates amount and currency.

- `GatewayResponse` (`BaseSchema`)  
  - What you receive **from the gateway** after initiation: gateway name/order/payment IDs, status, success flag, checkout URL/token, SDK options, raw response, timestamps, error details.

- `GatewayWebhook` (`BaseSchema`)  
  - Incoming webhook payload from gateway: event identifiers, gateway order/payment IDs, status, amount, currency, raw payload, signature, timestamps.

- `GatewayCallback` (`BaseSchema`)  
  - Data you get when user is redirected back from gateway (query params or body): order/payment IDs, status, success flag, transaction ID, amount, signature, additional params.

- `GatewayRefundRequest` (`BaseSchema`)  
  - What you send to gateway to **initiate a refund**: internal payment ID, gateway payment ID, refund amount, original amount, currency, reason, is_partial, notes.  
  - Validates refund amount and ensures it doesn’t exceed original amount; auto-corrects `is_partial`.

- `GatewayRefundResponse` (`BaseSchema`)  
  - Gateway’s refund response: gateway refund/payment IDs, status, success flag, amount, currency, timestamps (initiated/processed/expected), raw response, error details.

- `GatewayVerification` (`BaseSchema`)  
  - Used when verifying a payment with the gateway: gateway order/payment IDs, `is_verified`, verification status, verified amount/currency, mapped `PaymentStatus`, transaction details, timestamps, raw verification data, discrepancy flags.

---

## 4. `payment_ledger.py`  
**Purpose:** Account-level representation of charges and payments (ledger, statements, adjustments, write-offs).

**Classes that should be here:**

- `LedgerEntry` (`BaseResponseSchema`)  
  - A single ledger line item for a student/hostel: type (debit/credit/adjustment/writeoff), transaction type, amount, currency, balances before/after, references, description, timestamps, posted_by.  
  - Computed flags: `is_debit`, `is_credit`, `absolute_amount`.

- `TransactionItem` (`BaseSchema`)  
  - Simplified transaction view for statements: date, reference, description, debit/credit columns, balance, payment_reference.  
  - Computed `transaction_type` (debit/credit/adjustment).

- `AccountStatement` (`BaseSchema`)  
  - Full account statement for a student over a period: student/hostel info, period, opening/closing balances, list of `TransactionItem`s, totals (debits, credits, payments, charges), metadata.  
  - Computed: `net_movement`, `transaction_count`.

- `LedgerSummary` (`BaseSchema`)  
  - Snapshot summary for a student or hostel: current balance, credit/debit flags, totals (charges, payments, adjustments, writeoffs), outstanding/overdue amounts, last activity dates.  
  - Computed: `balance_status` ("credit"/"debit"/"zero"), `payment_ratio`.

- `TransactionHistory` (`BaseSchema`)  
  - Paginated list of `LedgerEntry` for an entity + optional period filter, total count, page, page_size, computed `pages`.

- `BalanceAdjustment` (`BaseCreateSchema`)  
  - Request to manually adjust a student’s balance (positive = credit, negative = debit), with type (correction/refund/discount/penalty/other), reason, notes, approval info, verification flag.  
  - Validates non-zero bounded amount and reason.

- `WriteOff` (`BaseCreateSchema`)  
  - Request to write off uncollectible amounts: student/hostel, writeoff amount + outstanding amount, reason (enum), detailed reason, approval info, approval level, supporting docs.  
  - Validates amount > 0 and ≤ outstanding, validates reason length.

---

## 5. `payment_refund.py`  
**Purpose:** Internal refund lifecycle (requesting, status, approval, listing), distinct from gateway-side schemas.

**Classes that should be here:**

- `RefundRequest` (`BaseCreateSchema`)  
  - API input to request a refund: payment_id, refund_amount, reason, requested_by, flags for immediate initiation and notification, notes.  
  - Validates amount and reason.

- `RefundStatus` (`BaseSchema`)  
  - Short representation of a refund’s current status: refund_id, payment_id, status string + derived booleans (`is_completed`, `is_pending`, `is_failed`), amounts, key timestamps, gateway_refund_id.  
  - Computed `processing_time_hours`.

- `RefundResponse` (`BaseResponseSchema`)  
  - Full refund record for API responses: payment info, amounts (refund + original), currency, type flags (partial/full), status, reason, requested_by/approved_by + names, timestamps, gateway_refund_id, transaction_id, notes.  
  - Computed: `remaining_amount`, `refund_percentage`.

- `RefundApproval` (`BaseSchema`)  
  - Input for approving/rejecting a refund: refund_id, is_approved, approved_by, approval_notes, process_immediately.  
  - Normalizes/validates notes.

- `RefundListItem` (`BaseSchema`)  
  - Lightweight list item: IDs, reference, amounts, status, is_partial, requester name, key timestamps.  
  - Computed `status_display` for UI.

- `RefundList` (`BaseSchema`)  
  - Paginated list of `RefundListItem`: items, total, page, page_size, pages, computed `has_next`, `has_previous`.

---

## 6. `payment_reminder.py`  
**Purpose:** Configuration and tracking of payment reminders (automation and manual).

**Classes that should be here:**

- `ReminderConfig` (`BaseCreateSchema`)  
  - Per-hostel reminder rules: days before/after due, enabled, max_reminders, channels (email/SMS/push), template IDs, escalation options.  
  - Validates timing arrays, ensures at least one channel, validates escalation settings.

- `ReminderLog` (`BaseResponseSchema`)  
  - Log entry for a sent reminder: payment + student/payer info, reminder type/number, channels used, status, errors, timestamps, engagement tracking (opens/clicks).  
  - Computed: `channels_used`, `reminder_type_display`.

- `SendReminderRequest` (`BaseCreateSchema`)  
  - API request to trigger reminders (manual/batch): target payments or hostel, overdue filters, reminder_type, force_send, chosen channels, optional custom message.  
  - Validates channels, overdue range, payment_ids list (size & duplicates).

- `ReminderBatch` (`BaseSchema`)  
  - Summary of a reminder batch run: batch ID, timing, completion flag, counts (total/sent/failed/skipped), per-channel counts, error summary.  
  - Computed: `success_rate`, `duration_seconds`.

- `ReminderStats` (`BaseSchema`)  
  - Aggregated reminder statistics for a period (optionally per hostel): counts per channel, success/failure, opens/clicks, payments made after reminder, breakdown by reminder type.  
  - Computed: `success_rate`, `email_open_rate`, `email_click_rate`, `effectiveness_rate`.

---

## 7. `payment_request.py`  
**Purpose:** API input models for initiating or recording payments (online and offline, single and bulk) + a specific gateway initiation response.

**Classes that should be here:**

- `PaymentRequest` (`BaseCreateSchema`)  
  - **Online** payment initiation request: hostel+student/booking, type, amount, optional period, payment_method (online variants only), preferred gateway, success/failure/cancel URLs.  
  - Ensures amount is > 0 and ≥ minimum, validates payment_method is online, and that at least one of (student_id, booking_id) is present.

- `PaymentInitiation` (`BaseSchema`)  
  - Response your backend returns after initiating with the gateway: internal payment_id, reference, amount/currency, gateway name, gateway_order_id, gateway_key, checkout URL/token, gateway_options, expiry time.

- `ManualPaymentRequest` (`BaseCreateSchema`)  
  - **Offline** payment record: hostel, student, payment_type, amount, payment_method (cash/cheque/bank_transfer only), cheque/bank transfer details if applicable, period, collection details, notes.  
  - Validates that method is appropriate and that necessary cheque/transfer details exist; validates collection date.

- `SinglePaymentRecord` (`BaseSchema`)  
  - One payment within a bulk operation: student_id, payment_type, amount, method, optional transaction_reference, notes.  
  - Validates amount.

- `BulkPaymentRequest` (`BaseCreateSchema`)  
  - Batch record of multiple offline payments: hostel, list of `SinglePaymentRecord` (1–100, no duplicate students), collected_by, common collection_date (not in future).  
  - Validates list size and duplicates; validates collection_date.

---

## 8. `payment_response.py`  
**Purpose:** Output models for returning payment info from your APIs (list, detail, receipt, summary, analytics).

**Classes that should be here:**

- `PaymentResponse` (`BaseResponseSchema`)  
  - Standard/basic payment representation: IDs, payer info, hostel info, type, amount, currency, method, status, paid_at, due_date, overdue flag, receipt info.  
  - Computed: `amount_display`, `status_badge_color`.

- `PaymentDetail` (`BaseResponseSchema`)  
  - Full detailed payment view: all from `PaymentResponse` + payer contact, student/booking references, period, gateway info, failure info, gateway_response, full refund info, offline collection info, reminders info, notes, due date/overdue.  
  - Computed: `net_amount`, `is_fully_refunded`, `is_partially_refunded`, `days_overdue`, `payment_period_display`.

- `PaymentReceipt` (`BaseSchema`)  
  - Data needed to render/print a receipt: receipt & payment refs, payer + hostel details, amount + words, currency, method, transaction ID, period description, dates, receipt metadata, tax details, remarks.  
  - Computed: `receipt_display_id`.

- `PaymentListItem` (`BaseSchema`)  
  - Lightweight list row for UI: id, refs, payer/hostel names, type, amount, method, status, paid_at, due_date, overdue flag, created_at.  
  - Computed: `status_display`.

- `PaymentSummary` (`BaseSchema`)  
  - High-level stats for a student/hostel: totals (paid, pending, overdue), last/next payment info, counts (total/completed/pending payments).  
  - Computed: `payment_health_score`, `completion_rate`.

- `PaymentAnalytics` (`BaseSchema`)  
  - Aggregated analytics section (probably returned from analytics/reporting endpoints): period, total txns + amount, breakdown by status, method, type, averages, success rate, collection efficiency.  
  - Computed: `total_revenue` (same as completed_amount), `failure_rate`.

---

## 9. `payment_schedule.py`  
**Purpose:** Models for recurring payment schedules and their management.

**Classes that should be here:**

- `PaymentSchedule` (`BaseResponseSchema`)  
  - Existing schedule representation: student + hostel, fee_type, per-period amount, start/end dates, next_due_date, flags for auto-generate and active.  
  - Computed: `is_indefinite`, `days_until_next_payment`, `is_overdue`.

- `ScheduleCreate` (`BaseCreateSchema`)  
  - Input to create a new schedule: student, hostel, fee_type, amount, start/end dates, first_due_date, settings (auto_generate_invoice, send_reminders).  
  - Validates amount (bounds), dates (start/end/first due).

- `ScheduleUpdate` (`BaseUpdateSchema`)  
  - Update existing schedule: amount, next_due_date, end_date, auto_generate, is_active (all optional).  
  - Validates amount if present.

- `ScheduleGeneration` (`BaseSchema`)  
  - Request to generate payments for a schedule over a period: schedule_id, from/to dates, options to skip if already paid and to send notifications.  
  - Validates generation period and max length (≤ 365 days).

- `ScheduledPaymentGenerated` (`BaseSchema`)  
  - Result of a generation run: schedule_id, counts (generated vs skipped), list of generated payment IDs, next_generation_date.  
  - Computed: `total_processed`, `generation_success_rate`.

- `BulkScheduleCreate` (`BaseCreateSchema`)  
  - Create identical schedules for many students: hostel_id, list of student_ids (1–100, unique), common fee_type, amount, start_date, first_due_date.  
  - Validates student_ids list, amount, and date relationship.

- `ScheduleSuspension` (`BaseCreateSchema`)  
  - Suspend a schedule temporarily: schedule_id, reason, suspend_from/to dates, flag whether to skip dues during suspension.  
  - Validates reason length, suspension period (end > start, ≤ 365 days).

---

## 10. `__init__.py`  
**Purpose:** Aggregator/Facade for import convenience.

It should:

- Import and re-export all public payment-related schemas from the above modules.
- Ensure `__all__` includes exactly those classes you want as the public API of `app.schemas.payment`.

You already do this, with:

- Base: `PaymentBase`, `PaymentCreate`, `PaymentUpdate`
- Request: `PaymentRequest`, `PaymentInitiation`, `ManualPaymentRequest`, `BulkPaymentRequest`, `SinglePaymentRecord`
- Response: `PaymentResponse`, `PaymentDetail`, `PaymentReceipt`, `PaymentListItem`, `PaymentSummary`, `PaymentAnalytics`
- Gateway: `GatewayRequest`, `GatewayResponse`, `GatewayWebhook`, `GatewayCallback`, `GatewayRefundRequest`, `GatewayRefundResponse`, `GatewayVerification`
- Refund: `RefundRequest`, `RefundResponse`, `RefundStatus`, `RefundApproval`, `RefundList`, `RefundListItem`
- Schedule: `PaymentSchedule`, `ScheduleCreate`, `ScheduleUpdate`, `ScheduleGeneration`, `ScheduledPaymentGenerated`, `BulkScheduleCreate`, `ScheduleSuspension`
- Reminder: `ReminderConfig`, `ReminderLog`, `SendReminderRequest`, `ReminderBatch`, `ReminderStats`
- Ledger: `LedgerEntry`, `LedgerSummary`, `AccountStatement`, `TransactionHistory`, `TransactionItem`, `BalanceAdjustment`, `WriteOff`
- Filters/Reports/Analytics Requests:  
  `PaymentFilterParams`, `PaymentSearchRequest`, `PaymentSortOptions`, `PaymentReportRequest`, `PaymentExportRequest`, `PaymentAnalyticsRequest`

---

If you want, next I can:

- Draw a **flow-level map** (e.g., “online payment” path: `PaymentRequest` → `PaymentCreate` → `PaymentDetail`/`PaymentResponse`), or  
- Suggest a **minimal public surface** if you want to hide some of these from external consumers.

============================================================================================================================================================

Here’s the intended layout and responsibility of **every class in each referral-related file**, based on the code you shared. You can treat this as the “spec” for what belongs where.

---

## 1. `referral_base.py`

**Purpose:** Core models around a *single referral record* and its lifecycle (creation, update, conversion).

**Classes that should be in this file:**

- **`ReferralBase` (`BaseSchema`)**  
  Canonical schema for a **single referral record**, used as a base:
  - Program + referrer identification.
  - Referee identifiers (email / phone / user_id / name) – at least one required.
  - Referral code.
  - Referral status (`ReferralStatus`).
  - Conversion fields: `booking_id`, `conversion_date`.
  - Reward amounts for referrer/referee + currency + reward statuses.
  - Source tracking: `referral_source`, `campaign_id`.
  - `notes`.
  - Validators:
    - Normalize and validate `referral_code`.
    - Normalize `referee_phone`.
    - Quantize reward decimals to 2 dp.
    - Ensure at least one referee identifier.
    - Enforce conversion consistency when status is `COMPLETED`.

- **`ReferralCreate` (`ReferralBase`, `BaseCreateSchema`)**  
  Input model for **creating a referral record**:
  - Inherits everything from `ReferralBase`.
  - Overrides `referral_code` to be optional and **auto-generates** a code if not provided (using referrer_id + random suffix).

- **`ReferralUpdate` (`BaseSchema`)**  
  Input model for **updating** an existing referral:
  - Allows updating:
    - Referee info: `referee_user_id`, `referee_name`.
    - Referral `status`.
    - Conversion info: `booking_id`, `conversion_date`.
    - Reward statuses: `referrer_reward_status`, `referee_reward_status`.
    - `notes`.
  - No extra validation beyond types/ranges (logic handled by service layer).

- **`ReferralConversion` (`BaseCreateSchema`)**  
  Input model when a referral **converts to a booking**:
  - `referral_id`, `booking_id`.
  - `booking_amount`, `stay_duration_months`.
  - `conversion_date` (defaults to now, cannot be in the future).
  - Quantizes `booking_amount` to 2 dp.

---

## 2. `referral_code.py`

**Purpose:** Everything related to **referral codes themselves** – creation, validation, stats.

**Classes that should be in this file:**

- **`ReferralCodeGenerate` (`BaseCreateSchema`)**  
  Input to **generate** a personalized referral code for a user:
  - `user_id`, `program_id`.
  - Optional `prefix` and `custom_suffix`.
  - Optional `expires_at`, `max_uses`.
  - Validates prefix (upper, letters only) and `expires_at` (must be future).

- **`ReferralCodeResponse` (`BaseSchema`)**  
  Output schema after a code is generated or fetched:
  - `user_id`, `program_id`, `referral_code`.
  - `share_url`, optionally `qr_code_url`.
  - Usage tracking: `times_used`, `max_uses`, `remaining_uses`.
  - Validity: `is_active`, `created_at`, `expires_at`.

- **`CodeValidationRequest` (`BaseCreateSchema`)**  
  Input when someone **tries to use a referral code**:
  - `referral_code` (normalized to uppercase).
  - Optional `user_id` of the user using it.
  - Optional `context` (booking/registration/etc).

- **`CodeValidationResponse` (`BaseSchema`)**  
  Output of validation:
  - `referral_code`, `is_valid`.
  - If valid: `program_id`, `program_name`, `referrer_id`, `referrer_name`, reward info.
  - Message + `validation_errors`.
  - Usage info: `times_used`, `max_uses`, `expires_at`.

- **`ReferralCodeStats` (`BaseSchema`)**  
  Analytics for a single code:
  - Owner + program.
  - Counts: `total_shares`, `total_clicks`, `total_uses`, `total_registrations`, `total_bookings`.
  - `conversion_rate`.
  - Reward totals as strings: `total_rewards_earned`, `pending_rewards`.
  - Time: `created_at`, `last_used_at`.

---

## 3. `referral_program_base.py`

**Purpose:** Defining **referral programs** themselves (config, creation, updates).

**Classes that should be in this file:**

- **`ProgramType` (str)**  
  String-type enum for types of programs:
  - `student_referral`, `visitor_referral`, `affiliate`, `corporate`.

- **`RewardType` (str)**  
  String-type enum for reward types:
  - `cash`, `discount`, `voucher`, `free_month`, `points`.

- **`ReferralProgramBase` (`BaseSchema`)**  
  Canonical schema for a **referral program configuration**:
  - Identity: `program_name`, optional `program_code`, `program_type`.
  - Description.
  - Reward config: `reward_type`, referrer/referee amounts, `currency`.
  - Reward caps: `max_referrer_rewards_per_month`, `max_total_reward_amount`.
  - Eligibility: `min_booking_amount`, `min_stay_months`, `min_referrer_stay_months`.
  - Limits: `max_referrals_per_user`, `allowed_user_roles`.
  - Validity: `is_active`, `valid_from`, `valid_to`.
  - Terms: `terms_and_conditions`, `auto_approve_rewards`.
  - Tracking: `track_conversion`.
  - Validators:
    - Normalize `program_name`.
    - Validate + normalize `currency` against supported set.
    - Validate `allowed_user_roles`.
    - Quantize decimals for monetary fields.
    - Ensure reward amounts exist for certain `reward_type`s.
    - Ensure validity period constraints (valid_to > valid_from, ≤ 2 years).
    - Check eligibility consistency (min booking vs min stay).

- **`ProgramCreate` (`ReferralProgramBase`, `BaseCreateSchema`)**  
  Input model for **creating** a program:
  - Inherits all fields from `ReferralProgramBase`.
  - Pre-validator that **generates `program_code`** from name + timestamp if not provided.

- **`ProgramUpdate` (`BaseUpdateSchema`)**  
  Input model for **updating** a program:
  - All fields optional: name, description, reward_type, reward amounts, booking/stay thresholds, caps, roles, T&C, active flags, validity, etc.
  - Quantizes relevant decimals.
  - Model validator that ensures **at least one field is being updated**.

---

## 4. `referral_program_response.py`

**Purpose:** Output models for **viewing programs and program-level analytics**.

**Classes that should be in this file:**

- **`ProgramResponse` (`BaseResponseSchema`)**  
  Standard view of a program:
  - All main config: name/code/type, desc, reward type/amounts, caps, eligibility, roles.
  - Status: `is_active`, `valid_from`, `valid_to`.
  - T&C: `terms_and_conditions`, `auto_approve_rewards`, `track_conversion`.
  - Basic stats: `total_referrals`, `successful_referrals`, `pending_referrals`, `total_rewards_distributed`.
  - Audit: `created_at`, `updated_at`, `created_by`, `updated_by`.
  - Computed:
    - `is_expired`, `is_upcoming`, `conversion_rate`, `days_remaining`.

- **`ProgramList` (`BaseSchema`)**  
  Paginated list of programs:
  - Counts: `total_programs`, `active_programs`, `inactive_programs`, `expired_programs`.
  - List of `ProgramResponse` as `programs`.
  - Pagination: `page`, `page_size`, `total_pages`.
  - Computed: `has_next_page`, `has_previous_page`.

- **`ProgramStats` (`BaseSchema`)**  
  Detailed statistics for a single program:
  - Identity: id, name, code, type.
  - Referral counts (total/pending/successful/failed/cancelled/expired).
  - Metrics: `conversion_rate`, `average_conversion_time_days`.
  - Revenue: `total_booking_value`, `average_booking_value`.
  - Rewards: `total_rewards_earned`, `total_rewards_paid`, `pending_rewards`, `rewards_in_process`, `currency`.
  - Engagement: `total_referrers`, `active_referrers`, `top_referrers` (list of dicts).
  - Period: `period_start`, `period_end`, `generated_at`.
  - Computed: `roi_percentage`, `average_reward_per_conversion`.

- **`ProgramAnalytics` (`BaseSchema`)**  
  High-level analytics and trends for a program:
  - Id + name.
  - Trend data: `daily_referral_trend`, `weekly_conversion_trend`, `monthly_revenue_trend`.
  - Growth metrics: `month_over_month_growth`, `year_over_year_growth`.
  - Segmentation: `referrals_by_source`, `conversions_by_user_type`, `revenue_by_hostel`.
  - Highlights: best performing day/month, peak time.
  - Projections: `projected_monthly_referrals`, `projected_monthly_revenue`.
  - Quality metrics: `average_referee_lifetime_value`, `referee_retention_rate`.
  - Period: `analysis_start_date`, `analysis_end_date`, `generated_at`.

- **`ProgramPerformance` (`BaseSchema`)**  
  Comparison model for **multi-program / time-series performance**:
  - `comparison_type` ("multi_program" or "time_series").
  - `programs`: list of items (dicts) being compared.
  - `metrics_comparison`: side-by-side metrics by key.
  - Rankings: `best_conversion_rate`, `highest_revenue`, `most_cost_effective`.
  - `insights`, `recommendations`.
  - Period: `comparison_period_start`, `comparison_period_end`, `generated_at`.

---

## 5. `referral_response.py`

**Purpose:** Output models for **individual referrals, user-level referral stats, timelines, and referral-level analytics**.

**Classes that should be in this file:**

- **`ReferralResponse` (`BaseResponseSchema`)**  
  Standard/light referral view (single or list item):
  - Program info.
  - Referrer info.
  - Referee info.
  - Referral code, status, source.
  - Booking/conversion info: `booking_id`, `conversion_date`, `booking_amount`.
  - Reward amounts + currency.
  - Reward statuses.
  - Timestamps: created_at/updated_at.
  - Computed: `is_converted`, `total_reward_amount`, `days_since_referral`.

- **`ReferralDetail` (`BaseResponseSchema`)**  
  Full, detailed referral view:
  - Program details + description.
  - Referrer profile and aggregate (`referrer_total_referrals`).
  - Referee details + registration date.
  - Referral code, status, source, campaign.
  - Booking + stay details + hostel info.
  - Rewards + statuses + paid timestamps.
  - Status history: `status_history` (list of dicts).
  - Notes (`notes`, `admin_notes`).
  - Timestamps: created/updated/completed.
  - Computed: `conversion_time_days`, `total_reward_value`, `is_reward_fully_paid`.

- **`ReferralStats` (`BaseSchema`)**  
  Per-user referral performance stats:
  - User id + name.
  - Counts: total/successful/pending/failed/cancelled.
  - Metrics: `conversion_rate`, `average_conversion_time_days`.
  - Rewards: total earned/paid/pending, `currency`.
  - Breakdown: `referrals_by_program`, `rewards_by_program`.
  - Time-based: this month / last month counts.
  - Ranking: `user_rank`, `total_referrers`.
  - Activity: `last_referral_date`, `most_active_program`.
  - Computed: `success_rate`, `pending_payout_amount`, `average_reward_per_referral`.

- **`ReferralLeaderboard` (`BaseSchema`)**  
  Leaderboard of top referrers:
  - `period` (all_time/this_month/last_month/this_year).
  - `total_users`.
  - `top_referrers`: list of `LeaderboardEntry`.
  - `generated_at`.

- **`LeaderboardEntry` (`BaseSchema`)**  
  One row in the leaderboard:
  - `rank`, `user_id`, `user_name`, optional avatar.
  - `total_referrals`, `successful_referrals`, `total_rewards_earned`, `conversion_rate`.
  - Optional `badge`.

- **`ReferralTimeline` (`BaseSchema`)**  
  Chronological events for one referral:
  - `referral_id`.
  - `timeline_events`: list of `TimelineEvent`.

- **`TimelineEvent` (`BaseSchema`)**  
  A single event in the referral’s lifecycle:
  - `event_type` (created/shared/clicked/registered/booked/converted/reward_approved/reward_paid/cancelled/expired).
  - `event_title`, optional `event_description`.
  - `event_date`, `event_data` (extra info), optional actor id/name.

- **`ReferralAnalytics` (`BaseSchema`)**  
  **Referral-level** analytics over a period (optionally per program):
  - Optional `program_id`.
  - Period: `period_start`, `period_end`.
  - Totals: referrals, conversions, revenue, rewards.
  - Performance metrics: conversion rate, avg conversion time, avg booking value.
  - ROI: `roi_percentage`, `cost_per_acquisition`.
  - Trends: `referral_trend`, `conversion_trend`.
  - Top `top_referrers`, `top_sources`.
  - `referrals_by_location`, `status_breakdown`.
  - Computed: `effective_conversion_rate`.

---

## 6. `referral_rewards.py`

**Purpose:** Config + lifecycle around **rewards and payouts** for referrals.

**Classes that should be in this file:**

- **`RewardConfig` (`BaseSchema`)**  
  Global payout configuration:
  - Thresholds: `min_payout_amount`, `max_payout_amount`.
  - Allowed payout `payout_methods` (PaymentMethod).
  - Processing options: `auto_approve_payouts`, `payout_processing_time_days`.
  - Fees: `payout_fee_percentage`, `min_payout_fee`, `max_payout_fee`.
  - Frequency limits: `max_payouts_per_month`, `min_days_between_payouts`.
  - Tax: `tax_deduction_applicable`, `tax_deduction_percentage`.
  - Validators: unique payout_methods, 2-decimal monetary fields.

- **`RewardTracking` (`BaseSchema`)**  
  Per-user reward balances and history:
  - User id + name.
  - Totals: total earned/paid/pending, `available_for_payout`, currency.
  - Breakdown by program.
  - Breakdown by status: approved, pending_approval, cancelled.
  - Last payout info + `next_payout_eligible_date`.
  - Stats: total payouts, average payout amount.
  - Quantization on all monetary fields.

- **`RewardCalculation` (`BaseSchema`)**  
  Detailed reward calculation for one referral:
  - `referral_id`, `program_id`.
  - Booking: amount, stay duration.
  - Eligibility: `is_eligible` + reasons.
  - Calculated rewards: base + bonus + total for referrer + referee.
  - Deductions: tax, processing_fee.
  - Net amounts: `referrer_net_amount`, `referee_net_amount`.
  - Currency, `calculated_at`.
  - Quantizes all monetary fields.

- **`PayoutRequest` (`BaseCreateSchema`)**  
  Input to **request a payout**:
  - `user_id`, `amount`.
  - `payout_method` (UPI/BANK_TRANSFER), `payout_details` (fields vary by method).
  - Optional `currency`, `urgent_payout`, `notes`.
  - Validates `amount` in range [100, 100000], quantized.
  - Validates `payout_details` structure based on method.

- **`PayoutRequestResponse` (`BaseResponseSchema`)**  
  Payout request record + status:
  - `payout_request_id`, user id + name.
  - Amounts: `amount`, `processing_fee`, `tax_deduction`, `net_amount`, currency.
  - Payout method + masked details.
  - Status (`RewardStatus`) + timestamps (requested/approved/processed/completed).
  - Transaction ID, failure reason, admin notes.
  - `estimated_completion_date`, audit fields (approved_by, processed_by).
  - Quantizes monetary fields.

- **`PayoutHistory` (`BaseSchema`)**  
  List of payouts for a user:
  - `user_id`, `total_payouts`, `total_amount_paid`, currency.
  - `payouts`: list of `PayoutRequestResponse`.
  - Quantizes `total_amount_paid`.

- **`RewardSummary` (`BaseSchema`)**  
  Aggregated reward summary over a period:
  - Period: `period_start`, `period_end`.
  - Optional `user_id`, `program_id`.
  - Totals: earned/approved/paid/pending/cancelled.
  - Breakdowns: by status, program, month.
  - Payout stats: total requests, successful/failed payouts.
  - Averages: `average_reward_amount`, `average_payout_amount`.
  - `currency`.
  - Quantizes key monetary fields.

---

## 7. `__init__.py` (referral package)

**Purpose:** Public facade for `app.schemas.referral`.

It should import and re-export:

- Program base:  
  `ReferralProgramBase`, `ProgramCreate`, `ProgramUpdate`, `ProgramType`, `RewardType`
- Program responses:  
  `ProgramResponse`, `ProgramList`, `ProgramStats`, `ProgramAnalytics`, `ProgramPerformance`
- Referral base:  
  `ReferralBase`, `ReferralCreate`, `ReferralUpdate`, `ReferralConversion`
- Codes:  
  `ReferralCodeGenerate`, `ReferralCodeResponse`, `CodeValidationRequest`, `CodeValidationResponse`, `ReferralCodeStats`
- Referral responses:  
  `ReferralResponse`, `ReferralDetail`, `ReferralStats`, `ReferralLeaderboard`, `LeaderboardEntry`, `ReferralTimeline`, `TimelineEvent`, `ReferralAnalytics`
- Rewards:  
  `RewardConfig`, `RewardTracking`, `RewardCalculation`, `PayoutRequest`, `PayoutRequestResponse`, `PayoutHistory`, `RewardSummary`

This matches your current `__all__` and keeps your external import surface clean.

---

If you want, I can next map **end-to-end flows** (e.g., “user shares code → referral create → conversion → reward calc → payout”) and show exactly which schemas are involved at each step.


============================================================================================================================================================

Here’s a clear, file‑by‑file breakdown of what classes should live in each file, based on the code you shared and how the module is already structured.

---

## `review_base.py`

**Purpose:** Core review models for creating/updating a review (domain model, not submission workflow or responses).

**Classes that belong here:**

1. **`DetailedRatings`**  
   - Optional per‑aspect ratings (cleanliness, food, staff, etc.) stored directly on the review.
   - Used as part of the internal/base representation, not the submission form.

2. **`ReviewBase`**  
   - Core review data: IDs, overall rating, title, text, aspect ratings, photos.
   - Shared validation logic (title/text checks, rating consistency).

3. **`ReviewCreate`**  
   - Extends `ReviewBase` + creation‑time fields (`would_recommend`, `stay_duration_months`).
   - Used by internal API endpoints when creating a review (as opposed to the more UX‑oriented `ReviewSubmissionRequest`).

4. **`ReviewUpdate`**  
   - Partial update schema: all fields optional.
   - For edit operations within the allowed edit window.

---

## `review_response.py`

**Purpose:** How reviews are sent back to clients (read models / view models).

**Classes that belong here:**

1. **`HostelResponseDetail`**  
   - Represents a hostel’s reply attached to a review (as part of a review payload).
   - Used inside `ReviewDetail`.

2. **`ReviewResponse`**  
   - Minimal review representation for basic list views.
   - Contains ratings, content, helpful counts, and a helpfulness ratio.

3. **`ReviewDetail`**  
   - Full, detailed representation of a single review.
   - Includes all aspect ratings, verification, moderation, engagement, hostel response, metadata.

4. **`ReviewListItem`**  
   - Light‑weight list item optimized for paginated review lists (e.g., cards).
   - No heavy nested structures; just what’s needed to render a list.

5. **`ReviewSummary`**  
   - Aggregated summary for a hostel: average rating, count breakdowns, verified %,
     average aspect ratings, recent reviews, recommendation percentage, and derived quality labels.

---

## `review_filters.py`

**Purpose:** Request schemas for filtering/searching/sorting/exporting reviews.

**Classes that belong here:**

1. **`ReviewFilterParams`**  
   - General filter set for listing reviews (hostel_id(s), rating ranges, dates, flags, photos, etc.).

2. **`ReviewSearchRequest`**  
   - Full‑text search over reviews (query + filters + pagination).

3. **`ReviewSortOptions`**  
   - Sorting strategy: helpful, recent, high/low rating, verified, oldest, plus priority toggles.

4. **`ReviewExportRequest`**  
   - Parameters for exporting reviews (hostel, filters, format, date range, what to include).

---

## `review_moderation.py`

**Purpose:** Moderation / approval / flagging workflow.

**Classes that belong here:**

1. **`ModerationRequest`**  
   - Admin/moderator action on a review (approve/reject/flag/unflag/hold).

2. **`FlagReview`**  
   - User‑initiated flagging of a review (report abuse/inappropriate, etc.).

3. **`ModerationResponse`**  
   - Response returned after a moderation action (what happened, by whom, when).

4. **`PendingReview`**  
   - Representation of a review waiting in the moderation queue, with AI scores, flags, etc.

5. **`ModerationQueue`**  
   - Overview of pending reviews and queue‑level metrics (counts, wait times).

6. **`ApprovalWorkflow`**  
   - Full lifecycle status of a review: pending/approved/rejected/flagged/on_hold, timestamps, moderator info.

7. **`BulkModeration`**  
   - Bulk approve/reject/flag request for multiple reviews at once.

8. **`ModerationStats`**  
   - Aggregated stats for moderation performance (approval/rejection rates, times, per‑moderator activity).

---

## `review_analytics.py`

**Purpose:** Analytics and insights over reviews (metrics, trends, sentiments, competition).

**Classes that belong here:**

1. **`MonthlyRating`**  
   - Average rating and count per month (YYYY‑MM).

2. **`RatingDistribution`**  
   - Counts and percentages by star rating, and derived totals/score.

3. **`TrendAnalysis`**  
   - Ratings over time and trend direction (improving/declining/stable), with last 30/90/all‑time ratings and history.

4. **`SentimentAnalysis`**  
   - Overall sentiment classification, score, distribution, and extracted themes/keywords.

5. **`AspectAnalysis`**  
   - Per‑aspect analytics (e.g., cleanliness, staff): ratings, mentions, sentiment ratio, comments.

6. **`CompetitorComparison`**  
   - Comparison vs. nearby competitors: rating differences, percentile rank, competitive position, advantages/weaknesses.

7. **`ReviewAnalytics`**  
   - Top‑level analytics object for a hostel: total reviews, average rating, distributions, trends, sentiment, verification, engagement, and derived quality/health indicators.

---

## `review_response_schema.py`

**Purpose:** Schemas for creating/updating/serving hostel management responses to reviews, and response‑side analytics/guidelines.

**Classes that belong here:**

1. **`HostelResponseCreate`**  
   - Payload for creating a response to a review.

2. **`HostelResponseUpdate`**  
   - Payload for editing an existing response.

3. **`OwnerResponse`**  
   - Full response object as returned to clients (who responded, when, edits).

4. **`ResponseGuidelines`**  
   - Guidelines and best practices for staff when writing responses.

5. **`ResponseStats`**  
   - Metrics about how well the hostel responds (response rate, times, breakdown by rating, pending responses).

6. **`ResponseTemplate`**  
   - Pre‑approved response templates with placeholders and usage stats.

---

## `review_submission.py`

**Purpose:** UX‑oriented schemas for the end‑user review submission flow, verification, draft, and guidelines.

**Classes that belong here:**

1. **`DetailedRatingsInput`**  
   - Required/optional aspect ratings as provided in the submission form (slightly different shape from `DetailedRatings`).

2. **`ReviewSubmissionRequest`**  
   - Full submission payload a user posts: overall rating, title, text, detailed ratings, photos, pros/cons, stay details, and guideline acceptance.

3. **`VerifiedReview`**  
   - Marker/record of verification for a given review (method, who verified, confidence, details).

4. **`ReviewGuidelines`**  
   - Guidelines and prohibited content for writing reviews, plus minimum requirements.

5. **`ReviewEligibility`**  
   - Eligibility check result telling if a user can review/edit based on stay and existing reviews.

6. **`ReviewDraft`**  
   - Saved, partial review draft (with completion %, expiry, partial fields).

---

## `review_voting.py`

**Purpose:** Helpfulness voting on reviews and related engagement analytics.

**Classes that belong here:**

1. **`VoteRequest`**  
   - Submit a helpful/not_helpful vote on a review.

2. **`VoteResponse`**  
   - Response after voting, with updated counts and derived percentages.

3. **`HelpfulnessScore`**  
   - Encapsulates Wilson score and related fields for ranking reviews by helpfulness.

4. **`VoteHistoryItem`**  
   - One historical vote record for a user.

5. **`VoteHistory`**  
   - User’s complete voting history and derived patterns/percentages.

6. **`RemoveVote`**  
   - Payload to remove a previously cast vote.

7. **`VotingStats`**  
   - Hostel‑level voting stats: totals, averages, engagement rate, and overall sentiment from votes.

---

## `__init__.py` (package root)

**Purpose:** Public aggregation/re‑export of all review‑related schemas.

It should export exactly these classes (grouped logically as in your file):

- Base: `ReviewBase`, `ReviewCreate`, `ReviewUpdate`, `DetailedRatings`  
- Response: `ReviewResponse`, `ReviewDetail`, `ReviewListItem`, `ReviewSummary`, `HostelResponseDetail`  
- Submission: `ReviewSubmissionRequest`, `DetailedRatingsInput`, `VerifiedReview`, `ReviewGuidelines`, `ReviewEligibility`, `ReviewDraft`  
- Moderation: `ModerationRequest`, `ModerationResponse`, `ModerationQueue`, `PendingReview`, `ApprovalWorkflow`, `BulkModeration`, `ModerationStats`, `FlagReview`  
- Voting: `VoteRequest`, `VoteResponse`, `HelpfulnessScore`, `VoteHistory`, `VoteHistoryItem`, `RemoveVote`, `VotingStats`  
- Hostel Response: `HostelResponseCreate`, `HostelResponseUpdate`, `OwnerResponse`, `ResponseGuidelines`, `ResponseStats`, `ResponseTemplate`  
- Filters: `ReviewFilterParams`, `ReviewSearchRequest`, `ReviewSortOptions`, `ReviewExportRequest`  
- Analytics: `ReviewAnalytics`, `RatingDistribution`, `TrendAnalysis`, `MonthlyRating`, `SentimentAnalysis`, `AspectAnalysis`, `CompetitorComparison`


============================================================================================================================================================


Here’s a clear, file‑by‑file mapping of which classes belong where, and what role each file plays in the “room” schemas package.

---

## `bed_base.py`

**Purpose:** Input / command models for *beds* (create/update, assignment, bulk ops). These are used when *changing* bed data, not for read‑only responses.

**Classes that should be here:**

1. **`BedBase`**  
   - Core bed attributes (room_id, bed_number, status).  
   - Shared base for other bed input schemas.

2. **`BedCreate`**  
   - For manually creating a single bed in a room.  
   - Requires `room_id` and `bed_number`.

3. **`BedUpdate`**  
   - For partially updating an existing bed (number, status, legacy `is_occupied`, notes).  
   - Contains logic to sync `is_occupied` and `status`.

4. **`BulkBedCreate`**  
   - For creating multiple beds in one go based on a prefix, start number, count, and format.  
   - Includes method `generate_bed_numbers()`.

5. **`BedAssignmentRequest`**  
   - Command to assign a bed to a student (bed_id, student_id, occupied_from, etc.).  
   - Used to create a new bed assignment record.

6. **`BedReleaseRequest`**  
   - Command to release / vacate a bed (bed_id, release_date, reason, damages, etc.).

7. **`BedSwapRequest`**  
   - Command to swap beds between two students, with a specified swap date and reason.  
   - Enforces that students and beds are different.

8. **`BulkBedStatusUpdate`**  
   - Command to change the status of multiple beds at once (e.g. set to MAINTENANCE).  
   - Requires unique bed_ids and a reason when switching to maintenance.

---

## `bed_response.py`

**Purpose:** Read‑only / response models for *beds* (status, availability, assignments, history).

**Classes that should be here:**

1. **`BedResponse`**  
   - Compact representation of a single bed for generic API responses.  
   - Includes computed `is_available`.

2. **`BedAvailability`**  
   - Availability‑focused representation (for booking/selection flows).  
   - Combines bed basics, current occupant, and room features (price, AC, attached bath, etc.).  
   - Includes `days_until_available`.

3. **`BedAssignment`**  
   - Full details for a current (or historical) bed assignment: student info, dates, rent, booking_id, notes.  
   - Computed `days_occupied` and `expected_duration_days`.

4. **`BedAssignmentHistory`**  
   - One historical assignment entry for a bed (move in/out, duration, rent, etc.).  
   - Computed `duration_months`.

5. **`BedHistory`**  
   - Aggregate history for a bed: status, all assignments, occupancy stats.  
   - Computed `utilization_rate` since first assignment.

6. **`BedDetailedStatus`**  
   - Rich status object for a bed: assignment, maintenance, condition, and history stats.  
   - Computed `needs_maintenance` and `current_occupancy_days`.

---

## `room_availability.py`

**Purpose:** Availability & calendar models: checking availability, representing availability calendars, and day‑level booking data.

**Classes that should be here:**

1. **`RoomAvailabilityRequest`**  
   - Request payload to check availability: hostel_id, check_in_date, duration_months, filters (room_type, beds, AC, etc.).  
   - Computed `check_out_date`.

2. **`AvailableRoom`**  
   - Result item for an available room: bed counts, pricing (monthly/quarterly/… ), features, amenities, images.  
   - Computed `occupancy_rate`.

3. **`AvailabilityResponse`**  
   - Top‑level response for an availability check: hostel_id, dates, list of `AvailableRoom`, total beds, flags, and `filters_applied`.  
   - Computed `total_rooms_available` and `price_range` (min/max/avg).

4. **`BookingInfo`**  
   - Minimal booking details for calendar views (booking_id, student, dates, bed_number, status).  
   - Used inside `DayAvailability`.

5. **`DayAvailability`**  
   - Availability for a specific date: available/total beds, if available, list of `BookingInfo`, notes.  
   - Computed `occupancy_percentage`.

6. **`AvailabilityCalendar`**  
   - Month‑view calendar for a room: room info, month string, total beds, and `availability` mapping (date → `DayAvailability`).  
   - Computed `average_occupancy` and `fully_booked_days`.

7. **`BulkAvailabilityRequest`**  
   - Batch check of availability for multiple hostels.  
   - hostel_ids, check_in_date, duration, room_type filter, min beds/hostel.

---

## `room_base.py`

**Purpose:** Input / command models for *rooms*: create/update, bulk create, pricing changes, status changes, media.

**Classes that should be here:**

1. **`RoomBase`**  
   - Core room definition: hostel_id, room_number, type, beds, pricing, specs, amenities, status flags, images.  
   - Validation for room number/wing, lists, images, pricing logic, room_type vs total_beds.

2. **`RoomCreate`**  
   - Derived from `RoomBase` + `BaseCreateSchema`.  
   - Enforces required fields for creating a new room (hostel_id, room_number, room_type, total_beds, price_monthly).

3. **`RoomUpdate`**  
   - Partial update for rooms: all editable fields optional (numbers, type, capacity, pricing, specs, amenities, availability, status, images).  
   - Includes validators mirroring `RoomBase` but tolerant of `None`.

4. **`BulkRoomCreate`**  
   - Create multiple rooms at once via a list of `RoomCreate`.  
   - Enforces unique room numbers in batch and consistent hostel_id across rooms.

5. **`RoomPricingUpdate`**  
   - Dedicated pricing update schema: monthly/quarterly/half‑yearly/yearly prices, effective_from.  
   - Validates discount logic relative to monthly price and effective date.

6. **`RoomStatusUpdate`**  
   - Updates “operational” status: `status`, `is_available_for_booking`, `is_under_maintenance`, maintenance notes/dates.  
   - Enforces business rules when under maintenance.

7. **`RoomMediaUpdate`**  
   - Dedicated schema for media: room_images, primary_image, virtual_tour_url.  
   - Validates URLs, duplicates, and ensures primary_image is in room_images.

---

## `room_response.py`

**Purpose:** Read‑only / response models for *rooms* (list/detail, beds, occupancy, finances).

**Classes that should be here:**

1. **`RoomResponse`**  
   - Standard room response for general views: ID, type, bed counts, base pricing, AC/attached bath, status and booking availability.  
   - Computed `occupancy_percentage`.

2. **`BedDetail`**  
   - Detailed bed info used inside detailed room views (id, status, current student, dates, maintenance info, notes).

3. **`RoomDetail`**  
   - Full, detailed room response: hostel info, capacity, pricing (all tenures), specs, amenities, status+maintenance, media, and list of `BedDetail`.  
   - Computed occupancy %, fully_occupied flag, and discount percentages.

4. **`RoomListItem`**  
   - Lightweight list item for room lists: ID, number, type, basic counts, monthly price, AC, status, primary image.  
   - Computed `occupancy_percentage`.

5. **`BedInfo`**  
   - Simple bed summary for high‑level room overviews (id, bed_number, status, student_name, occupied_from).

6. **`RoomWithBeds`**  
   - Room overview specifically paired with `BedInfo` entries: basic counts + bed list.  
   - Computed `occupancy_rate`.

7. **`RoomOccupancyStats`**  
   - Room‑level occupancy and revenue snapshot: bed counts, reserved_beds, price_monthly, current and potential revenue, status, timestamps.  
   - Computed `occupancy_percentage`, `revenue_percentage`, and `lost_revenue`.

8. **`RoomFinancialSummary`**  
   - Financial summary: pricing per bed, current month revenue/collected/pending, YTD totals, average occupancy, and projections.  
   - Computed `collection_rate` and `occupancy_rate`.

---

## `__init__.py` (package root)

**Purpose:** Public, convenient re‑exports for all room & bed schemas.

It should re‑export exactly these (as it already does):

- **Room base / commands**  
  `RoomBase`, `RoomCreate`, `RoomUpdate`, `BulkRoomCreate`,  
  `RoomPricingUpdate`, `RoomStatusUpdate`, `RoomMediaUpdate`

- **Room responses**  
  `RoomResponse`, `RoomDetail`, `RoomListItem`, `RoomWithBeds`,  
  `RoomOccupancyStats`, `RoomFinancialSummary`,  
  `BedDetail`, `BedInfo`

- **Bed base / commands**  
  `BedBase`, `BedCreate`, `BedUpdate`, `BulkBedCreate`,  
  `BedAssignmentRequest`, `BedReleaseRequest`, `BedSwapRequest`, `BulkBedStatusUpdate`

- **Bed responses**  
  `BedResponse`, `BedAvailability`, `BedAssignment`, `BedHistory`,  
  `BedAssignmentHistory`, `BedDetailedStatus`

- **Availability**  
  `RoomAvailabilityRequest`, `AvailabilityResponse`, `AvailableRoom`,  
  `AvailabilityCalendar`, `DayAvailability`, `BulkAvailabilityRequest`


============================================================================================================================================================
### `search_analytics.py`

**Purpose:** Analytics/insights over search behavior and performance (not live search requests/responses).

**Classes that belong here:**

1. **`SearchTermStats`**  
   - Per-term stats: counts, zero-result rates, CTR, click positions, trend direction, growth, first/last searched.

2. **`SearchMetrics`**  
   - Aggregated metrics for a period: total/unique searches, avg results, zero-result rate, response times, CTR.

3. **`PopularSearchTerm`**  
   - “Top N” popular terms with rank, counts, average result count, and change in rank since last period.

4. **`TrendingSearch`**  
   - Rapidly growing terms: current vs previous counts, growth rate, velocity score.

5. **`ZeroResultTerm`**  
   - Terms that consistently return zero results: counts, affected users, first/last seen, suggested alternatives.

6. **`SearchAnalyticsRequest`**  
   - Request parameters for generating analytics: date range, thresholds, limits for top/trending/zero-result terms.

7. **`SearchAnalytics`**  
   - Full analytics report: period, metrics, top/trending/zero-result lists, per-term stats, category/geographic breakdown, plus computed `has_quality_issues` and `engagement_score`.

---

### `search_autocomplete.py`

**Purpose:** Autocomplete / typeahead requests & responses.

**Classes that belong here:**

1. **`SuggestionType` (Enum)**  
   - Types of suggestions (hostel, city, area, landmark, amenity, popular_search).

2. **`AutocompleteRequest`**  
   - Request for typeahead: prefix, optional type filters, limit, user location, include/exclude types.

3. **`Suggestion`**  
   - One autocomplete suggestion: value, label, type, score, result_count, icons/images, metadata, highlighted label.

4. **`AutocompleteResponse`**  
   - Response containing suggestions: flat list, optional grouped-by-type map, original prefix, total count, execution time, optional popular_searches.  
   - Includes `create_grouped()` helper for building grouped responses.

---

### `search_filters.py`

**Purpose:** Reusable, composable filter pieces for searches/facets.

**Classes that belong here:**

1. **`PriceFilter`**  
   - Min/max price with validation and `is_active` flag.

2. **`RatingFilter`**  
   - Min/max rating (0–5) with validation and `is_active`.

3. **`AmenityFilter`**  
   - `required_amenities`, `optional_amenities`, `excluded_amenities`, normalization; `is_active` indicates any amenity filters applied.

4. **`LocationFilter`**  
   - Text-based location: city/state/pincode.  
   - Proximity: lat/long + radius_km, with validation.  
   - Computed flags: `is_text_location`, `is_proximity_location`, `is_active`.

5. **`AvailabilityFilter`**  
   - Availability conditions: available_only, min_beds, check-in/out, instant_booking_only, verified_only, with date-range validation and `is_active`.

6. **`SearchFilterSet`**  
   - Composite wrapper that embeds `PriceFilter`, `RatingFilter`, `AmenityFilter`, `LocationFilter`, `AvailabilityFilter`, plus `hostel_types` and `room_types`.  
   - Computed: `active_filters`, `filter_count`, `has_filters`.

---

### `search_request.py`

**Purpose:** Primary search-related requests (keyword, advanced, nearby) and saved-search/history models.

**Classes that belong here:**

1. **`BasicSearchRequest`**  
   - Simple keyword + limit, with query normalization.

2. **`AdvancedSearchRequest`**  
   - Rich search request:  
     - Query, city/state/pincode, coordinates + radius  
     - Hostel/room types, gender preference  
     - Price, amenities (AND/OR), min_rating  
     - Availability flags (verified_only, available_only, instant_booking)  
     - Check-in/out dates  
     - Sorting, pagination, advanced toggles (include_nearby_cities, boost_featured)  
   - Validation for radius/coords, price range, date range.  
   - Computed: `has_location_filter`, `has_price_filter`, `offset`.

3. **`NearbySearchRequest`**  
   - Strict proximity search: required lat/long, radius, optional type/price filters, available_only, limit.  
   - Validates price range.

4. **`SavedSearchCreate`**  
   - Create a saved search: name, `search_criteria` (serialized parameters), alert flags/frequency, with normalized name and alert-related validation.

5. **`SavedSearchUpdate`**  
   - Partial update of saved search: name, criteria, alert flags/frequency, with normalized name.

6. **`SavedSearchResponse`**  
   - Read model for a saved search: identifies user, name, criteria, alert config, last_executed_at, last result_count.

7. **`SearchHistoryResponse`**  
   - Read model for a history entry: user (or anonymous), query, parameters, result_count, execution_time, clicked_result_ids.

---

### `search_response.py`

**Purpose:** Search result and facets responses, plus metadata and suggestions; this is what API returns for a search.

**Classes that belong here:**

1. **`SearchResultItem`**  
   - Single hostel result with:
     - Basic info (id, name, slug, type, address)  
     - Price range, rating, total_reviews  
     - Availability (available_beds, total_beds)  
     - Media (thumbnail, image_urls)  
     - Featured_amenities, verification/featured flags  
     - Search metadata: relevance_score, distance_km, highlights  
   - Computed: `occupancy_rate`, `has_availability`.

2. **`SearchMetadata`**  
   - Execution and result metadata: total/returned results, paging, times, applied_filters, sort, score range, optional debug_info.  
   - Computed: `has_next_page`, `has_previous_page`.

3. **`FacetBucket`**  
   - One facet value: value, label, count, is_selected, optional metadata.

4. **`SearchSuggestion`**  
   - Query refinement suggestion: type (spell_correction / alternative_query / related_search / popular_search), text, reason, expected_results.

5. **`FacetedSearchResponse`**  
   - Full search response:  
     - `results`: list of `SearchResultItem`  
     - `metadata`: `SearchMetadata`  
     - `facets`: dict of facet name → list of `FacetBucket`  
     - `suggestions`: list of `SearchSuggestion`  
   - Computed: `is_empty`, `facet_names`.

---

### `search_sort.py`

**Purpose:** Strongly-typed sort options and mapping to DB fields.

**Classes that belong here:**

1. **`SearchSortField` (Enum)**  
   - Allowed sort fields: relevance, price_asc/price_desc, rating_desc, distance_asc, newest, popular, availability.

2. **`SearchSortOrder` (Enum)**  
   - Direction: asc / desc.

3. **`SortCriteria`**  
   - Sort request object: primary `sort_by`, `sort_order`, optional secondary field/order.  
   - Computed: `effective_sort_order` (handles implicit direction for some fields).  
   - Method: `to_db_sort()` returns `(db_field, direction)` for queries.

---

### `__init__.py` (search package root)

**Purpose:** Public re‑exports for all search-related schemas.

It should re‑export (as it already does):

- **Requests:**  
  `BasicSearchRequest`, `AdvancedSearchRequest`, `NearbySearchRequest`,  
  `SavedSearchCreate`, `SavedSearchUpdate`, `SearchHistoryResponse`, `SavedSearchResponse`

- **Responses:**  
  `SearchResultItem`, `FacetedSearchResponse`, `SearchMetadata`,  
  `SearchSuggestion`, `FacetBucket`

- **Autocomplete:**  
  `AutocompleteRequest`, `AutocompleteResponse`, `Suggestion`, `SuggestionType`

- **Filters:**  
  `PriceFilter`, `RatingFilter`, `AmenityFilter`, `LocationFilter`,  
  `AvailabilityFilter`, `SearchFilterSet`

- **Sort:**  
  `SortCriteria`, `SearchSortField`, `SearchSortOrder`

- **Analytics:**  
  `SearchAnalytics`, `SearchAnalyticsRequest`, `SearchTermStats`,  
  `SearchMetrics`, `PopularSearchTerm`, `TrendingSearch`, `ZeroResultTerm`

This is the correct, coherent mapping of which classes belong in each file given your current design.

============================================================================================================================================================
Here’s how your student schema package is structured, and what *should* live in each file given the current design. I’ll go file by file and list the classes and their roles, so you have a clear mental model.

---

## 1. `student_base.py` – Core student model + state-changing commands

This file should hold:

### Core student entity schemas
- **`StudentBase`**  
  - The core “student record” with all main attributes: user/hostel/room/bed, guardians, institution/employment, financials, meals, status, dates, etc.  
  - Contains cross-field validation and business rules (dates, room/bed consistency, etc.).
- **`StudentCreate`**  
  - For **creating** a new student record.  
  - Inherits from `StudentBase` + `BaseCreateSchema` and tightens required fields like `user_id`, `hostel_id`, `guardian_name`, `guardian_phone`, and adds:
    - `booking_id` (optional source booking)
    - `initial_rent_paid`
- **`StudentUpdate`**  
  - For **partial updates** to an existing student record.  
  - All fields optional; mirrors most of `StudentBase` fields with `Union[... , None]`, plus reuses validators from `StudentBase`.

### Operational command schemas (actions on a student)
- **`StudentCheckInRequest`**  
  - Command to **check in** a student: requires `student_id`, `check_in_date`, `room_id`, `bed_id`, plus payment confirmations and IDs, doc verification flags, notes.
- **`StudentCheckOutRequest`**  
  - Command to **check out** a student: `student_id`, `checkout_date`, reason, financial clearance details, room condition, item returns, clearances, forwarding address, notes.
- **`StudentRoomAssignment`**  
  - Command to **assign / reassign** a room/bed: `student_id`, `room_id`, `bed_id`, `assignment_date`, reason, and optional rent adjustment/proration flag.
- **`StudentStatusUpdate`**  
  - Command to **change student status**: `student_id`, `new_status`, `effective_date`, `reason`, with status-specific fields like `notice_period_days`, `suspension_end_date`.

> Conceptually: `student_base.py` is the “write model” for core student lifecycle: create/update + check-in/out + room/status operations.

---

## 2. `student_dashboard.py` – Read-only dashboard view models

This file should hold all the **aggregated, read-only** schemas used to build a student’s dashboard:

- **`StudentFinancialSummary`**  
  - Snapshot of rent/mess/advance/deposit, due/overdue amounts, and computed flags like `total_outstanding`, `net_balance`, `is_payment_urgent`.
- **`AttendanceSummary`**  
  - Attendance stats (current month, last 30 days, overall) + computed flags (`is_below_minimum`, `percentage_gap`).
- **`StudentStats`**  
  - High-level counters: days/months in hostel, total payments/complaints, attendance %, mess meals, and `complaint_resolution_rate`.
- **`RecentPayment`**  
  - Simple view of a recent payment: id, amount, type, date, status, receipt, method.
- **`RecentComplaint`**  
  - Recent complaint: id, title, category, status, priority, timestamps, assignee, plus computed `days_open`.
- **`PendingLeave`**  
  - Pending leave application: type, dates, total_days, reason, status, timestamps, and `is_upcoming`.
- **`RecentAnnouncement`**  
  - Announcement snippet: id, title, content, category, priority, published_at, flags, and `is_new`.
- **`TodayMessMenu`**  
  - Today’s mess menu by meal, with `is_special`/`special_occasion`.
- **`UpcomingEvent`**  
  - Event card: title, date, time, location, category, registration flags, and `days_until_event`.
- **`StudentDashboard`**  
  - Top-level dashboard aggregate:
    - Student & hostel identity info
    - `financial_summary`, `attendance_summary`, `stats`
    - `recent_payments`, `recent_complaints`, `pending_leave_applications`
    - `recent_announcements`, `upcoming_events`
    - `today_mess_menu`, notification counts
    - Computed `has_urgent_items`, `action_items_count`.

> This module is purely for **read models / view models** consumed by the frontend.

---

## 3. `student_filters.py` – Filtering, search, sort, export, bulk actions

This file should hold all schemas used to **query, filter, sort, and bulk-operate** on students:

- **`StudentFilterParams`**  
  - Rich filtering for list endpoints: search text, hostel/room/status/date/financial/mess/institution/company/gender filters.
- **`StudentSearchRequest`**  
  - Full-text style search request: `query`, which fields to search in (name, email, phone, room, etc.), status filter, active-only flag, pagination.
- **`StudentSortOptions`**  
  - Sorting configuration: `sort_by` (name/email/room/created_at/etc.), `sort_order`.
- **`AdvancedStudentFilters`**  
  - Additional analytic filters: attendance %, payment history pattern, pending complaints, stay duration, age, document verification.
- **`StudentExportRequest`**  
  - Config for exporting students: format (csv/excel/pdf), optional `filters`, and booleans for which columns to include (financial, attendance, guardian, etc.).
- **`StudentBulkActionRequest`**  
  - Bulk operations over `student_ids`: `action` (activate/deactivate/send_notification/change_status/assign_room/update_rent/export), with relevant parameters (new_status, notification_message/title, new_rent_amount, effective_date, confirm_action).

> This file is the “query + admin actions” surface: how admins search, filter, or bulk-manipulate students.

---

## 4. `student_profile.py` – Profile creation, docs, preferences, privacy, import

This file should hold all schemas around **profile data (not room/financial)**, documentation, preferences, and imports:

### Profile CRUD
- **`StudentProfileCreate`**  
  - For onboarding profile data alongside user creation: guardians, institution OR employment, id_proof, dietary_pref, allergies. Enforces “either student or working professional” rule.
- **`StudentProfileUpdate`**  
  - Partial updates to the same set of profile fields.

### Documents
- **`DocumentInfo`**  
  - A single stored document: type/name/url, metadata, verification fields, expiry flags.
- **`StudentDocuments`**  
  - Collection of all documents for a student, plus counts (total, verified, pending).
- **`DocumentUploadRequest`**  
  - Command used *after* file upload to register it: student_id, type, name, URL, size, MIME, expiry, notes.
- **`DocumentVerificationRequest`**  
  - Admin action to verify/reject a document: document_id, verified, notes, reject_reason.

### Preferences & privacy
- **`StudentPreferences`**  
  - Per-student preferences: mess subscription and meal plan, notification settings, preferred language/contact method.
- **`StudentPrivacySettings`**  
  - What info is visible to others: profile visibility, room/phone/email/institution exposure, contact permissions, searchability, activity visibility.

### Bulk import
- **`StudentBulkImport`**  
  - Bulk student import job: hostel_id, import_file_url + type (csv/excel), options (skip_duplicates, send_welcome_email, auto_generate_passwords), optional `field_mapping`.

> Think of this file as **everything about the student’s profile, documents, preferences, and bulk onboarding**, independent of their day-to-day financials or room transfers.

---

## 5. `student_response.py` – API response models for generic endpoints

This file should hold **response-only** schemas used broadly across the API (not just dashboard):

- **`StudentResponse`**  
  - Standard/basic student response: user/hostel/room/bed, guardian, status, dates, basic financial fields, mess subscription, plus computed `days_in_hostel`, `is_checked_in`. Good for common list/detail endpoints.
- **`StudentDetail`**  
  - Full, rich detail view: user info, hostel/room/bed, identification, guardian, institution/employment, all key dates, financials, meal prefs, status, booking_id, additional_documents, plus computed:
    - `age`
    - `days_in_hostel`
    - `is_currently_resident`
    - `is_student`
    - `is_working_professional`
- **`StudentProfile`**  
  - **Public/peer-facing** compact profile: id, name, profile image, hostel, room, check-in date, optional institution/course/year/company, and derived `duration_in_hostel` (human readable).
- **`StudentListItem`**  
  - Optimized list row for admin: id, user_id, name, contact, profile image, room/bed, status, check_in_date, basic financial summary (monthly_rent, payment_status, overdue_amount), created_at, and `days_in_hostel`.
- **`StudentFinancialInfo`**  
  - Detailed financial section: rent, security deposit (paid/paid_date/refundable), totals paid/due, last/next due dates, overdue/advance, mess and other charges, and computed `payment_status`, `total_outstanding`, `net_balance`.
- **`StudentContactInfo`**  
  - Contact-centric view: student and guardian contact details, emergency contact, current hostel/room, forwarding address if checked out.
- **`StudentDocumentInfo`**  
  - Document-centric view: summary of key docs (ID, institutional, company), their verification status/timestamps, plus extra `additional_documents`, with computed `verification_status` and `documents_complete`.

> This module is your “generic response DTOs” for various endpoints: details, list views, financial/contact/document sub-resources, etc.

---

## 6. `student_room_history.py` – Room history, transfers, swaps

This file should hold everything about **where the student has lived and movement between rooms**:

- **`RoomHistoryItem`**  
  - One period in one room: hostel/room/bed info, move-in/out dates, duration_days, rent & total_rent_paid during that period, transfer type, audit fields, computed `is_current` and `duration_months`.
- **`RoomHistoryResponse`**  
  - Room history aggregate for a student: identity, current room/bed, list of `room_history` items, plus `total_assignments`, `total_transfers`, and `has_changed_rooms`.
- **`RoomTransferRequest`**  
  - Student/admin request to transfer: student_id, current_room_id, requested_room_id/bed, transfer_date, reason, preferences (accept_price_difference, flexible_on_bed), priority, supporting_documents.
- **`RoomTransferApproval`**  
  - Admin action to approve/reject a transfer: transfer_request_id, approved flag, room/bed/transfer_date if approved, rejection_reason if not, rent adjustments/charges, notes, validation around required fields depending on approval.
- **`RoomTransferStatus`**  
  - View of a transfer request’s lifecycle: ids, current/requested/approved rooms/beds, dates, status, priority, reason, approval notes, processed_by, financial adjustments, plus `is_pending`, `days_pending`.
- **`SingleTransfer`**  
  - One transfer entry in a bulk operation: `student_id`, `new_room_id`, optional `new_bed_id`, optional reason.
- **`BulkRoomTransfer`**  
  - Admin bulk transfer job: list of `SingleTransfer`, common `transfer_date` and `reason`, options (skip_on_error, send_notifications, prorated_rent), and `confirm_bulk_transfer` gate.
- **`RoomSwapRequest`**  
  - Mutual room swap between two students: student_1_id, student_2_id, swap_date, reason, both consents, handle_rent_difference flag, with validations on date, different students, both consents.

> This module is the **movement/relocation** domain: history + transfer commands + transfer status + swaps.

---

## 7. `__init__.py` – Public package interface

This file should re-export the commonly needed schemas from all the above modules so callers can do:

```python
from app.schemas.student import StudentCreate, StudentDetail, StudentDashboard, RoomTransferRequest, ...
```

Your `__all__` and imports are already aligned with the files above:

- From `student_base`:  
  `StudentBase, StudentCreate, StudentUpdate, StudentCheckInRequest, StudentCheckOutRequest, StudentRoomAssignment, StudentStatusUpdate`
- From `student_response`:  
  `StudentResponse, StudentDetail, StudentProfile, StudentListItem, StudentFinancialInfo, StudentContactInfo, StudentDocumentInfo`
- From `student_profile`:  
  `StudentProfileCreate, StudentProfileUpdate, StudentDocuments, DocumentInfo, DocumentUploadRequest, DocumentVerificationRequest, StudentPreferences, StudentPrivacySettings, StudentBulkImport`
- From `student_room_history`:  
  `RoomHistoryResponse, RoomHistoryItem, RoomTransferRequest, RoomTransferApproval, RoomTransferStatus, BulkRoomTransfer, SingleTransfer, RoomSwapRequest`
- From `student_dashboard`:  
  `StudentDashboard, StudentStats, StudentFinancialSummary, AttendanceSummary, RecentPayment, RecentComplaint, PendingLeave, RecentAnnouncement, TodayMessMenu, UpcomingEvent`
- From `student_filters`:  
  `StudentFilterParams, StudentSearchRequest, StudentSortOptions, StudentExportRequest, StudentBulkActionRequest, AdvancedStudentFilters`

---




============================================================================================================================================================
Here’s how the **subscription** schema package is logically structured, and which classes “belong” in each file, given your current design.

I’ll go file-by-file and list the classes and their roles, so you know exactly what each file should contain.

---

## 1. `commission.py` – Commission config, per-booking commission, aggregate summaries

This file is the **commission domain**: configuration + per-booking records + summary views.

It should contain:

- **`CommissionStatus` (Enum)**  
  Commission lifecycle state for a booking’s commission:
  - `pending`, `calculated`, `invoiced`, `paid`, `waived`, `disputed`.

- **`CommissionConfig` (BaseSchema)**  
  Global/platform-level configuration for commission:
  - `default_commission_percentage`, `min_commission_percentage`, `max_commission_percentage`.
  - `commission_by_plan: Dict[str, Decimal]` for per-plan overrides.
  - Validators to ensure:
    - Per-plan percentages are within [0,100].
    - `min <= default <= max`.
  - Helper: `get_commission_for_plan(plan_type: str)`.

- **`BookingCommissionResponse` (BaseResponseSchema)**  
  A **single commission record tied to a booking**:
  - IDs: `booking_id`, `hostel_id`, `subscription_id`.
  - Monetary: `booking_amount`, `commission_percentage`, `commission_amount`, `currency`.
  - Status: `status: CommissionStatus`, `due_date`, `paid_date`, `payment_reference`.
  - Validator enforcing:
    - `paid_date` required iff status is `PAID`.
    - `paid_date` must be `None` when status != `PAID`.

- **`CommissionSummary` (BaseSchema)**  
  **Aggregated commission summary** for platform or one hostel:
  - Scope: `scope_type` (`platform`/`hostel`), `hostel_id` (required if scope is hostel).
  - Period: `period_start`, `period_end`.
  - Counts: `total_bookings_count`, `bookings_with_commission_count`.
  - Monetary totals: `total_booking_amount`, `total_commission_due`, `total_commission_paid`, `total_commission_pending`, optional `average_commission_rate`.
  - Validators:
    - `period_end >= period_start`.
    - `bookings_with_commission_count <= total_bookings_count`.
    - `hostel_id` required for hostel scope.
  - Computed:
    - `commission_collection_rate` (% of due that is paid).

---

## 2. `subscription_base.py` – Core subscription entity + create/update commands

This file holds the **subscription entity** and the commands to create/update it.

- **`SubscriptionBase` (BaseSchema)**  
  The core subscription record fields:
  - Identity: `hostel_id`, `plan_id`, `subscription_reference`.
  - Billing: `billing_cycle`, `amount`, `currency`.
  - Dates: `start_date`, `end_date`, `next_billing_date`.
  - Behavior: `auto_renew`, `status: SubscriptionStatus`.
  - Validators:
    - `end_date >= start_date`.
    - `next_billing_date` not before `start_date`.
    - If `auto_renew` is False, `next_billing_date` not after `end_date`.
  - Normalization:
    - `subscription_reference` uppercased.

- **`SubscriptionCreate` (BaseCreateSchema)**  
  Command to **create** a subscription:
  - Basically same data as `SubscriptionBase` plus:
    - `trial_end_date` (optional).
  - Validators:
    - `end_date >= start_date`.
    - `trial_end_date` between `start_date` and `end_date`.
    - `next_billing_date >= start_date`.
  - Normalization of `subscription_reference` to uppercase.

- **`SubscriptionUpdate` (BaseUpdateSchema)**  
  Command to **partially update** a subscription:
  - Updatable: `status`, `end_date`, `auto_renew`, `next_billing_date`,
    `amount`, `billing_cycle`.
  - Validator:
    - If status is `CANCELLED` or `EXPIRED`, `auto_renew` cannot be True.

> Conceptually: this file is the **write model** for subscription lifecycles (excluding cancellation/plan changes which are in separate modules).

---

## 3. `subscription_billing.py` – Billing cycle view + invoice creation and response

This file is the **billing & invoice domain**.

- **`InvoiceStatus` (Enum)**  
  Invoice lifecycle states: `draft`, `issued`, `sent`, `paid`, `partially_paid`, `overdue`, `cancelled`, `refunded`.

- **`BillingCycleInfo` (BaseSchema)**  
  Read model describing the **current billing cycle**:
  - IDs: `subscription_id`, `hostel_id`.
  - Plan labels: `plan_name`, `plan_display_name`.
  - Cycle: `cycle_start`, `cycle_end`, `billing_cycle` (`monthly|yearly`).
  - Monetary: `amount`, `currency`.
  - Scheduling: `next_billing_date`, `days_until_billing`, `auto_renew`.
  - Trial flags: `is_in_trial`, `trial_days_remaining`.
  - Validator: `cycle_end >= cycle_start`.

- **`GenerateInvoiceRequest` (BaseCreateSchema)**  
  Command to **generate an invoice**:
  - Inputs: `subscription_id`, `billing_date`.
  - Optional overrides: `amount_override`, `due_date_override`, `notes`.
  - Discount fields: `discount_amount`, `discount_reason`.
  - Validator:
    - If `discount_amount` > 0, `discount_reason` is required.

- **`InvoiceInfo` (BaseSchema)**  
  Read model of a **generated invoice**:
  - IDs: `invoice_id`, `subscription_id`, `hostel_id`.
  - Identification: `invoice_number`, `invoice_date`, `due_date`.
  - Monetary: `subtotal`, `discount_amount`, `tax_amount`, `amount`,
    `amount_paid`, `amount_due`, `currency`.
  - Status: `status: InvoiceStatus`.
  - URLs: `invoice_url`, `payment_url`.
  - Metadata: `notes`.
  - Validator:
    - `due_date >= invoice_date`.
    - `amount == subtotal - discount_amount + tax_amount` (within 0.01).
    - `amount_due == amount - amount_paid` (within 0.01).
  - Computed:
    - `is_overdue` (today > due_date and not paid/cancelled).
    - `is_fully_paid` (`amount_due <= 0`).

---

## 4. `subscription_cancellation.py` – Cancellation request, preview, and confirmation

Everything about **canceling a subscription** lives here.

- **`CancellationRequest` (BaseCreateSchema)**  
  Command to **request cancellation**:
  - IDs: `subscription_id`, `hostel_id`.
  - Reason metadata: `cancellation_reason`, `cancellation_category`.
  - Behavior: `cancel_immediately` (vs end-of-term).
  - Optional feedback: `feedback`, `would_recommend`.
  - Validator:
    - `cancellation_reason` must contain at least 3 words.

- **`CancellationPreview` (BaseSchema)**  
  Read model for **“what will happen if you cancel”**:
  - IDs: `subscription_id`, `hostel_id`.
  - Plan info: `current_plan_name`, `billing_cycle`.
  - Dates: `cancellation_effective_date`, `current_period_end`, `days_remaining`.
  - Financial: `refund_eligible`, `refund_amount`, `currency`.
  - Warnings: `warnings[]`.
  - Access impact: `access_ends_at`.

- **`CancellationResponse` (BaseSchema)**  
  Confirmation after cancellation is processed:
  - IDs: `subscription_id`, `hostel_id`.
  - Flags/dates: `cancelled`, `cancellation_effective_date`, `cancelled_at`, `cancelled_by`.
  - Refund: `refund_issued`, `refund_amount`, `refund_reference`.
  - Message: `message`.
  - Reactivation: `reactivation_eligible`, `reactivation_deadline`.
  - Validator:
    - If `refund_issued` is True, `refund_amount` must be positive.

---

## 5. `subscription_plan_base.py` – Plan definition, base + create/update

This file defines the **subscription plan product** itself.

- **`PlanFeatureConfig` (BaseSchema)**  
  A single structured feature entry (you may or may not be using this yet):
  - `key`, `label`, `value`, `enabled`, `description`.

- **`SubscriptionPlanBase` (BaseSchema)**  
  Core plan definition:
  - Identity: `plan_name` (internal), `display_name`, `plan_type: SubscriptionPlan`.
  - Descriptions: `description`, `short_description`.
  - Pricing: `price_monthly`, `price_yearly`, `currency`.
  - Features: `features: Dict[str, Any]` (flags/config map).
  - Limits: `max_hostels`, `max_rooms_per_hostel`, `max_students`, `max_admins`.
  - Status/display flags: `is_active`, `is_public`, `is_featured`, `sort_order`.
  - Trial: `trial_days`.
  - Validator:
    - `price_yearly <= price_monthly * 12` (no more expensive yearly price).
  - Normalization:
    - `plan_name` lowercased.
  - Computed:
    - `yearly_savings` (12x monthly - yearly).
    - `yearly_discount_percent`.

- **`PlanCreate` (SubscriptionPlanBase, BaseCreateSchema)**  
  Command to **create** a plan:
  - Inherits all base fields.
  - Adds: `created_by`.
  - Validator for `features` structure (must be dict).

- **`PlanUpdate` (BaseUpdateSchema)**  
  Command to **partially update** a plan:
  - Updatable fields: display/descriptions, prices, currency, features, limits,
    flags, `sort_order`, `trial_days`.
  - Validator:
    - If both `price_monthly` and `price_yearly` provided, enforce
      yearly <= 12 * monthly.

---

## 6. `subscription_plan_response.py` – Plan responses, summaries, feature matrices, comparisons

These are **read models / view models** for exposing plan info.

- **`PlanResponse` (BaseResponseSchema)**  
  Full plan details for UI/API:
  - identity, pricing, features, limits, status, and `trial_days`.
  - Computed:
    - `price_monthly_formatted` (e.g., “INR 999.00”).
    - `price_yearly_formatted`.
    - `yearly_savings`, `yearly_discount_percent`.
    - `has_trial`.
    - `limits_display` (string “Unlimited” vs max numbers).

- **`PlanSummary` (BaseSchema)**  
  Condensed card/list view of a plan:
  - `id`, `plan_name`, `display_name`, `plan_type`.
  - Prices & `currency`.
  - `short_description`, `is_featured`, `trial_days`.

- **`PlanFeatures` (BaseSchema)**  
  Human-friendly feature matrix for a single plan:
  - `plan_name`, `display_name`, `plan_type`.
  - `features: Dict[str, str]` (display-ready labels → values).
  - `feature_categories`, `highlight_features`.
  - Classmethod `from_plan_response(plan, feature_labels)`:
    - Converts `PlanResponse.features` (raw) into formatted strings
      (✓/✗, “Unlimited”, or stringified values).

- **`PlanComparison` (BaseSchema)**  
  Multi-plan **comparison matrix**:
  - `plans: List[PlanResponse]` (at least 2).
  - `feature_matrix: Dict[feature_key][plan_name] -> value`.
  - `feature_order`, `category_order`.
  - Recommendations: `recommended_plan`, `recommendation_reason`.
  - Classmethod `create(plans, feature_order=None)`:
    - Builds `feature_matrix` from `PlanResponse.features`.
    - Adds basic limit features like `max_hostels`, `max_rooms_per_hostel`, `max_students`.
    - Picks the first `is_featured` plan as `recommended_plan`, if any.

---

## 7. `subscription_response.py` – Subscription responses and billing history views

These are **read models** around subscriptions & their billing events.

- **`SubscriptionResponse` (BaseResponseSchema)**  
  Full subscription view for a hostel:
  - Hostel info: `hostel_id`, `hostel_name`.
  - Plan info: `plan_id`, `plan_name`, `display_name`, `plan_type`.
  - Subscription details: `subscription_reference`, `billing_cycle`, `amount`, `currency`.
  - Dates & status: `start_date`, `end_date`, `auto_renew`, `next_billing_date`, `status`.
  - Trial info: `trial_end_date`, `is_in_trial`.
  - Payment info: `last_payment_date`, `last_payment_amount`.
  - Cancellation info: `cancelled_at`, `cancellation_effective_date`.
  - Computed:
    - `days_until_expiry`.
    - `days_until_billing`.
    - `is_active`.
    - `is_expiring_soon` (<= 7 days).
    - `amount_formatted` (including `/mo` or `/yr` label).

- **`SubscriptionSummary` (BaseSchema)**  
  Condensed summary for list/dashboard:
  - `id`, `hostel_id`, `hostel_name`.
  - Plan: `plan_name`, `plan_type`.
  - `status`, `billing_cycle`, `amount`, `currency`.
  - `end_date`, `auto_renew`.
  - `is_in_trial`, `days_until_expiry`.

- **`BillingHistoryItem` (BaseSchema)**  
  One **billing transaction**:
  - IDs: optional `id`.
  - `billing_date`.
  - Amount & `currency`.
  - `status`, `payment_reference`, `payment_method`.
  - Associated invoice: `invoice_number`, `invoice_url`.
  - `description`.
  - Period covered: `period_start`, `period_end`.
  - Computed: `is_paid` (status == "paid").

- **`BillingHistory` (BaseSchema)**  
  Aggregate of billing events for a subscription:
  - IDs: `subscription_id`, `hostel_id`, optional `hostel_name`.
  - `items: List[BillingHistoryItem]`.
  - Totals: `total_billed`, `total_paid`, `total_outstanding`, `total_refunded`, `currency`.
  - Pagination: `total_count`, `page`, `page_size`.
  - Validator:
    - `total_outstanding` ≈ `total_billed - total_paid - total_refunded` (clamped at >= 0).
  - Computed:
    - `has_outstanding`.
    - `payment_rate` (% of billed that is paid/refunded).

---

## 8. `subscription_upgrade.py` – Plan change (upgrade/downgrade) requests, preview, confirmation

Everything about **changing plans** (upgrade/downgrade/lateral):

- **`PlanChangeType` (Enum)**  
  - `upgrade`, `downgrade`, `lateral`.

- **`PlanChangeRequest` (BaseCreateSchema)**  
  Command to **request a plan change**:
  - IDs: `hostel_id`, `current_plan_id`, `new_plan_id`.
  - `billing_cycle` for new plan.
  - Timing: `effective_from`, `prorate`.
  - Options: `apply_credit`, `preserve_trial`.
  - Optional `change_reason`.
  - Validator:
    - `new_plan_id != current_plan_id`.
    - `effective_from` not in the past.

- **`PlanChangePreview` (BaseSchema)**  
  Read model to **show financial effects before confirmation**:
  - Plan info: current vs new (ids, names, display names).
  - `change_type: PlanChangeType`.
  - Pricing: `current_amount`, `new_amount`, `currency`.
  - Current period: `current_period_start`, `current_period_end`, `days_remaining`.
  - Proration: `prorated_credit`, `prorated_charge`.
  - Final amounts: `amount_due_now` (may be negative = net credit), `next_billing_amount`.
  - Dates: `effective_from`, `next_billing_date`.
  - Extra: `message`, `warnings[]`, `benefits[]`.
  - Computed:
    - `is_upgrade`, `is_downgrade`.
    - `monthly_difference`.
    - `savings_or_increase` (formatted string like `+INR 500.00/period`).

- **`PlanChangeConfirmation` (BaseSchema)**  
  Response after a change is actually applied:
  - IDs: `subscription_id`, `hostel_id`.
  - Plan change details: `previous_plan_id`, `previous_plan_name`,
    `new_plan_id`, `new_plan_name`, `change_type`.
  - Financial: `amount_charged`, `credit_applied`, `currency`.
  - Dates: `effective_from`, `next_billing_date`, `new_billing_amount`.
  - Confirmation: `processed_at`, `confirmation_number`, `message`.

---

## 9. `__init__.py` – Package-level re-exports

This file is the **public interface** for `app.schemas.subscription`. It re-exports:

- Enums: `CommissionStatus`, `InvoiceStatus`, `PlanChangeType`.
- Commission: `CommissionConfig`, `BookingCommissionResponse`, `CommissionSummary`.
- Subscriptions: `SubscriptionBase`, `SubscriptionCreate`, `SubscriptionUpdate`.
- Billing: `BillingCycleInfo`, `GenerateInvoiceRequest`, `InvoiceInfo`.
- Cancellation: `CancellationRequest`, `CancellationResponse`, `CancellationPreview`.
- Plan base: `SubscriptionPlanBase`, `PlanCreate`, `PlanUpdate`.
- Plan responses: `PlanResponse`, `PlanFeatures`, `PlanComparison`.  
  (Note: `PlanSummary` exists but is not exported; add it here if you need it from the package root.)
- Subscription responses: `SubscriptionResponse`, `SubscriptionSummary`, `BillingHistoryItem`, `BillingHistory`.
- Upgrade/downgrade: `PlanChangeRequest`, `PlanChangePreview`, `PlanChangeConfirmation`.


============================================================================================================================================================
Here’s how the supervisor schema package is structured and which classes logically belong in each file, based on what you’ve shown.

I’ll go file‑by‑file and list the classes with a short responsibility note, so you can see clearly what “should” live where.

---

## 1. `supervisor_base.py`

**Purpose:** Core supervisor entity + lifecycle operations (create/update/status/reassign/terminate). These are low‑level, not UI‑specific.

**Classes that belong here:**

- `SupervisorValidationConstants`
  - Centralized constants for validation across supervisor operations.

- `DecimalWithPrecision`
  - Type alias for `Decimal` with 2 decimal places; used in salary, adjustments, etc.

- `SupervisorBase`
  - Base schema shared by other supervisor operations.
  - Core employment fields: `user_id`, `assigned_hostel_id`, `join_date`, `employment_type`, `salary`, etc.

- `SupervisorCreate`
  - For **creating** a supervisor record / assignment.
  - Extends `SupervisorBase` + `BaseCreateSchema`.
  - Adds `assigned_by`, optional `permissions`, `assignment_notes`.

- `SupervisorUpdate`
  - For **updating** supervisor data in place (partial updates).
  - Employment details, status, permissions, notes.
  - Contains consistency check between `status` and `is_active`.

- `SupervisorStatusUpdate`
  - For **changing status** (ACTIVE, SUSPENDED, ON_LEAVE, TERMINATED).
  - Handles termination, suspension, leave periods, handover, etc.
  - Has strong validators for date ranges and required fields per status.

- `SupervisorReassignment`
  - For **moving** a supervisor from one hostel to another.
  - Controls effective date, permissions retention, salary adjustment, handover.

- `SupervisorTermination`
  - For **full termination process** (exit interview, clearance, assets, settlement).
  - Heavy business-logic model for termination workflows.

---

## 2. `supervisor_assignment.py`

**Purpose:** Supervisor ↔ Hostel assignment lifecycle (assign, update, revoke, transfer, summary).

**Classes that belong here:**

- `SupervisorAssignment`
  - Response model representing a supervisor’s assignment to a hostel.
  - Includes `is_active`, permission level summary, last active, total days assigned.

- `AssignmentRequest`
  - Request to assign a user as a supervisor to a hostel.
  - Employment basics: `join_date`, `employment_type`, `shift_timing`, `permissions`, `permission_template`.

- `AssignmentUpdate`
  - For updating an existing assignment’s employment/permissions/`is_active`.

- `RevokeAssignmentRequest`
  - For revoking a supervisor’s assignment.
  - Handles `revoke_date`, reason, and handover info.

- `AssignmentTransfer`
  - For transferring a supervisor from one hostel to another (assignment‑level, not whole employment record).
  - Handles `transfer_date`, permissions, templates.

- `AssignmentSummary`
  - Aggregated view per hostel:
  - Counts of supervisors, on leave, active, plus average rating, shift coverage.

---

## 3. `supervisor_activity.py`

**Purpose:** Activity/audit logging and analytics around supervisor actions.

**Classes that belong here:**

- `SupervisorActivityLog`
  - Single log entry for a supervisor’s action.
  - Includes action metadata, entity info, technical details, response time, success/failure.
  - Has computed `action_display_name`.

- `ActivityDetail`
  - Rich view of a specific activity with before/after (`old_values`/`new_values`).
  - Includes `impact_level`, `affected_users_count`, computed `has_changes` and `change_summary`.

- `TopActivity`
  - Summary of a frequently used action:
  - `count`, `last_performed`, `success_rate`, `average_response_time_ms`.
  - Computed `frequency_description`.

- `ActivityTimelinePoint`
  - Aggregated activity volume over a time bucket.
  - Counts, categories, success rate, average response time.
  - Computed `activity_level` (High/Medium/Low/Minimal).

- `ActivityMetrics`
  - Aggregated metrics for a supervisor across a period.
  - Total actions, unique types, success rate, peak hour/day, actions per day.
  - Computed `activity_score` and `productivity_level`.

- `ActivitySummary`
  - Dashboard‑oriented summary:
  - Totals, breakdowns by category/type, top activities, timeline, peak hours, success rate.
  - Computed `most_common_activity` and `activity_consistency`.

- `ActivityFilterParams`
  - Rich filtering model for querying activity logs.
  - Supervisor filters, hostel, date range, action types, entity, success/failed, response times, device, pagination/sorting.

- `ActivityExportRequest`
  - Request for exporting logs, with filters plus format + which fields/groups/summaries to include.

---

## 4. `supervisor_dashboard.py`

**Purpose:** Models that back the supervisor dashboard UI (metrics, tasks, recents, schedule, alerts, performance).

**Classes that belong here:**

- `DashboardMetrics`
  - High‑level hostel metrics (students, occupancy, complaints, maintenance, attendance, payments, communication).
  - Computed `overall_health_score` and `needs_attention` list.

- `TaskSummary`
  - Pending work & urgency (urgent complaints, critical maintenance, leave approvals, overdue tasks, etc.).
  - Computed `priority_score` and `workload_level`.

- `RecentComplaintItem`
  - Single recent complaint item with SLA info.
  - Computed `is_overdue` and `urgency_indicator`.

- `RecentMaintenanceItem`
  - Recent maintenance request, with cost and schedule.
  - Computed `is_overdue` and `days_pending`.

- `PendingLeaveItem`
  - Pending leave request card.
  - Computed `is_urgent` and `pending_days`.

- `ScheduledMaintenanceItem`
  - Maintenance scheduled **for today**.

- `ScheduledMeeting`
  - Meeting scheduled **for today**.

- `TodaySchedule`
  - Combined schedule for the day: inspection rounds, scheduled maintenance, meetings, events, deadlines.
  - Computed `total_scheduled_items` and `schedule_density`.

- `DashboardAlert`
  - Alert/notification for the dashboard with action support.
  - Computed `is_expired` and `age_minutes`.

- `QuickAction`
  - Individual quick action button (icon, url, badge, permissions, category).

- `QuickActions`
  - Collection of quick actions.
  - Computed `actions_by_category`.

- `PerformanceIndicators`
  - KPIs at the supervisor level (complaint resolution, response time, task completion, SLA compliance, activity, consistency).
  - Computed `overall_performance_score` and `performance_grade`.

- `SupervisorDashboard`
  - Top‑level dashboard payload.
  - Includes: `metrics`, `tasks`, recents, pending leaves, today’s schedule, alerts, quick actions, performance, and some activity metadata.
  - Computed `critical_alerts_count`, `workload_summary`, `dashboard_health_status`.

---

## 5. `supervisor_performance.py`

**Purpose:** Deeper performance analytics: detailed metrics, trends, peer comparison, goals, reviews, AI insights.

**Classes that belong here:**

- `PerformanceMetrics`
  - Aggregated performance stats for a period:
  - Complaints, attendance, maintenance, responsiveness, satisfaction, escalation, overall performance score & grade.
  - Computed `efficiency_score` and `quality_score`.

- `ComplaintPerformance`
  - Detailed complaint metrics: counts, category/priority breakdown, resolution times, SLA, satisfaction.
  - Computed `resolution_efficiency`.

- `AttendancePerformance`
  - Attendance‑specific metrics: days marked, missed, timeliness, accuracy, leave processing.
  - Computed `attendance_consistency` and `leave_approval_rate`.

- `MaintenancePerformance`
  - Maintenance‑specific metrics: created/completed/pending/overdue, category breakdown, times, cost, budget, preventive tasks.
  - Computed `completion_rate`, `budget_utilization`.

- `PerformanceTrendPoint`
  - A single point in a trend (e.g., month/quarter) with component scores.
  - Computed `trend_indicator`.

- `MetricComparison`
  - Comparison of a single metric vs peers (supervisor vs average/median/best).
  - Computed `performance_vs_peers`.

- `PeerComparison`
  - Supervisor’s rank among peers; contains a set of `MetricComparison`s.
  - Computed `performance_tier`.

- `PeriodComparison`
  - Current vs previous period comparison, with `metric_changes` and buckets of improved/declined/stable metrics.
  - Computed `overall_trend` and `improvement_summary`.

- `PerformanceGoal`
  - Definition of a performance goal (metric, target, time range, priority, category, frequency).
  - Validator for `end_date > start_date`.
  - Computed `duration_days`.

- `PerformanceGoalProgress`
  - Progress-tracking snapshot for a goal: values, percentages, days remaining, status, history.
  - Computed `days_elapsed`, `time_progress_percentage`, `is_on_schedule`, `projected_completion_date`.

- `PerformanceReport`
  - Full performance report for a supervisor over a `DateRangeFilter`.
  - Combines summary metrics, complaint/attendance/maintenance performance, trends, peer comparison, period comparison, insights, and current goals.
  - Computed `report_summary`.

- `PerformanceReview`
  - Admin’s formal review (1–5 ratings, narrative strengths/improvements/goals, action items, training recommendations).
  - Validator to clean empty list items.
  - Computed `average_rating`.

- `PerformanceReviewResponse`
  - Read‑only representation of a completed review, including acknowledgment by supervisor.
  - Computed `performance_level`.

- `PerformanceInsights`
  - “AI‑generated” style insights: strengths, improvements, trends, risks, recommendations, peer comparison insights, plus confidence.
  - Computed `overall_assessment`.

---

## 6. `supervisor_permissions.py`

**Purpose:** Permissions configuration, updates, templates, and audit logging.

**Classes that belong here:**

- `PermissionConstants`
  - Constants: permission groups, thresholds, templates names, min/max constraints.

- `SupervisorPermissions`
  - Main permissions configuration object (dozens of booleans and thresholds).
  - Model validators enforce dependency hierarchies and make thresholds consistent.
  - `get_permission_summary()` returns counts by category.

- `PermissionUpdate`
  - For updating permissions of **one** supervisor.
  - `permissions` dictionary + optional reason.
  - Validates keys against `SupervisorPermissions` fields and coerces values.

- `PermissionCheckRequest`
  - Request to verify if a supervisor has a particular permission, with optional context (amount, days, priority, etc.)
  - Validator ensures `permission_key` is valid.

- `PermissionCheckResponse`
  - Result of a permission check: has/hasn’t, threshold info, message.
  - `get_detailed_message()` builds a user‑friendly explanation.

- `BulkPermissionUpdate`
  - Batch update for multiple supervisors.
  - Ensures unique IDs and validates `permissions` using `PermissionUpdate` logic.

- `PermissionTemplate`
  - Represents a named template (system or custom) along with a `SupervisorPermissions` instance.
  - `get_system_templates()` returns built‑in templates for junior/senior/head/limited.

- `ApplyPermissionTemplate`
  - Request to apply a template to one or many supervisors.
  - Supports `override_existing` vs `merge_permissions` modes and validates the combination.

- `PermissionAuditLog`
  - Audit record for any permission change.
  - Stores who changed what, when, why, with context and approval fields.
  - Computed `changes_count` and `change_summary`.

---

## 7. `supervisor_profile.py`

**Purpose:** Profile‑level views of a supervisor: employment details, performance summary, history, preferences, and profile update.

**Classes that belong here:**

- `SupervisorEmployment`
  - Employment detail block: join date, type, designation, status, contract dates, termination info, assignment metadata, salary info.
  - Computed `tenure_days`, `tenure_display`, `is_contract_employee`, `contract_status`.

- `PerformanceSummary`
  - Lightweight performance metrics suitable for a profile card (not full analytics like `PerformanceMetrics`).
  - Complaint, attendance, maintenance metrics; month activity; ratings/feedback.
  - Computed `overall_efficiency_score` and `performance_level`.

- `EmploymentHistory`
  - One record in employment/assignment history (hostel, dates, designation, type, reason, rating).
  - Computed `duration_days` and `is_current`.

- `SupervisorPreferences`
  - User‑tunable preference settings:
  - Notification types, dashboard view, language, timezone, work hours.

- `SupervisorProfile`
  - Complete profile view:
  - Personal info, current hostel, `employment`, `employment_history`, `permissions`, `performance_summary`, `preferences`, activity tracking.
  - Computed `total_experience_days`, `experience_display`, `hostels_worked`.

- `SupervisorProfileUpdate`
  - What a supervisor can self‑update:
  - `phone`, `preferences`, emergency contacts, personal notes.
  - Normalizes phone numbers.

---

## 8. `supervisor_response.py`

**Purpose:** Generic, reusable response shapes for supervisors in various contexts (list views, detail views, stats, etc.).

**Classes that belong here:**

- `SupervisorResponse`
  - Standard/basic response model for a supervisor (common in many APIs).
  - Core identity + employment + assignment + status.
  - Computed `tenure_days`, `tenure_months`, `is_probation`.

- `SupervisorDetail`
  - Full detail view combining identity, employment, status, permissions, performance aggregates and activity.
  - Computed `age`, `tenure_months`, `tenure_years`, `is_probation`, `can_work`, `suspension_days_remaining`.

- `SupervisorListItem`
  - Minimal model for listing (tables / grids).
  - Identity, hostel, employment type, status, performance rating, last_login.
  - Computed `tenure_months` and `display_status`.

- `SupervisorSummary`
  - Dashboard‑style summary of a single supervisor.
  - Current month metrics + activity + online status.
  - Computed `complaint_resolution_rate` and `activity_status`.

- `SupervisorEmploymentInfo`
  - Employment/contract‑focused view with assignment and termination info.
  - Computed `tenure_days`, `tenure_display`, `is_contract_expiring_soon`, `contract_status`.

- `SupervisorStatistics`
  - Aggregated statistics for a given calculation period (e.g., last 30 days).
  - Complaint, attendance, maintenance, communication, activity, and overall performance.
  - Computed `complaint_resolution_rate`, `maintenance_completion_rate`, `attendance_punctuality_rate`, `activity_rate`, `performance_grade`.

---

## 9. `__init__.py` in `app/schemas/supervisor`

**Purpose:** Defines the *public* API of the `app.schemas.supervisor` package.

Right now it re‑exports a **subset** of the models from each module (the most commonly used ones):

- From `supervisor_base`: `SupervisorBase`, `SupervisorCreate`, `SupervisorUpdate`
- From `supervisor_response`: `SupervisorResponse`, `SupervisorDetail`, `SupervisorListItem`
- From `supervisor_profile`: `SupervisorProfile`, `SupervisorEmployment`, `SupervisorProfileUpdate`
- From `supervisor_permissions`: `SupervisorPermissions`, `PermissionUpdate`, `PermissionCheckRequest`, `PermissionCheckResponse`
- From `supervisor_assignment`: `SupervisorAssignment`, `AssignmentRequest`, `AssignmentUpdate`, `RevokeAssignmentRequest`
- From `supervisor_activity`: `SupervisorActivityLog`, `ActivitySummary`, `ActivityDetail`, `ActivityFilterParams`
- From `supervisor_dashboard`: `SupervisorDashboard`, `DashboardMetrics`, `TaskSummary`, `RecentComplaintItem`, `RecentMaintenanceItem`, `PendingLeaveItem`, `TodaySchedule`, `ScheduledMaintenanceItem`, `ScheduledMeeting`, `DashboardAlert`, `QuickActions`, `PerformanceIndicators`
- From `supervisor_performance`: `PerformanceMetrics`, `PerformanceReport`, `PerformanceReview`, `ComplaintPerformance`, `AttendancePerformance`, `MaintenancePerformance`

All other classes are still valid; they’re just accessed via their module path instead of `app.schemas.supervisor` top level.




============================================================================================================================================================
Here’s how the **user** schema package is organized, and exactly which classes belong in each file.

---

## `user_base.py` – Core user model + basic update fragments

This file should contain the **foundational user entity** and simple update fragments:

- **`UserBase` (BaseSchema)**  
  Core user attributes used across operations:
  - Identity & auth context: `email`, `phone`, `full_name`, `user_role`.
  - Optional personal info: `gender`, `date_of_birth`, `profile_image_url`.
  - Validators for:
    - Normalizing email/phone/name.
    - Age constraints (16–100).
    - Basic URL format for profile image.

- **`UserCreate` (UserBase, BaseCreateSchema)**  
  For **creating new user accounts**:
  - Inherits all from `UserBase`.
  - Adds `password` with strength validation (length, digit, upper, lower).

- **`UserUpdate` (BaseUpdateSchema)**  
  For **partial updates** to user core fields:
  - Optional versions of: `email`, `phone`, `full_name`, `gender`, `date_of_birth`, `profile_image_url`, `is_active`.
  - Same style validators as `UserBase` but all nullable.

- **`UserAddressUpdate` (AddressMixin, BaseUpdateSchema)**  
  For **updating address info only**:
  - Optional `address_line1`, `address_line2`, `city`, `state`, `pincode`, `country`.
  - All override `AddressMixin` fields to be optional for patch semantics.

- **`UserEmergencyContactUpdate` (EmergencyContactMixin, BaseUpdateSchema)**  
  For **updating emergency contact**:
  - Optional `emergency_contact_name`, `emergency_contact_phone`, `emergency_contact_relation`.
  - Normalization/validation for `emergency_contact_phone`.

> This file is the “core user write model”: create, generic update, address-only update, emergency-contact-only update.

---

## `user_profile.py` – Profile, contact & notification preference updates

This file contains more **granular profile-related updates** exposed to end users:

- **`ProfileUpdate` (BaseUpdateSchema)**  
  For comprehensive **profile (and address) edits**:
  - `full_name`, `gender`, `date_of_birth`.
  - Address fields: `address_line1/2`, `city`, `state`, `pincode`, `country`.
  - Validators for name, age, and text normalization.

- **`ProfileImageUpdate` (BaseUpdateSchema)**  
  For **updating just the profile image**:
  - Required `profile_image_url: HttpUrl`.

- **`ContactInfoUpdate` (BaseUpdateSchema)**  
  For **contact + emergency contact updates**:
  - Optional `phone`, `email`.
  - Optional emergency contact: `emergency_contact_name`, `emergency_contact_phone`, `emergency_contact_relation`.
  - Validators for normalizing phone numbers, emails, and text fields.

- **`NotificationPreferencesUpdate` (BaseUpdateSchema)**  
  For **notification channels and types**:
  - Channel toggles: `email_notifications`, `sms_notifications`, `push_notifications`.
  - Type toggles: booking, payment, complaint, announcement, maintenance, marketing.
  - Advanced settings: `digest_frequency`, `quiet_hours_start`, `quiet_hours_end`, with pattern validation and normalization.

> This file is “user self-service settings”: profile details, contact info, and notification preferences.

---

## `user_response.py` – User read models for various views

This file contains **response schemas** returned by the API:

- **`UserResponse` (BaseResponseSchema)**  
  Standard/compact user response:
  - `email`, `phone`, `full_name`, `user_role`.
  - `is_active`, `is_email_verified`, `is_phone_verified`.
  - `profile_image_url`, `last_login_at`.

- **`UserDetail` (BaseResponseSchema)**  
  **Full user profile** with all available info:
  - Basic + `gender`, `date_of_birth`, `profile_image_url`.
  - Address: `address_line1/2`, `city`, `state`, `country`, `pincode`.
  - Emergency contact block.
  - Account status & verification timestamps: `is_active`, `is_email_verified`, `is_phone_verified`, `email_verified_at`, `phone_verified_at`, `last_login_at`, `last_password_change_at`.

- **`UserListItem` (BaseSchema)**  
  For **admin/user list views**:
  - `id`, `email`, `full_name`, `user_role`, `is_active`, `profile_image_url`.
  - `created_at`, `last_login_at`.

- **`UserProfile` (BaseSchema)**  
  **Public-facing profile**:
  - `id`, `full_name`, `profile_image_url`, `user_role`, `member_since`.

- **`UserStats` (BaseSchema)**  
  Aggregate stats about a user’s activity:
  - Counts: `total_bookings`, `active_bookings`, `completed_bookings`, `total_payments`, `total_complaints`, `resolved_complaints`.
  - Monetary: `total_amount_paid` (float).
  - Ratings: `average_rating_given`.
  - Account metrics: `account_age_days`, `last_activity_at`.

> This file is purely read models: different slices of user data for different UI use-cases.

---

## `user_session.py` – Session tracking & management

This file holds everything for **user sessions**:

- **`UserSession` (BaseResponseSchema)**  
  DB/session-store representation:
  - `user_id`, `device_info`, `ip_address`, `is_revoked`, `expires_at`, `last_activity`.

- **`SessionInfo` (BaseSchema)**  
  Frontend-friendly session info:
  - `session_id`, `device_name`, `device_type`, `browser`, `os`, `ip_address`, `location`.
  - Flags/time: `is_current`, `created_at`, `last_activity`, `expires_at`.

- **`ActiveSessionsList` (BaseSchema)**  
  Aggregate of active sessions:
  - `sessions: List[SessionInfo]`, `total_sessions`, `current_session_id`.

- **`RevokeSessionRequest` (BaseCreateSchema)**  
  Command to **revoke a single session**:
  - `session_id`.

- **`RevokeAllSessionsRequest` (BaseCreateSchema)**  
  Command to **revoke all sessions**:
  - `keep_current`, optional `reason`.

- **`CreateSessionRequest` (BaseCreateSchema)**  
  Command to **create a new session** (on login):
  - `user_id`, optional `device_info`, `ip_address`, `user_agent`, `remember_me`.
  - Validator for basic IP format.

> This file is the “session domain”: what a session looks like and how you create/revoke them.

---

## `__init__.py` – Re-export surface

This file should re-export the commonly used classes so consumers can do:

```python
from app.schemas.user import UserCreate, UserResponse, ProfileUpdate, UserSession, ...
```

It currently (correctly) re-exports:

- From `user_base`:  
  `UserBase`, `UserCreate`, `UserUpdate`, `UserAddressUpdate`, `UserEmergencyContactUpdate`
- From `user_profile`:  
  `ProfileUpdate`, `ProfileImageUpdate`, `ContactInfoUpdate`, `NotificationPreferencesUpdate`
- From `user_response`:  
  `UserResponse`, `UserDetail`, `UserListItem`, `UserProfile`, `UserStats`
- From `user_session`:  
  `UserSession`, `SessionInfo`, `ActiveSessionsList`, `RevokeSessionRequest`, `RevokeAllSessionsRequest`, `CreateSessionRequest`

==================================================================================================================================================

Here’s how the **visitor** schema package is structured, and exactly which classes “belong” in each file based on your current design.

---

## 1. `visitor_base.py` – Core visitor model + create/update commands

This file is the **base/write model** for a visitor profile and its direct updates.

It should contain:

- **`VisitorBase` (BaseSchema)**  
  Core visitor profile fields tied to a user:
  - Identity: `user_id`.
  - Preferences:  
    - `preferred_room_type`  
    - `budget_min`, `budget_max`  
    - `preferred_cities`, `preferred_amenities`  
    - `favorite_hostel_ids`
  - Notification channels: `email_notifications`, `sms_notifications`, `push_notifications`.
  - Validators:
    - Positive budget, `budget_max >= budget_min`.
    - Deduplicated/normalized cities, amenities, favorites with max lengths.
  - Convenience properties:
    - `has_budget_preference`, `has_location_preference`, `notification_enabled_count`.

- **`VisitorCreate` (VisitorBase, BaseCreateSchema)**  
  Command to **create a visitor profile**:
  - Inherits all fields from `VisitorBase`.
  - Same required `user_id`.
  - Explicitly sets `preferred_cities`, `preferred_amenities`, `favorite_hostel_ids` to empty defaults for new profiles.

- **`VisitorUpdate` (BaseUpdateSchema)**  
  Command to **partially update visitor profile**:
  - Optional versions of:
    - `preferred_room_type`, `budget_min`, `budget_max`,
    - `preferred_cities`, `preferred_amenities`,
    - `email_notifications`, `sms_notifications`, `push_notifications`.
  - Validators for:
    - Positive budget, `budget_max >= budget_min` if both present.
    - Deduplicated/normalized cities & amenities with caps.

> This file owns “visitor as an entity” and simple CRUD-style updates on that entity.

---

## 2. `visitor_dashboard.py` – Visitor dashboard and related view models

This file contains **read-only view models** used to build the visitor’s dashboard.

It should contain:

- **`SavedHostelItem` (BaseSchema)**  
  A single saved/favorite hostel card:
  - Identity: `hostel_id`, `hostel_name`, `hostel_city`.
  - Pricing & rating: `starting_price`, `average_rating`, `available_beds`, `cover_image_url`.
  - Favorite metadata: `saved_at`, `notes`.
  - Price tracking: `price_when_saved`, `current_price`, `price_changed`, `price_change_percentage`.
  - Computed:
    - `has_availability`, `price_drop_amount`, `is_good_deal`.

- **`SavedHostels` (BaseSchema)**  
  Aggregate of saved hostels:
  - `total_saved`, `hostels: List[SavedHostelItem]`.
  - Computed:
    - `hostels_with_price_drops`, `hostels_with_availability`.

- **`BookingHistoryItem` (BaseSchema)**  
  A single booking item in history:
  - `booking_id`, `booking_reference`, `hostel_id`, `hostel_name`, `room_type`.
  - Dates: `booking_date`, `check_in_date`, `duration_months`.
  - Status & amount: `status`, `total_amount`.
  - Action flags: `can_cancel`, `can_modify`, `can_review`.
  - Computed:
    - `check_out_date`, `days_until_checkin`, `is_upcoming`.

- **`BookingHistory` (BaseSchema)**  
  Summary and list of bookings:
  - Counts: `total_bookings`, `active_bookings`, `completed_bookings`, `cancelled_bookings`.
  - `bookings: List[BookingHistoryItem]`.
  - Computed:
    - `cancellation_rate`, `completion_rate`.

- **`RecentSearch` (BaseSchema)**  
  One recent search:
  - `search_id`, `search_query`, `filters_applied` (dict), `results_count`, `searched_at`.
  - Computed:
    - `filters_count`.

- **`RecentlyViewedHostel` (BaseSchema)**  
  A recently viewed hostel:
  - `hostel_id`, `hostel_name`, `hostel_city`.
  - `starting_price`, `average_rating`, `cover_image_url`.
  - `viewed_at`, `view_count`.
  - Computed:
    - `is_highly_viewed`.

- **`RecommendedHostel` (BaseSchema)**  
  A recommended hostel:
  - Hostel details & pricing: id, name, city, `starting_price`, `average_rating`, `available_beds`, `cover_image_url`.
  - Match: `match_score`, `match_reasons`.
  - Validators: `match_reasons` non-empty.
  - Computed:
    - `is_excellent_match` (score ≥ 80).

- **`PriceDropAlert` (BaseSchema)**  
  A price drop alert:
  - `alert_id`, `hostel_id`, `hostel_name`.
  - `previous_price`, `new_price`, `discount_percentage`.
  - `alert_created`, `is_read`.
  - Computed:
    - `savings_amount`.

- **`AvailabilityAlert` (BaseSchema)**  
  An availability alert:
  - `alert_id`, `hostel_id`, `hostel_name`, `room_type`, `message`, `alert_created`, `is_read`.

- **`VisitorDashboard` (BaseSchema)**  
  Top-level dashboard model:
  - Visitor identity: `visitor_id`, `visitor_name`.
  - Sections:
    - `saved_hostels: SavedHostels`
    - `booking_history: BookingHistory`
    - `recent_searches: List[RecentSearch]`
    - `recently_viewed: List[RecentlyViewedHostel]`
    - `recommended_hostels: List[RecommendedHostel]`
    - `price_drop_alerts: List[PriceDropAlert]`
    - `availability_alerts: List[AvailabilityAlert]`
  - Totals: `total_searches`, `total_hostel_views`, `total_bookings`.
  - Computed:
    - `unread_alerts_count`
    - `has_activity`.

> This file is purely **dashboard/read models** used by the visitor-facing UI.

---

## 3. `visitor_favorites.py` – Favorites management (add/remove/list/compare)

This file is the **favorites/wishlist domain**.

It should contain:

- **`FavoriteRequest` (BaseCreateSchema)**  
  Command to **add/remove a hostel from favorites**:
  - `hostel_id`, `is_favorite`, optional `notes`.
  - Validator to clean/limit notes.

- **`FavoriteHostelItem` (BaseSchema)**  
  Detailed favorite entry (richer than the basic dashboard card):
  - IDs: `favorite_id`, `hostel_id`.
  - Hostel identity: `hostel_name`, `hostel_slug`, `hostel_city`, `hostel_type`.
  - Pricing: `starting_price_monthly`, `price_when_saved`, `current_price`,
    `has_price_drop`, optional `price_drop_percentage`.
  - Availability: `available_beds`, `has_availability`.
  - Rating: `average_rating`, `total_reviews`.
  - Media: `cover_image_url`.
  - Favorite metadata: `notes`, `added_to_favorites`.
  - View tracking: `times_viewed`, `last_viewed`.
  - Computed:
    - `price_savings`, `days_in_favorites`, `is_highly_rated`, `is_popular`, `is_frequently_viewed`.

- **`FavoritesList` (BaseSchema)**  
  Visitor’s favorites list with summary:
  - `visitor_id`, `total_favorites`, `favorites: List[FavoriteHostelItem]`.
  - Computed:
    - `favorites_with_availability`
    - `favorites_with_price_drops`
    - `total_potential_savings`.

- **`FavoriteUpdate` (BaseCreateSchema)**  
  Command to **update notes for a favorite**:
  - `favorite_id`, `notes`.

- **`FavoritesExport` (BaseSchema)**  
  Config for exporting favorites:
  - `format` (`pdf|csv|json`).
  - Flags: `include_prices`, `include_notes`.
  - Validator normalizes/validates `format`.

- **`FavoriteComparison` (BaseSchema)**  
  Request to **compare 2–4 favorites**:
  - `favorite_ids: List[UUID]` (2–4 entries).
  - Validator:
    - At least 2 IDs, at most 4.
    - Removes duplicates but ensures at least 2 unique.

> This file owns the entire **favorites management workflow**: add/remove, listing, exporting, comparing.

---

## 4. `visitor_preferences.py` – Full preferences, preference updates, saved searches

This file is about a visitor’s **search & hostel preferences**, plus saved searches.

It should contain:

- **`VisitorPreferences` (BaseSchema)**  
  Complete preference set:
  - Room/hostel type: `preferred_room_type`, `preferred_hostel_type`.
  - Budget: `budget_min`, `budget_max`.
  - Location: `preferred_cities`, `preferred_areas`, `max_distance_from_work_km`.
  - Amenities: `required_amenities`, `preferred_amenities`.
  - Facility requirements: `need_parking`, `need_gym`, `need_laundry`, `need_mess`.
  - Diet: `dietary_preference`.
  - Move-in: `earliest_move_in_date`, `preferred_lease_duration_months`.
  - Notification channels: `email_notifications`, `sms_notifications`, `push_notifications`.
  - Specific alerts: `notify_on_price_drop`, `notify_on_availability`, `notify_on_new_listings`.
  - Validators:
    - Positive budget, `budget_max >= budget_min`.
    - Move-in date not in the past.
    - Dedup/normalize locations and amenities.
    - Ensure at least one channel enabled if any specific alert is on.

- **`PreferenceUpdate` (BaseUpdateSchema)**  
  Partial update for preferences:
  - Optional versions of key `VisitorPreferences` fields:
    - `preferred_room_type`, `preferred_hostel_type`.
    - `budget_min`, `budget_max`.
    - `preferred_cities`, `preferred_areas`.
    - `required_amenities`, `preferred_amenities`.
    - `dietary_preference`.
    - Notification flags (`email_notifications`, `sms_notifications`, `push_notifications`, `notify_on_*`).
  - Validators:
    - Positive budget, `budget_max >= budget_min` if both given.

- **`SearchPreferences` (BaseSchema)**  
  Reusable structure for **saving a recurring search** (criteria + alerts):
  - Name: `search_name`.
  - Criteria: `cities`, `room_types`, `min_price`, `max_price`, `amenities`.
  - Alerts: `notify_on_new_matches`, `notification_frequency` (`instant|daily|weekly`).
  - Validators:
    - `search_name` trimmed and length-checked.
    - `max_price >= min_price` if both.
    - At least one criterion present (cities, room types, price, amenities).

- **`SavedSearch` (BaseSchema)**  
  Persisted saved search with tracking:
  - IDs: `id`, `visitor_id`.
  - `search_name`.
  - `criteria` (raw JSON dict).
  - Alert config: `notify_on_new_matches`, `notification_frequency`.
  - Stats: `total_matches`, `new_matches_since_last_check`.
  - Timestamps: `created_at`, `last_checked`.
  - Validator:
    - `criteria` cannot be empty.

> This file is the **preference & saved search domain**: what the visitor wants and how recurring searches are tracked.

---

## 5. `visitor_response.py` – Generic visitor API responses & stats

These are **response DTOs** for visitor-concerned endpoints.

It should contain:

- **`VisitorResponse` (BaseResponseSchema)**  
  Standard/basic visitor response:
  - `user_id`, `full_name`, `email`, `phone`.
  - Preferences: `preferred_room_type`, `budget_min`, `budget_max`, `preferred_cities`.
  - Stats: `total_bookings`, `saved_hostels_count`.
  - Notification flags: `email_notifications`, `sms_notifications`, `push_notifications`.
  - Computed:
    - `has_active_notifications`
    - `budget_range_display` (formatted string).

- **`VisitorProfile` (BaseSchema)**  
  Public/minimal profile:
  - `id`, `user_id`, `full_name`, `profile_image_url`, `member_since`.
  - Computed:
    - `display_name` (first name / "Guest").
    - `membership_days`.

- **`VisitorDetail` (BaseResponseSchema)**  
  Full, detailed visitor profile:
  - User info: `user_id`, `full_name`, `email`, `phone`, `profile_image_url`.
  - Preferences: room type, budget, cities, amenities.
  - Saved hostels: `favorite_hostel_ids`, `total_saved_hostels`.
  - Activity: `total_bookings`, `completed_bookings`, `cancelled_bookings`, `total_inquiries`.
  - Reviews: `total_reviews_written`, `average_rating_given`.
  - Notification flags.
  - Account info: `created_at`, `last_login`.
  - Computed:
    - `active_bookings`.
    - `booking_completion_rate`.
    - `is_active_user` (login within last 30 days).
    - `engagement_score` (0–100, weighted formula).

- **`VisitorStats` (BaseSchema)**  
  Analytics metrics for a visitor:
  - Identity: `visitor_id`.
  - Search behavior: `total_searches`, `unique_hostels_viewed`, `average_search_filters_used`.
  - Engagement: `total_hostel_views`, `total_comparisons`, `total_inquiries`.
  - Bookings: `total_bookings`, `booking_conversion_rate`.
  - Preference insights: `most_searched_city`, `most_viewed_room_type`, `average_budget`.
  - Computed:
    - `inquiry_conversion_rate`.
    - `average_views_per_search`.
    - `engagement_level` (`high|medium|low|inactive`).

> This file is your **generic read interface** for visitors: compact, public, detailed, and stats views.

---

## 6. `__init__.py` – Public export surface

The package `app.schemas.visitor` should re-export:

- Base: `VisitorBase`, `VisitorCreate`, `VisitorUpdate`
- Responses: `VisitorResponse`, `VisitorProfile`, `VisitorDetail`, `VisitorStats`
- Preferences: `VisitorPreferences`, `PreferenceUpdate`, `SearchPreferences`, `SavedSearch`
- Dashboard: `VisitorDashboard`, `SavedHostels`, `SavedHostelItem`, `BookingHistory`, `BookingHistoryItem`, `RecentSearch`, `RecentlyViewedHostel`, `RecommendedHostel`, `PriceDropAlert`, `AvailabilityAlert`
- Favorites: `FavoriteRequest`, `FavoritesList`, `FavoriteHostelItem`, `FavoriteUpdate`, `FavoritesExport`, `FavoriteComparison`


