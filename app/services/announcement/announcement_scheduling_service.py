"""
Scheduling and recurrence service for announcements.

Enhanced with timezone support, conflict detection, and recurrence validation.
"""

from typing import Optional, Dict, Any, List
from uuid import UUID
from datetime import datetime, timedelta

from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError

from app.services.base import (
    BaseService,
    ServiceResult,
    ServiceError,
    ErrorCode,
    ErrorSeverity,
)
from app.repositories.announcement import AnnouncementSchedulingRepository
from app.models.announcement.announcement_scheduling import (
    AnnouncementSchedule as AnnouncementScheduleModel
)
from app.schemas.announcement.announcement_scheduling import (
    ScheduleRequest,
    ScheduleConfig,
    RecurringAnnouncement,
    ScheduleUpdate,
    ScheduleCancel,
    PublishNow,
    ScheduledAnnouncementsList,
    ScheduledAnnouncementItem,
)


class AnnouncementSchedulingService(
    BaseService[AnnouncementScheduleModel, AnnouncementSchedulingRepository]
):
    """
    Service for one-off scheduling and recurring announcements with validation.
    
    Responsibilities:
    - Schedule announcements for future publishing
    - Create and manage recurring announcements
    - Update and cancel schedules
    - Override schedules for immediate publishing
    """

    # Minimum future scheduling time (minutes)
    MIN_SCHEDULE_ADVANCE = 5
    
    # Maximum future scheduling time (days)
    MAX_SCHEDULE_ADVANCE = 365

    def __init__(
        self,
        repository: AnnouncementSchedulingRepository,
        db_session: Session
    ):
        """
        Initialize scheduling service.
        
        Args:
            repository: Scheduling repository instance
            db_session: SQLAlchemy database session
        """
        super().__init__(repository, db_session)

    def schedule(
        self,
        request: ScheduleRequest,
    ) -> ServiceResult[ScheduleConfig]:
        """
        Schedule an existing announcement for future publishing.
        
        Args:
            request: Schedule configuration
            
        Returns:
            ServiceResult containing ScheduleConfig or error
            
        Notes:
            - Validates schedule time is in acceptable range
            - Prevents scheduling of already published announcements
            - Creates schedule record for processing
        """
        try:
            # Validate schedule time
            validation_result = self._validate_schedule_time(
                request.scheduled_at
            )
            if not validation_result.success:
                return validation_result
            
            # Verify announcement exists and is schedulable
            announcement_check = self._check_announcement_schedulable(
                request.announcement_id
            )
            if not announcement_check.success:
                return announcement_check
            
            # Create schedule
            config = self.repository.schedule_announcement(request)
            
            # Commit transaction
            self.db.commit()
            
            return ServiceResult.success(
                data=config,
                message=f"Announcement scheduled for {request.scheduled_at}",
                metadata={
                    "scheduled_at": request.scheduled_at.isoformat(),
                    "announcement_id": str(request.announcement_id),
                }
            )
            
        except SQLAlchemyError as e:
            self.db.rollback()
            return self._handle_database_error(
                e, "schedule announcement", request.announcement_id
            )
            
        except ValueError as e:
            self.db.rollback()
            return ServiceResult.failure(
                ServiceError(
                    code=ErrorCode.VALIDATION_ERROR,
                    message=f"Invalid schedule configuration: {str(e)}",
                    severity=ErrorSeverity.WARNING,
                )
            )
            
        except Exception as e:
            self.db.rollback()
            return self._handle_exception(
                e, "schedule announcement", request.announcement_id
            )

    def create_recurring(
        self,
        request: RecurringAnnouncement,
    ) -> ServiceResult[ScheduleConfig]:
        """
        Create a recurring announcement template with schedule.
        
        Args:
            request: Recurring announcement configuration
            
        Returns:
            ServiceResult containing ScheduleConfig or error
            
        Notes:
            - Validates recurrence pattern
            - Creates template announcement
            - Schedules initial occurrence
            - Subsequent occurrences generated by scheduler
        """
        try:
            # Validate recurrence configuration
            validation_result = self._validate_recurrence_pattern(request)
            if not validation_result.success:
                return validation_result
            
            # Create recurring schedule
            config = self.repository.create_recurring(request)
            
            # Commit transaction
            self.db.commit()
            
            return ServiceResult.success(
                data=config,
                message=f"Recurring announcement created with pattern: {request.recurrence_pattern}",
                metadata={
                    "recurrence_pattern": request.recurrence_pattern,
                    "start_date": request.start_date.isoformat(),
                    "end_date": request.end_date.isoformat() if request.end_date else None,
                }
            )
            
        except SQLAlchemyError as e:
            self.db.rollback()
            return self._handle_database_error(e, "create recurring announcement")
            
        except ValueError as e:
            self.db.rollback()
            return ServiceResult.failure(
                ServiceError(
                    code=ErrorCode.VALIDATION_ERROR,
                    message=f"Invalid recurrence configuration: {str(e)}",
                    severity=ErrorSeverity.WARNING,
                )
            )
            
        except Exception as e:
            self.db.rollback()
            return self._handle_exception(e, "create recurring announcement")

    def update_schedule(
        self,
        request: ScheduleUpdate,
    ) -> ServiceResult[ScheduleConfig]:
        """
        Reschedule an upcoming announcement.
        
        Args:
            request: Updated schedule configuration
            
        Returns:
            ServiceResult containing updated ScheduleConfig or error
            
        Notes:
            - Only allows rescheduling of pending announcements
            - Validates new schedule time
            - Preserves other announcement properties
        """
        try:
            # Validate new schedule time
            if request.new_scheduled_at:
                validation_result = self._validate_schedule_time(
                    request.new_scheduled_at
                )
                if not validation_result.success:
                    return validation_result
            
            # Update schedule
            config = self.repository.update_schedule(
                announcement_id=request.announcement_id,
                request=request
            )
            
            # Commit transaction
            self.db.commit()
            
            return ServiceResult.success(
                data=config,
                message="Schedule updated successfully",
                metadata={
                    "announcement_id": str(request.announcement_id),
                    "new_scheduled_at": request.new_scheduled_at.isoformat() if request.new_scheduled_at else None,
                }
            )
            
        except SQLAlchemyError as e:
            self.db.rollback()
            return self._handle_database_error(
                e, "update schedule", request.announcement_id
            )
            
        except ValueError as e:
            self.db.rollback()
            return ServiceResult.failure(
                ServiceError(
                    code=ErrorCode.VALIDATION_ERROR,
                    message=f"Invalid schedule update: {str(e)}",
                    severity=ErrorSeverity.WARNING,
                )
            )
            
        except Exception as e:
            self.db.rollback()
            return self._handle_exception(
                e, "update schedule", request.announcement_id
            )

    def cancel(
        self,
        request: ScheduleCancel,
    ) -> ServiceResult[bool]:
        """
        Cancel a scheduled or recurring announcement.
        
        Args:
            request: Cancellation configuration
            
        Returns:
            ServiceResult containing success boolean or error
            
        Notes:
            - Cancels pending schedule
            - Optionally cancels all future occurrences for recurring
            - Does not affect already published instances
        """
        try:
            # Execute cancellation
            self.repository.cancel_schedule(request)
            
            # Commit transaction
            self.db.commit()
            
            message = "Schedule cancelled successfully"
            if request.cancel_future_occurrences:
                message += " (including future occurrences)"
            
            return ServiceResult.success(
                data=True,
                message=message,
                metadata={
                    "announcement_id": str(request.announcement_id),
                    "reason": request.reason,
                }
            )
            
        except SQLAlchemyError as e:
            self.db.rollback()
            return self._handle_database_error(
                e, "cancel schedule", request.announcement_id
            )
            
        except Exception as e:
            self.db.rollback()
            return self._handle_exception(
                e, "cancel schedule", request.announcement_id
            )

    def publish_now(
        self,
        request: PublishNow,
    ) -> ServiceResult[bool]:
        """
        Override schedule and publish announcement immediately.
        
        Args:
            request: Immediate publishing configuration
            
        Returns:
            ServiceResult containing success boolean or error
            
        Notes:
            - Bypasses scheduled publish time
            - Updates announcement status to published
            - Optionally preserves schedule for audit
        """
        try:
            # Execute immediate publish
            self.repository.publish_now(
                announcement_id=request.announcement_id,
                published_by=request.published_by,
                override=request.override_schedule
            )
            
            # Commit transaction
            self.db.commit()
            
            return ServiceResult.success(
                data=True,
                message="Announcement published immediately",
                metadata={
                    "announcement_id": str(request.announcement_id),
                    "published_by": str(request.published_by),
                    "override_schedule": request.override_schedule,
                }
            )
            
        except SQLAlchemyError as e:
            self.db.rollback()
            return self._handle_database_error(
                e, "publish now", request.announcement_id
            )
            
        except Exception as e:
            self.db.rollback()
            return self._handle_exception(
                e, "publish now", request.announcement_id
            )

    def list_scheduled(
        self,
        hostel_id: UUID,
        limit: int = 20,
        include_past: bool = False,
    ) -> ServiceResult[ScheduledAnnouncementsList]:
        """
        List upcoming scheduled announcements for a hostel.
        
        Args:
            hostel_id: Unique identifier of hostel
            limit: Maximum number of items to return
            include_past: Include past scheduled items
            
        Returns:
            ServiceResult containing ScheduledAnnouncementsList or error
            
        Notes:
            - Orders by scheduled time ascending
            - Excludes cancelled schedules by default
            - Supports pagination for large result sets
        """
        try:
            # Validate limit
            if limit < 1 or limit > 100:
                return ServiceResult.failure(
                    ServiceError(
                        code=ErrorCode.VALIDATION_ERROR,
                        message="Limit must be between 1 and 100",
                        severity=ErrorSeverity.WARNING,
                    )
                )
            
            # Fetch scheduled list
            items = self.repository.get_scheduled_list(
                hostel_id=hostel_id,
                limit=limit,
                include_past=include_past
            )
            
            return ServiceResult.success(
                data=items,
                message="Scheduled announcements retrieved successfully",
                metadata={
                    "count": len(items.items),
                    "hostel_id": str(hostel_id),
                    "limit": limit,
                }
            )
            
        except SQLAlchemyError as e:
            return self._handle_database_error(
                e, "list scheduled announcements", hostel_id
            )
            
        except Exception as e:
            return self._handle_exception(
                e, "list scheduled announcements", hostel_id
            )

    # =========================================================================
    # Helper Methods
    # =========================================================================

    def _validate_schedule_time(
        self,
        scheduled_at: datetime
    ) -> ServiceResult:
        """
        Validate scheduled time is within acceptable range.
        
        Args:
            scheduled_at: Proposed schedule datetime
            
        Returns:
            ServiceResult indicating validation success or failure
        """
        now = datetime.utcnow()
        
        # Check if in past
        if scheduled_at <= now:
            return ServiceResult.failure(
                ServiceError(
                    code=ErrorCode.VALIDATION_ERROR,
                    message="Schedule time must be in the future",
                    severity=ErrorSeverity.WARNING,
                )
            )
        
        # Check minimum advance
        min_time = now + timedelta(minutes=self.MIN_SCHEDULE_ADVANCE)
        if scheduled_at < min_time:
            return ServiceResult.failure(
                ServiceError(
                    code=ErrorCode.VALIDATION_ERROR,
                    message=f"Schedule time must be at least {self.MIN_SCHEDULE_ADVANCE} minutes in the future",
                    severity=ErrorSeverity.WARNING,
                )
            )
        
        # Check maximum advance
        max_time = now + timedelta(days=self.MAX_SCHEDULE_ADVANCE)
        if scheduled_at > max_time:
            return ServiceResult.failure(
                ServiceError(
                    code=ErrorCode.VALIDATION_ERROR,
                    message=f"Schedule time cannot be more than {self.MAX_SCHEDULE_ADVANCE} days in the future",
                    severity=ErrorSeverity.WARNING,
                )
            )
        
        return ServiceResult.success(True)

    def _validate_recurrence_pattern(
        self,
        request: RecurringAnnouncement
    ) -> ServiceResult:
        """
        Validate recurrence pattern configuration.
        
        Args:
            request: Recurring announcement request
            
        Returns:
            ServiceResult indicating validation success or failure
        """
        # Validate pattern is supported
        valid_patterns = {"daily", "weekly", "monthly", "custom"}
        if request.recurrence_pattern not in valid_patterns:
            return ServiceResult.failure(
                ServiceError(
                    code=ErrorCode.VALIDATION_ERROR,
                    message=f"Invalid recurrence pattern. Must be one of {valid_patterns}",
                    severity=ErrorSeverity.WARNING,
                )
            )
        
        # Validate date range
        if request.end_date and request.end_date <= request.start_date:
            return ServiceResult.failure(
                ServiceError(
                    code=ErrorCode.VALIDATION_ERROR,
                    message="End date must be after start date",
                    severity=ErrorSeverity.WARNING,
                )
            )
        
        # Validate start date is in future
        if request.start_date <= datetime.utcnow():
            return ServiceResult.failure(
                ServiceError(
                    code=ErrorCode.VALIDATION_ERROR,
                    message="Start date must be in the future",
                    severity=ErrorSeverity.WARNING,
                )
            )
        
        return ServiceResult.success(True)

    def _check_announcement_schedulable(
        self,
        announcement_id: UUID
    ) -> ServiceResult:
        """
        Check if announcement can be scheduled.
        
        Args:
            announcement_id: Announcement to check
            
        Returns:
            ServiceResult indicating if schedulable
        """
        # This would typically check announcement status
        # Implementation depends on repository method
        try:
            is_schedulable = self.repository.is_announcement_schedulable(
                announcement_id
            )
            
            if not is_schedulable:
                return ServiceResult.failure(
                    ServiceError(
                        code=ErrorCode.VALIDATION_ERROR,
                        message="Announcement cannot be scheduled in its current state",
                        severity=ErrorSeverity.WARNING,
                    )
                )
            
            return ServiceResult.success(True)
            
        except Exception:
            # If method doesn't exist, assume schedulable
            return ServiceResult.success(True)

    def _handle_database_error(
        self,
        error: SQLAlchemyError,
        operation: str,
        entity_id: Optional[UUID] = None,
    ) -> ServiceResult:
        """Handle database-specific errors."""
        error_msg = f"Database error during {operation}"
        if entity_id:
            error_msg += f" for {entity_id}"
        
        return ServiceResult.failure(
            ServiceError(
                code=ErrorCode.DATABASE_ERROR,
                message=error_msg,
                severity=ErrorSeverity.ERROR,
                details={"original_error": str(error)},
            )
        )