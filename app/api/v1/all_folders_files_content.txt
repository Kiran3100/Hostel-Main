### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1 ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1 =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\router.py ---
# app/api/v1/router.py
from __future__ import annotations

from fastapi import APIRouter

from . import (
    admin,
    analytics,
    announcements,
    attendance,
    audit,
    auth,
    bookings,
    complaints,
    fee_structures,
    files,
    hostels,
    inquiries,
    leaves,
    maintenance,
    mess,
    notifications,
    payments,
    referrals,
    reviews,
    rooms,
    search,
    students,
    supervisors,
    users,
    visitors,
    
)

router = APIRouter()

# Core auth & user management
router.include_router(auth.router)
router.include_router(users.router)

# Domain routers
router.include_router(admin.router)
router.include_router(analytics.router)
router.include_router(announcements.router)
router.include_router(attendance.router)
router.include_router(audit.router)
router.include_router(bookings.router)
router.include_router(complaints.router)
router.include_router(fee_structures.router)
router.include_router(files.router)
router.include_router(hostels.router)
router.include_router(inquiries.router)
router.include_router(leaves.router)
router.include_router(maintenance.router)
router.include_router(mess.router)
router.include_router(notifications.router)
router.include_router(payments.router)
router.include_router(referrals.router)
router.include_router(reviews.router)
router.include_router(rooms.router)
router.include_router(search.router)
router.include_router(students.router)
router.include_router(supervisors.router)
router.include_router(visitors.router)

__all__ = ["router"]

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\__init__.py ---
# app/api/v1/__init__.py
from __future__ import annotations

"""
API v1 package.

This module re-exports the main FastAPI router that aggregates all
v1 sub-routers (auth, users, hostels, bookings, etc.).

The actual router composition lives in `app.api.v1.router`.
"""

from fastapi import APIRouter

from .router import router as api_router  # main v1 router

# `api_router` is what you typically include into the FastAPI app:
#
#     from app.api.v1 import api_router as api_v1_router
#     app.include_router(api_v1_router, prefix="/api/v1")
#

__all__ = [
    "APIRouter",
    "api_router",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\assignments.py ---
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.admin.admin_hostel_assignment import (
    AdminHostelAssignment,
    AssignmentCreate,
    AssignmentUpdate,
    BulkAssignment,
    RevokeAssignment,
    AssignmentList,
    HostelAdminList,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.admin import AdminHostelAssignmentService

router = APIRouter(prefix="/assignments")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


# -------- Admin → Hostels -------- #


@router.get(
    "/admins/{admin_id}",
    response_model=AssignmentList,
    summary="List hostel assignments for an admin",
)
async def list_admin_assignments(
    admin_id: UUID = Path(..., description="Admin ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentList:
    """
    Return all hostel assignments for a given admin, including primary flags and permissions.
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.list_assignments_for_admin(admin_id=admin_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/admins/{admin_id}",
    response_model=AdminHostelAssignment,
    status_code=status.HTTP_201_CREATED,
    summary="Assign an admin to a hostel",
)
async def create_admin_assignment(
    admin_id: UUID,
    payload: AssignmentCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> AdminHostelAssignment:
    """
    Create a single admin↔hostel assignment.

    Enforces:
    - Uniqueness per (admin, hostel)
    - At most one primary hostel per admin
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.create_assignment(admin_id=admin_id, data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/admins/{admin_id}/{assignment_id}",
    response_model=AdminHostelAssignment,
    summary="Update admin↔hostel assignment",
)
async def update_admin_assignment(
    admin_id: UUID,
    assignment_id: UUID,
    payload: AssignmentUpdate,
    uow: UnitOfWork = Depends(get_uow),
) -> AdminHostelAssignment:
    """
    Update assignment metadata (permissions, primary flag, etc.).
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.update_assignment(
            admin_id=admin_id,
            assignment_id=assignment_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/admins/{admin_id}/bulk",
    response_model=List[AdminHostelAssignment],
    summary="Bulk assign admin to multiple hostels",
)
async def bulk_assign_admin(
    admin_id: UUID,
    payload: BulkAssignment,
    uow: UnitOfWork = Depends(get_uow),
) -> List[AdminHostelAssignment]:
    """
    Bulk-assign an admin to multiple hostels in one call.
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.bulk_assign(admin_id=admin_id, data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/admins/{admin_id}/{assignment_id}/revoke",
    response_model=AdminHostelAssignment,
    summary="Revoke admin↔hostel assignment",
)
async def revoke_admin_assignment(
    admin_id: UUID,
    assignment_id: UUID,
    payload: RevokeAssignment,
    uow: UnitOfWork = Depends(get_uow),
) -> AdminHostelAssignment:
    """
    Revoke an assignment with a reason; typically marks it inactive and records revoked_date.
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.revoke_assignment(
            admin_id=admin_id,
            assignment_id=assignment_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


# -------- Hostel → Admins -------- #


@router.get(
    "/hostels/{hostel_id}",
    response_model=HostelAdminList,
    summary="List admins for a hostel",
)
async def list_hostel_admins(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelAdminList:
    """
    List all admins assigned to a given hostel, with metadata.
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.list_admins_for_hostel(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\dashboard.py ---
from __future__ import annotations

from datetime import date as Date
from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.analytics.platform_analytics import (
    PlatformMetrics,
    GrowthMetrics,
    PlatformUsageAnalytics,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.admin import SuperAdminDashboardService

router = APIRouter(prefix="/dashboard")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/platform/metrics/latest",
    response_model=PlatformMetrics,
    summary="Get latest platform-wide metrics (super admin)",
)
async def get_latest_platform_metrics(
    uow: UnitOfWork = Depends(get_uow),
) -> PlatformMetrics:
    """
    Fetch the latest platform-level metrics snapshot.

    Backed by SuperAdminDashboardService.
    """
    service = SuperAdminDashboardService(uow)
    try:
        return service.get_latest_platform_metrics()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/platform/growth",
    response_model=GrowthMetrics,
    summary="Get growth metrics for a period (super admin)",
)
async def get_growth_metrics(
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> GrowthMetrics:
    """
    Fetch growth metrics (hostels, revenue, users) for the given period.
    """
    service = SuperAdminDashboardService(uow)
    try:
        return service.get_growth_metrics(period_start=period_start, period_end=period_end)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/platform/usage/latest",
    response_model=PlatformUsageAnalytics,
    summary="Get latest platform usage analytics (super admin)",
)
async def get_latest_platform_usage(
    uow: UnitOfWork = Depends(get_uow),
) -> PlatformUsageAnalytics:
    """
    Fetch the latest API/platform usage analytics snapshot.
    """
    service = SuperAdminDashboardService(uow)
    try:
        return service.get_latest_platform_usage()
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\hostels.py ---
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.hostel.hostel_base import HostelCreate, HostelUpdate
from app.schemas.hostel.hostel_response import HostelResponse, HostelDetail
from app.schemas.hostel.hostel_filter import HostelFilterParams
from app.services.common.unit_of_work import UnitOfWork
from app.services.hostel import HostelService

router = APIRouter(prefix="/hostels")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/",
    response_model=List[HostelResponse],
    summary="List hostels (admin view)",
)
async def list_hostels(
    filters: HostelFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> List[HostelResponse]:
    """
    List hostels for admin users.

    Uses HostelService.list_hostels with HostelFilterParams.
    """
    service = HostelService(uow)
    try:
        return service.list_hostels(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/",
    response_model=HostelDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new hostel",
)
async def create_hostel(
    payload: HostelCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> HostelDetail:
    """
    Create a new hostel.

    Ensures slug uniqueness and applies default flags.
    """
    service = HostelService(uow)
    try:
        return service.create_hostel(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{hostel_id}",
    response_model=HostelDetail,
    summary="Get hostel details (admin)",
)
async def get_hostel(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelDetail:
    """
    Retrieve detailed hostel information for admin users.
    """
    service = HostelService(uow)
    try:
        return service.get_hostel(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{hostel_id}",
    response_model=HostelDetail,
    summary="Update a hostel (admin)",
)
async def update_hostel(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: HostelUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> HostelDetail:
    """
    Partially update hostel fields.

    Delegates to HostelService.update_hostel.
    """
    service = HostelService(uow)
    try:
        return service.update_hostel(hostel_id=hostel_id, data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\multi_hostel.py ---
"""
Multi-Hostel Dashboard API

Provides consolidated dashboard views for administrators managing
multiple hostels, aggregating metrics and analytics across properties.
"""

from __future__ import annotations

from typing import Annotated, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_current_active_user, get_uow
from app.core.exceptions import (
    ConflictError,
    NotFoundError,
    ServiceError,
    ValidationError,
)
from app.models.core import User
from app.schemas.admin.multi_hostel_dashboard import MultiHostelDashboard
from app.services.admin import MultiHostelDashboardService
from app.services.common.unit_of_work import UnitOfWork

router = APIRouter(prefix="/multi-hostel")


# ==================== Error Mapping ====================


def _map_service_error(exc: ServiceError) -> HTTPException:
    """
    Map service-layer exceptions to appropriate HTTP exceptions.

    Args:
        exc: Service exception to map

    Returns:
        Corresponding HTTPException with appropriate status code
    """
    error_map = {
        NotFoundError: (status.HTTP_404_NOT_FOUND, str(exc)),
        ValidationError: (status.HTTP_422_UNPROCESSABLE_ENTITY, str(exc)),
        ConflictError: (status.HTTP_409_CONFLICT, str(exc)),
    }

    for error_type, (status_code, detail) in error_map.items():
        if isinstance(exc, error_type):
            return HTTPException(status_code=status_code, detail=detail)

    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


# ==================== Helper Functions ====================


def _resolve_admin_id(
    admin_id: Optional[UUID],
    current_user: User,
) -> UUID:
    """
    Resolve admin ID from explicit parameter or current user.

    Args:
        admin_id: Explicitly provided admin ID (optional)
        current_user: Currently authenticated user

    Returns:
        Resolved admin ID

    Raises:
        HTTPException: If admin_id not provided and user is not an admin
    """
    if admin_id is not None:
        return admin_id

    # Attempt to derive from current user's admin profile
    admin_profile = getattr(current_user, "admin_profile", None)
    if admin_profile is None:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Current user does not have an admin profile. "
            "Please provide an explicit admin_id.",
        )

    return admin_profile.id


# ==================== Endpoints ====================


@router.get(
    "/dashboard",
    response_model=MultiHostelDashboard,
    status_code=status.HTTP_200_OK,
    summary="Get Multi-Hostel Dashboard",
    description="Retrieve consolidated dashboard data for an admin managing multiple hostels.",
    responses={
        200: {"description": "Successfully retrieved dashboard data"},
        403: {"description": "User is not an admin or lacks permissions"},
        404: {"description": "Admin not found or has no hostel assignments"},
    },
)
async def get_multi_hostel_dashboard(
    admin_id: Annotated[
        Optional[UUID],
        Query(
            description="Admin ID (optional; defaults to current user's admin profile)",
        ),
    ] = None,
    current_user: Annotated[User, Depends(get_current_active_user)] = ...,
    uow: Annotated[UnitOfWork, Depends(get_uow)] = ...,
) -> MultiHostelDashboard:
    """
    Build consolidated multi-hostel dashboard.

    Aggregates data across all hostels assigned to the admin:
    - Per-hostel key metrics (occupancy, revenue, issues)
    - Cross-hostel comparisons
    - Trend analysis
    - Alert notifications
    - Priority items requiring attention

    Admin ID resolution:
    - If `admin_id` is provided, uses that value
    - Otherwise, derives from current authenticated user's admin profile
    - Fails if user is not an admin and no admin_id provided

    Dashboard includes:
    - Summary cards for each hostel
    - Comparative analytics
    - Recent activity feed
    - Pending tasks and alerts
    - Performance indicators
    """
    # Resolve admin_id from parameter or current user
    resolved_admin_id = _resolve_admin_id(admin_id, current_user)

    service = MultiHostelDashboardService(uow)
    try:
        return await service.get_dashboard(admin_id=resolved_admin_id)
    except ServiceError as exc:
        raise _map_service_error(exc) from exc

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\overrides.py ---
"""
Admin Override Management API

Handles administrator overrides of supervisor/system decisions with
comprehensive audit logging and statistical tracking.
"""

from __future__ import annotations

from datetime import date as Date
from typing import Annotated, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ConflictError,
    NotFoundError,
    ServiceError,
    ValidationError,
)
from app.schemas.admin.admin_override import (
    AdminOverrideRequest,
    OverrideLog,
    OverrideSummary,
    SupervisorOverrideStats,
)
from app.services.admin import AdminOverrideService
from app.services.common.unit_of_work import UnitOfWork

router = APIRouter(prefix="/overrides")


# ==================== Error Mapping ====================


def _map_service_error(exc: ServiceError) -> HTTPException:
    """
    Map service-layer exceptions to appropriate HTTP exceptions.

    Args:
        exc: Service exception to map

    Returns:
        Corresponding HTTPException with appropriate status code
    """
    error_map = {
        NotFoundError: (status.HTTP_404_NOT_FOUND, str(exc)),
        ValidationError: (status.HTTP_422_UNPROCESSABLE_ENTITY, str(exc)),
        ConflictError: (status.HTTP_409_CONFLICT, str(exc)),
    }

    for error_type, (status_code, detail) in error_map.items():
        if isinstance(exc, error_type):
            return HTTPException(status_code=status_code, detail=detail)

    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


# ==================== Endpoints ====================


@router.post(
    "/",
    response_model=OverrideLog,
    status_code=status.HTTP_201_CREATED,
    summary="Create Admin Override",
    description="Record an administrative override of a supervisor or system decision.",
    responses={
        201: {"description": "Override successfully recorded"},
        400: {"description": "Invalid override data"},
        403: {"description": "Insufficient privileges to override"},
        404: {"description": "Target entity not found"},
        409: {"description": "Override conflicts with existing decision"},
        422: {"description": "Validation error in override request"},
    },
)
async def create_admin_override(
    payload: AdminOverrideRequest,
    uow: Annotated[UnitOfWork, Depends(get_uow)],
) -> OverrideLog:
    """
    Record an admin override of a previous decision.

    Use cases:
    - Overriding supervisor complaint resolutions
    - Bypassing automated rejection rules
    - Emergency leave approvals
    - Maintenance priority escalation

    Actions performed:
    - Validates admin authority
    - Records original decision
    - Logs override justification
    - Updates entity status
    - Creates audit trail
    - Notifies affected parties

    All overrides are immutable and fully audited.
    """
    service = AdminOverrideService(uow)
    try:
        return await service.create_override(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc) from exc


@router.get(
    "/entity/{entity_type}/{entity_id}",
    response_model=list[OverrideLog],
    status_code=status.HTTP_200_OK,
    summary="List Overrides for Entity",
    description="Retrieve all administrative overrides applied to a specific entity.",
    responses={
        200: {"description": "Successfully retrieved override history"},
        404: {"description": "Entity not found"},
    },
)
async def list_overrides_for_entity(
    entity_type: Annotated[
        str,
        Path(
            description="Entity type (e.g., complaint, maintenance_request, leave_application)",
            example="complaint",
        ),
    ],
    entity_id: Annotated[
        UUID,
        Path(description="Unique identifier of the entity"),
    ],
    uow: Annotated[UnitOfWork, Depends(get_uow)],
) -> list[OverrideLog]:
    """
    Fetch complete override history for an entity.

    Returns chronological list of all overrides including:
    - Override timestamp
    - Admin who performed override
    - Original decision details
    - Override justification
    - Resulting status change

    Useful for:
    - Decision audit trails
    - Compliance reviews
    - Dispute resolution
    - Pattern analysis
    """
    service = AdminOverrideService(uow)
    try:
        return await service.list_overrides_for_entity(
            entity_type=entity_type,
            entity_id=entity_id,
        )
    except ServiceError as exc:
        raise _map_service_error(exc) from exc


@router.get(
    "/summary",
    response_model=OverrideSummary,
    status_code=status.HTTP_200_OK,
    summary="Get Override Summary",
    description="Retrieve aggregated override statistics for a period with optional filters.",
    responses={
        200: {"description": "Successfully retrieved override summary"},
        400: {"description": "Invalid filter or Date parameters"},
        422: {"description": "Validation error in query parameters"},
    },
)
async def get_override_summary(
    hostel_id: Annotated[
        Optional[UUID],
        Query(description="Filter by specific hostel"),
    ] = None,
    supervisor_id: Annotated[
        Optional[UUID],
        Query(description="Filter by supervisor whose decisions were overridden"),
    ] = None,
    start_date: Annotated[
        Optional[Date],
        Query(description="Start Date for summary period (inclusive)"),
    ] = None,
    end_date: Annotated[
        Optional[Date],
        Query(description="End Date for summary period (inclusive)"),
    ] = None,
    uow: Annotated[UnitOfWork, Depends(get_uow)] = ...,
) -> OverrideSummary:
    """
    Generate override statistics summary.

    Provides aggregated metrics:
    - Total override count
    - Overrides by entity type
    - Overrides by reason
    - Trend analysis
    - Hostel/supervisor breakdown

    Supports filtering by:
    - Date range
    - Specific hostel
    - Specific supervisor
    """
    # Validate Date range if both provided
    if start_date and end_date and start_date > end_date:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail="start_date must be before or equal to end_date",
        )

    service = AdminOverrideService(uow)
    try:
        return await service.get_override_summary(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc) from exc


@router.get(
    "/supervisors/{supervisor_id}/stats",
    response_model=SupervisorOverrideStats,
    status_code=status.HTTP_200_OK,
    summary="Get Supervisor Override Statistics",
    description="Retrieve detailed override statistics for a specific supervisor.",
    responses={
        200: {"description": "Successfully retrieved supervisor stats"},
        404: {"description": "Supervisor not found"},
    },
)
async def get_supervisor_override_stats(
    supervisor_id: Annotated[
        UUID,
        Path(description="Unique identifier of the supervisor"),
    ],
    start_date: Annotated[
        Optional[Date],
        Query(description="Start Date for statistics period (inclusive)"),
    ] = None,
    end_date: Annotated[
        Optional[Date],
        Query(description="End Date for statistics period (inclusive)"),
    ] = None,
    uow: Annotated[UnitOfWork, Depends(get_uow)] = ...,
) -> SupervisorOverrideStats:
    """
    Get detailed override statistics for a supervisor.

    Analyzes:
    - Total decisions made
    - Number of decisions overridden
    - Override rate percentage
    - Override reasons breakdown
    - Time-based trends
    - Entity type distribution

    Useful for:
    - Performance reviews
    - Training needs assessment
    - Quality assurance
    - Process improvement
    """
    # Validate Date range if both provided
    if start_date and end_date and start_date > end_date:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail="start_date must be before or equal to end_date",
        )

    service = AdminOverrideService(uow)
    try:
        return await service.get_supervisor_override_stats(
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc) from exc

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\permissions.py ---
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.admin.admin_permissions import (
    PermissionMatrix,
    RolePermissions,
    PermissionCheck,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.admin import PermissionMatrixService

router = APIRouter(prefix="/permissions")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/matrix",
    response_model=PermissionMatrix,
    summary="Get global role→permissions matrix",
)
async def get_permission_matrix(
    uow: UnitOfWork = Depends(get_uow),
) -> PermissionMatrix:
    """
    Fetch the current role→permissions matrix.

    Backed by PermissionMatrixService.
    """
    service = PermissionMatrixService(uow)
    try:
        return service.get_matrix()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/matrix",
    response_model=PermissionMatrix,
    summary="Update global role→permissions matrix",
)
async def update_permission_matrix(
    payload: PermissionMatrix,
    uow: UnitOfWork = Depends(get_uow),
) -> PermissionMatrix:
    """
    Replace the stored permission matrix.

    Should typically be restricted to super admins.
    """
    service = PermissionMatrixService(uow)
    try:
        return service.update_matrix(matrix=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/roles/{role_name}",
    response_model=RolePermissions,
    summary="Get permissions for a specific role",
)
async def get_role_permissions(
    role_name: str = Path(..., description="Role name (e.g. HOSTEL_ADMIN)"),
    uow: UnitOfWork = Depends(get_uow),
) -> RolePermissions:
    """
    Fetch the permissions assigned to a specific role.
    """
    service = PermissionMatrixService(uow)
    try:
        return service.get_role_permissions(role_name=role_name)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/check",
    response_model=PermissionCheck,
    summary="Check if a principal has a permission in a hostel",
)
async def check_permission(
    payload: PermissionCheck,
    uow: UnitOfWork = Depends(get_uow),
) -> PermissionCheck:
    """
    Check a single permission for a principal in the context of a hostel.

    Uses PermissionMatrixService.check_permission which bridges into RBACService.
    """
    service = PermissionMatrixService(uow)
    try:
        return service.check_permission(check=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\__init__.py ---
"""
Admin API module for hostel management platform.

Provides comprehensive administrative functionality including:
- Dashboard and analytics
- Hostel management
- Admin-hostel assignments
- Permission matrix management
- Administrative overrides
- Multi-hostel dashboard views

All endpoints are designed for administrative users and include
proper authorization checks, audit logging, and error handling.
"""
from __future__ import annotations

from fastapi import APIRouter

from . import (
    dashboard,
    hostels,
    assignments,
    permissions,
    overrides,
    multi_hostel,
)

# Create main admin router
router = APIRouter(prefix="/admin", tags=["Admin"])

# Include sub-routers with clear organization
router.include_router(dashboard.router)
router.include_router(hostels.router)
router.include_router(assignments.router)
router.include_router(permissions.router)
router.include_router(overrides.router)
router.include_router(multi_hostel.router)

__all__ = [
    "router",
    "dashboard",
    "hostels",
    "assignments",
    "permissions",
    "overrides",
    "multi_hostel",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\__pycache__ =====


# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\assignments.py ---
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.admin.admin_hostel_assignment import (
    AdminHostelAssignment,
    AssignmentCreate,
    AssignmentUpdate,
    BulkAssignment,
    RevokeAssignment,
    AssignmentList,
    HostelAdminList,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.admin import AdminHostelAssignmentService

router = APIRouter(prefix="/assignments")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


# -------- Admin → Hostels -------- #


@router.get(
    "/admins/{admin_id}",
    response_model=AssignmentList,
    summary="List hostel assignments for an admin",
)
async def list_admin_assignments(
    admin_id: UUID = Path(..., description="Admin ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentList:
    """
    Return all hostel assignments for a given admin, including primary flags and permissions.
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.list_assignments_for_admin(admin_id=admin_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/admins/{admin_id}",
    response_model=AdminHostelAssignment,
    status_code=status.HTTP_201_CREATED,
    summary="Assign an admin to a hostel",
)
async def create_admin_assignment(
    admin_id: UUID,
    payload: AssignmentCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> AdminHostelAssignment:
    """
    Create a single admin↔hostel assignment.

    Enforces:
    - Uniqueness per (admin, hostel)
    - At most one primary hostel per admin
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.create_assignment(admin_id=admin_id, data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/admins/{admin_id}/{assignment_id}",
    response_model=AdminHostelAssignment,
    summary="Update admin↔hostel assignment",
)
async def update_admin_assignment(
    admin_id: UUID,
    assignment_id: UUID,
    payload: AssignmentUpdate,
    uow: UnitOfWork = Depends(get_uow),
) -> AdminHostelAssignment:
    """
    Update assignment metadata (permissions, primary flag, etc.).
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.update_assignment(
            admin_id=admin_id,
            assignment_id=assignment_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/admins/{admin_id}/bulk",
    response_model=List[AdminHostelAssignment],
    summary="Bulk assign admin to multiple hostels",
)
async def bulk_assign_admin(
    admin_id: UUID,
    payload: BulkAssignment,
    uow: UnitOfWork = Depends(get_uow),
) -> List[AdminHostelAssignment]:
    """
    Bulk-assign an admin to multiple hostels in one call.
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.bulk_assign(admin_id=admin_id, data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/admins/{admin_id}/{assignment_id}/revoke",
    response_model=AdminHostelAssignment,
    summary="Revoke admin↔hostel assignment",
)
async def revoke_admin_assignment(
    admin_id: UUID,
    assignment_id: UUID,
    payload: RevokeAssignment,
    uow: UnitOfWork = Depends(get_uow),
) -> AdminHostelAssignment:
    """
    Revoke an assignment with a reason; typically marks it inactive and records revoked_date.
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.revoke_assignment(
            admin_id=admin_id,
            assignment_id=assignment_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


# -------- Hostel → Admins -------- #


@router.get(
    "/hostels/{hostel_id}",
    response_model=HostelAdminList,
    summary="List admins for a hostel",
)
async def list_hostel_admins(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelAdminList:
    """
    List all admins assigned to a given hostel, with metadata.
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.list_admins_for_hostel(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\dashboard.py ---
from __future__ import annotations

from datetime import date as Date
from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.analytics.platform_analytics import (
    PlatformMetrics,
    GrowthMetrics,
    PlatformUsageAnalytics,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.admin import SuperAdminDashboardService

router = APIRouter(prefix="/dashboard")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/platform/metrics/latest",
    response_model=PlatformMetrics,
    summary="Get latest platform-wide metrics (super admin)",
)
async def get_latest_platform_metrics(
    uow: UnitOfWork = Depends(get_uow),
) -> PlatformMetrics:
    """
    Fetch the latest platform-level metrics snapshot.

    Backed by SuperAdminDashboardService.
    """
    service = SuperAdminDashboardService(uow)
    try:
        return service.get_latest_platform_metrics()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/platform/growth",
    response_model=GrowthMetrics,
    summary="Get growth metrics for a period (super admin)",
)
async def get_growth_metrics(
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> GrowthMetrics:
    """
    Fetch growth metrics (hostels, revenue, users) for the given period.
    """
    service = SuperAdminDashboardService(uow)
    try:
        return service.get_growth_metrics(period_start=period_start, period_end=period_end)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/platform/usage/latest",
    response_model=PlatformUsageAnalytics,
    summary="Get latest platform usage analytics (super admin)",
)
async def get_latest_platform_usage(
    uow: UnitOfWork = Depends(get_uow),
) -> PlatformUsageAnalytics:
    """
    Fetch the latest API/platform usage analytics snapshot.
    """
    service = SuperAdminDashboardService(uow)
    try:
        return service.get_latest_platform_usage()
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\hostels.py ---
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.hostel.hostel_base import HostelCreate, HostelUpdate
from app.schemas.hostel.hostel_response import HostelResponse, HostelDetail
from app.schemas.hostel.hostel_filter import HostelFilterParams
from app.services.common.unit_of_work import UnitOfWork
from app.services.hostel import HostelService

router = APIRouter(prefix="/hostels")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/",
    response_model=List[HostelResponse],
    summary="List hostels (admin view)",
)
async def list_hostels(
    filters: HostelFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> List[HostelResponse]:
    """
    List hostels for admin users.

    Uses HostelService.list_hostels with HostelFilterParams.
    """
    service = HostelService(uow)
    try:
        return service.list_hostels(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/",
    response_model=HostelDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new hostel",
)
async def create_hostel(
    payload: HostelCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> HostelDetail:
    """
    Create a new hostel.

    Ensures slug uniqueness and applies default flags.
    """
    service = HostelService(uow)
    try:
        return service.create_hostel(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{hostel_id}",
    response_model=HostelDetail,
    summary="Get hostel details (admin)",
)
async def get_hostel(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelDetail:
    """
    Retrieve detailed hostel information for admin users.
    """
    service = HostelService(uow)
    try:
        return service.get_hostel(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{hostel_id}",
    response_model=HostelDetail,
    summary="Update a hostel (admin)",
)
async def update_hostel(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: HostelUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> HostelDetail:
    """
    Partially update hostel fields.

    Delegates to HostelService.update_hostel.
    """
    service = HostelService(uow)
    try:
        return service.update_hostel(hostel_id=hostel_id, data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\multi_hostel.py ---
"""
Multi-Hostel Dashboard API

Provides consolidated dashboard views for administrators managing
multiple hostels, aggregating metrics and analytics across properties.
"""

from __future__ import annotations

from typing import Annotated, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_current_active_user, get_uow
from app.core.exceptions import (
    ConflictError,
    NotFoundError,
    ServiceError,
    ValidationError,
)
from app.models.core import User
from app.schemas.admin.multi_hostel_dashboard import MultiHostelDashboard
from app.services.admin import MultiHostelDashboardService
from app.services.common.unit_of_work import UnitOfWork

router = APIRouter(prefix="/multi-hostel")


# ==================== Error Mapping ====================


def _map_service_error(exc: ServiceError) -> HTTPException:
    """
    Map service-layer exceptions to appropriate HTTP exceptions.

    Args:
        exc: Service exception to map

    Returns:
        Corresponding HTTPException with appropriate status code
    """
    error_map = {
        NotFoundError: (status.HTTP_404_NOT_FOUND, str(exc)),
        ValidationError: (status.HTTP_422_UNPROCESSABLE_ENTITY, str(exc)),
        ConflictError: (status.HTTP_409_CONFLICT, str(exc)),
    }

    for error_type, (status_code, detail) in error_map.items():
        if isinstance(exc, error_type):
            return HTTPException(status_code=status_code, detail=detail)

    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


# ==================== Helper Functions ====================


def _resolve_admin_id(
    admin_id: Optional[UUID],
    current_user: User,
) -> UUID:
    """
    Resolve admin ID from explicit parameter or current user.

    Args:
        admin_id: Explicitly provided admin ID (optional)
        current_user: Currently authenticated user

    Returns:
        Resolved admin ID

    Raises:
        HTTPException: If admin_id not provided and user is not an admin
    """
    if admin_id is not None:
        return admin_id

    # Attempt to derive from current user's admin profile
    admin_profile = getattr(current_user, "admin_profile", None)
    if admin_profile is None:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Current user does not have an admin profile. "
            "Please provide an explicit admin_id.",
        )

    return admin_profile.id


# ==================== Endpoints ====================


@router.get(
    "/dashboard",
    response_model=MultiHostelDashboard,
    status_code=status.HTTP_200_OK,
    summary="Get Multi-Hostel Dashboard",
    description="Retrieve consolidated dashboard data for an admin managing multiple hostels.",
    responses={
        200: {"description": "Successfully retrieved dashboard data"},
        403: {"description": "User is not an admin or lacks permissions"},
        404: {"description": "Admin not found or has no hostel assignments"},
    },
)
async def get_multi_hostel_dashboard(
    admin_id: Annotated[
        Optional[UUID],
        Query(
            description="Admin ID (optional; defaults to current user's admin profile)",
        ),
    ] = None,
    current_user: Annotated[User, Depends(get_current_active_user)] = ...,
    uow: Annotated[UnitOfWork, Depends(get_uow)] = ...,
) -> MultiHostelDashboard:
    """
    Build consolidated multi-hostel dashboard.

    Aggregates data across all hostels assigned to the admin:
    - Per-hostel key metrics (occupancy, revenue, issues)
    - Cross-hostel comparisons
    - Trend analysis
    - Alert notifications
    - Priority items requiring attention

    Admin ID resolution:
    - If `admin_id` is provided, uses that value
    - Otherwise, derives from current authenticated user's admin profile
    - Fails if user is not an admin and no admin_id provided

    Dashboard includes:
    - Summary cards for each hostel
    - Comparative analytics
    - Recent activity feed
    - Pending tasks and alerts
    - Performance indicators
    """
    # Resolve admin_id from parameter or current user
    resolved_admin_id = _resolve_admin_id(admin_id, current_user)

    service = MultiHostelDashboardService(uow)
    try:
        return await service.get_dashboard(admin_id=resolved_admin_id)
    except ServiceError as exc:
        raise _map_service_error(exc) from exc

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\overrides.py ---
"""
Admin Override Management API

Handles administrator overrides of supervisor/system decisions with
comprehensive audit logging and statistical tracking.
"""

from __future__ import annotations

from datetime import date as Date
from typing import Annotated, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ConflictError,
    NotFoundError,
    ServiceError,
    ValidationError,
)
from app.schemas.admin.admin_override import (
    AdminOverrideRequest,
    OverrideLog,
    OverrideSummary,
    SupervisorOverrideStats,
)
from app.services.admin import AdminOverrideService
from app.services.common.unit_of_work import UnitOfWork

router = APIRouter(prefix="/overrides")


# ==================== Error Mapping ====================


def _map_service_error(exc: ServiceError) -> HTTPException:
    """
    Map service-layer exceptions to appropriate HTTP exceptions.

    Args:
        exc: Service exception to map

    Returns:
        Corresponding HTTPException with appropriate status code
    """
    error_map = {
        NotFoundError: (status.HTTP_404_NOT_FOUND, str(exc)),
        ValidationError: (status.HTTP_422_UNPROCESSABLE_ENTITY, str(exc)),
        ConflictError: (status.HTTP_409_CONFLICT, str(exc)),
    }

    for error_type, (status_code, detail) in error_map.items():
        if isinstance(exc, error_type):
            return HTTPException(status_code=status_code, detail=detail)

    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


# ==================== Endpoints ====================


@router.post(
    "/",
    response_model=OverrideLog,
    status_code=status.HTTP_201_CREATED,
    summary="Create Admin Override",
    description="Record an administrative override of a supervisor or system decision.",
    responses={
        201: {"description": "Override successfully recorded"},
        400: {"description": "Invalid override data"},
        403: {"description": "Insufficient privileges to override"},
        404: {"description": "Target entity not found"},
        409: {"description": "Override conflicts with existing decision"},
        422: {"description": "Validation error in override request"},
    },
)
async def create_admin_override(
    payload: AdminOverrideRequest,
    uow: Annotated[UnitOfWork, Depends(get_uow)],
) -> OverrideLog:
    """
    Record an admin override of a previous decision.

    Use cases:
    - Overriding supervisor complaint resolutions
    - Bypassing automated rejection rules
    - Emergency leave approvals
    - Maintenance priority escalation

    Actions performed:
    - Validates admin authority
    - Records original decision
    - Logs override justification
    - Updates entity status
    - Creates audit trail
    - Notifies affected parties

    All overrides are immutable and fully audited.
    """
    service = AdminOverrideService(uow)
    try:
        return await service.create_override(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc) from exc


@router.get(
    "/entity/{entity_type}/{entity_id}",
    response_model=list[OverrideLog],
    status_code=status.HTTP_200_OK,
    summary="List Overrides for Entity",
    description="Retrieve all administrative overrides applied to a specific entity.",
    responses={
        200: {"description": "Successfully retrieved override history"},
        404: {"description": "Entity not found"},
    },
)
async def list_overrides_for_entity(
    entity_type: Annotated[
        str,
        Path(
            description="Entity type (e.g., complaint, maintenance_request, leave_application)",
            example="complaint",
        ),
    ],
    entity_id: Annotated[
        UUID,
        Path(description="Unique identifier of the entity"),
    ],
    uow: Annotated[UnitOfWork, Depends(get_uow)],
) -> list[OverrideLog]:
    """
    Fetch complete override history for an entity.

    Returns chronological list of all overrides including:
    - Override timestamp
    - Admin who performed override
    - Original decision details
    - Override justification
    - Resulting status change

    Useful for:
    - Decision audit trails
    - Compliance reviews
    - Dispute resolution
    - Pattern analysis
    """
    service = AdminOverrideService(uow)
    try:
        return await service.list_overrides_for_entity(
            entity_type=entity_type,
            entity_id=entity_id,
        )
    except ServiceError as exc:
        raise _map_service_error(exc) from exc


@router.get(
    "/summary",
    response_model=OverrideSummary,
    status_code=status.HTTP_200_OK,
    summary="Get Override Summary",
    description="Retrieve aggregated override statistics for a period with optional filters.",
    responses={
        200: {"description": "Successfully retrieved override summary"},
        400: {"description": "Invalid filter or Date parameters"},
        422: {"description": "Validation error in query parameters"},
    },
)
async def get_override_summary(
    hostel_id: Annotated[
        Optional[UUID],
        Query(description="Filter by specific hostel"),
    ] = None,
    supervisor_id: Annotated[
        Optional[UUID],
        Query(description="Filter by supervisor whose decisions were overridden"),
    ] = None,
    start_date: Annotated[
        Optional[Date],
        Query(description="Start Date for summary period (inclusive)"),
    ] = None,
    end_date: Annotated[
        Optional[Date],
        Query(description="End Date for summary period (inclusive)"),
    ] = None,
    uow: Annotated[UnitOfWork, Depends(get_uow)] = ...,
) -> OverrideSummary:
    """
    Generate override statistics summary.

    Provides aggregated metrics:
    - Total override count
    - Overrides by entity type
    - Overrides by reason
    - Trend analysis
    - Hostel/supervisor breakdown

    Supports filtering by:
    - Date range
    - Specific hostel
    - Specific supervisor
    """
    # Validate Date range if both provided
    if start_date and end_date and start_date > end_date:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail="start_date must be before or equal to end_date",
        )

    service = AdminOverrideService(uow)
    try:
        return await service.get_override_summary(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc) from exc


@router.get(
    "/supervisors/{supervisor_id}/stats",
    response_model=SupervisorOverrideStats,
    status_code=status.HTTP_200_OK,
    summary="Get Supervisor Override Statistics",
    description="Retrieve detailed override statistics for a specific supervisor.",
    responses={
        200: {"description": "Successfully retrieved supervisor stats"},
        404: {"description": "Supervisor not found"},
    },
)
async def get_supervisor_override_stats(
    supervisor_id: Annotated[
        UUID,
        Path(description="Unique identifier of the supervisor"),
    ],
    start_date: Annotated[
        Optional[Date],
        Query(description="Start Date for statistics period (inclusive)"),
    ] = None,
    end_date: Annotated[
        Optional[Date],
        Query(description="End Date for statistics period (inclusive)"),
    ] = None,
    uow: Annotated[UnitOfWork, Depends(get_uow)] = ...,
) -> SupervisorOverrideStats:
    """
    Get detailed override statistics for a supervisor.

    Analyzes:
    - Total decisions made
    - Number of decisions overridden
    - Override rate percentage
    - Override reasons breakdown
    - Time-based trends
    - Entity type distribution

    Useful for:
    - Performance reviews
    - Training needs assessment
    - Quality assurance
    - Process improvement
    """
    # Validate Date range if both provided
    if start_date and end_date and start_date > end_date:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail="start_date must be before or equal to end_date",
        )

    service = AdminOverrideService(uow)
    try:
        return await service.get_supervisor_override_stats(
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc) from exc

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\permissions.py ---
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.admin.admin_permissions import (
    PermissionMatrix,
    RolePermissions,
    PermissionCheck,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.admin import PermissionMatrixService

router = APIRouter(prefix="/permissions")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/matrix",
    response_model=PermissionMatrix,
    summary="Get global role→permissions matrix",
)
async def get_permission_matrix(
    uow: UnitOfWork = Depends(get_uow),
) -> PermissionMatrix:
    """
    Fetch the current role→permissions matrix.

    Backed by PermissionMatrixService.
    """
    service = PermissionMatrixService(uow)
    try:
        return service.get_matrix()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/matrix",
    response_model=PermissionMatrix,
    summary="Update global role→permissions matrix",
)
async def update_permission_matrix(
    payload: PermissionMatrix,
    uow: UnitOfWork = Depends(get_uow),
) -> PermissionMatrix:
    """
    Replace the stored permission matrix.

    Should typically be restricted to super admins.
    """
    service = PermissionMatrixService(uow)
    try:
        return service.update_matrix(matrix=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/roles/{role_name}",
    response_model=RolePermissions,
    summary="Get permissions for a specific role",
)
async def get_role_permissions(
    role_name: str = Path(..., description="Role name (e.g. HOSTEL_ADMIN)"),
    uow: UnitOfWork = Depends(get_uow),
) -> RolePermissions:
    """
    Fetch the permissions assigned to a specific role.
    """
    service = PermissionMatrixService(uow)
    try:
        return service.get_role_permissions(role_name=role_name)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/check",
    response_model=PermissionCheck,
    summary="Check if a principal has a permission in a hostel",
)
async def check_permission(
    payload: PermissionCheck,
    uow: UnitOfWork = Depends(get_uow),
) -> PermissionCheck:
    """
    Check a single permission for a principal in the context of a hostel.

    Uses PermissionMatrixService.check_permission which bridges into RBACService.
    """
    service = PermissionMatrixService(uow)
    try:
        return service.check_permission(check=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\__init__.py ---
"""
Admin API module for hostel management platform.

Provides comprehensive administrative functionality including:
- Dashboard and analytics
- Hostel management
- Admin-hostel assignments
- Permission matrix management
- Administrative overrides
- Multi-hostel dashboard views

All endpoints are designed for administrative users and include
proper authorization checks, audit logging, and error handling.
"""
from __future__ import annotations

from fastapi import APIRouter

from . import (
    dashboard,
    hostels,
    assignments,
    permissions,
    overrides,
    multi_hostel,
)

# Create main admin router
router = APIRouter(prefix="/admin", tags=["Admin"])

# Include sub-routers with clear organization
router.include_router(dashboard.router)
router.include_router(hostels.router)
router.include_router(assignments.router)
router.include_router(permissions.router)
router.include_router(overrides.router)
router.include_router(multi_hostel.router)

__all__ = [
    "router",
    "dashboard",
    "hostels",
    "assignments",
    "permissions",
    "overrides",
    "multi_hostel",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\admin\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\analytics =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\analytics\bookings.py ---
from __future__ import annotations

from datetime import date as Date
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.booking_analytics import BookingAnalyticsSummary
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingAnalyticsService

router = APIRouter(prefix="/bookings")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/summary",
    response_model=BookingAnalyticsSummary,
    summary="Get booking analytics for a hostel",
)
async def get_booking_analytics(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> BookingAnalyticsSummary:
    """
    Produce hostel booking analytics: KPIs, daily trends, funnel, cancellations, source conversions.
    """
    service = BookingAnalyticsService(uow)
    try:
        return service.get_booking_analytics(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\analytics\complaints.py ---
from __future__ import annotations

from datetime import date as Date
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.complaint_analytics import ComplaintDashboard
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics.complaint_analytics_service import ComplaintAnalyticsService

router = APIRouter(prefix="/complaints")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/dashboard",
    response_model=ComplaintDashboard,
    summary="Get complaint analytics dashboard for a hostel",
)
async def get_complaint_dashboard(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintDashboard:
    """
    Compute complaint KPIs, trends, and category/priority breakdowns for a hostel.
    """
    service = ComplaintAnalyticsService(uow)
    try:
        return service.get_hostel_complaint_dashboard(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\analytics\custom.py ---
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.custom_reports import (
    CustomReportRequest,
    CustomReportResult,
    CustomReportDefinition,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import CustomReportService

router = APIRouter(prefix="/custom")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/run",
    response_model=CustomReportResult,
    summary="Run a custom analytics report",
)
async def run_custom_report(
    payload: CustomReportRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> CustomReportResult:
    """
    Execute a schema-driven custom report over payments, bookings, complaints, attendance, etc.
    """
    service = CustomReportService(uow)
    try:
        return service.run_report(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/definitions",
    response_model=CustomReportDefinition,
    status_code=status.HTTP_201_CREATED,
    summary="Create a saved custom report definition",
)
async def create_report_definition(
    payload: CustomReportDefinition,
    uow: UnitOfWork = Depends(get_uow),
) -> CustomReportDefinition:
    """
    Create and store a custom report definition for later reuse.
    """
    service = CustomReportService(uow)
    try:
        return service.create_definition(definition=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/definitions",
    response_model=List[CustomReportDefinition],
    summary="List saved custom report definitions",
)
async def list_report_definitions(
    uow: UnitOfWork = Depends(get_uow),
) -> List[CustomReportDefinition]:
    """
    List all saved custom report definitions (optionally, you may extend with filters).
    """
    service = CustomReportService(uow)
    try:
        return service.list_definitions()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/definitions/{report_id}",
    response_model=CustomReportDefinition,
    summary="Get a specific report definition",
)
async def get_report_definition(
    report_id: UUID = Path(..., description="Report definition ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> CustomReportDefinition:
    """
    Retrieve a specific custom report definition.
    """
    service = CustomReportService(uow)
    try:
        return service.get_definition(report_id=report_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.delete(
    "/definitions/{report_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete a report definition",
)
async def delete_report_definition(
    report_id: UUID = Path(..., description="Report definition ID"),
    uow: UnitOfWork = Depends(get_uow),
):
    """
    Delete a saved custom report definition.
    """
    service = CustomReportService(uow)
    try:
        service.delete_definition(report_id=report_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\analytics\dashboard.py ---
from __future__ import annotations

from datetime import date as Date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.dashboard_analytics import DashboardMetrics as DashboardMetricsSchema
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import DashboardAnalyticsService

router = APIRouter(prefix="/dashboard")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/",
    response_model=DashboardMetricsSchema,
    summary="Get dashboard metrics snapshot for a scope",
)
async def get_dashboard_metrics(
    scope_type: str = Query(..., description="Scope type: hostel | platform | admin"),
    scope_id: Optional[UUID] = Query(
        None,
        description="Scope ID (hostel_id or admin_id); null for platform scope",
    ),
    period_start: Optional[Date] = Query(
        None,
        description="Start Date (inclusive). If omitted, service will choose a default window.",
    ),
    period_end: Optional[Date] = Query(
        None,
        description="End Date (inclusive). If omitted, service will choose a default window.",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> DashboardMetricsSchema:
    """
    Fetch a pre-aggregated dashboard metrics snapshot for the given scope.

    Backed by DashboardAnalyticsService which wraps `analytics_dashboard_metrics`.
    """
    service = DashboardAnalyticsService(uow)
    try:
        return service.get_dashboard_metrics(
            scope_type=scope_type,
            scope_id=scope_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\analytics\financial.py ---
from __future__ import annotations

from datetime import date as Date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.financial_analytics import FinancialReport
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import FinancialAnalyticsService

router = APIRouter(prefix="/financial")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/report",
    response_model=FinancialReport,
    summary="Get financial analytics report",
)
async def get_financial_report(
    scope_type: str = Query(
        "hostel",
        description="Scope type: hostel | platform | admin (default hostel)",
    ),
    scope_id: Optional[UUID] = Query(
        None,
        description="Scope ID (hostel_id, admin_id, or null for platform-wide)",
    ),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> FinancialReport:
    """
    Compute a financial analytics report for the given scope and period.

    Includes revenue, expenses, P&L, cashflow, and collection/overdue ratios.
    """
    service = FinancialAnalyticsService(uow)
    try:
        return service.get_financial_report(
            scope_type=scope_type,
            scope_id=scope_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\analytics\occupancy.py ---
from __future__ import annotations

from datetime import date as Date
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.occupancy_analytics import OccupancyReport
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import OccupancyAnalyticsService

router = APIRouter(prefix="/occupancy")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/report",
    response_model=OccupancyReport,
    summary="Get occupancy report for a hostel",
)
async def get_occupancy_report(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> OccupancyReport:
    """
    Build an occupancy report for the given hostel and period.

    Includes KPIs, daily trend, and occupancy by room type.
    """
    service = OccupancyAnalyticsService(uow)
    try:
        return service.get_occupancy_report(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\analytics\platform.py ---
from __future__ import annotations

from datetime import date as Date
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.platform_analytics import (
    PlatformMetrics,
    GrowthMetrics,
    PlatformUsageAnalytics,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import PlatformAnalyticsService

router = APIRouter(prefix="/platform")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/metrics/latest",
    response_model=PlatformMetrics,
    summary="Get latest platform metrics",
)
async def get_latest_platform_metrics(
    uow: UnitOfWork = Depends(get_uow),
) -> PlatformMetrics:
    """
    Fetch latest platform-wide metrics (tenants, users, load, etc.).
    """
    service = PlatformAnalyticsService(uow)
    try:
        return service.get_latest_metrics()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/growth",
    response_model=GrowthMetrics,
    summary="Get platform growth metrics for a period",
)
async def get_growth_metrics(
    period_start: Date = Query(...),
    period_end: Date = Query(...),
    uow: UnitOfWork = Depends(get_uow),
) -> GrowthMetrics:
    """
    Fetch growth metrics (hostels, revenue, users) for the given period.
    """
    service = PlatformAnalyticsService(uow)
    try:
        return service.get_growth_metrics(period_start=period_start, period_end=period_end)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/usage/latest",
    response_model=PlatformUsageAnalytics,
    summary="Get latest platform usage analytics",
)
async def get_latest_platform_usage(
    uow: UnitOfWork = Depends(get_uow),
) -> PlatformUsageAnalytics:
    """
    Fetch latest API/platform usage statistics (traffic, error rates, latency).
    """
    service = PlatformAnalyticsService(uow)
    try:
        return service.get_latest_usage()
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\analytics\supervisors.py ---
from __future__ import annotations

from datetime import date as Date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.supervisor_analytics import (
    SupervisorDashboardAnalytics,
    SupervisorComparison,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import SupervisorAnalyticsService

router = APIRouter(prefix="/supervisors")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/{supervisor_id}/dashboard",
    response_model=SupervisorDashboardAnalytics,
    summary="Get supervisor performance dashboard",
)
async def get_supervisor_dashboard(
    supervisor_id: UUID = Path(..., description="Supervisor ID"),
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Date = Query(...),
    period_end: Date = Query(...),
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorDashboardAnalytics:
    """
    Build a performance dashboard for a specific supervisor at a hostel.
    """
    service = SupervisorAnalyticsService(uow)
    try:
        return service.get_supervisor_dashboard(
            supervisor_id=supervisor_id,
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/comparison",
    response_model=SupervisorComparison,
    summary="Compare supervisors within a hostel",
)
async def compare_supervisors(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Date = Query(...),
    period_end: Date = Query(...),
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorComparison:
    """
    Compare supervisors on performance metrics within a given hostel and period.
    """
    service = SupervisorAnalyticsService(uow)
    try:
        return service.get_supervisor_comparison(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\analytics\visitors.py ---
from __future__ import annotations

from datetime import date as Date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.visitor_analytics import (
    VisitorFunnel,
    TrafficSourceAnalytics,
    VisitorBehaviorAnalytics as VisitorBehaviorAnalyticsSchema,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import VisitorAnalyticsService

router = APIRouter(prefix="/visitors")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/funnel",
    response_model=VisitorFunnel,
    summary="Get visitor funnel analytics",
)
async def get_visitor_funnel(
    hostel_id: Optional[UUID] = Query(None, description="Optional hostel filter"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> VisitorFunnel:
    """
    Return high-level funnel metrics: visits → registrations → bookings.
    """
    service = VisitorAnalyticsService(uow)
    try:
        return service.get_funnel(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/traffic",
    response_model=TrafficSourceAnalytics,
    summary="Get traffic source analytics",
)
async def get_traffic_sources(
    hostel_id: Optional[UUID] = Query(None, description="Optional hostel filter"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> TrafficSourceAnalytics:
    """
    Return per-source traffic and conversion analytics.
    """
    service = VisitorAnalyticsService(uow)
    try:
        return service.get_traffic_sources(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/behavior/{visitor_id}",
    response_model=VisitorBehaviorAnalyticsSchema,
    summary="Get aggregated behavior analytics for a visitor",
)
async def get_visitor_behavior(
    visitor_id: UUID = Path(..., description="Visitor ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> VisitorBehaviorAnalyticsSchema:
    """
    Return aggregated behavior metrics for a specific visitor.
    """
    service = VisitorAnalyticsService(uow)
    try:
        return service.get_visitor_behavior(visitor_id=visitor_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\analytics\__init__.py ---
from __future__ import annotations

from fastapi import APIRouter

from . import dashboard
from . import financial
from . import occupancy
from . import complaints
from . import visitors
from . import bookings
from . import supervisors
from . import platform
from . import custom

router = APIRouter(prefix="/analytics")

router.include_router(dashboard.router, tags=["Analytics - Dashboard"])
router.include_router(financial.router, tags=["Analytics - Financial"])
router.include_router(occupancy.router, tags=["Analytics - Occupancy"])
router.include_router(complaints.router, tags=["Analytics - Complaints"])
router.include_router(visitors.router, tags=["Analytics - Visitors"])
router.include_router(bookings.router, tags=["Analytics - Bookings"])
router.include_router(supervisors.router, tags=["Analytics - Supervisors"])
router.include_router(platform.router, tags=["Analytics - Platform"])
router.include_router(custom.router, tags=["Analytics - Custom Reports"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\analytics\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\announcements =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\announcements\announcements.py ---
# api/v1/announcements/announcements.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.announcement.announcement_base import AnnouncementCreate, AnnouncementUpdate
from app.schemas.announcement.announcement_response import (
    AnnouncementDetail,
    AnnouncementList,
)
from app.schemas.announcement.announcement_filters import (
    AnnouncementFilterParams,
    ArchiveRequest,
)
from app.schemas.common.response import BulkOperationResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.announcement import AnnouncementService

router = APIRouter(prefix="/announcements")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/",
    response_model=AnnouncementList,
    summary="List announcements",
)
async def list_announcements(
    filters: AnnouncementFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> AnnouncementList:
    """
    List announcements using filter/search parameters.

    Typical filters include hostel, category, priority, publish state, and date range.
    """
    service = AnnouncementService(uow)
    try:
        return service.list_announcements(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/",
    response_model=AnnouncementDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new announcement",
)
async def create_announcement(
    payload: AnnouncementCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> AnnouncementDetail:
    """
    Create a new announcement.

    Handles targeting, scheduling fields, and initial publish flags as part
    of the create payload.
    """
    service = AnnouncementService(uow)
    try:
        return service.create_announcement(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}",
    response_model=AnnouncementDetail,
    summary="Get announcement details",
)
async def get_announcement(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AnnouncementDetail:
    """
    Retrieve full details for a single announcement.
    """
    service = AnnouncementService(uow)
    try:
        return service.get_announcement(announcement_id=announcement_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{announcement_id}",
    response_model=AnnouncementDetail,
    summary="Update an announcement",
)
async def update_announcement(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: AnnouncementUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AnnouncementDetail:
    """
    Partially update announcement fields (content, category, priority, targeting,
    scheduling, publish flags, etc.).
    """
    service = AnnouncementService(uow)
    try:
        return service.update_announcement(
            announcement_id=announcement_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/archive",
    response_model=BulkOperationResponse,
    summary="Archive announcements in bulk",
)
async def archive_announcements(
    payload: ArchiveRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> BulkOperationResponse:
    """
    Archive announcements based on the supplied criteria.

    Typically used to bulk-archive old or expired announcements.
    """
    service = AnnouncementService(uow)
    try:
        return service.archive_announcements(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\announcements\approval.py ---
# api/v1/announcements/approval.py
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.announcement.announcement_approval import (
    ApprovalRequest,
    ApprovalResponse,
    RejectionRequest,
    ApprovalWorkflow,
    SupervisorApprovalQueue,
    BulkApproval,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.announcement import AnnouncementService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/{announcement_id}/approval/request",
    response_model=ApprovalWorkflow,
    status_code=status.HTTP_200_OK,
    summary="Request approval for an announcement",
)
async def request_approval(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: ApprovalRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalWorkflow:
    """
    Mark an announcement as requiring approval and create/update its approval workflow.
    """
    service = AnnouncementService(uow)
    try:
        return service.request_approval(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{announcement_id}/approval/approve",
    response_model=ApprovalResponse,
    summary="Approve an announcement",
)
async def approve_announcement(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: ApprovalRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalResponse:
    """
    Approve an announcement (typically by a supervisor/admin).
    """
    service = AnnouncementService(uow)
    try:
        return service.approve_announcement(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{announcement_id}/approval/reject",
    response_model=ApprovalResponse,
    summary="Reject an announcement",
)
async def reject_announcement(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: RejectionRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalResponse:
    """
    Reject an announcement with a structured rejection reason and notes.
    """
    service = AnnouncementService(uow)
    try:
        return service.reject_announcement(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/approvals/pending",
    response_model=SupervisorApprovalQueue,
    summary="List pending announcement approvals",
)
async def list_pending_approvals(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    approver_id: Optional[UUID] = Query(
        None,
        description="Optional approver/supervisor filter",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorApprovalQueue:
    """
    List pending announcement approvals, typically grouped by approver/supervisor.
    """
    service = AnnouncementService(uow)
    try:
        return service.list_pending_approvals(
            hostel_id=hostel_id,
            approver_id=approver_id,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/approvals/bulk",
    response_model=List[ApprovalResponse],
    summary="Bulk approve/reject announcements",
)
async def bulk_approve_announcements(
    payload: BulkApproval,
    uow: UnitOfWork = Depends(get_uow),
) -> List[ApprovalResponse]:
    """
    Bulk approval/rejection of multiple announcements in one call.
    """
    service = AnnouncementService(uow)
    try:
        return service.bulk_approve(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\announcements\delivery.py ---
# api/v1/announcements/delivery.py
from __future__ import annotations

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api import deps
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.announcement.announcement_delivery import (
    DeliveryConfig,
    DeliveryStatus,
    DeliveryReport,
    RetryDelivery,
    BatchDelivery,
)
from app.services.announcement import AnnouncementDeliveryService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/{announcement_id}/delivery/config",
    response_model=DeliveryConfig,
    summary="Get delivery configuration for an announcement",
)
async def get_delivery_config(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    delivery_service: Annotated[
        AnnouncementDeliveryService,
        Depends(deps.get_announcement_delivery_service),
    ] = ...,  # type: ignore[assignment]
) -> DeliveryConfig:
    """
    Return the delivery configuration (channels, batching, etc.) for an announcement.
    """
    try:
        return delivery_service.get_config(announcement_id=announcement_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/{announcement_id}/delivery/config",
    response_model=DeliveryConfig,
    summary="Update delivery configuration for an announcement",
)
async def update_delivery_config(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: DeliveryConfig = ...,
    delivery_service: Annotated[
        AnnouncementDeliveryService,
        Depends(deps.get_announcement_delivery_service),
    ] = ...,  # type: ignore[assignment]
) -> DeliveryConfig:
    """
    Update the delivery configuration (channels, batching strategy, etc.) for an announcement.
    """
    try:
        return delivery_service.update_config(
            announcement_id=announcement_id,
            config=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}/delivery/status",
    response_model=DeliveryStatus,
    summary="Get delivery status for an announcement",
)
async def get_delivery_status(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    delivery_service: Annotated[
        AnnouncementDeliveryService,
        Depends(deps.get_announcement_delivery_service),
    ] = ...,  # type: ignore[assignment]
) -> DeliveryStatus:
    """
    Return high-level delivery status across channels (queued, in-progress, completed, failed).
    """
    try:
        return delivery_service.get_status(announcement_id=announcement_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}/delivery/report",
    response_model=DeliveryReport,
    summary="Get detailed delivery report for an announcement",
)
async def get_delivery_report(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    delivery_service: Annotated[
        AnnouncementDeliveryService,
        Depends(deps.get_announcement_delivery_service),
    ] = ...,  # type: ignore[assignment]
) -> DeliveryReport:
    """
    Return a delivery report with per-channel stats, failed deliveries, and other metadata.
    """
    try:
        return delivery_service.get_report(announcement_id=announcement_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{announcement_id}/delivery/retry",
    response_model=BatchDelivery,
    status_code=status.HTTP_200_OK,
    summary="Retry failed deliveries for an announcement",
)
async def retry_failed_deliveries(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: RetryDelivery = ...,
    delivery_service: Annotated[
        AnnouncementDeliveryService,
        Depends(deps.get_announcement_delivery_service),
    ] = ...,  # type: ignore[assignment]
) -> BatchDelivery:
    """
    Retry failed deliveries for an announcement, possibly limited to selected channels or
    recipient subsets.
    """
    try:
        return delivery_service.retry_failed(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\announcements\scheduling.py ---
# api/v1/announcements/scheduling.py
from __future__ import annotations

from datetime import date as Date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.announcement.announcement_scheduling import (
    ScheduleRequest,
    ScheduleUpdate,
    ScheduleCancel,
    PublishNow,
    ScheduleConfig,
    ScheduledAnnouncementsList,
)
from app.schemas.announcement.announcement_response import AnnouncementDetail
from app.services.common.unit_of_work import UnitOfWork
from app.services.announcement import AnnouncementService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/{announcement_id}/schedule",
    response_model=ScheduleConfig,
    status_code=status.HTTP_200_OK,
    summary="Schedule an announcement",
)
async def schedule_announcement(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: ScheduleRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ScheduleConfig:
    """
    Schedule a single announcement with optional expiry and recurrence.
    """
    service = AnnouncementService(uow)
    try:
        return service.schedule_announcement(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{announcement_id}/schedule",
    response_model=ScheduleConfig,
    summary="Update announcement schedule",
)
async def update_announcement_schedule(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: ScheduleUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ScheduleConfig:
    """
    Update scheduling details (publish time, expiry, recurrence) for an announcement.
    """
    service = AnnouncementService(uow)
    try:
        return service.update_schedule(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{announcement_id}/schedule/cancel",
    response_model=ScheduleConfig,
    summary="Cancel announcement schedule",
)
async def cancel_announcement_schedule(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: ScheduleCancel = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ScheduleConfig:
    """
    Cancel the active schedule for an announcement (the announcement itself is
    not deleted).
    """
    service = AnnouncementService(uow)
    try:
        return service.cancel_schedule(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{announcement_id}/publish-now",
    response_model=AnnouncementDetail,
    summary="Publish an announcement immediately",
)
async def publish_now(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: PublishNow = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AnnouncementDetail:
    """
    Publish an announcement immediately, bypassing any future scheduled publish time.
    """
    service = AnnouncementService(uow)
    try:
        return service.publish_now(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/scheduled",
    response_model=ScheduledAnnouncementsList,
    summary="List scheduled announcements",
)
async def list_scheduled_announcements(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    start_date: Optional[Date] = Query(
        None,
        description="Optional start of Date window (inclusive)",
    ),
    end_date: Optional[Date] = Query(
        None,
        description="Optional end of Date window (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> ScheduledAnnouncementsList:
    """
    List upcoming scheduled announcements, optionally filtered by hostel and Date range.
    """
    service = AnnouncementService(uow)
    try:
        return service.list_scheduled_announcements(
            hostel_id=hostel_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\announcements\targeting.py ---
# api/v1/announcements/targeting.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.announcement.announcement_targeting import (
    TargetingConfig,
    TargetingSummary,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.announcement import AnnouncementService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/{announcement_id}/targeting",
    response_model=TargetingConfig,
    summary="Get audience targeting configuration for an announcement",
)
async def get_targeting_config(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> TargetingConfig:
    """
    Fetch the current audience targeting configuration for a given announcement.
    """
    service = AnnouncementService(uow)
    try:
        return service.get_targeting_config(announcement_id=announcement_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/{announcement_id}/targeting",
    response_model=TargetingConfig,
    summary="Update audience targeting for an announcement",
)
async def update_targeting_config(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: TargetingConfig = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> TargetingConfig:
    """
    Replace the audience targeting configuration for an announcement.

    The service is expected to recompute derived counts as needed.
    """
    service = AnnouncementService(uow)
    try:
        return service.update_targeting_config(
            announcement_id=announcement_id,
            config=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}/targeting/summary",
    response_model=TargetingSummary,
    summary="Get targeting summary for an announcement",
)
async def get_targeting_summary(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> TargetingSummary:
    """
    Return a summary of the targeted audience: total recipients and breakdown
    by audience segments (rooms, floors, students, etc.).
    """
    service = AnnouncementService(uow)
    try:
        return service.get_targeting_summary(announcement_id=announcement_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\announcements\tracking.py ---
# api/v1/announcements/tracking.py
from __future__ import annotations

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api import deps
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.announcement.announcement_tracking import (
    ReadReceipt,
    AcknowledgmentRequest,
    AcknowledgmentTracking,
    PendingAcknowledgment,
    EngagementMetrics,
    AnnouncementAnalytics,
)
from app.services.announcement import AnnouncementTrackingService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/{announcement_id}/read",
    response_model=ReadReceipt,
    status_code=status.HTTP_200_OK,
    summary="Record a read receipt for an announcement",
)
async def record_read_receipt(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: ReadReceipt = ...,
    tracking_service: Annotated[
        AnnouncementTrackingService,
        Depends(deps.get_announcement_tracking_service),
    ] = ...,  # type: ignore[assignment]
) -> ReadReceipt:
    """
    Record that a recipient has read the announcement (for engagement tracking).
    """
    try:
        return tracking_service.record_read_receipt(
            announcement_id=announcement_id,
            receipt=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{announcement_id}/acknowledge",
    response_model=AcknowledgmentTracking,
    status_code=status.HTTP_200_OK,
    summary="Record an acknowledgment for an announcement",
)
async def acknowledge_announcement(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: AcknowledgmentRequest = ...,
    tracking_service: Annotated[
        AnnouncementTrackingService,
        Depends(deps.get_announcement_tracking_service),
    ] = ...,  # type: ignore[assignment]
) -> AcknowledgmentTracking:
    """
    Record a formal acknowledgment from a recipient for an announcement.
    """
    try:
        return tracking_service.record_acknowledgment(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}/acknowledgments/pending",
    response_model=PendingAcknowledgment,
    summary="Get pending acknowledgments for an announcement",
)
async def get_pending_acknowledgments(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    tracking_service: Annotated[
        AnnouncementTrackingService,
        Depends(deps.get_announcement_tracking_service),
    ] = ...,  # type: ignore[assignment]
) -> PendingAcknowledgment:
    """
    Return information about recipients who have not yet acknowledged the announcement.
    """
    try:
        return tracking_service.get_pending_acknowledgments(
            announcement_id=announcement_id,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}/engagement",
    response_model=EngagementMetrics,
    summary="Get engagement metrics for an announcement",
)
async def get_engagement_metrics(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    tracking_service: Annotated[
        AnnouncementTrackingService,
        Depends(deps.get_announcement_tracking_service),
    ] = ...,  # type: ignore[assignment]
) -> EngagementMetrics:
    """
    Return engagement metrics such as open/read rates, acknowledgment rates,
    and basic reading-time statistics.
    """
    try:
        return tracking_service.get_engagement_metrics(
            announcement_id=announcement_id,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}/analytics",
    response_model=AnnouncementAnalytics,
    summary="Get full analytics for an announcement",
)
async def get_announcement_analytics(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    tracking_service: Annotated[
        AnnouncementTrackingService,
        Depends(deps.get_announcement_tracking_service),
    ] = ...,  # type: ignore[assignment]
) -> AnnouncementAnalytics:
    """
    Return comprehensive analytics for an announcement, combining delivery and
    engagement data.
    """
    try:
        return tracking_service.get_announcement_analytics(
            announcement_id=announcement_id,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\announcements\__init__.py ---
# api/v1/announcements/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import announcements
from . import targeting
from . import scheduling
from . import approval
from . import delivery
from . import tracking

router = APIRouter(prefix="/announcements")

router.include_router(announcements.router, tags=["Announcements - Core"])
router.include_router(targeting.router, tags=["Announcements - Targeting"])
router.include_router(scheduling.router, tags=["Announcements - Scheduling"])
router.include_router(approval.router, tags=["Announcements - Approval"])
router.include_router(delivery.router, tags=["Announcements - Delivery"])
router.include_router(tracking.router, tags=["Announcements - Tracking"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\announcements\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\attendance =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\attendance\alerts.py ---
# api/v1/attendance/alerts.py
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.attendance.attendance_alert import (
    AlertConfig,
    AlertTrigger,
    AttendanceAlert,
    AlertAcknowledgment,
    AlertList,
    AlertSummary,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.attendance import AttendanceAlertService

router = APIRouter(prefix="/alerts")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/config/{hostel_id}",
    response_model=AlertConfig,
    summary="Get attendance alert configuration for a hostel",
)
async def get_alert_config(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AlertConfig:
    """
    Fetch the alert configuration (thresholds, channels, patterns) for a hostel.
    """
    service = AttendanceAlertService(uow)
    try:
        return service.get_alert_config(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/config/{hostel_id}",
    response_model=AlertConfig,
    summary="Update attendance alert configuration for a hostel",
)
async def update_alert_config(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: AlertConfig = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AlertConfig:
    """
    Update the alert configuration for a hostel.
    """
    service = AttendanceAlertService(uow)
    try:
        return service.update_alert_config(
            hostel_id=hostel_id,
            config=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/trigger",
    response_model=AttendanceAlert,
    status_code=status.HTTP_201_CREATED,
    summary="Trigger an attendance alert manually",
)
async def trigger_alert(
    payload: AlertTrigger,
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceAlert:
    """
    Manually trigger an attendance alert (e.g., low attendance, anomaly).
    """
    service = AttendanceAlertService(uow)
    try:
        return service.trigger_alert(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{alert_id}/acknowledge",
    response_model=AlertAcknowledgment,
    status_code=status.HTTP_200_OK,
    summary="Acknowledge an attendance alert",
)
async def acknowledge_alert(
    alert_id: UUID = Path(..., description="Alert ID"),
    payload: AlertAcknowledgment = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AlertAcknowledgment:
    """
    Acknowledge that an alert has been seen/handled.
    """
    service = AttendanceAlertService(uow)
    try:
        return service.acknowledge_alert(
            alert_id=alert_id,
            acknowledgment=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/",
    response_model=AlertList,
    summary="List attendance alerts",
)
async def list_alerts(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> AlertList:
    """
    List attendance alerts, optionally filtered by hostel.
    """
    service = AttendanceAlertService(uow)
    try:
        return service.list_alerts(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/summary",
    response_model=AlertSummary,
    summary="Get attendance alert summary",
)
async def get_alert_summary(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> AlertSummary:
    """
    Get summarized statistics for attendance alerts (counts, types, trends).
    """
    service = AttendanceAlertService(uow)
    try:
        return service.get_alert_summary(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\attendance\attendance.py ---
# api/v1/attendance/attendance.py
from __future__ import annotations

from datetime import date as Date
from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.attendance.attendance_base import AttendanceCreate, AttendanceUpdate
from app.schemas.attendance.attendance_response import (
    AttendanceResponse,
    AttendanceDetail,
    DailyAttendanceSummary,
)
from app.schemas.attendance.attendance_filters import AttendanceFilterParams
from app.services.common.unit_of_work import UnitOfWork
from app.services.attendance import AttendanceService

router = APIRouter(prefix="/records")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/",
    response_model=List[AttendanceResponse],
    summary="List attendance records",
)
async def list_attendance_records(
    filters: AttendanceFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> List[AttendanceResponse]:
    """
    List attendance records using filters (hostel, student, Date range, status, mode, etc.).
    """
    service = AttendanceService(uow)
    try:
        return service.list_attendance(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/",
    response_model=AttendanceDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create an attendance record",
)
async def create_attendance_record(
    payload: AttendanceCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceDetail:
    """
    Create a single attendance record.
    """
    service = AttendanceService(uow)
    try:
        return service.create_attendance(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{attendance_id}",
    response_model=AttendanceDetail,
    summary="Get attendance record details",
)
async def get_attendance_record(
    attendance_id: UUID = Path(..., description="Attendance record ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceDetail:
    """
    Retrieve full details for a specific attendance record.
    """
    service = AttendanceService(uow)
    try:
        return service.get_attendance(attendance_id=attendance_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{attendance_id}",
    response_model=AttendanceDetail,
    summary="Update an attendance record",
)
async def update_attendance_record(
    attendance_id: UUID = Path(..., description="Attendance record ID"),
    payload: AttendanceUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceDetail:
    """
    Partially update an attendance record (times, status, notes, etc.).
    """
    service = AttendanceService(uow)
    try:
        return service.update_attendance(
            attendance_id=attendance_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/summary",
    response_model=DailyAttendanceSummary,
    summary="Get daily attendance summary for a hostel",
)
async def get_daily_hostel_summary(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    day: Date = Query(..., description="Date for the summary (YYYY-MM-DD)"),
    uow: UnitOfWork = Depends(get_uow),
) -> DailyAttendanceSummary:
    """
    Get summarized attendance statistics for a hostel on a specific day.
    """
    service = AttendanceService(uow)
    try:
        return service.get_daily_summary(
            hostel_id=hostel_id,
            day=day,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\attendance\bulk.py ---
# api/v1/attendance/bulk.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.attendance.attendance_base import BulkAttendanceCreate
from app.schemas.common.response import BulkOperationResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.attendance import AttendanceService

router = APIRouter(prefix="/bulk")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/create",
    response_model=BulkOperationResponse,
    status_code=status.HTTP_200_OK,
    summary="Bulk create attendance records",
)
async def bulk_create_attendance(
    payload: BulkAttendanceCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> BulkOperationResponse:
    """
    Bulk-create attendance records from a structured list of records.
    """
    service = AttendanceService(uow)
    try:
        return service.bulk_create_attendance(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\attendance\policy.py ---
# api/v1/attendance/policy.py
from __future__ import annotations

from datetime import date as Date
from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.attendance.attendance_policy import (
    AttendancePolicy,
    PolicyUpdate,
    PolicyViolation,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.attendance import AttendancePolicyService

router = APIRouter(prefix="/policy")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/hostels/{hostel_id}",
    response_model=AttendancePolicy,
    summary="Get attendance policy for a hostel",
)
async def get_attendance_policy(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AttendancePolicy:
    """
    Fetch the current attendance policy configuration for a hostel.
    """
    service = AttendancePolicyService(uow)
    try:
        return service.get_policy(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/hostels/{hostel_id}",
    response_model=AttendancePolicy,
    summary="Update attendance policy for a hostel",
)
async def update_attendance_policy(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: PolicyUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AttendancePolicy:
    """
    Update the attendance policy for a hostel.
    """
    service = AttendancePolicyService(uow)
    try:
        return service.update_policy(
            hostel_id=hostel_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/students/{student_id}/violations",
    response_model=List[PolicyViolation],
    summary="Evaluate policy violations for a student",
)
async def get_policy_violations_for_student(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    student_id: UUID = Path(..., description="Student ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> List[PolicyViolation]:
    """
    Evaluate attendance policy violations for a student over a given period.
    """
    service = AttendancePolicyService(uow)
    try:
        return service.evaluate_violations(
            hostel_id=hostel_id,
            student_id=student_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\attendance\record.py ---
# api/v1/attendance/record.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.attendance.attendance_record import (
    AttendanceRecordRequest,
    BulkAttendanceRequest,
    AttendanceCorrection,
    QuickAttendanceMarkAll,
)
from app.schemas.attendance.attendance_response import AttendanceDetail
from app.schemas.common.response import BulkOperationResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.attendance import AttendanceService

router = APIRouter(prefix="/mark")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/single",
    response_model=AttendanceDetail,
    status_code=status.HTTP_200_OK,
    summary="Mark attendance for a single student",
)
async def mark_single_attendance(
    payload: AttendanceRecordRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceDetail:
    """
    Mark attendance for a single student on a given day.
    """
    service = AttendanceService(uow)
    try:
        return service.mark_attendance(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=BulkOperationResponse,
    status_code=status.HTTP_200_OK,
    summary="Bulk mark attendance",
)
async def bulk_mark_attendance(
    payload: BulkAttendanceRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> BulkOperationResponse:
    """
    Bulk mark attendance for many students in one call.
    """
    service = AttendanceService(uow)
    try:
        return service.bulk_mark_attendance(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/correction",
    response_model=AttendanceDetail,
    status_code=status.HTTP_200_OK,
    summary="Correct an existing attendance record",
)
async def correct_attendance(
    payload: AttendanceCorrection,
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceDetail:
    """
    Apply a correction to an existing attendance record (status/time updates, etc.).
    """
    service = AttendanceService(uow)
    try:
        return service.correct_attendance(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/mark-all",
    response_model=BulkOperationResponse,
    status_code=status.HTTP_200_OK,
    summary="Quick mark all present with exceptions",
)
async def quick_mark_all(
    payload: QuickAttendanceMarkAll,
    uow: UnitOfWork = Depends(get_uow),
) -> BulkOperationResponse:
    """
    Quickly mark all students present, with specific exceptions (absent/late/etc.).
    """
    service = AttendanceService(uow)
    try:
        return service.quick_mark_all(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\attendance\reports.py ---
# api/v1/attendance/reports.py
from __future__ import annotations

from datetime import date as Date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.attendance.attendance_report import (
    AttendanceReport,
    MonthlyReport,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.attendance import AttendanceReportService

router = APIRouter(prefix="/reports")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/students/{student_id}",
    response_model=AttendanceReport,
    summary="Get attendance report for a student",
)
async def get_student_attendance_report(
    student_id: UUID = Path(..., description="Student ID"),
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceReport:
    """
    Generate a detailed attendance report for a student in a hostel over a period.
    """
    service = AttendanceReportService(uow)
    try:
        return service.get_student_report(
            student_id=student_id,
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/monthly",
    response_model=MonthlyReport,
    summary="Get monthly hostel attendance report",
)
async def get_hostel_monthly_attendance_report(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    year: int = Query(..., ge=2000, description="Year (e.g. 2025)"),
    month: int = Query(..., ge=1, le=12, description="Month (1-12)"),
    uow: UnitOfWork = Depends(get_uow),
) -> MonthlyReport:
    """
    Generate a monthly attendance report for a hostel, aggregated across students.
    """
    service = AttendanceReportService(uow)
    try:
        return service.get_hostel_monthly_report(
            hostel_id=hostel_id,
            year=year,
            month=month,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\attendance\__init__.py ---
# api/v1/attendance/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import attendance
from . import record
from . import bulk
from . import reports
from . import policy
from . import alerts

router = APIRouter(prefix="/attendance")

router.include_router(attendance.router, tags=["Attendance - Records"])
router.include_router(record.router, tags=["Attendance - Marking"])
router.include_router(bulk.router, tags=["Attendance - Bulk"])
router.include_router(reports.router, tags=["Attendance - Reports"])
router.include_router(policy.router, tags=["Attendance - Policy"])
router.include_router(alerts.router, tags=["Attendance - Alerts"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\attendance\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\audit =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\audit\activity.py ---
# api/v1/audit/activity.py
from __future__ import annotations

from datetime import date as Date
from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.audit.supervisor_activity_log import (
    SupervisorActivityCreate,
    SupervisorActivityLogResponse,
    SupervisorActivityDetail,
    SupervisorActivityFilter,
    SupervisorActivitySummary,
    SupervisorActivityTimelinePoint,
)
from app.schemas.common.pagination import PaginatedResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.audit import SupervisorActivityService

router = APIRouter(prefix="/activity")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/",
    response_model=SupervisorActivityDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Log supervisor activity",
)
async def log_supervisor_activity(
    payload: SupervisorActivityCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorActivityDetail:
    """
    Create a new supervisor activity log entry.
    """
    service = SupervisorActivityService(uow)
    try:
        return service.log_activity(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/",
    response_model=PaginatedResponse[SupervisorActivityLogResponse],
    summary="List supervisor activity logs",
)
async def list_supervisor_activity(
    filters: SupervisorActivityFilter = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[SupervisorActivityLogResponse]:
    """
    List supervisor activity logs with filters (hostel, supervisor, category, Date range)
    and pagination.
    """
    service = SupervisorActivityService(uow)
    try:
        return service.list_activity(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{activity_id}",
    response_model=SupervisorActivityDetail,
    summary="Get supervisor activity details",
)
async def get_supervisor_activity(
    activity_id: UUID = Path(..., description="Supervisor activity log ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorActivityDetail:
    """
    Retrieve details for a specific supervisor activity log entry.
    """
    service = SupervisorActivityService(uow)
    try:
        return service.get_activity(activity_id=activity_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/summary",
    response_model=SupervisorActivitySummary,
    summary="Get supervisor activity summary",
)
async def get_supervisor_activity_summary(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Filter by hostel ID",
    ),
    supervisor_id: Optional[UUID] = Query(
        None,
        description="Filter by supervisor ID",
    ),
    start_date: Optional[Date] = Query(
        None,
        description="Start Date (inclusive)",
    ),
    end_date: Optional[Date] = Query(
        None,
        description="End Date (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorActivitySummary:
    """
    Summarize supervisor activity over a period (counts, categories, types, etc.).
    """
    service = SupervisorActivityService(uow)
    try:
        return service.get_summary(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/timeline",
    response_model=List[SupervisorActivityTimelinePoint],
    summary="Get supervisor activity timeline",
)
async def get_supervisor_activity_timeline(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Filter by hostel ID",
    ),
    supervisor_id: Optional[UUID] = Query(
        None,
        description="Filter by supervisor ID",
    ),
    start_date: Optional[Date] = Query(
        None,
        description="Start Date (inclusive)",
    ),
    end_date: Optional[Date] = Query(
        None,
        description="End Date (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> List[SupervisorActivityTimelinePoint]:
    """
    Return timeline points for supervisor activity for visualization/analysis.
    """
    service = SupervisorActivityService(uow)
    try:
        return service.get_timeline(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\audit\logs.py ---
# api/v1/audit/logs.py
from __future__ import annotations

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.audit.audit_log_base import AuditLogCreate
from app.schemas.audit.audit_log_response import AuditLogResponse, AuditLogDetail
from app.schemas.audit.audit_filters import AuditFilterParams
from app.schemas.audit.audit_reports import EntityChangeHistory
from app.schemas.common.pagination import PaginatedResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.audit import AuditLogService, EntityHistoryService

router = APIRouter(prefix="/logs")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/",
    response_model=AuditLogDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create an audit log entry",
)
async def create_audit_log(
    payload: AuditLogCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> AuditLogDetail:
    """
    Create a new audit log entry.

    In most cases, business services log actions internally, but this endpoint
    can be used for manual/debug logging or integrations.
    """
    service = AuditLogService(uow)
    try:
        return service.log_action(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/",
    response_model=PaginatedResponse[AuditLogResponse],
    summary="List audit logs with filters",
)
async def list_audit_logs(
    filters: AuditFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[AuditLogResponse]:
    """
    List audit logs with flexible filters (user, role, hostel, entity, action, time range)
    and pagination parameters.
    """
    service = AuditLogService(uow)
    try:
        return service.list_logs(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{log_id}",
    response_model=AuditLogDetail,
    summary="Get audit log details",
)
async def get_audit_log(
    log_id: UUID = Path(..., description="Audit log ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AuditLogDetail:
    """
    Retrieve detailed information for a single audit log entry.
    """
    service = AuditLogService(uow)
    try:
        return service.get_log(log_id=log_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/entity/{entity_type}/{entity_id}/history",
    response_model=EntityChangeHistory,
    summary="Get change history for an entity",
)
async def get_entity_change_history(
    entity_type: str = Path(..., description="Entity type (e.g. hostel, student, complaint)"),
    entity_id: UUID = Path(..., description="Entity ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> EntityChangeHistory:
    """
    Build a change history for a specific entity from its audit log entries.
    """
    service = EntityHistoryService(uow)
    try:
        return service.get_entity_history(
            entity_type=entity_type,
            entity_id=entity_id,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\audit\overrides.py ---
# api/v1/audit/overrides.py
from __future__ import annotations

from datetime import date as Date
from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.audit.admin_override_log import (
    AdminOverrideLogResponse,
    AdminOverrideDetail,
    AdminOverrideSummary,
    AdminOverrideTimelinePoint,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.audit import AdminOverrideAuditService

router = APIRouter(prefix="/overrides")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/",
    response_model=List[AdminOverrideLogResponse],
    summary="List admin overrides (audit)",
)
async def list_admin_overrides(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Filter by hostel ID",
    ),
    supervisor_id: Optional[UUID] = Query(
        None,
        description="Filter by supervisor ID",
    ),
    entity_type: Optional[str] = Query(
        None,
        description="Filter by entity type (complaint, maintenance, leave, etc.)",
    ),
    entity_id: Optional[UUID] = Query(
        None,
        description="Filter by entity ID",
    ),
    start_date: Optional[Date] = Query(
        None,
        description="Start Date (inclusive)",
    ),
    end_date: Optional[Date] = Query(
        None,
        description="End Date (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> List[AdminOverrideLogResponse]:
    """
    List admin overrides with optional filters for hostel, supervisor, entity, and period.
    """
    service = AdminOverrideAuditService(uow)
    try:
        return service.list_overrides(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            entity_type=entity_type,
            entity_id=entity_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{override_id}",
    response_model=AdminOverrideDetail,
    summary="Get admin override details",
)
async def get_admin_override(
    override_id: UUID = Path(..., description="Override record ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AdminOverrideDetail:
    """
    Retrieve a detailed view of a specific admin override record.
    """
    service = AdminOverrideAuditService(uow)
    try:
        return service.get_override_detail(override_id=override_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/summary",
    response_model=AdminOverrideSummary,
    summary="Get summary of admin overrides",
)
async def get_admin_override_summary(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Filter by hostel ID",
    ),
    supervisor_id: Optional[UUID] = Query(
        None,
        description="Filter by supervisor ID",
    ),
    start_date: Optional[Date] = Query(
        None,
        description="Start Date (inclusive)",
    ),
    end_date: Optional[Date] = Query(
        None,
        description="End Date (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> AdminOverrideSummary:
    """
    Summarize admin overrides over a period, grouped by type, hostel, and supervisor.
    """
    service = AdminOverrideAuditService(uow)
    try:
        return service.get_summary(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/timeline",
    response_model=List[AdminOverrideTimelinePoint],
    summary="Get admin override timeline",
)
async def get_admin_override_timeline(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Filter by hostel ID",
    ),
    supervisor_id: Optional[UUID] = Query(
        None,
        description="Filter by supervisor ID",
    ),
    start_date: Optional[Date] = Query(
        None,
        description="Start Date (inclusive)",
    ),
    end_date: Optional[Date] = Query(
        None,
        description="End Date (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> List[AdminOverrideTimelinePoint]:
    """
    Return a timeline of admin overrides across a period for visualization/analysis.
    """
    service = AdminOverrideAuditService(uow)
    try:
        return service.get_timeline(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\audit\reports.py ---
# api/v1/audit/reports.py
from __future__ import annotations

from datetime import date as Date
from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.audit.audit_reports import (
    AuditReport,
    UserActivitySummary,
    EntityChangeSummary,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.reporting import AuditReportingService

router = APIRouter(prefix="/reports")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/",
    response_model=AuditReport,
    summary="Get overall audit report",
)
async def get_audit_report(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    user_id: Optional[UUID] = Query(
        None,
        description="Optional user filter",
    ),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> AuditReport:
    """
    Return an overall audit report for the given period, aggregating audit logs,
    overrides, and supervisor activities by entity type and category.
    """
    service = AuditReportingService(uow)
    try:
        return service.get_audit_report(
            hostel_id=hostel_id,
            user_id=user_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/user-activity",
    response_model=UserActivitySummary,
    summary="Get user activity summary",
)
async def get_user_activity_summary(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    user_id: Optional[UUID] = Query(
        None,
        description="User ID to summarize activity for",
    ),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> UserActivitySummary:
    """
    Summarize user activity over a period (counts of actions, categories, etc.).
    """
    service = AuditReportingService(uow)
    try:
        return service.get_user_activity_summary(
            hostel_id=hostel_id,
            user_id=user_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/entities",
    response_model=List[EntityChangeSummary],
    summary="Get entity change summaries",
)
async def get_entity_change_summaries(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    entity_type: Optional[str] = Query(
        None,
        description="Optional entity type filter (hostel, room, student, etc.)",
    ),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> List[EntityChangeSummary]:
    """
    Summarize changes per entity type over a period (counts, categories).
    """
    service = AuditReportingService(uow)
    try:
        return service.get_entity_change_summaries(
            hostel_id=hostel_id,
            entity_type=entity_type,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\audit\__init__.py ---
# api/v1/audit/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import logs
from . import overrides
from . import activity
from . import reports

router = APIRouter(prefix="/audit")

router.include_router(logs.router, tags=["Audit - Logs"])
router.include_router(overrides.router, tags=["Audit - Admin Overrides"])
router.include_router(activity.router, tags=["Audit - Supervisor Activity"])
router.include_router(reports.router, tags=["Audit - Reports"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\audit\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\auth =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\auth\login.py ---
# app/api/v1/auth/login.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.core.exceptions import AppError, ValidationError, NotFoundError, ConflictError
from app.schemas.auth import LoginRequest, LoginResponse
from app.services.common import UnitOfWork
from app.services.auth import AuthService

router = APIRouter(prefix="/auth", tags=["Auth"])


def get_uow(session: Session = Depends(get_session)) -> UnitOfWork:
    """Provide a UnitOfWork bound to the current DB session."""
    return UnitOfWork(session)


def get_auth_service(uow: UnitOfWork = Depends(get_uow)) -> AuthService:
    """Provide AuthService instance."""
    return AuthService(uow)


def _handle_service_error(exc: AppError) -> HTTPException:
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(exc),
        )
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail="Internal server error",
    )


@router.post("/login", response_model=LoginResponse)
def login(
    payload: LoginRequest,
    service: AuthService = Depends(get_auth_service),
) -> LoginResponse:
    """
    Authenticate a user using email/phone + password and return access/refresh tokens
    plus basic user info.
    """
    try:
        # Adjust method name/signature if your AuthService differs.
        return service.login(payload)
    except AppError as exc:
        raise _handle_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\auth\otp.py ---
# app/api/v1/auth/otp.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.core.exceptions import AppError, ValidationError, NotFoundError
from app.schemas.auth import (
    OTPGenerateRequest,
    OTPVerifyRequest,
    OTPResponse,
    OTPVerifyResponse,
)
from app.services.common import UnitOfWork
from app.services.auth import OTPService

router = APIRouter(prefix="/auth", tags=["Auth"])


def get_uow(session: Session = Depends(get_session)) -> UnitOfWork:
    return UnitOfWork(session)


def get_otp_service(uow: UnitOfWork = Depends(get_uow)) -> OTPService:
    return OTPService(uow)


def _handle_service_error(exc: AppError) -> HTTPException:
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(exc),
        )
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail="Internal server error",
    )


@router.post("/otp/send", response_model=OTPResponse, status_code=status.HTTP_200_OK)
def send_otp(
    payload: OTPGenerateRequest,
    service: OTPService = Depends(get_otp_service),
) -> OTPResponse:
    """
    Generate and send an OTP for a given identifier (email/phone) and purpose.
    """
    try:
        # Adjust method name/signature if your OTPService differs.
        return service.generate_otp(payload)
    except AppError as exc:
        raise _handle_service_error(exc)


@router.post("/otp/verify", response_model=OTPVerifyResponse, status_code=status.HTTP_200_OK)
def verify_otp(
    payload: OTPVerifyRequest,
    service: OTPService = Depends(get_otp_service),
) -> OTPVerifyResponse:
    """
    Verify a previously sent OTP.
    """
    try:
        # Adjust method name/signature if your OTPService differs.
        return service.verify_otp(payload)
    except AppError as exc:
        raise _handle_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\auth\password.py ---
# app/api/v1/auth/password.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, Header, HTTPException, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.core.exceptions import AppError, ValidationError, NotFoundError, ConflictError
from app.core.security import decode_token, TokenDecodeError
from app.schemas.auth import (
    PasswordResetRequest,
    PasswordChangeRequest,
    PasswordChangeResponse,
    TokenData,
)
from app.schemas.common.response import MessageResponse
from app.services.common import UnitOfWork
from app.services.auth import PasswordService

router = APIRouter(prefix="/auth", tags=["Auth"])


def get_uow(session: Session = Depends(get_session)) -> UnitOfWork:
    return UnitOfWork(session)


def get_password_service(uow: UnitOfWork = Depends(get_uow)) -> PasswordService:
    return PasswordService(uow)


def _handle_service_error(exc: AppError) -> HTTPException:
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(exc),
        )
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail="Internal server error",
    )


def get_current_user_id(
    authorization: str = Header(..., description="Bearer access token"),
) -> UUID:
    """
    Extract current user's ID from Authorization: Bearer <token> header.
    Assumes JWT payload matches TokenData schema.
    """
    if not authorization.lower().startswith("bearer "):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authorization header",
        )
    token = authorization.split(" ", 1)[1].strip()
    try:
        payload = decode_token(token)
        data = TokenData(**payload)
    except TokenDecodeError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
        )
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        )
    return data.user_id  # assumes TokenData has user_id: UUID


@router.post(
    "/password/reset",
    response_model=MessageResponse,
    status_code=status.HTTP_200_OK,
)
def request_password_reset(
    payload: PasswordResetRequest,
    service: PasswordService = Depends(get_password_service),
) -> MessageResponse:
    """
    Initiate password reset (e.g., send reset email/OTP).
    """
    try:
        # Adjust method name/signature if your PasswordService differs.
        service.request_password_reset(payload)
        return MessageResponse(message="Password reset instructions sent")
    except AppError as exc:
        raise _handle_service_error(exc)


@router.post(
    "/password/change",
    response_model=PasswordChangeResponse,
    status_code=status.HTTP_200_OK,
)
def change_password(
    payload: PasswordChangeRequest,
    user_id: UUID = Depends(get_current_user_id),
    service: PasswordService = Depends(get_password_service),
) -> PasswordChangeResponse:
    """
    Change password for the currently authenticated user.

    Expects current_password + new_password in the payload.
    """
    try:
        # Adjust method signature if your PasswordService differs.
        return service.change_password(user_id=user_id, data=payload)
    except AppError as exc:
        raise _handle_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\auth\register.py ---
# app/api/v1/auth/register.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.core.exceptions import AppError, ValidationError, NotFoundError, ConflictError
from app.schemas.auth import RegisterRequest, RegisterResponse
from app.services.common import UnitOfWork
from app.services.auth import RegistrationService

router = APIRouter(prefix="/auth", tags=["Auth"])


def get_uow(session: Session = Depends(get_session)) -> UnitOfWork:
    return UnitOfWork(session)


def get_registration_service(uow: UnitOfWork = Depends(get_uow)) -> RegistrationService:
    return RegistrationService(uow)


def _handle_service_error(exc: AppError) -> HTTPException:
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail="Internal server error",
    )


@router.post("/register", response_model=RegisterResponse, status_code=status.HTTP_201_CREATED)
def register(
    payload: RegisterRequest,
    service: RegistrationService = Depends(get_registration_service),
) -> RegisterResponse:
    """
    Self-service registration endpoint (typically VISITOR role).
    Creates core user and visitor profile.
    """
    try:
        # Adjust method name/signature if your RegistrationService differs.
        return service.register(payload)
    except AppError as exc:
        raise _handle_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\auth\social.py ---
# app/api/v1/auth/social.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.core.exceptions import AppError, ValidationError, ConflictError
from app.schemas.auth import (
    GoogleAuthRequest,
    FacebookAuthRequest,
    SocialAuthResponse,
)
from app.services.common import UnitOfWork
from app.services.auth import SocialAuthService

router = APIRouter(prefix="/auth", tags=["Auth"])


def get_uow(session: Session = Depends(get_session)) -> UnitOfWork:
    return UnitOfWork(session)


def get_social_auth_service(uow: UnitOfWork = Depends(get_uow)) -> SocialAuthService:
    return SocialAuthService(uow)


def _handle_service_error(exc: AppError) -> HTTPException:
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail="Internal server error",
    )


@router.post("/google", response_model=SocialAuthResponse)
def google_login(
    payload: GoogleAuthRequest,
    service: SocialAuthService = Depends(get_social_auth_service),
) -> SocialAuthResponse:
    """
    Authenticate via Google OAuth.

    Expects an ID token or authorization code, depending on your chosen flow.
    """
    try:
        # Adjust method name/signature if your SocialAuthService differs.
        return service.authenticate_google(payload)
    except NotImplementedError:
        raise HTTPException(
            status_code=status.HTTP_501_NOT_IMPLEMENTED,
            detail="Google social login not configured",
        )
    except AppError as exc:
        raise _handle_service_error(exc)


@router.post("/facebook", response_model=SocialAuthResponse)
def facebook_login(
    payload: FacebookAuthRequest,
    service: SocialAuthService = Depends(get_social_auth_service),
) -> SocialAuthResponse:
    """
    Authenticate via Facebook OAuth.
    """
    try:
        # Adjust method name/signature if your SocialAuthService differs.
        return service.authenticate_facebook(payload)
    except NotImplementedError:
        raise HTTPException(
            status_code=status.HTTP_501_NOT_IMPLEMENTED,
            detail="Facebook social login not configured",
        )
    except AppError as exc:
        raise _handle_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\auth\token.py ---
# app/api/v1/auth/token.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.core.exceptions import AppError, ValidationError
from app.schemas.auth import RefreshTokenRequest, RefreshTokenResponse
from app.services.common import UnitOfWork
from app.services.auth import AuthService

router = APIRouter(prefix="/auth", tags=["Auth"])


def get_uow(session: Session = Depends(get_session)) -> UnitOfWork:
    return UnitOfWork(session)


def get_auth_service(uow: UnitOfWork = Depends(get_uow)) -> AuthService:
    return AuthService(uow)


def _handle_service_error(exc: AppError) -> HTTPException:
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid or expired refresh token",
    )


@router.post("/token/refresh", response_model=RefreshTokenResponse)
def refresh_token(
    payload: RefreshTokenRequest,
    service: AuthService = Depends(get_auth_service),
) -> RefreshTokenResponse:
    """
    Exchange a valid refresh token for a new access (and optionally refresh) token.
    """
    try:
        # Adjust method name/signature if your AuthService differs.
        return service.refresh_token(payload)
    except AppError as exc:
        raise _handle_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\auth\__init__.py ---
# app/api/v1/auth/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from .login import router as login_router
from .register import router as register_router
from .token import router as token_router
from .password import router as password_router
from .otp import router as otp_router
from .social import router as social_router

router = APIRouter()

# All routes under /auth/*
router.include_router(login_router)
router.include_router(register_router)
router.include_router(token_router)
router.include_router(password_router)
router.include_router(otp_router)
router.include_router(social_router)

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\auth\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\bookings =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\bookings\analytics.py ---
# api/v1/bookings/analytics.py
from __future__ import annotations

from datetime import date as Date
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.booking_analytics import BookingAnalyticsSummary
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingAnalyticsService

router = APIRouter(prefix="/analytics")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/summary",
    response_model=BookingAnalyticsSummary,
    summary="Get booking analytics summary for a hostel",
)
async def get_booking_analytics_summary(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> BookingAnalyticsSummary:
    """
    Produce booking analytics for a hostel: KPIs, daily trends, funnel, cancellations,
    and source conversions.
    """
    service = BookingAnalyticsService(uow)
    try:
        return service.get_booking_analytics(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\bookings\approval.py ---
# api/v1/bookings/approval.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_approval import (
    BookingApprovalRequest,
    ApprovalResponse,
    RejectionRequest,
    BulkApprovalRequest,
    ApprovalSettings,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingApprovalService

router = APIRouter(prefix="/approval")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/bookings/{booking_id}/approve",
    response_model=ApprovalResponse,
    summary="Approve a booking",
)
async def approve_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: BookingApprovalRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalResponse:
    """
    Approve a booking, confirm pricing, and optionally require advance payment.
    """
    service = BookingApprovalService(uow)
    try:
        return service.approve_booking(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bookings/{booking_id}/reject",
    response_model=ApprovalResponse,
    summary="Reject a booking",
)
async def reject_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: RejectionRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalResponse:
    """
    Reject a booking with structured rejection reasons and potential alternatives.
    """
    service = BookingApprovalService(uow)
    try:
        return service.reject_booking(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=List[ApprovalResponse],
    summary="Bulk approve/reject bookings",
)
async def bulk_approve_bookings(
    payload: BulkApprovalRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> List[ApprovalResponse]:
    """
    Bulk approve or reject multiple bookings in a single request.
    """
    service = BookingApprovalService(uow)
    try:
        return service.bulk_approve(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/settings",
    response_model=ApprovalSettings,
    summary="Get booking approval settings",
)
async def get_approval_settings(
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalSettings:
    """
    Get automated approval settings (thresholds, rules).
    """
    service = BookingApprovalService(uow)
    try:
        return service.get_settings()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/settings",
    response_model=ApprovalSettings,
    summary="Update booking approval settings",
)
async def update_approval_settings(
    payload: ApprovalSettings,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalSettings:
    """
    Update automated approval settings.
    """
    service = BookingApprovalService(uow)
    try:
        return service.update_settings(settings=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\bookings\assignment.py ---
# api/v1/bookings/assignment.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_assignment import (
    AssignmentRequest,
    BulkAssignmentRequest,
    ReassignmentRequest,
    AssignmentResponse,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingService

router = APIRouter(prefix="/assignments")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/{booking_id}",
    response_model=AssignmentResponse,
    status_code=status.HTTP_200_OK,
    summary="Assign room/bed for a booking",
)
async def assign_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: AssignmentRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentResponse:
    """
    Assign a room and optionally a bed to a booking.
    """
    service = BookingService(uow)
    try:
        return service.assign_booking(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=List[AssignmentResponse],
    summary="Bulk assign rooms/beds for bookings",
)
async def bulk_assign_bookings(
    payload: BulkAssignmentRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> List[AssignmentResponse]:
    """
    Bulk assign rooms/beds to multiple bookings.
    """
    service = BookingService(uow)
    try:
        return service.bulk_assign_bookings(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{booking_id}/reassign",
    response_model=AssignmentResponse,
    summary="Reassign room/bed for a booking",
)
async def reassign_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: ReassignmentRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentResponse:
    """
    Reassign a booking to a new room/bed.
    """
    service = BookingService(uow)
    try:
        return service.reassign_booking(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\bookings\bookings.py ---
# api/v1/bookings/bookings.py
from __future__ import annotations

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_base import BookingCreate, BookingUpdate
from app.schemas.booking.booking_response import (
    BookingDetail,
    BookingListItem,
    BookingConfirmation,
)
from app.schemas.booking.booking_filters import (
    BookingFilterParams,
    BookingSearchRequest,
)
from app.schemas.common.pagination import PaginatedResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/",
    response_model=PaginatedResponse[BookingListItem],
    summary="List bookings",
)
async def list_bookings(
    filters: BookingFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[BookingListItem]:
    """
    List bookings using flexible filters (hostel, status, date range, source, etc.)
    with pagination and sorting.
    """
    service = BookingService(uow)
    try:
        return service.list_bookings(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/",
    response_model=BookingDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new booking",
)
async def create_booking(
    payload: BookingCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> BookingDetail:
    """
    Create a new booking (internal/admin or system-side).

    Validates amounts and requested room type using BookingCreate.
    """
    service = BookingService(uow)
    try:
        return service.create_booking(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{booking_id}",
    response_model=BookingDetail,
    summary="Get booking details",
)
async def get_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> BookingDetail:
    """
    Retrieve detailed booking information including hostel, amounts, status history,
    and assignment (if any).
    """
    service = BookingService(uow)
    try:
        return service.get_booking(booking_id=booking_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{booking_id}",
    response_model=BookingDetail,
    summary="Update a booking",
)
async def update_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: BookingUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> BookingDetail:
    """
    Partially update a booking (dates, duration, notes, status, etc.).
    """
    service = BookingService(uow)
    try:
        return service.update_booking(
            booking_id=booking_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/search",
    response_model=PaginatedResponse[BookingListItem],
    summary="Search bookings",
)
async def search_bookings(
    payload: BookingSearchRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[BookingListItem]:
    """
    Structured booking search endpoint (richer than simple filters),
    e.g. multi-field search, complex status/date logic.
    """
    service = BookingService(uow)
    try:
        return service.search_bookings(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{booking_id}/confirmation",
    response_model=BookingConfirmation,
    summary="Get booking confirmation payload",
)
async def get_booking_confirmation(
    booking_id: UUID = Path(..., description="Booking ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> BookingConfirmation:
    """
    Retrieve a confirmation payload for the booking (for emails/PDF, guest view).
    """
    service = BookingService(uow)
    try:
        return service.get_confirmation(booking_id=booking_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\bookings\calendar.py ---
# api/v1/bookings/calendar.py
from __future__ import annotations

from datetime import date as Date
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_calendar import (
    CalendarView,
    AvailabilityCalendar,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingCalendarService

router = APIRouter(prefix="/calendar")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/hostels/{hostel_id}",
    response_model=CalendarView,
    summary="Get hostel booking calendar",
)
async def get_hostel_calendar(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> CalendarView:
    """
    Build a booking calendar view for a hostel (check-in/out events per day).
    """
    service = BookingCalendarService(uow)
    try:
        return service.get_hostel_calendar(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/rooms/{room_id}",
    response_model=CalendarView,
    summary="Get room booking calendar",
)
async def get_room_calendar(
    room_id: UUID = Path(..., description="Room ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> CalendarView:
    """
    Build a booking calendar view for a specific room.
    """
    service = BookingCalendarService(uow)
    try:
        return service.get_room_calendar(
            room_id=room_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/availability",
    response_model=AvailabilityCalendar,
    summary="Get hostel availability calendar",
)
async def get_hostel_availability_calendar(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> AvailabilityCalendar:
    """
    Return an availability calendar for a hostel, showing available beds per day.
    """
    service = BookingCalendarService(uow)
    try:
        return service.get_availability_calendar(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\bookings\cancellation.py ---
# api/v1/bookings/cancellation.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_cancellation import (
    CancellationRequest,
    CancellationResponse,
    RefundCalculation,
    BulkCancellation,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingCancellationService

router = APIRouter(prefix="/cancellation")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/bookings/{booking_id}/preview",
    response_model=RefundCalculation,
    summary="Preview cancellation refund for a booking",
)
async def preview_cancellation(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: CancellationRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> RefundCalculation:
    """
    Preview refund and charges for a potential cancellation without applying it.
    """
    service = BookingCancellationService(uow)
    try:
        return service.preview_cancellation(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bookings/{booking_id}",
    response_model=CancellationResponse,
    summary="Cancel a booking",
)
async def cancel_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: CancellationRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> CancellationResponse:
    """
    Cancel a booking and optionally trigger refund execution.
    """
    service = BookingCancellationService(uow)
    try:
        return service.cancel_booking(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=List[CancellationResponse],
    summary="Bulk cancel bookings",
)
async def bulk_cancel_bookings(
    payload: BulkCancellation,
    uow: UnitOfWork = Depends(get_uow),
) -> List[CancellationResponse]:
    """
    Bulk cancel multiple bookings and compute/apply refunds.
    """
    service = BookingCancellationService(uow)
    try:
        return service.bulk_cancel(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\bookings\conversion.py ---
# api/v1/bookings/conversion.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_conversion import (
    ConvertToStudentRequest,
    ConversionResponse,
    BulkConversion,
    ConversionRollback,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingConversionService

router = APIRouter(prefix="/conversion")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/bookings/{booking_id}",
    response_model=ConversionResponse,
    summary="Convert booking into student",
)
async def convert_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: ConvertToStudentRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ConversionResponse:
    """
    Convert a confirmed booking into a student profile and assign a bed.
    """
    service = BookingConversionService(uow)
    try:
        return service.convert_booking(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=List[ConversionResponse],
    summary="Bulk convert bookings into students",
)
async def bulk_convert_bookings(
    payload: BulkConversion,
    uow: UnitOfWork = Depends(get_uow),
) -> List[ConversionResponse]:
    """
    Bulk convert multiple bookings into students.
    """
    service = BookingConversionService(uow)
    try:
        return service.bulk_convert(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/rollback",
    response_model=ConversionResponse,
    summary="Rollback a booking conversion",
)
async def rollback_conversion(
    payload: ConversionRollback,
    uow: UnitOfWork = Depends(get_uow),
) -> ConversionResponse:
    """
    Rollback a prior conversion (if allowed), reverting student/bed assignment.
    """
    service = BookingConversionService(uow)
    try:
        return service.rollback_conversion(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\bookings\modification.py ---
# api/v1/bookings/modification.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_modification import (
    ModificationRequest,
    ModificationResponse,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingModificationService

router = APIRouter(prefix="/modification")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/bookings/{booking_id}/preview",
    response_model=ModificationResponse,
    summary="Preview booking modification",
)
async def preview_modification(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: ModificationRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ModificationResponse:
    """
    Preview the impact (price, duration) of modifying a booking.
    """
    service = BookingModificationService(uow)
    try:
        return service.preview_modification(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bookings/{booking_id}/apply",
    response_model=ModificationResponse,
    summary="Apply booking modification",
)
async def apply_modification(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: ModificationRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ModificationResponse:
    """
    Apply a modification to a booking (after optional approval).
    """
    service = BookingModificationService(uow)
    try:
        return service.apply_modification(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\bookings\waitlist.py ---
# api/v1/bookings/waitlist.py
from __future__ import annotations

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_waitlist import (
    WaitlistRequest,
    WaitlistResponse,
    WaitlistStatus,
    WaitlistNotification,
    WaitlistConversion,
    WaitlistCancellation,
    WaitlistManagement,
)
from app.schemas.common.enums import RoomType
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingWaitlistService

router = APIRouter(prefix="/waitlist")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/",
    response_model=WaitlistResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Add visitor to booking waitlist",
)
async def add_to_waitlist(
    payload: WaitlistRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> WaitlistResponse:
    """
    Add a visitor to the waitlist for a hostel/room type.
    """
    service = BookingWaitlistService(uow)
    try:
        return service.add_to_waitlist(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/cancel",
    response_model=WaitlistResponse,
    summary="Cancel a waitlist entry",
)
async def cancel_waitlist_entry(
    payload: WaitlistCancellation,
    uow: UnitOfWork = Depends(get_uow),
) -> WaitlistResponse:
    """
    Cancel an existing waitlist entry.
    """
    service = BookingWaitlistService(uow)
    try:
        return service.cancel_waitlist(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/",
    response_model=WaitlistManagement,
    summary="List waitlist entries for a hostel",
)
async def list_waitlist_for_hostel(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    room_type: Optional[RoomType] = Query(None, description="Optional room type filter"),
    uow: UnitOfWork = Depends(get_uow),
) -> WaitlistManagement:
    """
    List waitlist entries for a hostel (optionally filtered by room type).
    """
    service = BookingWaitlistService(uow)
    try:
        return service.list_waitlist_for_hostel(
            hostel_id=hostel_id,
            room_type=room_type,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{entry_id}/notify",
    response_model=WaitlistResponse,
    summary="Notify a waitlist entry about availability",
)
async def notify_waitlist_entry(
    entry_id: UUID = Path(..., description="Waitlist entry ID"),
    payload: WaitlistNotification = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> WaitlistResponse:
    """
    Mark that a waitlisted visitor has been notified of availability.
    """
    service = BookingWaitlistService(uow)
    try:
        return service.notify_availability(
            entry_id=entry_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{entry_id}/convert",
    response_model=WaitlistResponse,
    summary="Convert a waitlist entry into a booking",
)
async def convert_waitlist_entry(
    entry_id: UUID = Path(..., description="Waitlist entry ID"),
    payload: WaitlistConversion = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> WaitlistResponse:
    """
    Mark a waitlist entry as converted (booking created) or declined.
    """
    service = BookingWaitlistService(uow)
    try:
        return service.mark_converted(
            entry_id=entry_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/status",
    response_model=WaitlistStatus,
    summary="Get waitlist status for a visitor",
)
async def get_waitlist_status(
    visitor_id: UUID = Query(..., description="Visitor ID"),
    hostel_id: UUID = Query(..., description="Hostel ID"),
    room_type: Optional[RoomType] = Query(None, description="Optional room type filter"),
    uow: UnitOfWork = Depends(get_uow),
) -> WaitlistStatus:
    """
    Get current waitlist status for a visitor at a hostel (and optional room type).
    """
    service = BookingWaitlistService(uow)
    try:
        return service.get_status(
            visitor_id=visitor_id,
            hostel_id=hostel_id,
            room_type=room_type,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\bookings\__init__.py ---
# api/v1/bookings/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import bookings
from . import approval
from . import calendar
from . import assignment
from . import cancellation
from . import modification
from . import waitlist
from . import conversion
from . import analytics

router = APIRouter(prefix="/bookings")

router.include_router(bookings.router, tags=["Bookings - Core"])
router.include_router(approval.router, tags=["Bookings - Approval"])
router.include_router(calendar.router, tags=["Bookings - Calendar"])
router.include_router(assignment.router, tags=["Bookings - Assignment"])
router.include_router(cancellation.router, tags=["Bookings - Cancellation"])
router.include_router(modification.router, tags=["Bookings - Modification"])
router.include_router(waitlist.router, tags=["Bookings - Waitlist"])
router.include_router(conversion.router, tags=["Bookings - Conversion"])
router.include_router(analytics.router, tags=["Bookings - Analytics"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\bookings\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\analytics.py ---
# api/v1/complaints/analytics.py
from __future__ import annotations

from datetime import date as Date

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_analytics import ComplaintAnalytics
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintAnalyticsService

router = APIRouter(prefix="/analytics")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "",
    response_model=ComplaintAnalytics,
    summary="Get detailed complaint analytics for a hostel",
)
async def get_complaint_analytics(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintAnalytics:
    """
    Compute detailed complaint analytics for a hostel over a period:
    resolution metrics, category breakdowns, trends, staff performance,
    complaint heatmap, etc.
    """
    service = ComplaintAnalyticsService(uow)
    try:
        return service.get_complaint_analytics(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\assignment.py ---
# api/v1/complaints/assignment.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_assignment import (
    AssignmentRequest,
    AssignmentResponse,
    ReassignmentRequest,
    BulkAssignment,
    UnassignRequest,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintAssignmentService

router = APIRouter(prefix="/assignments")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/{complaint_id}",
    response_model=AssignmentResponse,
    status_code=status.HTTP_200_OK,
    summary="Assign a complaint to a supervisor",
)
async def assign_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: AssignmentRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentResponse:
    """
    Assign a complaint to a supervisor (or staff member).
    """
    service = ComplaintAssignmentService(uow)
    try:
        return service.assign_complaint(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{complaint_id}/reassign",
    response_model=AssignmentResponse,
    summary="Reassign a complaint",
)
async def reassign_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: ReassignmentRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentResponse:
    """
    Reassign a complaint to a different supervisor.
    """
    service = ComplaintAssignmentService(uow)
    try:
        return service.reassign_complaint(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=List[AssignmentResponse],
    summary="Bulk assign complaints",
)
async def bulk_assign_complaints(
    payload: BulkAssignment,
    uow: UnitOfWork = Depends(get_uow),
) -> List[AssignmentResponse]:
    """
    Bulk assign multiple complaints to supervisors.
    """
    service = ComplaintAssignmentService(uow)
    try:
        return service.bulk_assign(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{complaint_id}/unassign",
    response_model=AssignmentResponse,
    summary="Unassign a complaint",
)
async def unassign_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: UnassignRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentResponse:
    """
    Remove the current supervisor assignment from a complaint.
    """
    service = ComplaintAssignmentService(uow)
    try:
        return service.unassign_complaint(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\comments.py ---
# api/v1/complaints/comments.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_comments import (
    CommentCreate,
    CommentResponse,
    CommentList,
    CommentUpdate,
    CommentDelete,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintService

router = APIRouter(prefix="/comments")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/{complaint_id}",
    response_model=CommentList,
    summary="List comments for a complaint",
)
async def list_comments(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> CommentList:
    """
    List all comments associated with a complaint.
    """
    service = ComplaintService(uow)
    try:
        return service.list_comments(complaint_id=complaint_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{complaint_id}",
    response_model=CommentResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Add a comment to a complaint",
)
async def add_comment(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: CommentCreate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> CommentResponse:
    """
    Add a new comment to a complaint.
    """
    service = ComplaintService(uow)
    try:
        return service.add_comment(
            complaint_id=complaint_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{complaint_id}/{comment_id}",
    response_model=CommentResponse,
    summary="Update a complaint comment",
)
async def update_comment(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    comment_id: UUID = Path(..., description="Comment ID"),
    payload: CommentUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> CommentResponse:
    """
    Update an existing comment on a complaint.
    """
    service = ComplaintService(uow)
    try:
        return service.update_comment(
            complaint_id=complaint_id,
            comment_id=comment_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.delete(
    "/{complaint_id}/{comment_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete a complaint comment",
)
async def delete_comment(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    comment_id: UUID = Path(..., description="Comment ID"),
    payload: CommentDelete = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> None:
    """
    Delete a comment from a complaint (or mark it as deleted, depending on implementation).
    """
    service = ComplaintService(uow)
    try:
        service.delete_comment(
            complaint_id=complaint_id,
            comment_id=comment_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\complaints.py ---
# api/v1/complaints/complaints.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_base import (
    ComplaintCreate,
    ComplaintUpdate,
    ComplaintStatusUpdate,
)
from app.schemas.complaint.complaint_response import (
    ComplaintDetail,
    ComplaintListItem,
    ComplaintSummary,
)
from app.schemas.complaint.complaint_filters import ComplaintFilterParams, ComplaintSearchRequest
from app.schemas.common.pagination import PaginatedResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/",
    response_model=PaginatedResponse[ComplaintListItem],
    summary="List complaints",
)
async def list_complaints(
    filters: ComplaintFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[ComplaintListItem]:
    """
    List complaints using filters (hostel, status, category, priority, date range, etc.)
    with pagination and sorting.
    """
    service = ComplaintService(uow)
    try:
        return service.list_complaints(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/",
    response_model=ComplaintDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new complaint",
)
async def create_complaint(
    payload: ComplaintCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintDetail:
    """
    Create a new complaint record.
    """
    service = ComplaintService(uow)
    try:
        return service.create_complaint(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{complaint_id}",
    response_model=ComplaintDetail,
    summary="Get complaint details",
)
async def get_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintDetail:
    """
    Retrieve detailed complaint information, including room/student context if available.
    """
    service = ComplaintService(uow)
    try:
        return service.get_complaint(complaint_id=complaint_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{complaint_id}",
    response_model=ComplaintDetail,
    summary="Update a complaint",
)
async def update_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: ComplaintUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintDetail:
    """
    Partially update complaint fields (title, description, category, priority, location, etc.).
    """
    service = ComplaintService(uow)
    try:
        return service.update_complaint(
            complaint_id=complaint_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{complaint_id}/status",
    response_model=ComplaintDetail,
    summary="Update complaint status",
)
async def update_complaint_status(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: ComplaintStatusUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintDetail:
    """
    Update the status of a complaint (open, in_progress, resolved, closed, escalated, etc.).
    """
    service = ComplaintService(uow)
    try:
        return service.update_status(
            complaint_id=complaint_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/search",
    response_model=PaginatedResponse[ComplaintListItem],
    summary="Search complaints",
)
async def search_complaints(
    payload: ComplaintSearchRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[ComplaintListItem]:
    """
    Perform a structured search over complaints with richer query criteria.
    """
    service = ComplaintService(uow)
    try:
        return service.search_complaints(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/summary",
    response_model=ComplaintSummary,
    summary="Get complaint summary for a hostel",
)
async def get_complaint_summary_for_hostel(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintSummary:
    """
    Summarize complaints for a hostel: counts by status, average resolution time, etc.
    """
    service = ComplaintService(uow)
    try:
        return service.get_hostel_summary(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\escalation.py ---
# api/v1/complaints/escalation.py
from __future__ import annotations

from datetime import date as Date

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_escalation import (
    EscalationRequest,
    EscalationResponse,
    EscalationHistory,
    AutoEscalationRule,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintEscalationService

router = APIRouter(prefix="/escalation")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/{complaint_id}",
    response_model=EscalationResponse,
    summary="Escalate a complaint",
)
async def escalate_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: EscalationRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> EscalationResponse:
    """
    Manually escalate a complaint according to escalation rules.
    """
    service = ComplaintEscalationService(uow)
    try:
        return service.escalate(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{complaint_id}/history",
    response_model=EscalationHistory,
    summary="Get complaint escalation history",
)
async def get_escalation_history(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> EscalationHistory:
    """
    Retrieve the full escalation history for a complaint.
    """
    service = ComplaintEscalationService(uow)
    try:
        return service.get_history(complaint_id=complaint_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/rules/{hostel_id}",
    response_model=AutoEscalationRule,
    summary="Get auto-escalation rules for a hostel",
)
async def get_auto_escalation_rules(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AutoEscalationRule:
    """
    Fetch SLA-based auto-escalation rules for a hostel.
    """
    service = ComplaintEscalationService(uow)
    try:
        return service.get_rules(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/rules/{hostel_id}",
    response_model=AutoEscalationRule,
    summary="Update auto-escalation rules for a hostel",
)
async def update_auto_escalation_rules(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: AutoEscalationRule = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AutoEscalationRule:
    """
    Create or update SLA-based auto-escalation rules for a hostel.
    """
    service = ComplaintEscalationService(uow)
    try:
        return service.update_rules(
            hostel_id=hostel_id,
            rules=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\feedback.py ---
# api/v1/complaints/feedback.py
from __future__ import annotations

from datetime import date as Date

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_feedback import (
    FeedbackRequest,
    FeedbackResponse,
    FeedbackSummary,
    FeedbackAnalysis,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintFeedbackService

router = APIRouter(prefix="/feedback")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/{complaint_id}",
    response_model=FeedbackResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Submit feedback for a complaint",
)
async def submit_feedback(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: FeedbackRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> FeedbackResponse:
    """
    Submit post-resolution feedback for a complaint.
    """
    service = ComplaintFeedbackService(uow)
    try:
        return service.submit_feedback(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{complaint_id}",
    response_model=FeedbackResponse,
    summary="Get feedback for a complaint",
)
async def get_feedback(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeedbackResponse:
    """
    Retrieve feedback associated with a specific complaint (if any).
    """
    service = ComplaintFeedbackService(uow)
    try:
        return service.get_feedback(complaint_id=complaint_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/summary",
    response_model=FeedbackSummary,
    summary="Get feedback summary for a hostel",
)
async def get_feedback_summary(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Optional[Date] = Query(None, description="Start Date (inclusive)"),
    period_end: Optional[Date] = Query(None, description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeedbackSummary:
    """
    Summarize complaint feedback for a hostel: ratings, satisfaction, etc.
    """
    service = ComplaintFeedbackService(uow)
    try:
        return service.get_summary(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/analysis",
    response_model=FeedbackAnalysis,
    summary="Analyze complaint feedback for a hostel",
)
async def get_feedback_analysis(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Optional[Date] = Query(None, description="Start Date (inclusive)"),
    period_end: Optional[Date] = Query(None, description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeedbackAnalysis:
    """
    Return a more detailed analysis of complaint feedback (trends, ratings, etc.).
    """
    service = ComplaintFeedbackService(uow)
    try:
        return service.get_analysis(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\resolution.py ---
# api/v1/complaints/resolution.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_resolution import (
    ResolutionRequest,
    ResolutionResponse,
    ResolutionUpdate,
    ReopenRequest,
    CloseRequest,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintService

router = APIRouter(prefix="/resolution")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/{complaint_id}",
    response_model=ResolutionResponse,
    status_code=status.HTTP_200_OK,
    summary="Add resolution details to a complaint",
)
async def add_resolution(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: ResolutionRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ResolutionResponse:
    """
    Record resolution details for a complaint and update its status.
    """
    service = ComplaintService(uow)
    try:
        return service.add_resolution(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{complaint_id}",
    response_model=ResolutionResponse,
    summary="Update complaint resolution",
)
async def update_resolution(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: ResolutionUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ResolutionResponse:
    """
    Update existing resolution details for a complaint.
    """
    service = ComplaintService(uow)
    try:
        return service.update_resolution(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{complaint_id}/reopen",
    response_model=ResolutionResponse,
    summary="Reopen a resolved/closed complaint",
)
async def reopen_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: ReopenRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ResolutionResponse:
    """
    Reopen a previously resolved or closed complaint.
    """
    service = ComplaintService(uow)
    try:
        return service.reopen_complaint(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{complaint_id}/close",
    response_model=ResolutionResponse,
    summary="Close a complaint",
)
async def close_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: CloseRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ResolutionResponse:
    """
    Close a complaint after resolution is confirmed.
    """
    service = ComplaintService(uow)
    try:
        return service.close_complaint(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\__init__.py ---
# api/v1/complaints/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import complaints
from . import assignment
from . import resolution
from . import escalation
from . import feedback
from . import comments
from . import analytics

router = APIRouter(prefix="/complaints")

router.include_router(complaints.router, tags=["Complaints - Core"])
router.include_router(assignment.router, tags=["Complaints - Assignment"])
router.include_router(resolution.router, tags=["Complaints - Resolution"])
router.include_router(escalation.router, tags=["Complaints - Escalation"])
router.include_router(feedback.router, tags=["Complaints - Feedback"])
router.include_router(comments.router, tags=["Complaints - Comments"])
router.include_router(analytics.router, tags=["Complaints - Analytics"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\__pycache__ =====


# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\analytics.py ---
# api/v1/complaints/analytics.py
from __future__ import annotations

from datetime import date as Date

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_analytics import ComplaintAnalytics
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintAnalyticsService

router = APIRouter(prefix="/analytics")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "",
    response_model=ComplaintAnalytics,
    summary="Get detailed complaint analytics for a hostel",
)
async def get_complaint_analytics(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintAnalytics:
    """
    Compute detailed complaint analytics for a hostel over a period:
    resolution metrics, category breakdowns, trends, staff performance,
    complaint heatmap, etc.
    """
    service = ComplaintAnalyticsService(uow)
    try:
        return service.get_complaint_analytics(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\assignment.py ---
# api/v1/complaints/assignment.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_assignment import (
    AssignmentRequest,
    AssignmentResponse,
    ReassignmentRequest,
    BulkAssignment,
    UnassignRequest,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintAssignmentService

router = APIRouter(prefix="/assignments")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/{complaint_id}",
    response_model=AssignmentResponse,
    status_code=status.HTTP_200_OK,
    summary="Assign a complaint to a supervisor",
)
async def assign_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: AssignmentRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentResponse:
    """
    Assign a complaint to a supervisor (or staff member).
    """
    service = ComplaintAssignmentService(uow)
    try:
        return service.assign_complaint(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{complaint_id}/reassign",
    response_model=AssignmentResponse,
    summary="Reassign a complaint",
)
async def reassign_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: ReassignmentRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentResponse:
    """
    Reassign a complaint to a different supervisor.
    """
    service = ComplaintAssignmentService(uow)
    try:
        return service.reassign_complaint(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=List[AssignmentResponse],
    summary="Bulk assign complaints",
)
async def bulk_assign_complaints(
    payload: BulkAssignment,
    uow: UnitOfWork = Depends(get_uow),
) -> List[AssignmentResponse]:
    """
    Bulk assign multiple complaints to supervisors.
    """
    service = ComplaintAssignmentService(uow)
    try:
        return service.bulk_assign(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{complaint_id}/unassign",
    response_model=AssignmentResponse,
    summary="Unassign a complaint",
)
async def unassign_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: UnassignRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentResponse:
    """
    Remove the current supervisor assignment from a complaint.
    """
    service = ComplaintAssignmentService(uow)
    try:
        return service.unassign_complaint(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\comments.py ---
# api/v1/complaints/comments.py
from __future__ import annotations

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status, Response

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_comments import (
    CommentCreate,
    CommentResponse,
    CommentList,
    CommentUpdate,
    CommentDelete,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintService

router = APIRouter(prefix="/comments")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/{complaint_id}",
    response_model=CommentList,
    summary="List comments for a complaint",
)
async def list_comments(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> CommentList:
    """
    List all comments associated with a complaint.
    """
    service = ComplaintService(uow)
    try:
        return service.list_comments(complaint_id=complaint_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{complaint_id}",
    response_model=CommentResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Add a comment to a complaint",
)
async def add_comment(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: CommentCreate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> CommentResponse:
    """
    Add a new comment to a complaint.
    """
    service = ComplaintService(uow)
    try:
        return service.add_comment(
            complaint_id=complaint_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{complaint_id}/{comment_id}",
    response_model=CommentResponse,
    summary="Update a complaint comment",
)
async def update_comment(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    comment_id: UUID = Path(..., description="Comment ID"),
    payload: CommentUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> CommentResponse:
    """
    Update an existing comment on a complaint.
    """
    service = ComplaintService(uow)
    try:
        return service.update_comment(
            complaint_id=complaint_id,
            comment_id=comment_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.delete(
    "/{complaint_id}/{comment_id}",
    summary="Delete a complaint comment",
)
async def delete_comment(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    comment_id: UUID = Path(..., description="Comment ID"),
    reason: Optional[str] = Query(
        None, 
        description="Deletion reason (optional)",
        max_length=200
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> Response:
    """
    Delete a comment from a complaint (or mark it as deleted, depending on implementation).
    """
    service = ComplaintService(uow)
    try:
        # Create CommentDelete object from query parameter
        delete_data = CommentDelete(
            comment_id=str(comment_id), 
            reason=reason
        )
        service.delete_comment(
            complaint_id=complaint_id,
            comment_id=comment_id,
            data=delete_data,
        )
        return Response(status_code=204)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\complaints.py ---
# api/v1/complaints/complaints.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_base import (
    ComplaintCreate,
    ComplaintUpdate,
    ComplaintStatusUpdate,
)
from app.schemas.complaint.complaint_response import (
    ComplaintDetail,
    ComplaintListItem,
    ComplaintSummary,
)
from app.schemas.complaint.complaint_filters import ComplaintFilterParams, ComplaintSearchRequest
from app.schemas.common.pagination import PaginatedResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/",
    response_model=PaginatedResponse[ComplaintListItem],
    summary="List complaints",
)
async def list_complaints(
    filters: ComplaintFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[ComplaintListItem]:
    """
    List complaints using filters (hostel, status, category, priority, date range, etc.)
    with pagination and sorting.
    """
    service = ComplaintService(uow)
    try:
        return service.list_complaints(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/",
    response_model=ComplaintDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new complaint",
)
async def create_complaint(
    payload: ComplaintCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintDetail:
    """
    Create a new complaint record.
    """
    service = ComplaintService(uow)
    try:
        return service.create_complaint(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{complaint_id}",
    response_model=ComplaintDetail,
    summary="Get complaint details",
)
async def get_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintDetail:
    """
    Retrieve detailed complaint information, including room/student context if available.
    """
    service = ComplaintService(uow)
    try:
        return service.get_complaint(complaint_id=complaint_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{complaint_id}",
    response_model=ComplaintDetail,
    summary="Update a complaint",
)
async def update_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: ComplaintUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintDetail:
    """
    Partially update complaint fields (title, description, category, priority, location, etc.).
    """
    service = ComplaintService(uow)
    try:
        return service.update_complaint(
            complaint_id=complaint_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{complaint_id}/status",
    response_model=ComplaintDetail,
    summary="Update complaint status",
)
async def update_complaint_status(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: ComplaintStatusUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintDetail:
    """
    Update the status of a complaint (open, in_progress, resolved, closed, escalated, etc.).
    """
    service = ComplaintService(uow)
    try:
        return service.update_status(
            complaint_id=complaint_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/search",
    response_model=PaginatedResponse[ComplaintListItem],
    summary="Search complaints",
)
async def search_complaints(
    payload: ComplaintSearchRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[ComplaintListItem]:
    """
    Perform a structured search over complaints with richer query criteria.
    """
    service = ComplaintService(uow)
    try:
        return service.search_complaints(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/summary",
    response_model=ComplaintSummary,
    summary="Get complaint summary for a hostel",
)
async def get_complaint_summary_for_hostel(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintSummary:
    """
    Summarize complaints for a hostel: counts by status, average resolution time, etc.
    """
    service = ComplaintService(uow)
    try:
        return service.get_hostel_summary(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\escalation.py ---
# api/v1/complaints/escalation.py
from __future__ import annotations

from datetime import date as Date

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_escalation import (
    EscalationRequest,
    EscalationResponse,
    EscalationHistory,
    AutoEscalationRule,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintEscalationService

router = APIRouter(prefix="/escalation")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/{complaint_id}",
    response_model=EscalationResponse,
    summary="Escalate a complaint",
)
async def escalate_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: EscalationRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> EscalationResponse:
    """
    Manually escalate a complaint according to escalation rules.
    """
    service = ComplaintEscalationService(uow)
    try:
        return service.escalate(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{complaint_id}/history",
    response_model=EscalationHistory,
    summary="Get complaint escalation history",
)
async def get_escalation_history(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> EscalationHistory:
    """
    Retrieve the full escalation history for a complaint.
    """
    service = ComplaintEscalationService(uow)
    try:
        return service.get_history(complaint_id=complaint_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/rules/{hostel_id}",
    response_model=AutoEscalationRule,
    summary="Get auto-escalation rules for a hostel",
)
async def get_auto_escalation_rules(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AutoEscalationRule:
    """
    Fetch SLA-based auto-escalation rules for a hostel.
    """
    service = ComplaintEscalationService(uow)
    try:
        return service.get_rules(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/rules/{hostel_id}",
    response_model=AutoEscalationRule,
    summary="Update auto-escalation rules for a hostel",
)
async def update_auto_escalation_rules(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: AutoEscalationRule = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AutoEscalationRule:
    """
    Create or update SLA-based auto-escalation rules for a hostel.
    """
    service = ComplaintEscalationService(uow)
    try:
        return service.update_rules(
            hostel_id=hostel_id,
            rules=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\feedback.py ---
# api/v1/complaints/feedback.py
from __future__ import annotations

from datetime import date as Date

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_feedback import (
    FeedbackRequest,
    FeedbackResponse,
    FeedbackSummary,
    FeedbackAnalysis,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintFeedbackService

router = APIRouter(prefix="/feedback")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/{complaint_id}",
    response_model=FeedbackResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Submit feedback for a complaint",
)
async def submit_feedback(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: FeedbackRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> FeedbackResponse:
    """
    Submit post-resolution feedback for a complaint.
    """
    service = ComplaintFeedbackService(uow)
    try:
        return service.submit_feedback(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{complaint_id}",
    response_model=FeedbackResponse,
    summary="Get feedback for a complaint",
)
async def get_feedback(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeedbackResponse:
    """
    Retrieve feedback associated with a specific complaint (if any).
    """
    service = ComplaintFeedbackService(uow)
    try:
        return service.get_feedback(complaint_id=complaint_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/summary",
    response_model=FeedbackSummary,
    summary="Get feedback summary for a hostel",
)
async def get_feedback_summary(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Optional[Date] = Query(None, description="Start Date (inclusive)"),
    period_end: Optional[Date] = Query(None, description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeedbackSummary:
    """
    Summarize complaint feedback for a hostel: ratings, satisfaction, etc.
    """
    service = ComplaintFeedbackService(uow)
    try:
        return service.get_summary(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/analysis",
    response_model=FeedbackAnalysis,
    summary="Analyze complaint feedback for a hostel",
)
async def get_feedback_analysis(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Optional[Date] = Query(None, description="Start Date (inclusive)"),
    period_end: Optional[Date] = Query(None, description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeedbackAnalysis:
    """
    Return a more detailed analysis of complaint feedback (trends, ratings, etc.).
    """
    service = ComplaintFeedbackService(uow)
    try:
        return service.get_analysis(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\resolution.py ---
# api/v1/complaints/resolution.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.complaint.complaint_resolution import (
    ResolutionRequest,
    ResolutionResponse,
    ResolutionUpdate,
    ReopenRequest,
    CloseRequest,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.complaint import ComplaintService

router = APIRouter(prefix="/resolution")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/{complaint_id}",
    response_model=ResolutionResponse,
    status_code=status.HTTP_200_OK,
    summary="Add resolution details to a complaint",
)
async def add_resolution(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: ResolutionRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ResolutionResponse:
    """
    Record resolution details for a complaint and update its status.
    """
    service = ComplaintService(uow)
    try:
        return service.add_resolution(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{complaint_id}",
    response_model=ResolutionResponse,
    summary="Update complaint resolution",
)
async def update_resolution(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: ResolutionUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ResolutionResponse:
    """
    Update existing resolution details for a complaint.
    """
    service = ComplaintService(uow)
    try:
        return service.update_resolution(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{complaint_id}/reopen",
    response_model=ResolutionResponse,
    summary="Reopen a resolved/closed complaint",
)
async def reopen_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: ReopenRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ResolutionResponse:
    """
    Reopen a previously resolved or closed complaint.
    """
    service = ComplaintService(uow)
    try:
        return service.reopen_complaint(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{complaint_id}/close",
    response_model=ResolutionResponse,
    summary="Close a complaint",
)
async def close_complaint(
    complaint_id: UUID = Path(..., description="Complaint ID"),
    payload: CloseRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ResolutionResponse:
    """
    Close a complaint after resolution is confirmed.
    """
    service = ComplaintService(uow)
    try:
        return service.close_complaint(
            complaint_id=complaint_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\__init__.py ---
# api/v1/complaints/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import complaints
from . import assignment
from . import resolution
from . import escalation
from . import feedback
from . import comments
from . import analytics

router = APIRouter(prefix="/complaints")

router.include_router(complaints.router, tags=["Complaints - Core"])
router.include_router(assignment.router, tags=["Complaints - Assignment"])
router.include_router(resolution.router, tags=["Complaints - Resolution"])
router.include_router(escalation.router, tags=["Complaints - Escalation"])
router.include_router(feedback.router, tags=["Complaints - Feedback"])
router.include_router(comments.router, tags=["Complaints - Comments"])
router.include_router(analytics.router, tags=["Complaints - Analytics"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\complaints\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\fee_structures =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\fee_structures\config.py ---
# api/v1/fee_structures/config.py
from __future__ import annotations

from datetime import date as Date

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.common.enums import RoomType, FeeType
from app.schemas.fee_structure.fee_config import FeeConfiguration
from app.services.common.unit_of_work import UnitOfWork
from app.services.fee_structure import FeeConfigService

router = APIRouter(prefix="/config")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/effective",
    response_model=FeeConfiguration,
    summary="Get effective fee configuration",
)
async def get_effective_fee_configuration(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    room_type: RoomType = Query(..., description="Room type"),
    fee_type: FeeType = Query(..., description="Fee type (e.g. RENT, DEPOSIT)"),
    as_of: Date = Query(..., description="Date for which to compute effective fee"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeeConfiguration:
    """
    Compute the effective fee configuration for a hostel, room type, and fee type
    on a given Date.

    Returns a FeeConfiguration that includes breakdown (rent, mess, utilities,
    deposit) and totals.
    """
    service = FeeConfigService(uow)
    try:
        return service.get_fee_configuration(
            hostel_id=hostel_id,
            room_type=room_type,
            fee_type=fee_type,
            as_of=as_of,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\fee_structures\fees.py ---
# api/v1/fee_structures/fees.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.fee_structure.fee_base import (
    FeeStructureCreate,
    FeeStructureUpdate,
)
from app.schemas.fee_structure.fee_response import (
    FeeStructureResponse,
    FeeStructureList,
    FeeDetail,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.fee_structure import FeeStructureService

router = APIRouter(prefix="/fees")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/",
    response_model=FeeStructureList,
    summary="List fee structures for a hostel",
)
async def list_fee_structures(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeeStructureList:
    """
    List all fee structures configured for a given hostel.
    """
    service = FeeStructureService(uow)
    try:
        return service.list_fee_structures(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/",
    response_model=FeeStructureResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create a fee structure",
)
async def create_fee_structure(
    payload: FeeStructureCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> FeeStructureResponse:
    """
    Create a new fee structure (per hostel and room type).

    Typically includes rent, security deposit, mess and utility configuration.
    """
    service = FeeStructureService(uow)
    try:
        return service.create_fee_structure(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{fee_id}",
    response_model=FeeStructureResponse,
    summary="Get fee structure details",
)
async def get_fee_structure(
    fee_id: UUID = Path(..., description="Fee structure ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeeStructureResponse:
    """
    Retrieve a single fee structure row.
    """
    service = FeeStructureService(uow)
    try:
        return service.get_fee_structure(fee_id=fee_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{fee_id}",
    response_model=FeeStructureResponse,
    summary="Update a fee structure",
)
async def update_fee_structure(
    fee_id: UUID = Path(..., description="Fee structure ID"),
    payload: FeeStructureUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> FeeStructureResponse:
    """
    Partially update a fee structure (amounts, mess, utilities, effective dates, etc.).
    """
    service = FeeStructureService(uow)
    try:
        return service.update_fee_structure(
            fee_id=fee_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{fee_id}/deactivate",
    response_model=FeeStructureResponse,
    summary="Deactivate a fee structure",
)
async def deactivate_fee_structure(
    fee_id: UUID = Path(..., description="Fee structure ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeeStructureResponse:
    """
    Mark a fee structure as inactive (effective_to, is_active=false), without deleting it.
    """
    service = FeeStructureService(uow)
    try:
        return service.deactivate_fee_structure(fee_id=fee_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{fee_id}/detail",
    response_model=FeeDetail,
    summary="Get fee detail (first-month and recurring totals)",
)
async def get_fee_detail(
    fee_id: UUID = Path(..., description="Fee structure ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeeDetail:
    """
    Get a derived view for a fee structure, including first-month and recurring totals.
    """
    service = FeeStructureService(uow)
    try:
        return service.get_fee_detail(fee_id=fee_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\fee_structures\__init__.py ---
# api/v1/fee_structures/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import fees
from . import config

router = APIRouter(prefix="/fee-structures")

router.include_router(fees.router, tags=["Fee Structures - Core"])
router.include_router(config.router, tags=["Fee Structures - Configuration"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\fee_structures\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\files =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\files\documents.py ---
# api/v1/files/documents.py
from __future__ import annotations

from typing import Annotated, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api import deps
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.file.document_upload import (
    DocumentUploadInitRequest,
    DocumentUploadInitResponse,
    DocumentValidationResult,
    DocumentInfo,
    DocumentList,
)
from app.services.file import DocumentService

router = APIRouter(prefix="/documents")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/{document_id}/validate",
    response_model=DocumentValidationResult,
    status_code=status.HTTP_200_OK,
    summary="Validate an uploaded document",
)
async def validate_document(
    document_service: Annotated[DocumentService, Depends(deps.get_document_service)],
    document_id: UUID = Path(..., description="Document ID"),
) -> DocumentValidationResult:
    try:
        return document_service.validate_document(document_id=document_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/",
    response_model=DocumentList,
    summary="List documents",
)
async def list_documents(
    document_service: Annotated[DocumentService, Depends(deps.get_document_service)],
    owner_id: Optional[UUID] = Query(
        None,
        description="Optional owner/user ID filter",
    ),
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    doc_type: Optional[str] = Query(
        None,
        description="Optional document type filter",
    ),
) -> DocumentList:
    try:
        return document_service.list_documents(
            owner_id=owner_id,
            hostel_id=hostel_id,
            doc_type=doc_type,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{document_id}",
    response_model=DocumentInfo,
    summary="Get document details",
)
async def get_document(
    document_service: Annotated[DocumentService, Depends(deps.get_document_service)],
    document_id: UUID = Path(..., description="Document ID"),
) -> DocumentInfo:
    try:
        return document_service.get_document(document_id=document_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\files\images.py ---
# api/v1/files/images.py
from __future__ import annotations

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api import deps
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.file.image_upload import (
    ImageUploadInitRequest,
    ImageUploadInitResponse,
    ImageProcessingResult,
)
from app.schemas.file.file_response import FileInfo
from app.services.file import ImageService

router = APIRouter(prefix="/images")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/init",
    response_model=ImageUploadInitResponse,
    status_code=status.HTTP_200_OK,
    summary="Initialize an image upload",
)
async def init_image_upload(
    payload: ImageUploadInitRequest,
    image_service: Annotated[ImageService, Depends(deps.get_image_service)],
) -> ImageUploadInitResponse:
    """
    Initialize an image upload, specifying constraints and usage context.

    Service typically returns upload targets and planned variants.
    """
    try:
        return image_service.init_upload(payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{image_id}",
    response_model=FileInfo,
    summary="Get image file metadata",
)
async def get_image_info(
    image_service: Annotated[ImageService, Depends(deps.get_image_service)],
    image_id: UUID = Path(..., description="Image file ID"),
) -> FileInfo:
    try:
        return image_service.get_image(image_id=image_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{image_id}/processing",
    response_model=ImageProcessingResult,
    summary="Get image processing/variants information",
)
async def get_image_processing_result(
    image_service: Annotated[ImageService, Depends(deps.get_image_service)],
    image_id: UUID = Path(..., description="Image file ID"),
) -> ImageProcessingResult:
    try:
        return image_service.get_processing_result(image_id=image_id)
    except ServiceError as exc:
        raise _map_service_error(exc)
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\files\upload.py ---
# api/v1/files/upload.py
from __future__ import annotations

from typing import Annotated, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api import deps
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.file.file_upload import (
    FileUploadInitRequest,
    FileUploadInitResponse,
    FileUploadCompleteRequest,
)
from app.schemas.file.file_response import (
    FileInfo,
    FileListResponse,
    FileURL,
)
from app.services.file import FileService

router = APIRouter(prefix="/upload")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/init",
    response_model=FileUploadInitResponse,
    status_code=status.HTTP_200_OK,
    summary="Initialize a generic file upload",
)
async def init_file_upload(
    payload: FileUploadInitRequest,
    file_service: Annotated[FileService, Depends(deps.get_file_service)],
) -> FileUploadInitResponse:
    """
    Initialize a generic file upload (e.g. S3 presigned URL or similar).

    The service returns upload target information and any metadata needed
    by the client to perform the actual upload.
    """
    try:
        return file_service.init_upload(payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/complete",
    response_model=FileInfo,
    status_code=status.HTTP_201_CREATED,
    summary="Mark an upload as completed",
)
async def complete_file_upload(
    payload: FileUploadCompleteRequest,
    file_service: Annotated[FileService, Depends(deps.get_file_service)],
) -> FileInfo:
    """
    Notify the backend that the file has finished uploading.

    The service persists file metadata and returns a FileInfo record.
    """
    try:
        return file_service.complete_upload(payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


# Get file metadata
@router.get(
    "/{file_id}",
    response_model=FileInfo,
    summary="Get file metadata",
)
async def get_file(
    file_service: Annotated[FileService, Depends(deps.get_file_service)],
    file_id: UUID = Path(..., description="File ID"),
) -> FileInfo:
    try:
        return file_service.get_file(file_id=file_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


# List files
@router.get(
    "/",
    response_model=FileListResponse,
    summary="List files",
)
async def list_files(
    file_service: Annotated[FileService, Depends(deps.get_file_service)],
    owner_id: Optional[UUID] = Query(
        None,
        description="Optional owner/user ID filter",
    ),
    folder: Optional[str] = Query(
        None,
        description="Optional logical folder/path filter",
    ),
    tag: Optional[str] = Query(
        None,
        description="Optional tag filter",
    ),
) -> FileListResponse:
    try:
        return file_service.list_files(
            owner_id=owner_id,
            folder=folder,
            tag=tag,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


# Get file URL
@router.get(
    "/{file_id}/url",
    response_model=FileURL,
    summary="Get a file URL",
)
async def get_file_url(
    file_service: Annotated[FileService, Depends(deps.get_file_service)],
    file_id: UUID = Path(..., description="File ID"),
) -> FileURL:
    try:
        return file_service.get_file_url(file_id=file_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\files\__init__.py ---
# api/v1/files/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import upload
from . import images
from . import documents

router = APIRouter(prefix="/files")

router.include_router(upload.router, tags=["Files - Upload"])
router.include_router(images.router, tags=["Files - Images"])
router.include_router(documents.router, tags=["Files - Documents"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\files\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\hostels =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\hostels\analytics.py ---
# api/v1/hostels/analytics.py
from __future__ import annotations

from datetime import date as Date

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.hostel.hostel_analytics import (
    HostelAnalytics,
    HostelOccupancyStats,
    HostelRevenueStats,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.hostel import HostelAnalyticsService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/{hostel_id}/analytics",
    response_model=HostelAnalytics,
    summary="Get comprehensive analytics for a hostel",
)
async def get_hostel_analytics(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelAnalytics:
    """
    Aggregate analytics for a hostel over a period:
    occupancy, revenue, bookings, complaints, reviews.
    """
    service = HostelAnalyticsService(uow)
    try:
        return service.get_hostel_analytics(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{hostel_id}/analytics/occupancy",
    response_model=HostelOccupancyStats,
    summary="Get occupancy stats for a hostel",
)
async def get_hostel_occupancy_stats(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelOccupancyStats:
    """
    Occupancy-focused stats for a hostel (overall and by room type).
    """
    service = HostelAnalyticsService(uow)
    try:
        return service.get_occupancy_stats(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{hostel_id}/analytics/revenue",
    response_model=HostelRevenueStats,
    summary="Get revenue stats for a hostel",
)
async def get_hostel_revenue_stats(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelRevenueStats:
    """
    Revenue-focused stats for a hostel (monthly revenue, per-student metrics, etc.).
    """
    service = HostelAnalyticsService(uow)
    try:
        return service.get_revenue_stats(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\hostels\comparison.py ---
# api/v1/hostels/comparison.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.hostel.hostel_comparison import (
    HostelComparisonRequest,
    ComparisonResult,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.hostel import HostelComparisonService

router = APIRouter(prefix="/comparison")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/",
    response_model=ComparisonResult,
    summary="Compare multiple hostels",
)
async def compare_hostels(
    payload: HostelComparisonRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> ComparisonResult:
    """
    Compare up to 4 hostels on capacity, pricing, ratings, amenities, room types, and availability.
    """
    service = HostelComparisonService(uow)
    try:
        return service.compare_hostels(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\hostels\details.py ---
# api/v1/hostels/details.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.hostel.hostel_admin import (
    HostelAdminView,
    HostelSettings,
    HostelVisibilityUpdate,
    HostelCapacityUpdate,
    HostelStatusUpdate,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.hostel import HostelAdminViewService

router = APIRouter(prefix="/details")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/{hostel_id}/admin-view",
    response_model=HostelAdminView,
    summary="Get admin view for a hostel",
)
async def get_hostel_admin_view(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelAdminView:
    """
    Build an admin dashboard-style view for a hostel, aggregating capacity,
    students, finances, bookings, complaints, maintenance, subscription, and reviews.
    """
    service = HostelAdminViewService(uow)
    try:
        return service.get_admin_view(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{hostel_id}/settings",
    response_model=HostelSettings,
    summary="Get hostel admin settings",
)
async def get_hostel_settings(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelSettings:
    """
    Get hostel-level admin settings (booking, payments, attendance, notifications, mess, etc.).
    """
    service = HostelAdminViewService(uow)
    try:
        return service.get_settings(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/{hostel_id}/settings",
    response_model=HostelSettings,
    summary="Update hostel admin settings",
)
async def update_hostel_settings(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: HostelSettings = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> HostelSettings:
    """
    Update hostel admin settings.
    """
    service = HostelAdminViewService(uow)
    try:
        return service.update_settings(
            hostel_id=hostel_id,
            settings=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{hostel_id}/visibility",
    response_model=HostelSettings,
    summary="Update hostel visibility flags",
)
async def update_hostel_visibility(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: HostelVisibilityUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> HostelSettings:
    """
    Update hostel visibility-related flags (is_public, is_featured, etc.).
    """
    service = HostelAdminViewService(uow)
    try:
        return service.update_visibility(
            hostel_id=hostel_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{hostel_id}/capacity",
    response_model=HostelSettings,
    summary="Update hostel capacity configuration",
)
async def update_hostel_capacity(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: HostelCapacityUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> HostelSettings:
    """
    Update hostel capacity-related configuration.
    """
    service = HostelAdminViewService(uow)
    try:
        return service.update_capacity(
            hostel_id=hostel_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{hostel_id}/status",
    response_model=HostelSettings,
    summary="Update hostel operational status",
)
async def update_hostel_status(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: HostelStatusUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> HostelSettings:
    """
    Update hostel operational status (active/inactive, status enum).
    """
    service = HostelAdminViewService(uow)
    try:
        return service.update_status(
            hostel_id=hostel_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\hostels\hostels.py ---
# api/v1/hostels/hostels.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.hostel.hostel_filter import HostelFilterParams
from app.schemas.hostel.hostel_response import HostelResponse, HostelDetail, HostelStats
from app.services.common.unit_of_work import UnitOfWork
from app.services.hostel import HostelService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/",
    response_model=List[HostelResponse],
    summary="List hostels (read-only, internal)",
)
async def list_hostels(
    filters: HostelFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> List[HostelResponse]:
    """
    List hostels for internal consumers (students, supervisors, etc.).

    This is a read-only view; admin creation/updating lives under /admin/hostels.
    """
    service = HostelService(uow)
    try:
        return service.list_hostels(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{hostel_id}",
    response_model=HostelDetail,
    summary="Get hostel details (internal)",
)
async def get_hostel(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelDetail:
    """
    Retrieve detailed hostel information for internal use.
    """
    service = HostelService(uow)
    try:
        return service.get_hostel(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{hostel_id}/stats",
    response_model=HostelStats,
    summary="Get hostel statistics (occupancy, revenue, etc.)",
)
async def get_hostel_stats(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelStats:
    """
    Summarized hostel stats: occupancy, revenue, bookings, complaints, reviews.
    """
    service = HostelService(uow)
    try:
        return service.get_hostel_stats(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\hostels\public.py ---
# api/v1/hostels/public.py
from __future__ import annotations

from typing import List
from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.hostel.hostel_public import (
    PublicHostelCard,
    PublicHostelProfile,
    PublicHostelList,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.hostel_public import HostelIndexService, PublicHostelService

router = APIRouter(prefix="/public")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/featured",
    response_model=PublicHostelList,
    summary="List featured hostels (public)",
)
async def list_featured_hostels(
    uow: UnitOfWork = Depends(get_uow),
) -> PublicHostelList:
    """
    Return a list of featured hostels for the public landing page.
    """
    service = HostelIndexService(uow)
    try:
        return service.list_featured()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/newest",
    response_model=PublicHostelList,
    summary="List newest hostels (public)",
)
async def list_newest_hostels(
    uow: UnitOfWork = Depends(get_uow),
) -> PublicHostelList:
    """
    Return a list of newest hostels for the public landing page.
    """
    service = HostelIndexService(uow)
    try:
        return service.list_newest()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{slug}",
    response_model=PublicHostelProfile,
    summary="Get public hostel profile by slug",
)
async def get_public_hostel_profile(
    slug: str = Path(..., description="Hostel slug"),
    uow: UnitOfWork = Depends(get_uow),
) -> PublicHostelProfile:
    """
    Retrieve a public-facing hostel profile by slug (for visitors).
    """
    service = PublicHostelService(uow)
    try:
        return service.get_public_profile(slug=slug)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\hostels\search.py ---
# api/v1/hostels/search.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.hostel.hostel_search import (
    HostelSearchRequest,
    HostelSearchResponse,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.hostel_public import HostelSearchService

router = APIRouter(prefix="/search")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/",
    response_model=HostelSearchResponse,
    summary="Search hostels (public)",
)
async def search_hostels(
    payload: HostelSearchRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> HostelSearchResponse:
    """
    Public hostel search using rich filters, sorting, and facet generation.
    """
    service = HostelSearchService(uow)
    try:
        return service.search(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\hostels\__init__.py ---
# api/v1/hostels/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import hostels
from . import details
from . import analytics
from . import comparison
from . import public
from . import search

router = APIRouter(prefix="/hostels")

router.include_router(hostels.router, tags=["Hostels - Internal"])
router.include_router(details.router, tags=["Hostels - Admin View"])
router.include_router(analytics.router, tags=["Hostels - Analytics"])
router.include_router(comparison.router, tags=["Hostels - Comparison"])
router.include_router(public.router, tags=["Hostels - Public"])
router.include_router(search.router, tags=["Hostels - Search"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\hostels\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\inquiries =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\inquiries\inquiries.py ---
# api/v1/inquiries/inquiries.py
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.common.enums import InquiryStatus
from app.schemas.inquiry.inquiry_base import InquiryCreate
from app.schemas.inquiry.inquiry_response import (
    InquiryResponse,
    InquiryDetail,
    InquiryListItem,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.inquiry import InquiryService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/",
    response_model=InquiryDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new inquiry",
)
async def create_inquiry(
    payload: InquiryCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> InquiryDetail:
    """
    Create a visitor inquiry for a hostel.

    Can be used by public visitor flows or internal/admin tools.
    """
    service = InquiryService(uow)
    try:
        return service.create_inquiry(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{inquiry_id}",
    response_model=InquiryDetail,
    summary="Get inquiry details",
)
async def get_inquiry(
    inquiry_id: UUID = Path(..., description="Inquiry ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> InquiryDetail:
    """
    Retrieve detailed information about a specific inquiry.
    """
    service = InquiryService(uow)
    try:
        return service.get_inquiry(inquiry_id=inquiry_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/",
    response_model=List[InquiryListItem],
    summary="List inquiries for a hostel",
)
async def list_inquiries(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    status_filter: Optional[InquiryStatus] = Query(
        None,
        alias="status",
        description="Optional inquiry status filter",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> List[InquiryListItem]:
    """
    List inquiries for a given hostel, optionally filtered by status.
    """
    service = InquiryService(uow)
    try:
        return service.list_inquiries(
            hostel_id=hostel_id,
            status=status_filter,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/open",
    response_model=List[InquiryListItem],
    summary="List open inquiries for a hostel",
)
async def list_open_inquiries_for_hostel(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> List[InquiryListItem]:
    """
    List open/pending inquiries for a given hostel.
    """
    service = InquiryService(uow)
    try:
        return service.list_open_inquiries(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\inquiries\status.py ---
# api/v1/inquiries/status.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.inquiry.inquiry_status import (
    InquiryStatusUpdate,
    InquiryAssignment,
    InquiryTimelineEntry,
)
from app.schemas.inquiry.inquiry_response import InquiryDetail
from app.services.common.unit_of_work import UnitOfWork
from app.services.inquiry import InquiryService, InquiryAssignmentService

router = APIRouter(prefix="/status")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/{inquiry_id}",
    response_model=InquiryDetail,
    summary="Update inquiry status",
)
async def update_inquiry_status(
    inquiry_id: UUID = Path(..., description="Inquiry ID"),
    payload: InquiryStatusUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> InquiryDetail:
    """
    Update the status of an inquiry (pending, contacted, closed, etc.)
    and optionally add notes.
    """
    service = InquiryService(uow)
    try:
        return service.update_status(
            inquiry_id=inquiry_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{inquiry_id}/assign",
    response_model=InquiryDetail,
    summary="Assign an inquiry to an admin/staff member",
)
async def assign_inquiry(
    inquiry_id: UUID = Path(..., description="Inquiry ID"),
    payload: InquiryAssignment = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> InquiryDetail:
    """
    Assign an inquiry to a specific admin/staff member and update
    contact status/notes as needed.
    """
    service = InquiryAssignmentService(uow)
    try:
        return service.assign_inquiry(
            inquiry_id=inquiry_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{inquiry_id}/timeline",
    response_model=List[InquiryTimelineEntry],
    summary="Get inquiry status/assignment timeline",
)
async def get_inquiry_timeline(
    inquiry_id: UUID = Path(..., description="Inquiry ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> List[InquiryTimelineEntry]:
    """
    Return a timeline of status changes, assignments, and notes
    for a given inquiry.
    """
    service = InquiryService(uow)
    try:
        return service.get_timeline(inquiry_id=inquiry_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\inquiries\__init__.py ---
# api/v1/inquiries/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import inquiries
from . import status

router = APIRouter(prefix="/inquiries")

router.include_router(inquiries.router, tags=["Inquiries - Core"])
router.include_router(status.router, tags=["Inquiries - Status & Assignment"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\inquiries\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\leaves =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\leaves\apply.py ---
# api/v1/leaves/apply.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.leave.leave_application import (
    LeaveApplicationRequest,
    LeaveCancellationRequest,
)
from app.schemas.leave.leave_response import LeaveDetail
from app.services.common.unit_of_work import UnitOfWork
from app.services.leave import LeaveService

router = APIRouter(prefix="/apply")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/",
    response_model=LeaveDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Apply for leave",
)
async def apply_for_leave(
    payload: LeaveApplicationRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> LeaveDetail:
    """
    Submit a new leave application for a student.
    """
    service = LeaveService(uow)
    try:
        return service.apply_for_leave(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{leave_id}/cancel",
    response_model=LeaveDetail,
    summary="Cancel a leave application",
)
async def cancel_leave(
    leave_id: UUID = Path(..., description="Leave application ID"),
    payload: LeaveCancellationRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> LeaveDetail:
    """
    Request cancellation of an existing leave application.

    The service enforces that only certain statuses are cancellable.
    """
    service = LeaveService(uow)
    try:
        return service.cancel_leave(
            leave_id=leave_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\leaves\approval.py ---
# api/v1/leaves/approval.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.leave.leave_approval import (
    LeaveApprovalRequest,
    LeaveApprovalResponse,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.leave import LeaveApprovalService

router = APIRouter(prefix="/approval")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/{leave_id}",
    response_model=LeaveApprovalResponse,
    summary="Approve or reject a leave application",
)
async def approve_or_reject_leave(
    leave_id: UUID = Path(..., description="Leave application ID"),
    payload: LeaveApprovalRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> LeaveApprovalResponse:
    """
    Supervisor/admin approval or rejection of a leave application.

    Only pending leaves can be approved/rejected.
    """
    service = LeaveApprovalService(uow)
    try:
        return service.process_approval(
            leave_id=leave_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\leaves\balance.py ---
# api/v1/leaves/balance.py
from __future__ import annotations

from datetime import date as Date

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.leave.leave_balance import LeaveBalanceSummary
from app.services.common.unit_of_work import UnitOfWork
from app.services.leave import LeaveBalanceService

router = APIRouter(prefix="/balance")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/students/{student_id}",
    response_model=LeaveBalanceSummary,
    summary="Get leave balance summary for a student",
)
async def get_leave_balance_summary(
    student_id: UUID = Path(..., description="Student ID"),
    hostel_id: UUID = Query(..., description="Hostel ID"),
    academic_year_start: Date = Query(
        ...,
        description="Start Date of the academic year (inclusive)",
    ),
    academic_year_end: Date = Query(
        ...,
        description="End Date of the academic year (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> LeaveBalanceSummary:
    """
    Return leave balance summary per type for a student within an academic year.
    """
    service = LeaveBalanceService(uow)
    try:
        return service.get_balance_summary(
            student_id=student_id,
            hostel_id=hostel_id,
            academic_year_start=academic_year_start,
            academic_year_end=academic_year_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\leaves\leaves.py ---
# api/v1/leaves/leaves.py
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.common.enums import LeaveStatus
from app.schemas.leave.leave_base import LeaveUpdate
from app.schemas.leave.leave_response import (
    LeaveResponse,
    LeaveDetail,
    LeaveListItem,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.leave import LeaveService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/{leave_id}",
    response_model=LeaveDetail,
    summary="Get leave application details",
)
async def get_leave(
    leave_id: UUID = Path(..., description="Leave application ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> LeaveDetail:
    """
    Retrieve detailed information about a specific leave application.
    """
    service = LeaveService(uow)
    try:
        return service.get_leave(leave_id=leave_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/students/{student_id}",
    response_model=List[LeaveListItem],
    summary="List leaves for a student",
)
async def list_leaves_for_student(
    student_id: UUID = Path(..., description="Student ID"),
    status_filter: Optional[LeaveStatus] = Query(
        None,
        alias="status",
        description="Optional leave status filter",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> List[LeaveListItem]:
    """
    List leave applications for a student, optionally filtered by status.
    """
    service = LeaveService(uow)
    try:
        return service.list_leaves_for_student(
            student_id=student_id,
            status=status_filter,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/pending",
    response_model=List[LeaveListItem],
    summary="List pending leave applications for a hostel",
)
async def list_pending_leaves_for_hostel(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> List[LeaveListItem]:
    """
    List all pending leave applications for a hostel (for supervisors/admins).
    """
    service = LeaveService(uow)
    try:
        return service.list_pending_for_hostel(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{leave_id}",
    response_model=LeaveDetail,
    summary="Update a leave application",
)
async def update_leave(
    leave_id: UUID = Path(..., description="Leave application ID"),
    payload: LeaveUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> LeaveDetail:
    """
    Partially update a leave application (dates, reason, contacts, document URL, etc.).

    Status changes (approve/reject) are handled via the approval endpoints.
    """
    service = LeaveService(uow)
    try:
        return service.update_leave(
            leave_id=leave_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\leaves\__init__.py ---
# api/v1/leaves/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import leaves
from . import apply
from . import approval
from . import balance

router = APIRouter(prefix="/leaves")

router.include_router(leaves.router, tags=["Leaves - Core"])
router.include_router(apply.router, tags=["Leaves - Apply & Cancel"])
router.include_router(approval.router, tags=["Leaves - Approval"])
router.include_router(balance.router, tags=["Leaves - Balance"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\leaves\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\maintenance =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\maintenance\analytics.py ---
# api/v1/maintenance/analytics.py
from __future__ import annotations

from datetime import date as Date

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.maintenance.maintenance_analytics import MaintenanceAnalytics
from app.services.common.unit_of_work import UnitOfWork
from app.services.maintenance import MaintenanceAnalyticsService

router = APIRouter(prefix="/analytics")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "",
    response_model=MaintenanceAnalytics,
    summary="Get maintenance analytics for a hostel",
)
async def get_maintenance_analytics(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: Date = Query(..., description="Start Date (inclusive)"),
    period_end: Date = Query(..., description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> MaintenanceAnalytics:
    """
    Compute maintenance analytics for a hostel over a period:
    counts, completion rates, costs, trends, category breakdowns, and vendor performance.
    """
    service = MaintenanceAnalyticsService(uow)
    try:
        return service.get_analytics(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\maintenance\approval.py ---
# api/v1/maintenance/approval.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.maintenance.maintenance_approval import (
    ApprovalRequest,
    ApprovalResponse,
    ThresholdConfig,
    ApprovalWorkflow,
    RejectionRequest,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.maintenance import MaintenanceApprovalService

router = APIRouter(prefix="/approval")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/hostels/{hostel_id}/thresholds",
    response_model=ThresholdConfig,
    summary="Get maintenance approval thresholds for a hostel",
)
async def get_threshold_config(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> ThresholdConfig:
    """
    Fetch cost approval thresholds per hostel (e.g. supervisor/admin limits).
    """
    service = MaintenanceApprovalService(uow)
    try:
        return service.get_threshold_config(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/hostels/{hostel_id}/thresholds",
    response_model=ThresholdConfig,
    summary="Update maintenance approval thresholds for a hostel",
)
async def update_threshold_config(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: ThresholdConfig = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ThresholdConfig:
    """
    Update cost approval thresholds for a hostel.
    """
    service = MaintenanceApprovalService(uow)
    try:
        return service.update_threshold_config(
            hostel_id=hostel_id,
            config=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{maintenance_id}",
    response_model=ApprovalResponse,
    summary="Approve a maintenance request",
)
async def approve_maintenance(
    maintenance_id: UUID = Path(..., description="Maintenance request ID"),
    payload: ApprovalRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalResponse:
    """
    Approve a maintenance request, recording cost approval workflow and flags.
    """
    service = MaintenanceApprovalService(uow)
    try:
        return service.approve_maintenance(
            maintenance_id=maintenance_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{maintenance_id}/reject",
    response_model=ApprovalResponse,
    summary="Reject a maintenance request approval",
)
async def reject_maintenance_approval(
    maintenance_id: UUID = Path(..., description="Maintenance request ID"),
    payload: RejectionRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalResponse:
    """
    Reject or decline approval for a maintenance request.
    """
    service = MaintenanceApprovalService(uow)
    try:
        return service.reject_maintenance(
            maintenance_id=maintenance_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{maintenance_id}/workflow",
    response_model=ApprovalWorkflow,
    summary="Get approval workflow for a maintenance request",
)
async def get_approval_workflow(
    maintenance_id: UUID = Path(..., description="Maintenance request ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalWorkflow:
    """
    Retrieve the approval workflow state for a maintenance request.
    """
    service = MaintenanceApprovalService(uow)
    try:
        return service.get_workflow(maintenance_id=maintenance_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\maintenance\assignment.py ---
# api/v1/maintenance/assignment.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.maintenance.maintenance_assignment import (
    TaskAssignment,
    VendorAssignment,
    AssignmentUpdate,
    BulkAssignment,
    AssignmentHistory,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.maintenance import MaintenanceAssignmentService

router = APIRouter(prefix="/assignment")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/{maintenance_id}",
    response_model=TaskAssignment,
    status_code=status.HTTP_200_OK,
    summary="Assign maintenance request to a supervisor/staff",
)
async def assign_maintenance(
    maintenance_id: UUID = Path(..., description="Maintenance request ID"),
    payload: TaskAssignment = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> TaskAssignment:
    """
    Assign a maintenance request to a supervisor or staff member.
    """
    service = MaintenanceAssignmentService(uow)
    try:
        return service.assign_task(
            maintenance_id=maintenance_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{maintenance_id}/vendor",
    response_model=TaskAssignment,
    summary="Assign maintenance request to a vendor",
)
async def assign_vendor(
    maintenance_id: UUID = Path(..., description="Maintenance request ID"),
    payload: VendorAssignment = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> TaskAssignment:
    """
    Assign or update vendor information for a maintenance request.
    """
    service = MaintenanceAssignmentService(uow)
    try:
        return service.assign_vendor(
            maintenance_id=maintenance_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{maintenance_id}",
    response_model=TaskAssignment,
    summary="Update maintenance assignment",
)
async def update_maintenance_assignment(
    maintenance_id: UUID = Path(..., description="Maintenance request ID"),
    payload: AssignmentUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> TaskAssignment:
    """
    Update an existing assignment (e.g. reassignment, deadline, instructions).
    """
    service = MaintenanceAssignmentService(uow)
    try:
        return service.update_assignment(
            maintenance_id=maintenance_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=List[TaskAssignment],
    summary="Bulk assign maintenance requests",
)
async def bulk_assign_maintenance(
    payload: BulkAssignment,
    uow: UnitOfWork = Depends(get_uow),
) -> List[TaskAssignment]:
    """
    Bulk assign multiple maintenance requests to supervisors/staff.
    """
    service = MaintenanceAssignmentService(uow)
    try:
        return service.bulk_assign(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{maintenance_id}/history",
    response_model=AssignmentHistory,
    summary="Get assignment history for a maintenance request",
)
async def get_assignment_history(
    maintenance_id: UUID = Path(..., description="Maintenance request ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentHistory:
    """
    Retrieve the full assignment history for a maintenance request.
    """
    service = MaintenanceAssignmentService(uow)
    try:
        return service.get_history(maintenance_id=maintenance_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\maintenance\completion.py ---
# api/v1/maintenance/completion.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.maintenance.maintenance_completion import (
    CompletionRequest,
    CompletionResponse,
    CompletionCertificate,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.maintenance import MaintenanceCompletionService

router = APIRouter(prefix="/completion")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/{maintenance_id}",
    response_model=CompletionResponse,
    summary="Mark a maintenance request as completed",
)
async def complete_maintenance(
    maintenance_id: UUID = Path(..., description="Maintenance request ID"),
    payload: CompletionRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> CompletionResponse:
    """
    Mark a maintenance request as completed, recording work done, materials, costs,
    and quality checks.
    """
    service = MaintenanceCompletionService(uow)
    try:
        return service.complete_maintenance(
            maintenance_id=maintenance_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{maintenance_id}",
    response_model=CompletionResponse,
    summary="Get completion details for a maintenance request",
)
async def get_completion_details(
    maintenance_id: UUID = Path(..., description="Maintenance request ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> CompletionResponse:
    """
    Retrieve completion details for a maintenance request.
    """
    service = MaintenanceCompletionService(uow)
    try:
        return service.get_completion(maintenance_id=maintenance_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{maintenance_id}/certificate",
    response_model=CompletionCertificate,
    summary="Get completion certificate for a maintenance request",
)
async def get_completion_certificate(
    maintenance_id: UUID = Path(..., description="Maintenance request ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> CompletionCertificate:
    """
    Return a completion certificate payload (for downloads/printing).
    """
    service = MaintenanceCompletionService(uow)
    try:
        return service.get_completion_certificate(maintenance_id=maintenance_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\maintenance\cost.py ---
# api/v1/maintenance/cost.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.maintenance.maintenance_cost import (
    CostTracking,
    CategoryBudget,
    ExpenseReport,
    CostAnalysis,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.maintenance import MaintenanceCostService

router = APIRouter(prefix="/cost")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/{maintenance_id}/tracking",
    response_model=CostTracking,
    summary="Get cost tracking for a maintenance request",
)
async def get_cost_tracking(
    maintenance_id: UUID = Path(..., description="Maintenance request ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> CostTracking:
    """
    Return detailed cost tracking for a single maintenance request.
    """
    service = MaintenanceCostService(uow)
    try:
        return service.get_cost_tracking(maintenance_id=maintenance_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/budget",
    response_model=List[CategoryBudget],
    summary="Get maintenance budget allocation per category for a hostel",
)
async def get_hostel_budget(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> List[CategoryBudget]:
    """
    Get configured budget allocations per maintenance category for a hostel.
    """
    service = MaintenanceCostService(uow)
    try:
        return service.get_budget_allocations(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/expenses",
    response_model=ExpenseReport,
    summary="Get maintenance expense report for a hostel",
)
async def get_hostel_expense_report(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    year: int = Query(..., ge=2000, description="Year for the report"),
    month: int = Query(..., ge=1, le=12, description="Month for the report"),
    uow: UnitOfWork = Depends(get_uow),
) -> ExpenseReport:
    """
    Get an expense report for maintenance costs for a given hostel and month.
    """
    service = MaintenanceCostService(uow)
    try:
        return service.get_expense_report(
            hostel_id=hostel_id,
            year=year,
            month=month,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/analysis",
    response_model=CostAnalysis,
    summary="Get high-level cost analysis for a hostel",
)
async def get_hostel_cost_analysis(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> CostAnalysis:
    """
    High-level cost analysis for maintenance at a hostel (trends, ratios, etc.).
    """
    service = MaintenanceCostService(uow)
    try:
        return service.get_cost_analysis(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\maintenance\requests.py ---
# api/v1/maintenance/requests.py
from __future__ import annotations

from datetime import date as Date

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.maintenance.maintenance_base import (
    MaintenanceCreate,
    MaintenanceUpdate,
    MaintenanceStatusUpdate,
)
from app.schemas.maintenance.maintenance_response import (
    MaintenanceDetail,
    RequestListItem,
    MaintenanceSummary,
)
from app.schemas.maintenance.maintenance_filters import (
    MaintenanceFilterParams,
    SearchRequest as MaintenanceSearchRequest,
)
from app.schemas.maintenance.maintenance_request import (
    MaintenanceRequest,
    RequestSubmission,
    EmergencyRequest,
)
from app.schemas.common.pagination import PaginatedResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.maintenance import MaintenanceService

router = APIRouter(prefix="/requests")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "",
    response_model=PaginatedResponse[RequestListItem],
    summary="List maintenance requests",
)
async def list_maintenance_requests(
    filters: MaintenanceFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[RequestListItem]:
    """
    List maintenance requests using filters (hostel, status, category, priority,
    Date range, etc.) with pagination and sorting.
    """
    service = MaintenanceService(uow)
    try:
        return service.list_requests(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/",
    response_model=MaintenanceDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create a maintenance request (low-level)",
)
async def create_maintenance_request(
    payload: MaintenanceCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> MaintenanceDetail:
    """
    Create a maintenance request with full low-level fields.

    For higher-level flows, prefer `/requests/submit` or `/requests/emergency`.
    """
    service = MaintenanceService(uow)
    try:
        return service.create_request(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/submit",
    response_model=MaintenanceDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Submit a maintenance request",
)
async def submit_maintenance_request(
    payload: RequestSubmission,
    uow: UnitOfWork = Depends(get_uow),
) -> MaintenanceDetail:
    """
    Higher-level submission of a maintenance request by supervisors/staff.

    Includes estimated cost, vendor, and days if known.
    """
    service = MaintenanceService(uow)
    try:
        return service.submit_request(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/emergency",
    response_model=MaintenanceDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Submit an emergency maintenance request",
)
async def submit_emergency_request(
    payload: EmergencyRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> MaintenanceDetail:
    """
    Create an emergency maintenance request with incident details.
    """
    service = MaintenanceService(uow)
    try:
        return service.submit_emergency(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{request_id}",
    response_model=MaintenanceDetail,
    summary="Get maintenance request details",
)
async def get_maintenance_request(
    request_id: UUID = Path(..., description="Maintenance request ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> MaintenanceDetail:
    """
    Retrieve detailed information about a specific maintenance request.
    """
    service = MaintenanceService(uow)
    try:
        return service.get_request(request_id=request_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{request_id}",
    response_model=MaintenanceDetail,
    summary="Update a maintenance request",
)
async def update_maintenance_request(
    request_id: UUID = Path(..., description="Maintenance request ID"),
    payload: MaintenanceUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> MaintenanceDetail:
    """
    Partially update fields of a maintenance request (title, description,
    category, priority, location, costs, etc.).
    """
    service = MaintenanceService(uow)
    try:
        return service.update_request(
            request_id=request_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{request_id}/status",
    response_model=MaintenanceDetail,
    summary="Update maintenance request status",
)
async def update_maintenance_status(
    request_id: UUID = Path(..., description="Maintenance request ID"),
    payload: MaintenanceStatusUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> MaintenanceDetail:
    """
    Update only the status of a maintenance request
    (open, in_progress, pending_approval, completed, etc.).
    """
    service = MaintenanceService(uow)
    try:
        return service.update_status(
            request_id=request_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/search",
    response_model=PaginatedResponse[RequestListItem],
    summary="Search maintenance requests",
)
async def search_maintenance_requests(
    payload: MaintenanceSearchRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[RequestListItem]:
    """
    Perform a richer search over maintenance requests (free-text, combined filters, etc.).
    """
    service = MaintenanceService(uow)
    try:
        return service.search_requests(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/summary",
    response_model=MaintenanceSummary,
    summary="Get maintenance summary for a hostel",
)
async def get_hostel_maintenance_summary(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> MaintenanceSummary:
    """
    Summarize maintenance requests for a hostel (counts by status/priority,
    average completion time, etc.).
    """
    service = MaintenanceService(uow)
    try:
        return service.get_hostel_summary(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\maintenance\schedule.py ---
# api/v1/maintenance/schedule.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.maintenance.maintenance_schedule import (
    PreventiveSchedule,
    ScheduleCreate,
    ScheduleUpdate,
    ScheduleExecution,
    ChecklistResult,
    ScheduleHistory,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.maintenance import MaintenanceScheduleService

router = APIRouter(prefix="/schedule")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/hostels/{hostel_id}",
    response_model=List[PreventiveSchedule],
    summary="List preventive maintenance schedules for a hostel",
)
async def list_preventive_schedules(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> List[PreventiveSchedule]:
    """
    List all preventive maintenance schedules configured for a hostel.
    """
    service = MaintenanceScheduleService(uow)
    try:
        return service.list_schedules(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/hostels/{hostel_id}",
    response_model=PreventiveSchedule,
    status_code=status.HTTP_201_CREATED,
    summary="Create a preventive maintenance schedule",
)
async def create_preventive_schedule(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: ScheduleCreate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> PreventiveSchedule:
    """
    Create a new preventive maintenance schedule for a hostel.
    """
    service = MaintenanceScheduleService(uow)
    try:
        return service.create_schedule(
            hostel_id=hostel_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{schedule_id}",
    response_model=PreventiveSchedule,
    summary="Update a preventive maintenance schedule",
)
async def update_preventive_schedule(
    schedule_id: UUID = Path(..., description="Schedule ID"),
    payload: ScheduleUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> PreventiveSchedule:
    """
    Partially update a preventive maintenance schedule.
    """
    service = MaintenanceScheduleService(uow)
    try:
        return service.update_schedule(
            schedule_id=schedule_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{schedule_id}/execute",
    response_model=ChecklistResult,
    summary="Record schedule execution",
)
async def execute_schedule(
    schedule_id: UUID = Path(..., description="Schedule ID"),
    payload: ScheduleExecution = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ChecklistResult:
    """
    Record an execution instance for a preventive maintenance schedule.
    """
    service = MaintenanceScheduleService(uow)
    try:
        return service.record_execution(
            schedule_id=schedule_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{schedule_id}/history",
    response_model=ScheduleHistory,
    summary="Get schedule execution history",
)
async def get_schedule_history(
    schedule_id: UUID = Path(..., description="Schedule ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> ScheduleHistory:
    """
    Retrieve execution history for a preventive maintenance schedule.
    """
    service = MaintenanceScheduleService(uow)
    try:
        return service.get_history(schedule_id=schedule_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\maintenance\__init__.py ---
# api/v1/maintenance/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import requests
from . import assignment
from . import approval
from . import completion
from . import schedule
from . import cost
from . import analytics

router = APIRouter(prefix="/maintenance")

router.include_router(requests.router, tags=["Maintenance - Requests"])
router.include_router(assignment.router, tags=["Maintenance - Assignment"])
router.include_router(approval.router, tags=["Maintenance - Approval"])
router.include_router(completion.router, tags=["Maintenance - Completion"])
router.include_router(schedule.router, tags=["Maintenance - Preventive Schedule"])
router.include_router(cost.router, tags=["Maintenance - Cost & Budgets"])
router.include_router(analytics.router, tags=["Maintenance - Analytics"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\maintenance\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\mess =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\mess\approval.py ---
# api/v1/mess/approval.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.mess.menu_approval import (
    MenuApprovalRequest,
    MenuApprovalResponse,
    ApprovalWorkflow,
    BulkApproval,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.mess import MessMenuService

router = APIRouter(prefix="/approval")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/menus/{menu_id}",
    response_model=MenuApprovalResponse,
    summary="Approve or reject a mess menu",
)
async def approve_menu(
    menu_id: UUID = Path(..., description="Mess menu ID"),
    payload: MenuApprovalRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> MenuApprovalResponse:
    """
    Approve or reject a mess menu according to MenuApprovalRequest.

    The request typically contains approver info, decision, and notes.
    """
    service = MessMenuService(uow)
    try:
        return service.approve_menu(
            menu_id=menu_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/menus/{menu_id}/workflow",
    response_model=ApprovalWorkflow,
    summary="Get approval workflow for a mess menu",
)
async def get_menu_approval_workflow(
    menu_id: UUID = Path(..., description="Mess menu ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalWorkflow:
    """
    Retrieve the approval workflow/timeline for a given mess menu.
    """
    service = MessMenuService(uow)
    try:
        return service.get_approval_workflow(menu_id=menu_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=List[MenuApprovalResponse],
    summary="Bulk approve/reject mess menus",
)
async def bulk_approve_menus(
    payload: BulkApproval,
    uow: UnitOfWork = Depends(get_uow),
) -> List[MenuApprovalResponse]:
    """
    Bulk approval or rejection of multiple mess menus in one request.
    """
    service = MessMenuService(uow)
    try:
        return service.bulk_approve(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\mess\duplicate.py ---
# api/v1/mess/duplicate.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.mess.menu_duplication import (
    DuplicateMenuRequest,
    DuplicateResponse,
    BulkMenuCreate,
    CrossHostelDuplication,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.mess import MessMenuPlanningService

router = APIRouter(prefix="/duplicate")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/",
    response_model=DuplicateResponse,
    summary="Duplicate a single mess menu",
)
async def duplicate_menu(
    payload: DuplicateMenuRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> DuplicateResponse:
    """
    Duplicate a single mess menu (e.g. copy a day's menu to another date).
    """
    service = MessMenuPlanningService(uow)
    try:
        return service.duplicate_menu(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=DuplicateResponse,
    summary="Bulk create menus across a date range",
)
async def bulk_create_menus(
    payload: BulkMenuCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> DuplicateResponse:
    """
    Bulk create menus over a date range from templates or existing weekly patterns.
    """
    service = MessMenuPlanningService(uow)
    try:
        return service.bulk_create_menus(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/cross-hostel",
    response_model=DuplicateResponse,
    summary="Duplicate menus across hostels",
)
async def cross_hostel_duplication(
    payload: CrossHostelDuplication,
    uow: UnitOfWork = Depends(get_uow),
) -> DuplicateResponse:
    """
    Duplicate menus from one hostel to others according to CrossHostelDuplication config.
    """
    service = MessMenuPlanningService(uow)
    try:
        return service.cross_hostel_duplicate(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\mess\feedback.py ---
# api/v1/mess/feedback.py
from __future__ import annotations

from datetime import date as Date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.mess.menu_feedback import (
    FeedbackRequest,
    FeedbackResponse,
    RatingsSummary,
    QualityMetrics,
    FeedbackAnalysis,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.mess import MessFeedbackService

router = APIRouter(prefix="/feedback")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/menus/{menu_id}",
    response_model=FeedbackResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Submit feedback for a mess menu",
)
async def submit_menu_feedback(
    menu_id: UUID = Path(..., description="Mess menu ID"),
    payload: FeedbackRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> FeedbackResponse:
    """
    Submit feedback and ratings for a specific mess menu.
    """
    service = MessFeedbackService(uow)
    try:
        return service.submit_feedback(
            menu_id=menu_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/menus/{menu_id}",
    response_model=FeedbackResponse,
    summary="Get feedback for a mess menu",
)
async def get_menu_feedback(
    menu_id: UUID = Path(..., description="Mess menu ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeedbackResponse:
    """
    Retrieve aggregated feedback for a specific mess menu.
    """
    service = MessFeedbackService(uow)
    try:
        return service.get_feedback(menu_id=menu_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/ratings",
    response_model=RatingsSummary,
    summary="Get ratings summary for a hostel's mess",
)
async def get_ratings_summary(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    period_start: Optional[Date] = Query(None, description="Start Date (inclusive)"),
    period_end: Optional[Date] = Query(None, description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> RatingsSummary:
    """
    Get overall and per-meal ratings summary for a hostel's mess over a period.
    """
    service = MessFeedbackService(uow)
    try:
        return service.get_ratings_summary(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/analysis",
    response_model=FeedbackAnalysis,
    summary="Get detailed feedback analysis for a hostel's mess",
)
async def get_feedback_analysis(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    period_start: Optional[Date] = Query(None, description="Start Date (inclusive)"),
    period_end: Optional[Date] = Query(None, description="End Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> FeedbackAnalysis:
    """
    Detailed analysis of mess feedback (trends, quality metrics, item-level ratings, etc.).
    """
    service = MessFeedbackService(uow)
    try:
        return service.get_feedback_analysis(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\mess\menu.py ---
# api/v1/mess/menu.py
from __future__ import annotations

from datetime import date as Date

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.mess.mess_menu_base import MessMenuCreate, MessMenuUpdate
from app.schemas.mess.mess_menu_response import (
    MenuResponse,
    MenuDetail,
    WeeklyMenu,
    MonthlyMenu,
    TodayMenu,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.mess import MessMenuService

router = APIRouter(prefix="/menu")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/",
    response_model=MenuDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create a mess menu entry",
)
async def create_mess_menu(
    payload: MessMenuCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> MenuDetail:
    """
    Create a daily mess menu for a hostel.
    """
    service = MessMenuService(uow)
    try:
        return service.create_menu(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{menu_id}",
    response_model=MenuDetail,
    summary="Get mess menu details",
)
async def get_mess_menu(
    menu_id: UUID = Path(..., description="Mess menu ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> MenuDetail:
    """
    Retrieve full details for a specific mess menu entry.
    """
    service = MessMenuService(uow)
    try:
        return service.get_menu(menu_id=menu_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{menu_id}",
    response_model=MenuDetail,
    summary="Update a mess menu",
)
async def update_mess_menu(
    menu_id: UUID = Path(..., description="Mess menu ID"),
    payload: MessMenuUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> MenuDetail:
    """
    Partially update a mess menu (items, times, flags, etc.).
    """
    service = MessMenuService(uow)
    try:
        return service.update_menu(
            menu_id=menu_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/today",
    response_model=TodayMenu,
    summary="Get today's mess menu for a hostel",
)
async def get_today_menu(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> TodayMenu:
    """
    Return today's mess menu for a hostel in a simplified format.
    """
    service = MessMenuService(uow)
    try:
        return service.get_today_menu(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/Date",
    response_model=MenuDetail,
    summary="Get mess menu for a specific Date",
)
async def get_menu_for_date(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    menu_date: Date = Query(..., description="Menu Date (YYYY-MM-DD)"),
    uow: UnitOfWork = Depends(get_uow),
) -> MenuDetail:
    """
    Get the mess menu for a hostel on a given Date.
    """
    service = MessMenuService(uow)
    try:
        return service.get_menu_for_date(
            hostel_id=hostel_id,
            menu_date=menu_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/week",
    response_model=WeeklyMenu,
    summary="Get weekly mess menu for a hostel",
)
async def get_weekly_menu(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    start_date: Date = Query(..., description="Week start Date (inclusive)"),
    end_date: Date = Query(..., description="Week end Date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> WeeklyMenu:
    """
    Return a weekly menu view for a hostel between the given dates.
    """
    service = MessMenuService(uow)
    try:
        return service.get_weekly_menu(
            hostel_id=hostel_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/month",
    response_model=MonthlyMenu,
    summary="Get monthly mess menu for a hostel",
)
async def get_monthly_menu(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    year: int = Query(..., ge=2000, description="Year (e.g. 2025)"),
    month: int = Query(..., ge=1, le=12, description="Month (1-12)"),
    uow: UnitOfWork = Depends(get_uow),
) -> MonthlyMenu:
    """
    Return a monthly menu calendar for a hostel.
    """
    service = MessMenuService(uow)
    try:
        return service.get_monthly_menu(
            hostel_id=hostel_id,
            year=year,
            month=month,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\mess\planning.py ---
# api/v1/mess/planning.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status

from app.api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.mess.menu_planning import (
    MenuPlanRequest,
    WeeklyPlan,
    MonthlyPlan,
    MenuTemplate,
    MenuSuggestion,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.mess import MessMenuPlanningService

router = APIRouter(prefix="/planning")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/plan",
    response_model=WeeklyPlan | MonthlyPlan,
    summary="Generate a mess menu plan",
)
async def generate_menu_plan(
    payload: MenuPlanRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> WeeklyPlan | MonthlyPlan:
    """
    Generate a weekly or monthly mess menu plan based on the provided request,
    templates, and patterns.
    """
    service = MessMenuPlanningService(uow)
    try:
        return service.generate_plan(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/templates",
    response_model=list[MenuTemplate],
    summary="List saved menu templates",
)
async def list_menu_templates(
    uow: UnitOfWork = Depends(get_uow),
) -> list[MenuTemplate]:
    """
    List available mess menu templates that can be used for planning/duplication.
    """
    service = MessMenuPlanningService(uow)
    try:
        return service.list_templates()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/suggestions",
    response_model=list[MenuSuggestion],
    summary="Get menu suggestions",
)
async def get_menu_suggestions(
    uow: UnitOfWork = Depends(get_uow),
) -> list[MenuSuggestion]:
    """
    Get suggested menu combinations or special menus (e.g. for special days).
    """
    service = MessMenuPlanningService(uow)
    try:
        return service.get_suggestions()
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\mess\__init__.py ---
# api/v1/mess/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import menu
from . import planning
from . import feedback
from . import approval
from . import duplicate

router = APIRouter(prefix="/mess")

router.include_router(menu.router, tags=["Mess - Menu"])
router.include_router(planning.router, tags=["Mess - Planning"])
router.include_router(feedback.router, tags=["Mess - Feedback"])
router.include_router(approval.router, tags=["Mess - Approval"])
router.include_router(duplicate.router, tags=["Mess - Duplication"])

__all__ = ["router"]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\mess\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\notifications =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\notifications\notifications.py ---
# app/api/v1/notifications/notifications.py
from __future__ import annotations

from typing import Optional

from fastapi import APIRouter, Depends, Query, status, Response
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.notification import NotificationService
from app.schemas.notification.notification_base import (
    MarkAsRead,
    BulkMarkAsRead,
    NotificationDelete,
)
from app.schemas.notification.notification_response import (
    NotificationList,
    NotificationDetail,
    UnreadCount,
    NotificationSummary,
)
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Notifications - In-App"])


def _get_service(session: Session) -> NotificationService:
    uow = UnitOfWork(session)
    return NotificationService(uow)


@router.get("/", response_model=NotificationList)
def list_my_notifications(
    only_unread: bool = Query(
        False,
        description="If true, return only unread notifications",
    ),
    limit: int = Query(
        50,
        ge=1,
        le=200,
        description="Maximum number of notifications to return",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> NotificationList:
    """
    List notifications for the authenticated user.
    """
    service = _get_service(session)
    # Expected: list_notifications_for_user(user_id, only_unread, limit) -> NotificationList
    return service.list_notifications_for_user(
        user_id=current_user.id,
        only_unread=only_unread,
        limit=limit,
    )


@router.get("/unread-count", response_model=UnreadCount)
def get_unread_count(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> UnreadCount:
    """
    Get unread notifications count for the authenticated user.
    """
    service = _get_service(session)
    # Expected: get_unread_count_for_user(user_id) -> UnreadCount
    return service.get_unread_count_for_user(user_id=current_user.id)


@router.get("/summary", response_model=NotificationSummary)
def get_notification_summary(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> NotificationSummary:
    """
    Get notification summary (unread counts per type/category, etc.).
    """
    service = _get_service(session)
    # Expected: get_summary_for_user(user_id) -> NotificationSummary
    return service.get_summary_for_user(user_id=current_user.id)


@router.get("/{notification_id}", response_model=NotificationDetail)
def get_notification(
    notification_id: str,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> NotificationDetail:
    """
    Get details of a single notification.
    """
    service = _get_service(session)
    # Expected: get_notification_for_user(notification_id, user_id) -> NotificationDetail
    return service.get_notification_for_user(
        notification_id=notification_id,
        user_id=current_user.id,
    )


@router.post("/{notification_id}/read", response_model=NotificationDetail)
def mark_notification_as_read(
    notification_id: str,
    payload: MarkAsRead | None = None,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> NotificationDetail:
    """
    Mark a single notification as read.
    """
    service = _get_service(session)
    # Expected: mark_as_read(user_id, notification_id, data: Optional[MarkAsRead]) -> NotificationDetail
    return service.mark_as_read(
        user_id=current_user.id,
        notification_id=notification_id,
        data=payload,
    )


@router.post("/read/bulk", response_model=NotificationList)
def bulk_mark_as_read(
    payload: BulkMarkAsRead,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> NotificationList:
    """
    Bulk mark multiple notifications as read.
    """
    service = _get_service(session)
    # Expected: bulk_mark_as_read(user_id, data: BulkMarkAsRead) -> NotificationList
    return service.bulk_mark_as_read(
        user_id=current_user.id,
        data=payload,
    )


@router.delete("/{notification_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_notification(
    notification_id: str,
    payload: NotificationDelete | None = None,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> Response:
    """
    Delete (or soft-delete) a single notification.
    """
    service = _get_service(session)
    # Expected: delete_notification(user_id, notification_id, data: Optional[NotificationDelete]) -> None
    service.delete_notification(
        user_id=current_user.id,
        notification_id=notification_id,
        data=payload,
    )
    return Response(status_code=status.HTTP_204_NO_CONTENT)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\notifications\preferences.py ---
# app/api/v1/notifications/preferences.py
from __future__ import annotations

from fastapi import APIRouter, Depends, status, Response
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.notification import PreferenceService
from app.schemas.notification.notification_preferences import (
    UserPreferences,
    PreferenceUpdate,
    UnsubscribeRequest,
)
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Notifications - Preferences"])


def _get_service(session: Session) -> PreferenceService:
    uow = UnitOfWork(session)
    return PreferenceService(uow)


@router.get("/me", response_model=UserPreferences)
def get_my_preferences(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> UserPreferences:
    """
    Get notification preferences for the authenticated user.
    """
    service = _get_service(session)
    # Expected: get_preferences(user_id: UUID) -> UserPreferences
    return service.get_preferences(user_id=current_user.id)


@router.patch("/me", response_model=UserPreferences)
def update_my_preferences(
    payload: PreferenceUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> UserPreferences:
    """
    Update notification preferences for the authenticated user.
    """
    service = _get_service(session)
    # Expected: update_preferences(user_id: UUID, data: PreferenceUpdate) -> UserPreferences
    return service.update_preferences(
        user_id=current_user.id,
        data=payload,
    )


@router.post("/unsubscribe", status_code=status.HTTP_204_NO_CONTENT)
def unsubscribe(
    payload: UnsubscribeRequest,
    session: Session = Depends(get_session),
) -> Response:
    """
    Unsubscribe endpoint (can be used with signed links; may not require auth).

    Service is responsible for validating tokens / keys in the request.
    """
    service = _get_service(session)
    # Expected: handle_unsubscribe(request: UnsubscribeRequest) -> None
    service.handle_unsubscribe(request=payload)
    return Response(status_code=status.HTTP_204_NO_CONTENT)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\notifications\send.py ---
# app/api/v1/notifications/send.py
from __future__ import annotations

from fastapi import APIRouter, Depends, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.notification import (
    NotificationService,
    EmailService,
    SMSService,
    PushService,
)
from app.schemas.notification.notification_base import NotificationCreate
from app.schemas.notification.notification_response import NotificationDetail
from app.schemas.notification.email_notification import (
    EmailRequest,
    BulkEmailRequest,
    EmailStats,
)
from app.schemas.notification.sms_notification import (
    SMSRequest,
    BulkSMSRequest,
    SMSStats,
)
from app.schemas.notification.push_notification import (
    PushRequest,
    PushStats,
)
from . import CurrentUser, get_current_user, get_current_admin

router = APIRouter(tags=["Notifications - Send"])


def _get_notification_service(session: Session) -> NotificationService:
    uow = UnitOfWork(session)
    return NotificationService(uow)


def _get_email_service(session: Session) -> EmailService:
    uow = UnitOfWork(session)
    return EmailService(uow)


def _get_sms_service(session: Session) -> SMSService:
    uow = UnitOfWork(session)
    return SMSService(uow)


def _get_push_service(session: Session) -> PushService:
    uow = UnitOfWork(session)
    return PushService(uow)


# In-app notifications --------------------------------------------------------


@router.post("/in-app", response_model=NotificationDetail, status_code=status.HTTP_201_CREATED)
def send_in_app_notification(
    payload: NotificationCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> NotificationDetail:
    """
    Create and dispatch an in-app notification (admin-triggered).
    """
    service = _get_notification_service(session)
    # Expected: send_notification(created_by: UUID, data: NotificationCreate) -> NotificationDetail
    return service.send_notification(
        created_by=current_user.id,
        data=payload,
    )


# Email -----------------------------------------------------------------------


@router.post("/email", response_model=EmailStats)
def send_email(
    payload: EmailRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> EmailStats:
    """
    Send a single email via EmailService.
    """
    service = _get_email_service(session)
    # Expected: send_email(requester_id: UUID, data: EmailRequest) -> EmailStats | similar
    return service.send_email(
        requester_id=current_user.id,
        data=payload,
    )


@router.post("/email/bulk", response_model=EmailStats)
def send_bulk_email(
    payload: BulkEmailRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> EmailStats:
    """
    Send bulk emails via EmailService.
    """
    service = _get_email_service(session)
    # Expected: send_bulk_email(requester_id: UUID, data: BulkEmailRequest) -> EmailStats
    return service.send_bulk_email(
        requester_id=current_user.id,
        data=payload,
    )


@router.get("/email/stats", response_model=EmailStats)
def get_email_stats(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> EmailStats:
    """
    Get high-level email stats.
    """
    service = _get_email_service(session)
    # Expected: get_stats() -> EmailStats
    return service.get_stats()


# SMS -------------------------------------------------------------------------


@router.post("/sms", response_model=SMSStats)
def send_sms(
    payload: SMSRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> SMSStats:
    """
    Send a single SMS via SMSService.
    """
    service = _get_sms_service(session)
    # Expected: send_sms(requester_id: UUID, data: SMSRequest) -> SMSStats
    return service.send_sms(
        requester_id=current_user.id,
        data=payload,
    )


@router.post("/sms/bulk", response_model=SMSStats)
def send_bulk_sms(
    payload: BulkSMSRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> SMSStats:
    """
    Send bulk SMS via SMSService.
    """
    service = _get_sms_service(session)
    # Expected: send_bulk_sms(requester_id: UUID, data: BulkSMSRequest) -> SMSStats
    return service.send_bulk_sms(
        requester_id=current_user.id,
        data=payload,
    )


@router.get("/sms/stats", response_model=SMSStats)
def get_sms_stats(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> SMSStats:
    """
    Get high-level SMS stats.
    """
    service = _get_sms_service(session)
    # Expected: get_stats() -> SMSStats
    return service.get_stats()


# Push ------------------------------------------------------------------------


@router.post("/push", response_model=PushStats)
def send_push(
    payload: PushRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> PushStats:
    """
    Send a push notification via PushService.
    """
    service = _get_push_service(session)
    # Expected: send_push(requester_id: UUID, data: PushRequest) -> PushStats
    return service.send_push(
        requester_id=current_user.id,
        data=payload,
    )


@router.get("/push/stats", response_model=PushStats)
def get_push_stats(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> PushStats:
    """
    Get high-level push notification stats.
    """
    service = _get_push_service(session)
    # Expected: get_stats() -> PushStats
    return service.get_stats()

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\notifications\templates.py ---
# app/api/v1/notifications/templates.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.notification import TemplateService
from app.schemas.notification.notification_template import (
    TemplateCreate,
    TemplateUpdate,
    TemplateResponse,
    TemplatePreview,
    TemplatePreviewResponse,
    TemplateList,
    TemplateCategory,
)
from . import CurrentUser, get_current_admin

router = APIRouter(tags=["Notifications - Templates"])


def _get_service(session: Session) -> TemplateService:
    uow = UnitOfWork(session)
    return TemplateService(uow)


@router.get("/", response_model=TemplateList)
def list_templates(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> TemplateList:
    """
    List all notification templates.
    """
    service = _get_service(session)
    # Expected: list_templates() -> TemplateList
    return service.list_templates()


@router.get("/categories", response_model=List[TemplateCategory])
def list_template_categories(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> List[TemplateCategory]:
    """
    List template categories.
    """
    service = _get_service(session)
    # Expected: list_categories() -> list[TemplateCategory]
    return service.list_categories()


@router.get("/{template_id}", response_model=TemplateResponse)
def get_template(
    template_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> TemplateResponse:
    """
    Get a single template.
    """
    service = _get_service(session)
    # Expected: get_template(template_id: UUID) -> TemplateResponse
    return service.get_template(template_id=template_id)


@router.post(
    "/",
    response_model=TemplateResponse,
    status_code=status.HTTP_201_CREATED,
)
def create_template(
    payload: TemplateCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> TemplateResponse:
    """
    Create a new template.
    """
    service = _get_service(session)
    # Expected: create_template(data: TemplateCreate, created_by: UUID) -> TemplateResponse
    return service.create_template(
        data=payload,
        created_by=current_user.id,
    )


@router.patch("/{template_id}", response_model=TemplateResponse)
def update_template(
    template_id: UUID,
    payload: TemplateUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> TemplateResponse:
    """
    Update an existing template.
    """
    service = _get_service(session)
    # Expected: update_template(template_id: UUID, data: TemplateUpdate, updated_by: UUID) -> TemplateResponse
    return service.update_template(
        template_id=template_id,
        data=payload,
        updated_by=current_user.id,
    )


@router.delete("/{template_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_template(
    template_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> None:
    """
    Delete a template.
    """
    service = _get_service(session)
    # Expected: delete_template(template_id: UUID) -> None
    service.delete_template(template_id=template_id)
    return None


@router.post("/{template_id}/preview", response_model=TemplatePreviewResponse)
def preview_template(
    template_id: UUID,
    payload: TemplatePreview,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> TemplatePreviewResponse:
    """
    Render a preview of a template with given variables.
    """
    service = _get_service(session)
    # Expected: preview_template(template_id: UUID, data: TemplatePreview) -> TemplatePreviewResponse
    return service.preview_template(
        template_id=template_id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\notifications\__init__.py ---
# app/api/v1/notifications/__init__.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core.security import decode_token, TokenDecodeError
from app.schemas.common.enums import UserRole

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")


@dataclass
class CurrentUser:
    """Minimal representation of the authenticated user for notification APIs."""
    id: UUID
    role: UserRole


def get_current_user(token: str = Depends(oauth2_scheme)) -> CurrentUser:
    """
    Decode JWT and return minimal CurrentUser.

    Expects payload to contain either:
      - sub (user id as string) and role
      - or user_id and user_role
    """
    try:
        payload: dict[str, Any] = decode_token(token)
    except TokenDecodeError as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        ) from exc

    user_id_raw = payload.get("sub") or payload.get("user_id")
    role_raw = payload.get("role") or payload.get("user_role")

    if not user_id_raw or not role_raw:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    try:
        user_id = UUID(str(user_id_raw))
        role = UserRole(str(role_raw))
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        ) from exc

    return CurrentUser(id=user_id, role=role)


def get_current_admin(current_user: CurrentUser = Depends(get_current_user)) -> CurrentUser:
    """Ensure the authenticated user is an ADMIN for admin-only endpoints."""
    if current_user.role is not UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins can access this endpoint",
        )
    return current_user


# Import sub-routers and mount them under /notifications in the main API router.
from . import notifications, templates, preferences, send  # noqa: E402

router.include_router(notifications.router, prefix="/notifications")
router.include_router(templates.router, prefix="/templates")
router.include_router(preferences.router, prefix="/preferences")
router.include_router(send.router, prefix="/send")

__all__ = [
    "router",
    "CurrentUser",
    "get_current_user",
    "get_current_admin",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\notifications\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\payments =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\payments\gateway.py ---
# app/api/v1/payments/gateway.py
from __future__ import annotations

from fastapi import APIRouter, Depends, Request, Response, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.payment import PaymentGatewayService
from app.schemas.payment.payment_gateway import (
    GatewayRequest,
    GatewayResponse,
    GatewayWebhook,
    GatewayCallback,
)
from . import CurrentUser, get_current_admin_or_staff

router = APIRouter(tags=["Payments - Gateway"])


def _get_service(session: Session) -> PaymentGatewayService:
    uow = UnitOfWork(session)
    return PaymentGatewayService(uow)


@router.post("/order", response_model=GatewayResponse)
def create_gateway_order(
    payload: GatewayRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> GatewayResponse:
    """
    Create/refresh a gateway order for an existing Payment.
    """
    service = _get_service(session)
    # Expected: create_order(data: GatewayRequest, requester_id: UUID) -> GatewayResponse
    return service.create_order(
        data=payload,
        requester_id=current_user.id,
    )


@router.post("/webhook", status_code=status.HTTP_200_OK)
async def gateway_webhook(
    payload: GatewayWebhook,
    request: Request,
    session: Session = Depends(get_session),
) -> Response:
    """
    Gateway webhook endpoint to update payment status (unauthenticated; secured by gateway secret).
    """
    service = _get_service(session)
    # Expected: handle_webhook(webhook: GatewayWebhook, raw_request: Request) -> None
    await service.handle_webhook(
        webhook=payload,
        raw_request=request,
    )
    return Response(status_code=status.HTTP_200_OK)


@router.post("/callback", response_model=GatewayResponse)
async def gateway_callback(
    payload: GatewayCallback,
    request: Request,
    session: Session = Depends(get_session),
) -> GatewayResponse:
    """
    Browser/server callback endpoint after payment completion.
    """
    service = _get_service(session)
    # Expected: handle_callback(callback: GatewayCallback, raw_request: Request) -> GatewayResponse
    return await service.handle_callback(
        callback=payload,
        raw_request=request,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\payments\initiate.py ---
# app/api/v1/payments/initiate.py
from __future__ import annotations

from fastapi import APIRouter, Depends, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.payment import PaymentRequestService
from app.schemas.payment.payment_request import (
    PaymentRequest,
    PaymentInitiation,
    ManualPaymentRequest,
    BulkPaymentRequest,
    SinglePaymentRecord,
)
from app.schemas.payment.payment_response import PaymentDetail
from . import CurrentUser, get_current_user, get_current_admin_or_staff

router = APIRouter(tags=["Payments - Initiation"])


def _get_service(session: Session) -> PaymentRequestService:
    uow = UnitOfWork(session)
    return PaymentRequestService(uow)


@router.post("/online", response_model=PaymentInitiation, status_code=status.HTTP_201_CREATED)
def initiate_online_payment(
    payload: PaymentRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> PaymentInitiation:
    """
    Start an online payment flow (creates Payment + gateway order).
    """
    service = _get_service(session)
    # Expected: initiate_online_payment(requester_id: UUID, data: PaymentRequest) -> PaymentInitiation
    return service.initiate_online_payment(
        requester_id=current_user.id,
        data=payload,
    )


@router.post("/manual", response_model=PaymentDetail, status_code=status.HTTP_201_CREATED)
def record_manual_payment(
    payload: ManualPaymentRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> PaymentDetail:
    """
    Record a completed manual payment (cash/cheque/bank_transfer).
    """
    service = _get_service(session)
    # Expected: record_manual_payment(collector_id: UUID, data: ManualPaymentRequest) -> PaymentDetail
    return service.record_manual_payment(
        collector_id=current_user.id,
        data=payload,
    )


@router.post("/bulk", response_model=list[SinglePaymentRecord], status_code=status.HTTP_201_CREATED)
def bulk_create_payments(
    payload: BulkPaymentRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> list[SinglePaymentRecord]:
    """
    Bulk-create/manual payments (e.g., import from CSV).
    """
    service = _get_service(session)
    # Expected: bulk_create_payments(creator_id: UUID, data: BulkPaymentRequest) -> list[SinglePaymentRecord]
    return service.bulk_create_payments(
        creator_id=current_user.id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\payments\ledger.py ---
# app/api/v1/payments/ledger.py
from __future__ import annotations

from datetime import date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.payment import PaymentLedgerService
from app.schemas.payment.payment_ledger import (
    LedgerSummary,
    AccountStatement,
    TransactionHistory,
)
from . import CurrentUser, get_current_user, get_current_admin_or_staff

router = APIRouter(tags=["Payments - Ledger"])


def _get_service(session: Session) -> PaymentLedgerService:
    uow = UnitOfWork(session)
    return PaymentLedgerService(uow)


@router.get("/students/{student_id}/summary", response_model=LedgerSummary)
def get_student_ledger_summary(
    student_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> LedgerSummary:
    """
    Get high-level ledger summary for a student.
    """
    service = _get_service(session)
    # Expected: get_ledger_summary(student_id: UUID) -> LedgerSummary
    return service.get_ledger_summary(student_id=student_id)


@router.get("/students/{student_id}/statement", response_model=AccountStatement)
def get_student_account_statement(
    student_id: UUID,
    start_date: Optional[date] = Query(
        None,
        description="Start date for the statement period (inclusive).",
    ),
    end_date: Optional[date] = Query(
        None,
        description="End date for the statement period (inclusive).",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> AccountStatement:
    """
    Get account statement for a student over a date range.
    """
    service = _get_service(session)
    # Expected:
    #   get_account_statement(student_id: UUID,
    #                         start_date: Optional[date],
    #                         end_date: Optional[date]) -> AccountStatement
    return service.get_account_statement(
        student_id=student_id,
        start_date=start_date,
        end_date=end_date,
    )


@router.get("/students/{student_id}/transactions", response_model=TransactionHistory)
def get_student_transaction_history(
    student_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> TransactionHistory:
    """
    Get full transaction history for a student.
    """
    service = _get_service(session)
    # Expected: get_transaction_history(student_id: UUID) -> TransactionHistory
    return service.get_transaction_history(student_id=student_id)


@router.get("/me/statement", response_model=AccountStatement)
def get_my_account_statement(
    start_date: Optional[date] = Query(
        None,
        description="Start date for the statement period (inclusive).",
    ),
    end_date: Optional[date] = Query(
        None,
        description="End date for the statement period (inclusive).",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> AccountStatement:
    """
    Get an account statement for the authenticated user (if they are a student/payer).
    """
    service = _get_service(session)
    # Expected: get_account_statement_for_user(user_id: UUID, start_date, end_date) -> AccountStatement
    return service.get_account_statement_for_user(
        user_id=current_user.id,
        start_date=start_date,
        end_date=end_date,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\payments\payments.py ---
# app/api/v1/payments/payments.py
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.payment import PaymentService
from app.schemas.payment.payment_base import PaymentCreate, PaymentUpdate
from app.schemas.payment.payment_response import (
    PaymentListItem,
    PaymentDetail,
    PaymentSummary,
)
from app.schemas.payment.payment_filters import PaymentFilterParams
from . import CurrentUser, get_current_user, get_current_admin_or_staff

router = APIRouter(tags=["Payments - Core"])


def _get_service(session: Session) -> PaymentService:
    uow = UnitOfWork(session)
    return PaymentService(uow)


@router.get("/", response_model=List[PaymentListItem])
def list_payments(
    filters: PaymentFilterParams = Depends(),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> List[PaymentListItem]:
    """
    List payments with filters/search/sorting (admin/staff).
    """
    service = _get_service(session)
    # Expected: list_payments(filters: PaymentFilterParams) -> list[PaymentListItem]
    return service.list_payments(filters=filters)


@router.get("/{payment_id}", response_model=PaymentDetail)
def get_payment(
    payment_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> PaymentDetail:
    """
    Get detailed information about a single payment.

    (Visible to staff or the payer themselves; enforcement is in service.)
    """
    service = _get_service(session)
    # Expected: get_payment_detail(payment_id: UUID, requester_id: UUID, role: UserRole) -> PaymentDetail
    return service.get_payment_detail(
        payment_id=payment_id,
        requester_id=current_user.id,
        role=current_user.role,
    )


@router.get("/students/{student_id}", response_model=List[PaymentListItem])
def list_payments_for_student(
    student_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> List[PaymentListItem]:
    """
    List payments for a given student (admin/staff).
    """
    service = _get_service(session)
    # Expected: list_for_student(student_id: UUID) -> list[PaymentListItem]
    return service.list_for_student(student_id=student_id)


@router.get("/hostels/{hostel_id}/summary", response_model=PaymentSummary)
def get_hostel_payment_summary(
    hostel_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> PaymentSummary:
    """
    Payment summary for a hostel (total, due, overdue, etc.).
    """
    service = _get_service(session)
    # Expected: get_summary_for_hostel(hostel_id: UUID) -> PaymentSummary
    return service.get_summary_for_hostel(hostel_id=hostel_id)


@router.post(
    "/",
    response_model=PaymentDetail,
    status_code=status.HTTP_201_CREATED,
)
def create_payment(
    payload: PaymentCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> PaymentDetail:
    """
    Low-level create payment (primarily for admin/manual adjustments).
    Prefer /payments/initiate for interactive flows.
    """
    service = _get_service(session)
    # Expected: create_payment(data: PaymentCreate, created_by: UUID) -> PaymentDetail
    return service.create_payment(data=payload, created_by=current_user.id)


@router.patch("/{payment_id}", response_model=PaymentDetail)
def update_payment(
    payment_id: UUID,
    payload: PaymentUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> PaymentDetail:
    """
    Update a payment (status, receipt info, etc.) (admin/staff).
    """
    service = _get_service(session)
    # Expected: update_payment(payment_id: UUID, data: PaymentUpdate, updated_by: UUID) -> PaymentDetail
    return service.update_payment(
        payment_id=payment_id,
        data=payload,
        updated_by=current_user.id,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\payments\receipt.py ---
# app/api/v1/payments/receipt.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.payment import PaymentService
from app.schemas.payment.payment_response import PaymentReceipt
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Payments - Receipt"])


def _get_service(session: Session) -> PaymentService:
    uow = UnitOfWork(session)
    return PaymentService(uow)


@router.get("/{payment_id}", response_model=PaymentReceipt)
def get_payment_receipt(
    payment_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> PaymentReceipt:
    """
    Get a printable receipt view for a payment.

    (Visible to staff or the payer; enforcement is in service.)
    """
    service = _get_service(session)
    # Expected: get_receipt(payment_id: UUID, requester_id: UUID, role: UserRole) -> PaymentReceipt
    return service.get_receipt(
        payment_id=payment_id,
        requester_id=current_user.id,
        role=current_user.role,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\payments\refunds.py ---
# app/api/v1/payments/refunds.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.payment import RefundService
from app.schemas.payment.payment_refund import (
    RefundRequest,
    RefundResponse,
    RefundApproval,
    RefundList,
    RefundListItem,
)
from . import CurrentUser, get_current_admin_or_staff

router = APIRouter(tags=["Payments - Refunds"])


def _get_service(session: Session) -> RefundService:
    uow = UnitOfWork(session)
    return RefundService(uow)


@router.post("/", response_model=RefundResponse, status_code=status.HTTP_201_CREATED)
def create_refund_request(
    payload: RefundRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> RefundResponse:
    """
    Create a refund request for a payment (admin/staff).
    """
    service = _get_service(session)
    # Expected: create_refund_request(requester_id: UUID, data: RefundRequest) -> RefundResponse
    return service.create_refund_request(
        requester_id=current_user.id,
        data=payload,
    )


@router.get("/", response_model=RefundList)
def list_refunds(
    status_filter: str | None = Query(
        None,
        description="Optional refund status filter",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> RefundList:
    """
    List refund requests with basic totals.
    """
    service = _get_service(session)
    # Expected: list_refunds(status: Optional[str]) -> RefundList
    return service.list_refunds(status=status_filter)


@router.get("/{refund_id}", response_model=RefundResponse)
def get_refund(
    refund_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> RefundResponse:
    """
    Get a single refund by ID.
    """
    service = _get_service(session)
    # Expected: get_refund(refund_id: UUID) -> RefundResponse
    return service.get_refund(refund_id=refund_id)


@router.post("/{refund_id}/approve", response_model=RefundResponse)
def approve_refund(
    refund_id: UUID,
    payload: RefundApproval,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> RefundResponse:
    """
    Approve or reject a refund request.
    """
    service = _get_service(session)
    # Expected: approve_refund(refund_id: UUID, approver_id: UUID, data: RefundApproval) -> RefundResponse
    return service.approve_refund(
        refund_id=refund_id,
        approver_id=current_user.id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\payments\reminders.py ---
# app/api/v1/payments/reminders.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.payment import PaymentReminderService
from app.schemas.payment.payment_reminder import (
    ReminderConfig,
    ReminderLog,
    SendReminderRequest,
    ReminderBatch,
    ReminderStats,
)
from . import CurrentUser, get_current_admin_or_staff

router = APIRouter(tags=["Payments - Reminders"])


def _get_service(session: Session) -> PaymentReminderService:
    uow = UnitOfWork(session)
    return PaymentReminderService(uow)


@router.get("/config/{hostel_id}", response_model=ReminderConfig)
def get_reminder_config(
    hostel_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> ReminderConfig:
    """
    Get reminder configuration for a hostel.
    """
    service = _get_service(session)
    # Expected: get_config(hostel_id: UUID) -> ReminderConfig
    return service.get_config(hostel_id=hostel_id)


@router.put("/config/{hostel_id}", response_model=ReminderConfig)
def update_reminder_config(
    hostel_id: UUID,
    payload: ReminderConfig,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> ReminderConfig:
    """
    Update reminder configuration for a hostel.
    """
    service = _get_service(session)
    # Expected: update_config(hostel_id: UUID, data: ReminderConfig) -> ReminderConfig
    return service.update_config(
        hostel_id=hostel_id,
        data=payload,
    )


@router.post("/send", response_model=ReminderBatch)
def send_reminders(
    payload: SendReminderRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> ReminderBatch:
    """
    Trigger sending reminders for pending/overdue payments according to config.
    """
    service = _get_service(session)
    # Expected: send_reminders(request: SendReminderRequest) -> ReminderBatch
    return service.send_reminders(request=payload)


@router.get("/logs/{hostel_id}", response_model=List[ReminderLog])
def list_reminder_logs(
    hostel_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> List[ReminderLog]:
    """
    List reminder logs for a hostel.
    """
    service = _get_service(session)
    # Expected: list_logs(hostel_id: UUID) -> list[ReminderLog]
    return service.list_logs(hostel_id=hostel_id)


@router.get("/stats/{hostel_id}", response_model=ReminderStats)
def get_reminder_stats(
    hostel_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> ReminderStats:
    """
    Get reminder statistics for a hostel.
    """
    service = _get_service(session)
    # Expected: get_stats(hostel_id: UUID) -> ReminderStats
    return service.get_stats(hostel_id=hostel_id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\payments\schedule.py ---
# app/api/v1/payments/schedule.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.payment import PaymentScheduleService
from app.schemas.payment.payment_schedule import (
    PaymentSchedule,
    ScheduleCreate,
    ScheduleUpdate,
    BulkScheduleCreate,
    ScheduleGeneration,
    ScheduledPaymentGenerated,
    ScheduleSuspension,
)
from . import CurrentUser, get_current_admin_or_staff

router = APIRouter(tags=["Payments - Schedule"])


def _get_service(session: Session) -> PaymentScheduleService:
    uow = UnitOfWork(session)
    return PaymentScheduleService(uow)


@router.get("/students/{student_id}", response_model=List[PaymentSchedule])
def list_schedules_for_student(
    student_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> List[PaymentSchedule]:
    """
    List payment schedules for a student.
    """
    service = _get_service(session)
    # Expected: list_schedules_for_student(student_id: UUID) -> list[PaymentSchedule]
    return service.list_schedules_for_student(student_id=student_id)


@router.post("/", response_model=PaymentSchedule, status_code=status.HTTP_201_CREATED)
def create_schedule(
    payload: ScheduleCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> PaymentSchedule:
    """
    Create a single payment schedule.
    """
    service = _get_service(session)
    # Expected: create_schedule(data: ScheduleCreate) -> PaymentSchedule
    return service.create_schedule(data=payload)


@router.patch("/{schedule_id}", response_model=PaymentSchedule)
def update_schedule(
    schedule_id: UUID,
    payload: ScheduleUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> PaymentSchedule:
    """
    Update an existing payment schedule.
    """
    service = _get_service(session)
    # Expected: update_schedule(schedule_id: UUID, data: ScheduleUpdate) -> PaymentSchedule
    return service.update_schedule(
        schedule_id=schedule_id,
        data=payload,
    )


@router.post("/bulk", response_model=List[PaymentSchedule], status_code=status.HTTP_201_CREATED)
def bulk_create_schedules(
    payload: BulkScheduleCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> List[PaymentSchedule]:
    """
    Bulk-create payment schedules (e.g., for all students in a hostel).
    """
    service = _get_service(session)
    # Expected: bulk_create_schedules(data: BulkScheduleCreate) -> list[PaymentSchedule]
    return service.bulk_create_schedules(data=payload)


@router.post("/{schedule_id}/generate", response_model=List[ScheduledPaymentGenerated])
def generate_payments_from_schedule(
    schedule_id: UUID,
    payload: ScheduleGeneration,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> List[ScheduledPaymentGenerated]:
    """
    Generate pending Payment records from a schedule across a Date range.
    """
    service = _get_service(session)
    # Expected:
    #   generate_payments(schedule_id: UUID, data: ScheduleGeneration)
    #     -> list[ScheduledPaymentGenerated]
    return service.generate_payments(
        schedule_id=schedule_id,
        data=payload,
    )


@router.post("/{schedule_id}/suspend", response_model=PaymentSchedule)
def suspend_schedule(
    schedule_id: UUID,
    payload: ScheduleSuspension,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin_or_staff),
) -> PaymentSchedule:
    """
    Suspend or resume a payment schedule.
    """
    service = _get_service(session)
    # Expected: suspend_schedule(schedule_id: UUID, data: ScheduleSuspension) -> PaymentSchedule
    return service.suspend_schedule(
        schedule_id=schedule_id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\payments\__init__.py ---
# app/api/v1/payments/__init__.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core.security import decode_token, TokenDecodeError
from app.schemas.common.enums import UserRole

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")


@dataclass
class CurrentUser:
    """Minimal representation of the authenticated user for payment APIs."""
    id: UUID
    role: UserRole


def get_current_user(token: str = Depends(oauth2_scheme)) -> CurrentUser:
    """
    Decode JWT and return minimal CurrentUser.

    Expects payload to contain either:
      - sub (user id as string) and role
      - or user_id and user_role
    """
    try:
        payload: dict[str, Any] = decode_token(token)
    except TokenDecodeError as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        ) from exc

    user_id_raw = payload.get("sub") or payload.get("user_id")
    role_raw = payload.get("role") or payload.get("user_role")

    if not user_id_raw or not role_raw:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    try:
        user_id = UUID(str(user_id_raw))
        role = UserRole(str(role_raw))
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        ) from exc

    return CurrentUser(id=user_id, role=role)


def get_current_admin_or_staff(current_user: CurrentUser = Depends(get_current_user)) -> CurrentUser:
    """
    Ensure the authenticated user is staff (ADMIN or SUPERVISOR) for admin-facing endpoints.
    """
    if current_user.role not in {UserRole.ADMIN, UserRole.SUPERVISOR}:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins or supervisors can access this endpoint",
        )
    return current_user


# Import sub-routers and mount them under /payments in the main API router.
from . import payments, initiate, gateway, refunds, schedule, reminders, ledger, receipt  # noqa: E402

router.include_router(payments.router, prefix="/payments")
router.include_router(initiate.router, prefix="/initiate")
router.include_router(gateway.router, prefix="/gateway")
router.include_router(refunds.router, prefix="/refunds")
router.include_router(schedule.router, prefix="/schedule")
router.include_router(reminders.router, prefix="/reminders")
router.include_router(ledger.router, prefix="/ledger")
router.include_router(receipt.router, prefix="/receipt")

__all__ = [
    "router",
    "CurrentUser",
    "get_current_user",
    "get_current_admin_or_staff",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\payments\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\referrals =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\referrals\codes.py ---
# app/api/v1/referrals/codes.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.referral import ReferralService
from app.schemas.referral.referral_code import (
    ReferralCodeGenerate,
    ReferralCodeResponse,
    CodeValidationRequest,
    CodeValidationResponse,
)
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Referrals - Codes"])


def _get_service(session: Session) -> ReferralService:
    uow = UnitOfWork(session)
    return ReferralService(uow)


@router.post("/generate", response_model=ReferralCodeResponse)
def generate_referral_code(
    payload: ReferralCodeGenerate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> ReferralCodeResponse:
    """
    Generate a referral code for the authenticated user.

    (Typically 1 code per active program/user combination, but up to service logic.)
    """
    service = _get_service(session)
    # Expected: generate_code(referrer_id: UUID, data: ReferralCodeGenerate) -> ReferralCodeResponse
    return service.generate_code(
        referrer_id=current_user.id,
        data=payload,
    )


@router.post("/validate", response_model=CodeValidationResponse)
def validate_referral_code(
    payload: CodeValidationRequest,
    session: Session = Depends(get_session),
) -> CodeValidationResponse:
    """
    Validate a referral code (public endpoint).

    Returns validity, associated program/benefits, and potential referrer info.
    """
    service = _get_service(session)
    # Expected: validate_code(request: CodeValidationRequest) -> CodeValidationResponse
    return service.validate_code(request=payload)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\referrals\programs.py ---
# app/api/v1/referrals/programs.py
from __future__ import annotations

from datetime import date as Date
from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.referral import ReferralProgramService
from app.schemas.referral.referral_program_base import ProgramCreate, ProgramUpdate
from app.schemas.referral.referral_program_response import ProgramResponse
from . import CurrentUser, get_current_user, get_current_admin

router = APIRouter(tags=["Referrals - Programs"])


def _get_service(session: Session) -> ReferralProgramService:
    uow = UnitOfWork(session)
    return ReferralProgramService(uow)


@router.get("/", response_model=List[ProgramResponse])
def list_programs(
    active_only: bool = Query(
        False,
        description="If true, return only active programs.",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[ProgramResponse]:
    """
    List referral programs (optionally active_only).

    Expected service method:
        list_programs(active_only: bool) -> list[ProgramResponse]
    """
    service = _get_service(session)
    return service.list_programs(active_only=active_only)


@router.get("/active", response_model=List[ProgramResponse])
def list_active_programs(
    as_of: Optional[date] = Query(
        None,
        description="Filter programs active on this date (defaults to today).",
    ),
    session: Session = Depends(get_session),
) -> List[ProgramResponse]:
    """
    Public endpoint: list active referral programs (by validity window).
    """
    service = _get_service(session)
    # Expected service method:
    #   list_active_programs(as_of: Optional[date]) -> list[ProgramResponse]
    return service.list_active_programs(as_of=as_of)


@router.get("/{program_id}", response_model=ProgramResponse)
def get_program(
    program_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> ProgramResponse:
    """
    Get a single referral program by ID.
    """
    service = _get_service(session)
    # Expected: get_program(program_id: UUID) -> ProgramResponse
    return service.get_program(program_id=program_id)


@router.post(
    "/",
    response_model=ProgramResponse,
    status_code=status.HTTP_201_CREATED,
)
def create_program(
    payload: ProgramCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> ProgramResponse:
    """
    Create a new referral program (admin-only).
    """
    service = _get_service(session)
    # Expected: create_program(data: ProgramCreate) -> ProgramResponse
    return service.create_program(data=payload)


@router.patch("/{program_id}", response_model=ProgramResponse)
def update_program(
    program_id: UUID,
    payload: ProgramUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> ProgramResponse:
    """
    Update an existing referral program (admin-only).
    """
    service = _get_service(session)
    # Expected: update_program(program_id: UUID, data: ProgramUpdate) -> ProgramResponse
    return service.update_program(
        program_id=program_id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\referrals\referrals.py ---
# app/api/v1/referrals/referrals.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.referral import ReferralService
from app.schemas.referral.referral_base import ReferralCreate
from app.schemas.referral.referral_response import ReferralResponse, ReferralStats
from . import CurrentUser, get_current_user, get_current_admin

router = APIRouter(tags=["Referrals - Referrals"])


def _get_service(session: Session) -> ReferralService:
    uow = UnitOfWork(session)
    return ReferralService(uow)


@router.post("/", response_model=ReferralResponse)
def create_referral(
    payload: ReferralCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> ReferralResponse:
    """
    Create a referral record for the current user as referrer.
    """
    service = _get_service(session)
    # Expected: create_referral(referrer_id: UUID, data: ReferralCreate) -> ReferralResponse
    return service.create_referral(
        referrer_id=current_user.id,
        data=payload,
    )


@router.get("/me", response_model=ReferralStats)
def get_my_referral_stats(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> ReferralStats:
    """
    Get aggregated referral statistics for the authenticated user.
    """
    service = _get_service(session)
    # Expected: get_stats_for_referrer(referrer_id: UUID) -> ReferralStats
    return service.get_stats_for_referrer(referrer_id=current_user.id)


@router.get("/me/list", response_model=List[ReferralResponse])
def list_my_referrals(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[ReferralResponse]:
    """
    List all referrals created by the authenticated user.
    """
    service = _get_service(session)
    # Expected: list_referrals_for_referrer(referrer_id: UUID) -> list[ReferralResponse]
    return service.list_referrals_for_referrer(referrer_id=current_user.id)


@router.get("/{referral_id}", response_model=ReferralResponse)
def get_referral(
    referral_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> ReferralResponse:
    """
    Get a single referral record by ID.

    (Visible to admin or the referrer themselves.)
    """
    service = _get_service(session)
    # Expected: get_referral(referral_id: UUID, requester_id: UUID, requester_role: UserRole) -> ReferralResponse
    return service.get_referral(
        referral_id=referral_id,
        requester_id=current_user.id,
        requester_role=current_user.role,
    )


@router.get("/programs/{program_id}", response_model=List[ReferralResponse])
def list_referrals_for_program(
    program_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> List[ReferralResponse]:
    """
    Admin endpoint: list referrals under a given program.
    """
    service = _get_service(session)
    # Expected: list_referrals_for_program(program_id: UUID) -> list[ReferralResponse]
    return service.list_referrals_for_program(program_id=program_id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\referrals\rewards.py ---
# app/api/v1/referrals/rewards.py
from __future__ import annotations

from datetime import date as Date
from typing import Optional, List
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.referral import ReferralRewardService
from app.schemas.referral.referral_rewards import (
    RewardConfig,
    RewardTracking,
    PayoutRequest,
    PayoutRequestResponse,
)
from . import CurrentUser, get_current_user, get_current_admin

router = APIRouter(tags=["Referrals - Rewards"])


def _get_service(session: Session) -> ReferralRewardService:
    uow = UnitOfWork(session)
    return ReferralRewardService(uow)


@router.get("/config", response_model=RewardConfig)
def get_reward_config(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> RewardConfig:
    """
    Get global referral reward configuration (admin-only).
    """
    service = _get_service(session)
    # Expected: get_config() -> RewardConfig
    return service.get_config()


@router.put("/config", response_model=RewardConfig)
def update_reward_config(
    payload: RewardConfig,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> RewardConfig:
    """
    Update global referral reward configuration (admin-only).
    """
    service = _get_service(session)
    # Expected: update_config(data: RewardConfig) -> RewardConfig
    return service.update_config(data=payload)


@router.get("/me/tracking", response_model=RewardTracking)
def get_my_reward_tracking(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> RewardTracking:
    """
    Get referral rewards tracking for the authenticated user (earned/paid/pending).
    """
    service = _get_service(session)
    # Expected: get_tracking_for_user(user_id: UUID) -> RewardTracking
    return service.get_tracking_for_user(user_id=current_user.id)


@router.post("/payouts", response_model=PayoutRequestResponse, status_code=status.HTTP_201_CREATED)
def request_payout(
    payload: PayoutRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> PayoutRequestResponse:
    """
    Create a payout request for the authenticated user.

    Enforces minimum payout amounts via RewardConfig.
    """
    service = _get_service(session)
    # Expected: create_payout_request(user_id: UUID, data: PayoutRequest) -> PayoutRequestResponse
    return service.create_payout_request(
        user_id=current_user.id,
        data=payload,
    )


@router.get("/payouts", response_model=List[PayoutRequestResponse])
def list_payout_requests(
    status_filter: Optional[str] = Query(
        None,
        description="Optional filter by payout status (e.g., pending, approved, paid).",
    ),
    start_date: Optional[Date] = Query(
        None,
        description="Optional start Date for payout requests (inclusive).",
    ),
    end_date: Optional[Date] = Query(
        None,
        description="Optional end Date for payout requests (inclusive).",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_admin),
) -> List[PayoutRequestResponse]:
    """
    Admin endpoint: list payout requests with optional filters.
    """
    service = _get_service(session)
    # Expected:
    #   list_payout_requests(
    #       status: Optional[str],
    #       start_date: Optional[Date],
    #       end_date: Optional[Date],
    #   ) -> list[PayoutRequestResponse]
    return service.list_payout_requests(
        status=status_filter,
        start_date=start_date,
        end_date=end_date,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\referrals\__init__.py ---
# app/api/v1/referrals/__init__.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core.security import decode_token, TokenDecodeError
from app.schemas.common.enums import UserRole

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")


@dataclass
class CurrentUser:
    """Minimal representation of the authenticated user for referral APIs."""
    id: UUID
    role: UserRole


def get_current_user(token: str = Depends(oauth2_scheme)) -> CurrentUser:
    """
    Decode JWT and return minimal CurrentUser.

    Expects payload to contain either:
      - sub (user id as string) and role
      - or user_id and user_role
    """
    try:
        payload: dict[str, Any] = decode_token(token)
    except TokenDecodeError as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        ) from exc

    user_id_raw = payload.get("sub") or payload.get("user_id")
    role_raw = payload.get("role") or payload.get("user_role")

    if not user_id_raw or not role_raw:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    try:
        user_id = UUID(str(user_id_raw))
        role = UserRole(str(role_raw))
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        ) from exc

    return CurrentUser(id=user_id, role=role)


def get_current_admin(current_user: CurrentUser = Depends(get_current_user)) -> CurrentUser:
    """Ensure the authenticated user is an ADMIN for admin-only referral endpoints."""
    if current_user.role is not UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins can access this endpoint",
        )
    return current_user


# Import sub-routers and mount them under /referrals in the main API router.
from . import programs, referrals, codes, rewards  # noqa: E402

router.include_router(programs.router, prefix="/programs")
router.include_router(referrals.router, prefix="/referrals")
router.include_router(codes.router, prefix="/codes")
router.include_router(rewards.router, prefix="/rewards")

__all__ = [
    "router",
    "CurrentUser",
    "get_current_user",
    "get_current_admin",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\referrals\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\reviews =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\reviews\analytics.py ---
# app/api/v1/reviews/analytics.py
from __future__ import annotations

from datetime import date as Date
from uuid import UUID
from typing import Optional

from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.review import ReviewAnalyticsService
from app.schemas.review.review_analytics import ReviewAnalytics
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Reviews - Analytics"])


def _get_service(session: Session) -> ReviewAnalyticsService:
    uow = UnitOfWork(session)
    return ReviewAnalyticsService(uow)


@router.get("/hostels/{hostel_id}", response_model=ReviewAnalytics)
def get_hostel_review_analytics(
    hostel_id: UUID,
    start_date: Optional[Date] = Query(
        None,
        description="Start Date (inclusive) for analytics period",
    ),
    end_date: Optional[Date] = Query(
        None,
        description="End Date (inclusive) for analytics period",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> ReviewAnalytics:
    """
    Get review analytics for a hostel over a period.

    Includes rating distribution, trends, aspect analysis, etc.
    """
    service = _get_service(session)
    # Expected:
    #   get_analytics_for_hostel(
    #       hostel_id: UUID,
    #       start_date: Optional[Date],
    #       end_date: Optional[Date],
    #   ) -> ReviewAnalytics
    return service.get_analytics_for_hostel(
        hostel_id=hostel_id,
        start_date=start_date,
        end_date=end_date,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\reviews\moderation.py ---
# app/api/v1/reviews/moderation.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.review import ReviewModerationService
from app.schemas.review.review_moderation import (
    ModerationRequest,
    ModerationResponse,
    ModerationQueue,
    PendingReview,
    BulkModeration,
    ModerationStats,
)
from . import CurrentUser, get_current_staff

router = APIRouter(tags=["Reviews - Moderation"])


def _get_service(session: Session) -> ReviewModerationService:
    uow = UnitOfWork(session)
    return ReviewModerationService(uow)


@router.get("/queue", response_model=ModerationQueue)
def get_moderation_queue(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_staff),
) -> ModerationQueue:
    """
    Get the pending moderation queue for staff.
    """
    service = _get_service(session)
    # Expected: get_moderation_queue() -> ModerationQueue
    return service.get_moderation_queue()


@router.get("/pending", response_model=List[PendingReview])
def list_pending_reviews(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_staff),
) -> List[PendingReview]:
    """
    List pending reviews (flat list).
    """
    service = _get_service(session)
    # Expected: list_pending_reviews() -> list[PendingReview]
    return service.list_pending_reviews()


@router.post("/{review_id}", response_model=ModerationResponse)
def moderate_review(
    review_id: UUID,
    payload: ModerationRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_staff),
) -> ModerationResponse:
    """
    Approve/reject/flag a single review.
    """
    service = _get_service(session)
    # Expected: moderate_review(review_id: UUID, data: ModerationRequest) -> ModerationResponse
    return service.moderate_review(
        review_id=review_id,
        data=payload,
    )


@router.post("/bulk", response_model=ModerationStats)
def bulk_moderate_reviews(
    payload: BulkModeration,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_staff),
) -> ModerationStats:
    """
    Bulk moderation of multiple reviews.
    """
    service = _get_service(session)
    # Expected: bulk_moderate(data: BulkModeration) -> ModerationStats
    return service.bulk_moderate(data=payload)


@router.get("/stats", response_model=ModerationStats)
def get_moderation_stats(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_staff),
) -> ModerationStats:
    """
    Moderation stats (actions, time-to-moderate, per-user counts).
    """
    service = _get_service(session)
    # Expected: get_stats() -> ModerationStats
    return service.get_stats()

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\reviews\response.py ---
# app/api/v1/reviews/response.py
from __future__ import annotations

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.review import HostelResponseService
from app.schemas.review.review_response_schema import (
    HostelResponseCreate,
    OwnerResponse,
    HostelResponseUpdate,
    ResponseGuidelines,
    ResponseStats,
)
from . import CurrentUser, get_current_staff

router = APIRouter(tags=["Reviews - Hostel Responses"])


def _get_service(session: Session) -> HostelResponseService:
    uow = UnitOfWork(session)
    return HostelResponseService(uow)


@router.get("/guidelines", response_model=ResponseGuidelines)
def get_response_guidelines(
    session: Session = Depends(get_session),
) -> ResponseGuidelines:
    """
    Public guidelines for responding to reviews.
    """
    service = _get_service(session)
    # Expected: get_guidelines() -> ResponseGuidelines
    return service.get_guidelines()


@router.get("/{review_id}", response_model=Optional[OwnerResponse])
def get_hostel_response_for_review(
    review_id: UUID,
    session: Session = Depends(get_session),
) -> Optional[OwnerResponse]:
    """
    Get hostel/owner response for a specific review (if any).
    """
    service = _get_service(session)
    # Expected: get_response_for_review(review_id: UUID) -> Optional[OwnerResponse]
    return service.get_response_for_review(review_id=review_id)


@router.post("/{review_id}", response_model=OwnerResponse)
def create_hostel_response(
    review_id: UUID,
    payload: HostelResponseCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_staff),
) -> OwnerResponse:
    """
    Create a hostel/owner response for a review (staff only).
    """
    service = _get_service(session)
    # Expected: create_response(review_id: UUID, user_id: UUID, data: HostelResponseCreate) -> OwnerResponse
    return service.create_response(
        review_id=review_id,
        user_id=current_user.id,
        data=payload,
    )


@router.patch("/{review_id}", response_model=OwnerResponse)
def update_hostel_response(
    review_id: UUID,
    payload: HostelResponseUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_staff),
) -> OwnerResponse:
    """
    Update an existing hostel/owner response (staff only).
    """
    service = _get_service(session)
    # Expected: update_response(review_id: UUID, user_id: UUID, data: HostelResponseUpdate) -> OwnerResponse
    return service.update_response(
        review_id=review_id,
        user_id=current_user.id,
        data=payload,
    )


@router.get("/hostels/{hostel_id}/stats", response_model=ResponseStats)
def get_response_stats_for_hostel(
    hostel_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_staff),
) -> ResponseStats:
    """
    Stats about how promptly/often a hostel responds to reviews.
    """
    service = _get_service(session)
    # Expected: get_stats_for_hostel(hostel_id: UUID) -> ResponseStats
    return service.get_stats_for_hostel(hostel_id=hostel_id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\reviews\reviews.py ---
# app/api/v1/reviews/reviews.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.review import ReviewService
from app.schemas.review.review_filters import ReviewFilterParams, ReviewExportRequest
from app.schemas.review.review_response import (
    ReviewDetail,
    ReviewListItem,
    ReviewSummary,
)
from . import CurrentUser, get_current_user, get_current_staff

router = APIRouter(tags=["Reviews - Admin/Internal"])


def _get_service(session: Session) -> ReviewService:
    uow = UnitOfWork(session)
    return ReviewService(uow)


@router.get("/", response_model=List[ReviewListItem])
def list_reviews(
    filters: ReviewFilterParams = Depends(),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_staff),
) -> List[ReviewListItem]:
    """
    List reviews with filters/search/sort (admin/internal).
    """
    service = _get_service(session)
    # Expected service method: list_reviews(filters: ReviewFilterParams) -> list[ReviewListItem]
    return service.list_reviews(filters=filters)


@router.get("/{review_id}", response_model=ReviewDetail)
def get_review(
    review_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_staff),
) -> ReviewDetail:
    """
    Get detailed review including moderation/override info (admin/internal).
    """
    service = _get_service(session)
    # Expected: get_review_detail(review_id: UUID) -> ReviewDetail
    return service.get_review_detail(review_id=review_id)


@router.get("/hostels/{hostel_id}/summary", response_model=ReviewSummary)
def get_hostel_review_summary(
    hostel_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> ReviewSummary:
    """
    Summary stats for reviews of a hostel (can be used in dashboards).
    """
    service = _get_service(session)
    # Expected: get_hostel_summary(hostel_id: UUID) -> ReviewSummary
    return service.get_hostel_summary(hostel_id=hostel_id)


@router.post("/export")
def export_reviews(
    payload: ReviewExportRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_staff),
) -> dict:
    """
    Export reviews matching filters (CSV/Excel/etc. via reporting/export service).
    """
    service = _get_service(session)
    # Expected: export_reviews(request: ReviewExportRequest) -> dict | ExportResult
    result = service.export_reviews(request=payload)
    return result

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\reviews\submission.py ---
# app/api/v1/reviews/submission.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.review import PublicReviewService
from app.schemas.review.review_submission import (
    ReviewSubmissionRequest,
    ReviewEligibility,
)
from app.schemas.review.review_response import (
    ReviewDetail,
    ReviewResponse,
)
from app.schemas.review.review_filters import ReviewSearchRequest, ReviewSortOptions
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Reviews - Public Submission & Listing"])


def _get_service(session: Session) -> PublicReviewService:
    uow = UnitOfWork(session)
    return PublicReviewService(uow)


@router.post("/", response_model=ReviewDetail)
def submit_review(
    payload: ReviewSubmissionRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> ReviewDetail:
    """
    Submit a public review (visitor/student). Requires authenticated user.
    """
    service = _get_service(session)
    # Expected: submit_review(user_id: UUID, data: ReviewSubmissionRequest) -> ReviewDetail
    return service.submit_review(
        user_id=current_user.id,
        data=payload,
    )


@router.get("/eligibility", response_model=ReviewEligibility)
def check_review_eligibility(
    hostel_id: UUID = Query(..., description="Hostel the user wants to review"),
    booking_id: UUID | None = Query(
        None,
        description="Optional booking id for more precise eligibility checks",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> ReviewEligibility:
    """
    Check if the current user is eligible to submit or edit a review for a hostel.
    """
    service = _get_service(session)
    # Expected: check_eligibility(user_id: UUID, hostel_id: UUID, booking_id: Optional[UUID]) -> ReviewEligibility
    return service.check_eligibility(
        user_id=current_user.id,
        hostel_id=hostel_id,
        booking_id=booking_id,
    )


@router.get("/hostels/{hostel_id}", response_model=List[ReviewResponse])
def list_public_reviews_for_hostel(
    hostel_id: UUID,
    search: ReviewSearchRequest = Depends(),
    sort: ReviewSortOptions = Depends(),
    session: Session = Depends(get_session),
) -> List[ReviewResponse]:
    """
    Public listing of approved reviews for a hostel (used in public profile pages).
    """
    service = _get_service(session)
    # Expected:
    #   list_public_reviews(hostel_id: UUID,
    #                       search: ReviewSearchRequest,
    #                       sort: ReviewSortOptions) -> list[ReviewResponse]
    return service.list_public_reviews(
        hostel_id=hostel_id,
        search=search,
        sort=sort,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\reviews\voting.py ---
# app/api/v1/reviews/voting.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, status, Response
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.review import ReviewVotingService
from app.schemas.review.review_voting import (
    VoteRequest,
    VoteResponse,
    HelpfulnessScore,
    VoteHistory,
    RemoveVote,
)
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Reviews - Voting"])


def _get_service(session: Session) -> ReviewVotingService:
    uow = UnitOfWork(session)
    return ReviewVotingService(uow)


@router.post("/{review_id}", response_model=VoteResponse)
def cast_or_update_vote(
    review_id: UUID,
    payload: VoteRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> VoteResponse:
    """
    Cast or update a helpfulness vote for a review.
    """
    service = _get_service(session)
    # Expected: cast_vote(user_id: UUID, review_id: UUID, data: VoteRequest) -> VoteResponse
    return service.cast_vote(
        user_id=current_user.id,
        review_id=review_id,
        data=payload,
    )


@router.delete("/{review_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_vote(
    review_id: UUID,
    payload: RemoveVote | None = None,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> Response:
    """
    Remove a helpfulness vote from a review.
    """
    service = _get_service(session)
    # Expected: remove_vote(user_id: UUID, review_id: UUID) -> None
    service.remove_vote(
        user_id=current_user.id,
        review_id=review_id,
    )
    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.get("/me/history", response_model=VoteHistory)
def get_my_vote_history(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> VoteHistory:
    """
    Get the vote history for the authenticated user.
    """
    service = _get_service(session)
    # Expected: get_vote_history(user_id: UUID) -> VoteHistory
    return service.get_vote_history(user_id=current_user.id)


@router.get("/{review_id}/score", response_model=HelpfulnessScore)
def get_review_helpfulness_score(
    review_id: UUID,
    session: Session = Depends(get_session),
) -> HelpfulnessScore:
    """
    Get the helpfulness score for a review.
    """
    service = _get_service(session)
    # Expected: get_helpfulness_score(review_id: UUID) -> HelpfulnessScore
    return service.get_helpfulness_score(review_id=review_id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\reviews\__init__.py ---
# app/api/v1/reviews/__init__.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core.security import decode_token, TokenDecodeError
from app.schemas.common.enums import UserRole

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")


@dataclass
class CurrentUser:
    """Minimal representation of the authenticated user for review APIs."""
    id: UUID
    role: UserRole


def get_current_user(token: str = Depends(oauth2_scheme)) -> CurrentUser:
    """
    Decode JWT and return minimal CurrentUser.

    Expects payload to contain either:
      - sub (user id as string) and role
      - or user_id and user_role
    """
    try:
        payload: dict[str, Any] = decode_token(token)
    except TokenDecodeError as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        ) from exc

    user_id_raw = payload.get("sub") or payload.get("user_id")
    role_raw = payload.get("role") or payload.get("user_role")

    if not user_id_raw or not role_raw:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    try:
        user_id = UUID(str(user_id_raw))
        role = UserRole(str(role_raw))
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        ) from exc

    return CurrentUser(id=user_id, role=role)


def get_current_staff(current_user: CurrentUser = Depends(get_current_user)) -> CurrentUser:
    """
    Ensure the authenticated user is staff (ADMIN or SUPERVISOR) for moderation/owner actions.
    """
    if current_user.role not in {UserRole.ADMIN, UserRole.SUPERVISOR}:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins or supervisors can access this endpoint",
        )
    return current_user


# Import sub-routers and mount them under /reviews in the main API router.
from . import reviews, submission, moderation, voting, response, analytics  # noqa: E402

router.include_router(reviews.router)
router.include_router(submission.router, prefix="/submission")
router.include_router(moderation.router, prefix="/moderation")
router.include_router(voting.router, prefix="/voting")
router.include_router(response.router, prefix="/response")
router.include_router(analytics.router, prefix="/analytics")

__all__ = [
    "router",
    "CurrentUser",
    "get_current_user",
    "get_current_staff",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\reviews\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\rooms =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\rooms\assignment.py ---
# app/api/v1/rooms/assignment.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.room import BedAssignmentService
from app.schemas.room.bed_base import (
    BedAssignmentRequest,
    BedReleaseRequest,
)
from app.schemas.room.bed_response import (
    BedAssignment,
    BedAssignmentHistory,
)
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Rooms - Bed Assignment"])


def _get_service(session: Session) -> BedAssignmentService:
    uow = UnitOfWork(session)
    return BedAssignmentService(uow)


@router.post("/", response_model=BedAssignment)
def assign_bed(
    payload: BedAssignmentRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> BedAssignment:
    """
    Assign a bed to a student.

    Expected service method:
        assign_bed(data: BedAssignmentRequest) -> BedAssignment
    """
    service = _get_service(session)
    return service.assign_bed(data=payload)


@router.post("/release", response_model=BedAssignment)
def release_bed(
    payload: BedReleaseRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> BedAssignment:
    """
    Release a bed from its current student.

    Expected service method:
        release_bed(data: BedReleaseRequest) -> BedAssignment
    """
    service = _get_service(session)
    return service.release_bed(data=payload)


@router.get("/history/{bed_id}", response_model=BedAssignmentHistory)
def get_bed_assignment_history(
    bed_id: str,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> BedAssignmentHistory:
    """
    Get assignment history for a bed (wrapper around StudentRoomAssignment history).

    Expected service method:
        get_bed_assignment_history(bed_id: UUID | str) -> BedAssignmentHistory
    """
    service = _get_service(session)
    return service.get_bed_assignment_history(bed_id=bed_id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\rooms\availability.py ---
# app/api/v1/rooms/availability.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.room import RoomAvailabilityService
from app.schemas.room.room_availability import (
    RoomAvailabilityRequest,
    AvailabilityResponse,
)

router = APIRouter(tags=["Rooms - Availability"])


def _get_service(session: Session) -> RoomAvailabilityService:
    uow = UnitOfWork(session)
    return RoomAvailabilityService(uow)


@router.post("/", response_model=AvailabilityResponse)
def get_room_availability(
    payload: RoomAvailabilityRequest,
    session: Session = Depends(get_session),
) -> AvailabilityResponse:
    """
    Compute room availability for a hostel/Date/room_type combination.

    Expected service method:
        get_availability(request: RoomAvailabilityRequest) -> AvailabilityResponse
    """
    service = _get_service(session)
    return service.get_availability(request=payload)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\rooms\beds.py ---
# app/api/v1/rooms/beds.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.room import BedService
from app.schemas.room.bed_base import (
    BedCreate,
    BedUpdate,
    BulkBedCreate,
)
from app.schemas.room.bed_response import (
    BedResponse,
    BedAvailability,
    BedHistory,
)
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Rooms - Beds"])


def _get_service(session: Session) -> BedService:
    uow = UnitOfWork(session)
    return BedService(uow)


@router.get("/{bed_id}", response_model=BedResponse)
def get_bed(
    bed_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> BedResponse:
    """
    Get a single bed by ID.

    Expected service method:
        get_bed(bed_id: UUID) -> BedResponse
    """
    service = _get_service(session)
    return service.get_bed(bed_id=bed_id)


@router.get("/by-room/{room_id}", response_model=List[BedResponse])
def list_beds_for_room(
    room_id: UUID,
    only_available: bool = Query(
        False,
        description="If true, return only beds that are currently available",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[BedResponse]:
    """
    List beds for a specific room.

    Expected service method:
        list_beds_for_room(room_id: UUID, only_available: bool) -> list[BedResponse]
    """
    service = _get_service(session)
    return service.list_beds_for_room(
        room_id=room_id,
        only_available=only_available,
    )


@router.get("/{bed_id}/availability", response_model=BedAvailability)
def get_bed_availability(
    bed_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> BedAvailability:
    """
    Get simple availability info for a bed.

    Expected service method:
        get_bed_availability(bed_id: UUID) -> BedAvailability
    """
    service = _get_service(session)
    return service.get_bed_availability(bed_id=bed_id)


@router.get("/{bed_id}/history", response_model=BedHistory)
def get_bed_history(
    bed_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> BedHistory:
    """
    Get assignment history for a bed.

    Expected service method:
        get_bed_history(bed_id: UUID) -> BedHistory
    """
    service = _get_service(session)
    return service.get_bed_history(bed_id=bed_id)


@router.post(
    "/",
    response_model=BedResponse,
    status_code=status.HTTP_201_CREATED,
)
def create_bed(
    payload: BedCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> BedResponse:
    """
    Create a single bed.

    Expected service method:
        create_bed(data: BedCreate) -> BedResponse
    """
    service = _get_service(session)
    return service.create_bed(data=payload)


@router.post(
    "/bulk",
    response_model=List[BedResponse],
    status_code=status.HTTP_201_CREATED,
)
def bulk_create_beds(
    payload: BulkBedCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[BedResponse]:
    """
    Bulk-create beds for a room.

    Expected service method:
        bulk_create_beds(data: BulkBedCreate) -> list[BedResponse]
    """
    service = _get_service(session)
    return service.bulk_create_beds(data=payload)


@router.patch("/{bed_id}", response_model=BedResponse)
def update_bed(
    bed_id: UUID,
    payload: BedUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> BedResponse:
    """
    Update bed metadata or status.

    Expected service method:
        update_bed(bed_id: UUID, data: BedUpdate) -> BedResponse
    """
    service = _get_service(session)
    return service.update_bed(
        bed_id=bed_id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\rooms\rooms.py ---
# app/api/v1/rooms/rooms.py
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.schemas.common.enums import RoomType
from app.schemas.room.room_base import (
    RoomCreate,
    RoomUpdate,
    BulkRoomCreate,
    RoomPricingUpdate,
    RoomStatusUpdate,
)
from app.schemas.room.room_response import (
    RoomListItem,
    RoomDetail,
    RoomWithBeds,
    RoomOccupancyStats,
)
from app.services import UnitOfWork
from app.services.room import RoomService
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Rooms"])


def _get_service(session: Session) -> RoomService:
    uow = UnitOfWork(session)
    return RoomService(uow)


@router.get("/", response_model=List[RoomListItem])
def list_rooms(
    hostel_id: UUID = Query(..., description="Hostel ID to list rooms for"),
    only_available: bool = Query(
        False,
        description="If true, return only rooms available for booking",
    ),
    room_type: Optional[RoomType] = Query(
        None,
        description="Optional filter by room type",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[RoomListItem]:
    """
    List rooms for a hostel with optional filters.

    Expected service method:
        list_rooms(hostel_id: UUID, only_available: bool, room_type: Optional[RoomType])
            -> list[RoomListItem]
    """
    service = _get_service(session)
    return service.list_rooms(
        hostel_id=hostel_id,
        only_available=only_available,
        room_type=room_type,
    )


@router.get("/{room_id}", response_model=RoomDetail)
def get_room(
    room_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> RoomDetail:
    """
    Get detailed information for a single room.

    Expected service method:
        get_room_detail(room_id: UUID) -> RoomDetail
    """
    service = _get_service(session)
    return service.get_room_detail(room_id=room_id)


@router.get("/{room_id}/with-beds", response_model=RoomWithBeds)
def get_room_with_beds(
    room_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> RoomWithBeds:
    """
    Get room details including bed information.

    Expected service method:
        get_room_with_beds(room_id: UUID) -> RoomWithBeds
    """
    service = _get_service(session)
    return service.get_room_with_beds(room_id=room_id)


@router.get("/{room_id}/occupancy", response_model=RoomOccupancyStats)
def get_room_occupancy_stats(
    room_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> RoomOccupancyStats:
    """
    Get occupancy and revenue projection stats for a room.

    Expected service method:
        get_room_occupancy_stats(room_id: UUID) -> RoomOccupancyStats
    """
    service = _get_service(session)
    return service.get_room_occupancy_stats(room_id=room_id)


@router.post(
    "/",
    response_model=RoomDetail,
    status_code=status.HTTP_201_CREATED,
)
def create_room(
    payload: RoomCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> RoomDetail:
    """
    Create a single room.

    Expected service method:
        create_room(data: RoomCreate) -> RoomDetail
    """
    service = _get_service(session)
    return service.create_room(data=payload)


@router.post(
    "/bulk",
    response_model=List[RoomDetail],
    status_code=status.HTTP_201_CREATED,
)
def bulk_create_rooms(
    payload: BulkRoomCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[RoomDetail]:
    """
    Bulk-create rooms for a hostel.

    Expected service method:
        bulk_create_rooms(data: BulkRoomCreate) -> list[RoomDetail]
    """
    service = _get_service(session)
    return service.bulk_create_rooms(data=payload)


@router.patch("/{room_id}", response_model=RoomDetail)
def update_room(
    room_id: UUID,
    payload: RoomUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> RoomDetail:
    """
    Update room metadata and configuration.

    Expected service method:
        update_room(room_id: UUID, data: RoomUpdate) -> RoomDetail
    """
    service = _get_service(session)
    return service.update_room(
        room_id=room_id,
        data=payload,
    )


@router.patch("/{room_id}/pricing", response_model=RoomDetail)
def update_room_pricing(
    room_id: UUID,
    payload: RoomPricingUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> RoomDetail:
    """
    Update pricing for a room.

    Expected service method:
        update_room_pricing(room_id: UUID, data: RoomPricingUpdate) -> RoomDetail
    """
    service = _get_service(session)
    return service.update_room_pricing(
        room_id=room_id,
        data=payload,
    )


@router.patch("/{room_id}/status", response_model=RoomDetail)
def update_room_status(
    room_id: UUID,
    payload: RoomStatusUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> RoomDetail:
    """
    Update availability/status flags for a room.

    Expected service method:
        update_room_status(room_id: UUID, data: RoomStatusUpdate) -> RoomDetail
    """
    service = _get_service(session)
    return service.update_room_status(
        room_id=room_id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\rooms\__init__.py ---
# app/api/v1/rooms/__init__.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core.security import decode_token, TokenDecodeError
from app.schemas.common.enums import UserRole

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")


@dataclass
class CurrentUser:
    """Minimal representation of the authenticated user for room APIs."""
    id: UUID
    role: UserRole


def get_current_user(token: str = Depends(oauth2_scheme)) -> CurrentUser:
    """
    Decode JWT and return minimal CurrentUser.

    Expects payload to contain either:
      - sub (user id as string) and role
      - or user_id and user_role
    """
    try:
        payload: dict[str, Any] = decode_token(token)
    except TokenDecodeError as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        ) from exc

    user_id_raw = payload.get("sub") or payload.get("user_id")
    role_raw = payload.get("role") or payload.get("user_role")

    if not user_id_raw or not role_raw:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    try:
        user_id = UUID(str(user_id_raw))
        role = UserRole(str(role_raw))
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        ) from exc

    return CurrentUser(id=user_id, role=role)


# Import sub-routers and mount them under /rooms in the main API router.
from . import rooms, availability, beds, assignment  # noqa: E402

router.include_router(rooms.router)
router.include_router(availability.router, prefix="/availability")
router.include_router(beds.router, prefix="/beds")
router.include_router(assignment.router, prefix="/assignment")

__all__ = [
    "router",
    "CurrentUser",
    "get_current_user",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\rooms\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\search =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\search\analytics.py ---
# app/api/v1/search/analytics.py
from __future__ import annotations

from datetime import date as Date
from typing import Optional

from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.search import SearchAnalyticsService
from app.schemas.search.search_analytics import SearchAnalytics
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Search - Analytics"])


def _get_service(session: Session) -> SearchAnalyticsService:
    uow = UnitOfWork(session)
    return SearchAnalyticsService(uow)


@router.get("/summary", response_model=SearchAnalytics)
def get_search_analytics(
    start_date: Optional[Date] = Query(
        None,
        description="Start Date for analytics window (inclusive). If omitted, uses a default window.",
    ),
    end_date: Optional[Date] = Query(
        None,
        description="End Date for analytics window (inclusive). If omitted, uses today.",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SearchAnalytics:
    """
    Aggregated search analytics for a period.

    Expected service method:
        get_analytics(start_date: Optional[Date], end_date: Optional[Date]) -> SearchAnalytics
    """
    service = _get_service(session)
    return service.get_analytics(
        start_date=start_date,
        end_date=end_date,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\search\autocomplete.py ---
# app/api/v1/search/autocomplete.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.search import AutocompleteService
from app.schemas.search.search_autocomplete import (
    AutocompleteRequest,
    AutocompleteResponse,
)

router = APIRouter(tags=["Search - Autocomplete"])


def _get_service(session: Session) -> AutocompleteService:
    uow = UnitOfWork(session)
    return AutocompleteService(uow)


@router.post("/", response_model=AutocompleteResponse)
def autocomplete(
    payload: AutocompleteRequest,
    session: Session = Depends(get_session),
) -> AutocompleteResponse:
    """
    Return autocomplete suggestions for hostel names, cities, and areas.

    Expected service method:
        get_suggestions(request: AutocompleteRequest) -> AutocompleteResponse
    """
    service = _get_service(session)
    return service.get_suggestions(request=payload)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\search\search.py ---
# app/api/v1/search/search.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.search import SearchService
from app.schemas.search.search_request import (
    BasicSearchRequest,
    AdvancedSearchRequest,
)
from app.schemas.search.search_response import FacetedSearchResponse

router = APIRouter(tags=["Search"])


def _get_service(session: Session) -> SearchService:
    uow = UnitOfWork(session)
    return SearchService(uow)


@router.post("/basic", response_model=FacetedSearchResponse)
def basic_search(
    payload: BasicSearchRequest,
    session: Session = Depends(get_session),
) -> FacetedSearchResponse:
    """
    Public basic search endpoint.

    Expected service method:
        basic_search(request: BasicSearchRequest) -> FacetedSearchResponse
    """
    service = _get_service(session)
    return service.basic_search(request=payload)


@router.post("/advanced", response_model=FacetedSearchResponse)
def advanced_search(
    payload: AdvancedSearchRequest,
    session: Session = Depends(get_session),
) -> FacetedSearchResponse:
    """
    Public advanced search endpoint with richer filters and sorting.

    Expected service method:
        advanced_search(request: AdvancedSearchRequest) -> FacetedSearchResponse
    """
    service = _get_service(session)
    return service.advanced_search(request=payload)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\search\__init__.py ---
# app/api/v1/search/__init__.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core.security import decode_token, TokenDecodeError
from app.schemas.common.enums import UserRole

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")


@dataclass
class CurrentUser:
    """Minimal representation of the authenticated user for search analytics."""
    id: UUID
    role: UserRole


def get_current_user(token: str = Depends(oauth2_scheme)) -> CurrentUser:
    """
    Decode JWT and return minimal CurrentUser.

    Expects payload to contain either:
      - sub (user id as string) and role
      - or user_id and user_role
    """
    try:
        payload: dict[str, Any] = decode_token(token)
    except TokenDecodeError as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        ) from exc

    user_id_raw = payload.get("sub") or payload.get("user_id")
    role_raw = payload.get("role") or payload.get("user_role")

    if not user_id_raw or not role_raw:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    try:
        user_id = UUID(str(user_id_raw))
        role = UserRole(str(role_raw))
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        ) from exc

    return CurrentUser(id=user_id, role=role)


# Import sub-routers and mount them under /search in the main API router.
from . import search, autocomplete, analytics  # noqa: E402

router.include_router(search.router)
router.include_router(autocomplete.router, prefix="/autocomplete")
router.include_router(analytics.router, prefix="/analytics")

__all__ = [
    "router",
    "CurrentUser",
    "get_current_user",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\search\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\students =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\students\dashboard.py ---
# app/api/v1/students/dashboard.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.student import StudentDashboardService
from app.schemas.student.student_dashboard import StudentDashboard
from . import CurrentUser, get_current_student

router = APIRouter(tags=["Students - Dashboard"])


def _get_service(session: Session) -> StudentDashboardService:
    uow = UnitOfWork(session)
    return StudentDashboardService(uow)


@router.get("/", response_model=StudentDashboard)
def get_my_dashboard(
    current_user: CurrentUser = Depends(get_current_student),
    session: Session = Depends(get_session),
) -> StudentDashboard:
    """
    Return the dashboard for the authenticated student.

    Expected service method:
        get_dashboard_for_user(user_id: UUID) -> StudentDashboard
    """
    service = _get_service(session)
    return service.get_dashboard_for_user(user_id=current_user.id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\students\finance.py ---
# app/api/v1/students/finance.py
from __future__ import annotations

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.student import StudentFinanceService
from app.schemas.student.student_dashboard import StudentFinancialSummary
from app.schemas.student.student_response import StudentFinancialInfo
from . import CurrentUser, get_current_user, get_current_student

router = APIRouter(tags=["Students - Finance"])


def _get_service(session: Session) -> StudentFinanceService:
    uow = UnitOfWork(session)
    return StudentFinanceService(uow)


@router.get("/me/summary", response_model=StudentFinancialSummary)
def get_my_financial_summary(
    current_user: CurrentUser = Depends(get_current_student),
    session: Session = Depends(get_session),
) -> StudentFinancialSummary:
    """
    Financial summary for the authenticated student (due/overdue/next due).

    Expected service method:
        get_summary_for_user(user_id: UUID) -> StudentFinancialSummary
    """
    service = _get_service(session)
    return service.get_summary_for_user(user_id=current_user.id)


@router.get("/{student_id}/summary", response_model=StudentFinancialSummary)
def get_financial_summary_for_student(
    student_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> StudentFinancialSummary:
    """
    Admin endpoint: financial summary for a specific student.

    Expected service method:
        get_summary_for_student(student_id: UUID) -> StudentFinancialSummary
    """
    service = _get_service(session)
    return service.get_summary_for_student(student_id=student_id)


@router.get("/{student_id}/detail", response_model=StudentFinancialInfo)
def get_financial_detail_for_student(
    student_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> StudentFinancialInfo:
    """
    Admin endpoint: detailed financial info for a specific student.

    Expected service method:
        get_financial_info(student_id: UUID) -> StudentFinancialInfo
    """
    service = _get_service(session)
    return service.get_financial_info(student_id=student_id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\students\profile.py ---
# app/api/v1/students/profile.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.student import StudentProfileService
from app.schemas.student.student_profile import (
    StudentProfileUpdate,
    StudentDocuments,
    DocumentInfo,
    DocumentUploadRequest,
    DocumentVerificationRequest,
    StudentPreferences,
)
from app.schemas.student.student_response import StudentDetail
from . import CurrentUser, get_current_student

router = APIRouter(tags=["Students - Profile"])


def _get_service(session: Session) -> StudentProfileService:
    uow = UnitOfWork(session)
    return StudentProfileService(uow)


@router.get("/", response_model=StudentDetail)
def get_my_student_profile(
    current_user: CurrentUser = Depends(get_current_student),
    session: Session = Depends(get_session),
) -> StudentDetail:
    """
    Get the student profile for the authenticated student user.

    Expected service method:
        get_profile_for_user(user_id: UUID) -> StudentDetail
    """
    service = _get_service(session)
    return service.get_profile_for_user(user_id=current_user.id)


@router.patch("", response_model=StudentDetail)
def update_my_student_profile(
    payload: StudentProfileUpdate,
    current_user: CurrentUser = Depends(get_current_student),
    session: Session = Depends(get_session),
) -> StudentDetail:
    """
    Update profile fields (guardian, institution, employment, preferences) for the current student.

    Expected service method:
        update_profile_for_user(user_id: UUID, data: StudentProfileUpdate) -> StudentDetail
    """
    service = _get_service(session)
    return service.update_profile_for_user(
        user_id=current_user.id,
        data=payload,
    )


@router.get("/preferences", response_model=StudentPreferences)
def get_my_preferences(
    current_user: CurrentUser = Depends(get_current_student),
    session: Session = Depends(get_session),
) -> StudentPreferences:
    """
    Get preferences for the authenticated student.

    Expected service method:
        get_preferences_for_user(user_id: UUID) -> StudentPreferences
    """
    service = _get_service(session)
    return service.get_preferences_for_user(user_id=current_user.id)


@router.patch("/preferences", response_model=StudentPreferences)
def update_my_preferences(
    payload: StudentPreferences,
    current_user: CurrentUser = Depends(get_current_student),
    session: Session = Depends(get_session),
) -> StudentPreferences:
    """
    Update preferences for the authenticated student.

    Expected service method:
        update_preferences_for_user(user_id: UUID, data: StudentPreferences) -> StudentPreferences
    """
    service = _get_service(session)
    return service.update_preferences_for_user(
        user_id=current_user.id,
        data=payload,
    )


@router.get("/documents", response_model=StudentDocuments)
def list_my_documents(
    current_user: CurrentUser = Depends(get_current_student),
    session: Session = Depends(get_session),
) -> StudentDocuments:
    """
    List all documents for the authenticated student.

    Expected service method:
        list_documents_for_user(user_id: UUID) -> StudentDocuments
    """
    service = _get_service(session)
    return service.list_documents_for_user(user_id=current_user.id)


@router.post("/documents/upload", response_model=DocumentInfo)
def init_document_upload(
    payload: DocumentUploadRequest,
    current_user: CurrentUser = Depends(get_current_student),
    session: Session = Depends(get_session),
) -> DocumentInfo:
    """
    Initialize a document upload for the student (returns metadata / upload target).

    Expected service method:
        init_document_upload(user_id: UUID, data: DocumentUploadRequest) -> DocumentInfo
    """
    service = _get_service(session)
    return service.init_document_upload(
        user_id=current_user.id,
        data=payload,
    )


@router.post("/documents/{document_id}/verify", response_model=DocumentInfo)
def verify_document(
    document_id: UUID,
    payload: DocumentVerificationRequest,
    current_user: CurrentUser = Depends(get_current_student),
    session: Session = Depends(get_session),
) -> DocumentInfo:
    """
    Submit verification info for an uploaded document.

    Expected service method:
        verify_document(user_id: UUID, document_id: UUID, data: DocumentVerificationRequest) -> DocumentInfo
    """
    service = _get_service(session)
    return service.verify_document(
        user_id=current_user.id,
        document_id=document_id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\students\room_history.py ---
# app/api/v1/students/room_history.py
from __future__ import annotations

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.student import StudentRoomHistoryService
from app.schemas.student.student_room_history import RoomHistoryResponse
from . import CurrentUser, get_current_user, get_current_student

router = APIRouter(tags=["Students - Room History"])


def _get_service(session: Session) -> StudentRoomHistoryService:
    uow = UnitOfWork(session)
    return StudentRoomHistoryService(uow)


@router.get("/", response_model=RoomHistoryResponse)
def get_my_room_history(
    current_user: CurrentUser = Depends(get_current_student),
    session: Session = Depends(get_session),
) -> RoomHistoryResponse:
    """
    Get room/bed history for the authenticated student.

    Expected service method:
        get_history_for_user(user_id: UUID) -> RoomHistoryResponse
    """
    service = _get_service(session)
    return service.get_history_for_user(user_id=current_user.id)


@router.get("/{student_id}", response_model=RoomHistoryResponse)
def get_room_history_for_student(
    student_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> RoomHistoryResponse:
    """
    Admin endpoint: get room/bed history for a specific student.

    Expected service method:
        get_history_for_student(student_id: UUID) -> RoomHistoryResponse
    """
    service = _get_service(session)
    return service.get_history_for_student(student_id=student_id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\students\search.py ---
# app/api/v1/students/search.py
from __future__ import annotations

from typing import List

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.student import StudentSearchService
from app.schemas.student.student_filters import (
    StudentSearchRequest,
    StudentExportRequest,
)
from app.schemas.student.student_response import StudentListItem
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Students - Search"])


def _get_service(session: Session) -> StudentSearchService:
    uow = UnitOfWork(session)
    return StudentSearchService(uow)


@router.post("/", response_model=List[StudentListItem])
def search_students(
    payload: StudentSearchRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[StudentListItem]:
    """
    Advanced student search over name, email, phone, room, institution, etc.

    Expected service method:
        search(request: StudentSearchRequest) -> list[StudentListItem]
    """
    service = _get_service(session)
    return service.search(request=payload)


@router.post("/export")
def export_students(
    payload: StudentExportRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> dict:
    """
    Export students matching given criteria.

    This returns a simple metadata dict; you can adapt it to stream files
    or integrate with your generic export service.

    Expected service method:
        export(request: StudentExportRequest) -> dict | ExportResult
    """
    service = _get_service(session)
    result = service.export(request=payload)
    # Assume result is already JSON-serializable (e.g., { "url": "...", "format": "csv" })
    return result

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\students\students.py ---
# app/api/v1/students/students.py
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.student import StudentService
from app.schemas.student.student_base import StudentCreate, StudentUpdate
from app.schemas.student.student_response import (
    StudentDetail,
    StudentListItem,
)
from app.schemas.student.student_filters import StudentFilterParams
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Students"])


def _get_service(session: Session) -> StudentService:
    uow = UnitOfWork(session)
    return StudentService(uow)


@router.get("/", response_model=List[StudentListItem])
def list_students(
    filters: StudentFilterParams = Depends(),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[StudentListItem]:
    """
    List students with advanced filters and sorting.

    Expected service method:
        list_students(filters: StudentFilterParams) -> list[StudentListItem]
    """
    service = _get_service(session)
    return service.list_students(filters=filters)


@router.get("/hostels/{hostel_id}", response_model=List[StudentListItem])
def list_students_for_hostel(
    hostel_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[StudentListItem]:
    """
    List students for a specific hostel.

    Expected service method:
        list_students_for_hostel(hostel_id: UUID) -> list[StudentListItem]
    """
    service = _get_service(session)
    return service.list_students_for_hostel(hostel_id=hostel_id)


@router.get("/{student_id}", response_model=StudentDetail)
def get_student(
    student_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> StudentDetail:
    """
    Get detailed information for a single student.

    Expected service method:
        get_student_detail(student_id: UUID) -> StudentDetail
    """
    service = _get_service(session)
    return service.get_student_detail(student_id=student_id)


@router.post(
    "/",
    response_model=StudentDetail,
    status_code=status.HTTP_201_CREATED,
)
def create_student(
    payload: StudentCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> StudentDetail:
    """
    Create a new student (admin-only operation).

    Expected service method:
        create_student(data: StudentCreate) -> StudentDetail
    """
    service = _get_service(session)
    return service.create_student(data=payload)


@router.patch("/{student_id}", response_model=StudentDetail)
def update_student(
    student_id: UUID,
    payload: StudentUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> StudentDetail:
    """
    Update an existing student.

    Expected service method:
        update_student(student_id: UUID, data: StudentUpdate) -> StudentDetail
    """
    service = _get_service(session)
    return service.update_student(
        student_id=student_id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\students\__init__.py ---
# app/api/v1/students/__init__.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core.security import decode_token, TokenDecodeError
from app.schemas.common.enums import UserRole

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")


@dataclass
class CurrentUser:
    """Minimal representation of the authenticated user."""
    id: UUID
    role: UserRole


def get_current_user(token: str = Depends(oauth2_scheme)) -> CurrentUser:
    """
    Decode JWT and return minimal CurrentUser.

    Expects payload to contain either:
      - sub (user id as string) and role
      - or user_id and user_role
    """
    try:
        payload: dict[str, Any] = decode_token(token)
    except TokenDecodeError as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        ) from exc

    user_id_raw = payload.get("sub") or payload.get("user_id")
    role_raw = payload.get("role") or payload.get("user_role")

    if not user_id_raw or not role_raw:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    try:
        user_id = UUID(str(user_id_raw))
        role = UserRole(str(role_raw))
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        ) from exc

    return CurrentUser(id=user_id, role=role)


def get_current_student(current_user: CurrentUser = Depends(get_current_user)) -> CurrentUser:
    """Ensure the authenticated user is a STUDENT."""
    if current_user.role is not UserRole.STUDENT:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only students can access this endpoint",
        )
    return current_user


# Import sub-routers and mount them under /students in the main API router.
from . import students, profile, dashboard, room_history, finance, search  # noqa: E402

# Admin/student management endpoints
router.include_router(students.router)
# Self-profile for current student
router.include_router(profile.router, prefix="/profile")
# Self dashboard
router.include_router(dashboard.router, prefix="/dashboard")
# Room/bed history
router.include_router(room_history.router, prefix="/room-history")
# Finance
router.include_router(finance.router, prefix="/finance")
# Search
router.include_router(search.router, prefix="/search")

__all__ = [
    "router",
    "CurrentUser",
    "get_current_user",
    "get_current_student",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\students\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\subscriptions =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\subscriptions\billing.py ---
# app/api/v1/subscriptions/billing.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.subscription import SubscriptionBillingService
from app.schemas.subscription.subscription_billing import (
    BillingCycleInfo,
    GenerateInvoiceRequest,
    InvoiceInfo,
)
from app.schemas.subscription.subscription_response import BillingHistory
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Subscription - Billing"])


def _get_service(session: Session) -> SubscriptionBillingService:
    uow = UnitOfWork(session)
    return SubscriptionBillingService(uow)


@router.get("/{subscription_id}/cycle", response_model=BillingCycleInfo)
def get_billing_cycle_info(
    subscription_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> BillingCycleInfo:
    """
    Get billing cycle info for a subscription.

    Expected service method:
        get_billing_cycle_info(subscription_id: UUID) -> BillingCycleInfo
    """
    service = _get_service(session)
    return service.get_billing_cycle_info(subscription_id=subscription_id)


@router.post("/{subscription_id}/invoices", response_model=InvoiceInfo)
def generate_invoice(
    subscription_id: UUID,
    payload: GenerateInvoiceRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> InvoiceInfo:
    """
    Generate an invoice for a subscription.

    Expected service method:
        generate_invoice(subscription_id: UUID, data: GenerateInvoiceRequest) -> InvoiceInfo
    """
    service = _get_service(session)
    return service.generate_invoice(
        subscription_id=subscription_id,
        data=payload,
    )


@router.get("/{subscription_id}/history", response_model=BillingHistory)
def get_billing_history(
    subscription_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> BillingHistory:
    """
    Get billing history for a subscription.

    Expected service method:
        get_billing_history(subscription_id: UUID) -> BillingHistory
    """
    service = _get_service(session)
    return service.get_billing_history(subscription_id=subscription_id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\subscriptions\cancellation.py ---
# app/api/v1/subscriptions/cancellation.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.subscription import SubscriptionService
from app.schemas.subscription.subscription_cancellation import (
    CancellationRequest,
    CancellationResponse,
)
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Subscription - Cancellation"])


def _get_service(session: Session) -> SubscriptionService:
    uow = UnitOfWork(session)
    return SubscriptionService(uow)


@router.post("/{subscription_id}", response_model=CancellationResponse)
def cancel_subscription(
    subscription_id: UUID,
    payload: CancellationRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> CancellationResponse:
    """
    Cancel a subscription and compute any applicable refunds / end dates.

    Expected service method:
        cancel_subscription(subscription_id: UUID, data: CancellationRequest) -> CancellationResponse
    """
    service = _get_service(session)
    return service.cancel_subscription(
        subscription_id=subscription_id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\subscriptions\commission.py ---
# app/api/v1/subscriptions/commission.py
from __future__ import annotations

from datetime import date as Date 
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.subscription import CommissionService
from app.schemas.subscription.commission import (
    CommissionConfig,
    BookingCommissionResponse,
    CommissionSummary,
)
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Subscription - Commission"])


def _get_service(session: Session) -> CommissionService:
    uow = UnitOfWork(session)
    return CommissionService(uow)


@router.get("/config", response_model=CommissionConfig)
def get_commission_config(
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> CommissionConfig:
    """
    Get current commission configuration.

    Expected service method:
        get_config() -> CommissionConfig
    """
    service = _get_service(session)
    return service.get_config()


@router.put("/config", response_model=CommissionConfig)
def update_commission_config(
    payload: CommissionConfig,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> CommissionConfig:
    """
    Update commission configuration.

    Expected service method:
        update_config(data: CommissionConfig) -> CommissionConfig
    """
    service = _get_service(session)
    return service.update_config(data=payload)


@router.get("/bookings/{booking_id}", response_model=BookingCommissionResponse)
def get_booking_commission(
    booking_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> BookingCommissionResponse:
    """
    Get commission details for a specific booking.

    Expected service method:
        get_booking_commission(booking_id: UUID) -> BookingCommissionResponse
    """
    service = _get_service(session)
    return service.get_booking_commission(booking_id=booking_id)


@router.get("/summary", response_model=CommissionSummary)
def get_commission_summary(
    start_date: Date = Query(..., description="Start Date for the summary period"),
    end_date: Date = Query(..., description="End Date for the summary period"),
    plan_id: Optional[UUID] = Query(
        None,
        description="Optionally restrict summary to a specific subscription plan.",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> CommissionSummary:
    """
    Get commission summary for a period (optionally per plan).

    Expected service method:
        get_commission_summary(start_date: Date, end_date: Date, plan_id: Optional[UUID]) -> CommissionSummary
    """
    service = _get_service(session)
    return service.get_commission_summary(
        start_date=start_date,
        end_date=end_date,
        plan_id=plan_id,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\subscriptions\plans.py ---
# app/api/v1/subscriptions/plans.py
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.schemas.subscription.subscription_plan_base import PlanCreate, PlanUpdate
from app.schemas.subscription.subscription_plan_response import (
    PlanResponse,
    PlanComparison,
)
from app.services.subscription import SubscriptionPlanService
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Subscription - Plans"])


def _get_service(session: Session) -> SubscriptionPlanService:
    uow = UnitOfWork(session)
    return SubscriptionPlanService(uow)


@router.get("/", response_model=List[PlanResponse])
def list_plans(
    public_only: bool = Query(
        True,
        description="If true, return only public plans; otherwise return all plans.",
    ),
    include_inactive: bool = Query(
        False,
        description="If true, include inactive plans (admin use).",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[PlanResponse]:
    """
    List subscription plans.

    Expected service method:
        list_plans(public_only: bool, include_inactive: bool) -> list[PlanResponse]
    """
    service = _get_service(session)
    return service.list_plans(
        public_only=public_only,
        include_inactive=include_inactive,
    )


@router.get("/public", response_model=List[PlanResponse])
def list_public_plans(
    session: Session = Depends(get_session),
) -> List[PlanResponse]:
    """
    Public endpoint: list only public & active plans (no auth required).

    Expected service method:
        list_public_plans() -> list[PlanResponse]
    """
    service = _get_service(session)
    return service.list_public_plans()


@router.get("/comparison", response_model=PlanComparison)
def compare_plans(
    plan_ids: Optional[List[UUID]] = Query(
        None,
        description="Optional list of plan IDs to compare; if omitted, compare all public plans.",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> PlanComparison:
    """
    Compare plans via feature matrix.

    Expected service method:
        get_plan_comparison(plan_ids: Optional[list[UUID]]) -> PlanComparison
    """
    service = _get_service(session)
    return service.get_plan_comparison(plan_ids=plan_ids)


@router.get("/{plan_id}", response_model=PlanResponse)
def get_plan(
    plan_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> PlanResponse:
    """
    Get a single subscription plan by ID.

    Expected service method:
        get_plan(plan_id: UUID) -> PlanResponse
    """
    service = _get_service(session)
    return service.get_plan(plan_id=plan_id)


@router.post(
    "/",
    response_model=PlanResponse,
    status_code=status.HTTP_201_CREATED,
)
def create_plan(
    payload: PlanCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> PlanResponse:
    """
    Create a new subscription plan.

    Expected service method:
        create_plan(data: PlanCreate) -> PlanResponse
    """
    service = _get_service(session)
    return service.create_plan(data=payload)


@router.patch("/{plan_id}", response_model=PlanResponse)
def update_plan(
    plan_id: UUID,
    payload: PlanUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> PlanResponse:
    """
    Update an existing subscription plan.

    Expected service method:
        update_plan(plan_id: UUID, data: PlanUpdate) -> PlanResponse
    """
    service = _get_service(session)
    return service.update_plan(
        plan_id=plan_id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\subscriptions\subscriptions.py ---
# app/api/v1/subscriptions/subscriptions.py
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.subscription import SubscriptionService
from app.schemas.subscription.subscription_base import (
    SubscriptionCreate,
    SubscriptionUpdate,
)
from app.schemas.subscription.subscription_response import (
    SubscriptionResponse,
)
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Subscription - Subscriptions"])


def _get_service(session: Session) -> SubscriptionService:
    uow = UnitOfWork(session)
    return SubscriptionService(uow)


@router.get("/", response_model=List[SubscriptionResponse])
def list_subscriptions(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optionally filter subscriptions by hostel ID.",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[SubscriptionResponse]:
    """
    List subscriptions, optionally filtered by hostel.

    Expected service method:
        list_subscriptions(hostel_id: Optional[UUID]) -> list[SubscriptionResponse]
    """
    service = _get_service(session)
    return service.list_subscriptions(hostel_id=hostel_id)


@router.get("/{subscription_id}", response_model=SubscriptionResponse)
def get_subscription(
    subscription_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SubscriptionResponse:
    """
    Get details of a single subscription.

    Expected service method:
        get_subscription(subscription_id: UUID) -> SubscriptionResponse
    """
    service = _get_service(session)
    return service.get_subscription(subscription_id=subscription_id)


@router.post(
    "/",
    response_model=SubscriptionResponse,
    status_code=status.HTTP_201_CREATED,
)
def create_subscription(
    payload: SubscriptionCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SubscriptionResponse:
    """
    Create a new hostel subscription.

    Expected service method:
        create_subscription(data: SubscriptionCreate) -> SubscriptionResponse
    """
    service = _get_service(session)
    return service.create_subscription(data=payload)


@router.patch("/{subscription_id}", response_model=SubscriptionResponse)
def update_subscription(
    subscription_id: UUID,
    payload: SubscriptionUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SubscriptionResponse:
    """
    Update an existing subscription.

    Expected service method:
        update_subscription(subscription_id: UUID, data: SubscriptionUpdate) -> SubscriptionResponse
    """
    service = _get_service(session)
    return service.update_subscription(
        subscription_id=subscription_id,
        data=payload,
    )


@router.get("/hostels/{hostel_id}/active", response_model=Optional[SubscriptionResponse])
def get_active_subscription_for_hostel(
    hostel_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> Optional[SubscriptionResponse]:
    """
    Get the active subscription for a hostel (if any).

    Expected service method:
        get_active_subscription_for_hostel(hostel_id: UUID) -> Optional[SubscriptionResponse]
    """
    service = _get_service(session)
    return service.get_active_subscription_for_hostel(hostel_id=hostel_id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\subscriptions\upgrade.py ---
# app/api/v1/subscriptions/upgrade.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.subscription import SubscriptionUpgradeService
from app.schemas.subscription.subscription_upgrade import (
    UpgradeRequest,
    UpgradePreview,
    DowngradeRequest,
)
from app.schemas.subscription.subscription_response import SubscriptionResponse
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Subscription - Upgrade"])


def _get_service(session: Session) -> SubscriptionUpgradeService:
    uow = UnitOfWork(session)
    return SubscriptionUpgradeService(uow)


@router.post("/{subscription_id}/preview", response_model=UpgradePreview)
def preview_upgrade(
    subscription_id: UUID,
    payload: UpgradeRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> UpgradePreview:
    """
    Preview financial impact of upgrading a subscription (proration, etc.).

    Expected service method:
        preview_upgrade(subscription_id: UUID, data: UpgradeRequest) -> UpgradePreview
    """
    service = _get_service(session)
    return service.preview_upgrade(
        subscription_id=subscription_id,
        data=payload,
    )


@router.post("/{subscription_id}/apply", response_model=SubscriptionResponse)
def apply_upgrade(
    subscription_id: UUID,
    payload: UpgradeRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SubscriptionResponse:
    """
    Apply an upgrade to a subscription.

    Expected service method:
        apply_upgrade(subscription_id: UUID, data: UpgradeRequest) -> SubscriptionResponse
    """
    service = _get_service(session)
    return service.apply_upgrade(
        subscription_id=subscription_id,
        data=payload,
    )


@router.post("/{subscription_id}/downgrade", response_model=SubscriptionResponse)
def apply_downgrade(
    subscription_id: UUID,
    payload: DowngradeRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SubscriptionResponse:
    """
    Apply a downgrade to a subscription.

    Expected service method:
        apply_downgrade(subscription_id: UUID, data: DowngradeRequest) -> SubscriptionResponse
    """
    service = _get_service(session)
    return service.apply_downgrade(
        subscription_id=subscription_id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\subscriptions\__init__.py ---
# app/api/v1/subscriptions/__init__.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core.security import decode_token, TokenDecodeError
from app.schemas.common.enums import UserRole

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")


@dataclass
class CurrentUser:
    """Minimal representation of the authenticated user for subscription APIs."""
    id: UUID
    role: UserRole


def get_current_user(token: str = Depends(oauth2_scheme)) -> CurrentUser:
    """
    Decode JWT and return minimal CurrentUser.

    Expects payload to contain either:
      - sub (user id as string) and role
      - or user_id and user_role

    Adjust this if your TokenPayload uses different claim names.
    """
    try:
        payload: dict[str, Any] = decode_token(token)
    except TokenDecodeError as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        ) from exc

    user_id_raw = payload.get("sub") or payload.get("user_id")
    role_raw = payload.get("role") or payload.get("user_role")

    if not user_id_raw or not role_raw:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    try:
        user_id = UUID(str(user_id_raw))
        role = UserRole(str(role_raw))
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        ) from exc

    return CurrentUser(id=user_id, role=role)


# Import sub-routers and mount them.
from . import plans, subscriptions, upgrade, billing, cancellation, commission  # noqa: E402

router.include_router(plans.router, prefix="/plans")
router.include_router(subscriptions.router, prefix="/subscriptions")
router.include_router(upgrade.router, prefix="/upgrade")
router.include_router(billing.router, prefix="/billing")
router.include_router(cancellation.router, prefix="/cancellation")
router.include_router(commission.router, prefix="/commission")

__all__ = [
    "router",
    "CurrentUser",
    "get_current_user",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\supervisors =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\supervisors\activity.py ---
# app/api/v1/supervisors/activity.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.supervisor import SupervisorActivityService
from app.schemas.supervisor.supervisor_activity import (
    SupervisorActivityLog,
    ActivityDetail,
    ActivitySummary,
    ActivityFilterParams,
)
from . import CurrentUser, get_current_user, get_current_supervisor

router = APIRouter(tags=["Supervisors - Activity"])


def _get_service(session: Session) -> SupervisorActivityService:
    uow = UnitOfWork(session)
    return SupervisorActivityService(uow)


@router.get("/", response_model=List[SupervisorActivityLog])
def list_my_activity(
    filters: ActivityFilterParams = Depends(),
    current_user: CurrentUser = Depends(get_current_supervisor),
    session: Session = Depends(get_session),
) -> List[SupervisorActivityLog]:
    """
    List recent activity for the authenticated supervisor.

    Expected service method:
        list_activity_for_user(user_id: UUID, filters: ActivityFilterParams) -> list[SupervisorActivityLog]
    """
    service = _get_service(session)
    return service.list_activity_for_user(
        user_id=current_user.id,
        filters=filters,
    )


@router.get("/summary", response_model=ActivitySummary)
def get_my_activity_summary(
    filters: ActivityFilterParams = Depends(),
    current_user: CurrentUser = Depends(get_current_supervisor),
    session: Session = Depends(get_session),
) -> ActivitySummary:
    """
    Get a high-level summary of activity for the authenticated supervisor.

    Expected service method:
        get_activity_summary_for_user(user_id: UUID, filters: ActivityFilterParams) -> ActivitySummary
    """
    service = _get_service(session)
    return service.get_activity_summary_for_user(
        user_id=current_user.id,
        filters=filters,
    )


@router.get("/{activity_id}", response_model=ActivityDetail)
def get_activity_detail(
    activity_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> ActivityDetail:
    """
    Get detailed information about a single activity record.

    Expected service method:
        get_activity_detail(activity_id: UUID) -> ActivityDetail
    """
    service = _get_service(session)
    return service.get_activity_detail(activity_id=activity_id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\supervisors\assignments.py ---
# app/api/v1/supervisors/assignments.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.supervisor import SupervisorAssignmentService
from app.schemas.supervisor.supervisor_assignment import (
    SupervisorAssignment,
    AssignmentRequest,
    AssignmentUpdate,
    RevokeAssignmentRequest,
    AssignmentTransfer,
)
from . import CurrentUser, get_current_user, get_current_supervisor

router = APIRouter(tags=["Supervisors - Assignments"])


def _get_service(session: Session) -> SupervisorAssignmentService:
    uow = UnitOfWork(session)
    return SupervisorAssignmentService(uow)


@router.get("/me", response_model=List[SupervisorAssignment])
def list_my_assignments(
    current_user: CurrentUser = Depends(get_current_supervisor),
    session: Session = Depends(get_session),
) -> List[SupervisorAssignment]:
    """
    List hostel assignments for the authenticated supervisor.

    Expected service method:
        list_assignments_for_user(user_id: UUID) -> list[SupervisorAssignment]
    """
    service = _get_service(session)
    return service.list_assignments_for_user(user_id=current_user.id)


@router.get("/{supervisor_id}", response_model=List[SupervisorAssignment])
def list_assignments_for_supervisor(
    supervisor_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[SupervisorAssignment]:
    """
    List hostel assignments for the given supervisor.

    Expected service method:
        list_assignments_for_supervisor(supervisor_id: UUID) -> list[SupervisorAssignment]
    """
    service = _get_service(session)
    return service.list_assignments_for_supervisor(supervisor_id=supervisor_id)


@router.post(
    "",
    response_model=SupervisorAssignment,
    status_code=status.HTTP_201_CREATED,
)
def create_assignment(
    payload: AssignmentRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorAssignment:
    """
    Create a new supervisor↔hostel assignment.

    Expected service method:
        create_assignment(data: AssignmentRequest) -> SupervisorAssignment
    """
    service = _get_service(session)
    return service.create_assignment(data=payload)


@router.patch(
    "/{assignment_id}",
    response_model=SupervisorAssignment,
)
def update_assignment(
    assignment_id: UUID,
    payload: AssignmentUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorAssignment:
    """
    Update an existing assignment (role, dates, flags, etc.).

    Expected service method:
        update_assignment(assignment_id: UUID, data: AssignmentUpdate) -> SupervisorAssignment
    """
    service = _get_service(session)
    return service.update_assignment(
        assignment_id=assignment_id,
        data=payload,
    )


@router.post(
    "/{assignment_id}/revoke",
    response_model=SupervisorAssignment,
)
def revoke_assignment(
    assignment_id: UUID,
    payload: RevokeAssignmentRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorAssignment:
    """
    Revoke an assignment with a given reason.

    Expected service method:
        revoke_assignment(assignment_id: UUID, data: RevokeAssignmentRequest) -> SupervisorAssignment
    """
    service = _get_service(session)
    return service.revoke_assignment(
        assignment_id=assignment_id,
        data=payload,
    )


@router.post(
    "/transfer",
    response_model=SupervisorAssignment,
)
def transfer_assignment(
    payload: AssignmentTransfer,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorAssignment:
    """
    Transfer a supervisor from one hostel to another.

    Expected service method:
        transfer_assignment(data: AssignmentTransfer) -> SupervisorAssignment
    """
    service = _get_service(session)
    return service.transfer_assignment(data=payload)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\supervisors\dashboard.py ---
# app/api/v1/supervisors/dashboard.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.supervisor import SupervisorDashboardService
from app.schemas.supervisor.supervisor_dashboard import SupervisorDashboard
from . import CurrentUser, get_current_supervisor

router = APIRouter(tags=["Supervisors - Dashboard"])


def _get_service(session: Session) -> SupervisorDashboardService:
    uow = UnitOfWork(session)
    return SupervisorDashboardService(uow)


@router.get("/", response_model=SupervisorDashboard)
def get_my_dashboard(
    current_user: CurrentUser = Depends(get_current_supervisor),
    session: Session = Depends(get_session),
) -> SupervisorDashboard:
    """
    Return the dashboard for the authenticated supervisor.

    Expected service method:
        get_dashboard_for_user(user_id: UUID) -> SupervisorDashboard
    """
    service = _get_service(session)
    return service.get_dashboard_for_user(user_id=current_user.id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\supervisors\performance.py ---
# app/api/v1/supervisors/performance.py
from __future__ import annotations

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.supervisor import SupervisorPerformanceService
from app.schemas.supervisor.supervisor_performance import (
    PerformanceReport,
    PeerComparison,
)
from . import CurrentUser, get_current_user, get_current_supervisor

router = APIRouter(tags=["Supervisors - Performance"])


def _get_service(session: Session) -> SupervisorPerformanceService:
    uow = UnitOfWork(session)
    return SupervisorPerformanceService(uow)


@router.get("/me", response_model=PerformanceReport)
def get_my_performance(
    current_user: CurrentUser = Depends(get_current_supervisor),
    session: Session = Depends(get_session),
) -> PerformanceReport:
    """
    Get a detailed performance report for the authenticated supervisor.

    Expected service method:
        get_performance_for_user(user_id: UUID) -> PerformanceReport
    """
    service = _get_service(session)
    return service.get_performance_for_user(user_id=current_user.id)


@router.get("/{supervisor_id}", response_model=PerformanceReport)
def get_performance_for_supervisor(
    supervisor_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> PerformanceReport:
    """
    Get a detailed performance report for a specific supervisor.

    Expected service method:
        get_performance_for_supervisor(supervisor_id: UUID) -> PerformanceReport
    """
    service = _get_service(session)
    return service.get_performance_for_supervisor(supervisor_id=supervisor_id)


@router.get("/comparison", response_model=PeerComparison)
def compare_supervisors(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Restrict comparison to a single hostel (optional)",
    ),
    limit: int = Query(
        10,
        ge=1,
        le=100,
        description="Maximum number of supervisors to include in comparison",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> PeerComparison:
    """
    Compare supervisors' performance (e.g., top/bottom performers).

    Expected service method:
        compare_supervisors(hostel_id: Optional[UUID], limit: int) -> PeerComparison
    """
    service = _get_service(session)
    return service.compare_supervisors(
        hostel_id=hostel_id,
        limit=limit,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\supervisors\permissions.py ---
# app/api/v1/supervisors/permissions.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from uuid import UUID
from typing import Any

from app.core import get_session
from app.services import UnitOfWork
from app.services.supervisor import SupervisorPermissionsService
from app.schemas.supervisor.supervisor_permissions import (
    SupervisorPermissions,
    PermissionUpdate,
    PermissionCheckRequest,
    PermissionCheckResponse,
    BulkPermissionUpdate,
    ApplyPermissionTemplate,
)
from . import CurrentUser, get_current_user, get_current_supervisor

router = APIRouter(tags=["Supervisors - Permissions"])


def _get_service(session: Session) -> SupervisorPermissionsService:
    uow = UnitOfWork(session)
    return SupervisorPermissionsService(uow)


@router.get("/me", response_model=SupervisorPermissions)
def get_my_permissions(
    current_user: CurrentUser = Depends(get_current_supervisor),
    session: Session = Depends(get_session),
) -> SupervisorPermissions:
    """
    Get permissions for the authenticated supervisor.

    Expected service method:
        get_permissions_for_user(user_id: UUID) -> SupervisorPermissions
    """
    service = _get_service(session)
    return service.get_permissions_for_user(user_id=current_user.id)


@router.get("/{supervisor_id}", response_model=SupervisorPermissions)
def get_permissions_for_supervisor(
    supervisor_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorPermissions:
    """
    Get permissions for a specific supervisor.

    Expected service method:
        get_permissions(supervisor_id: UUID) -> SupervisorPermissions
    """
    service = _get_service(session)
    return service.get_permissions(supervisor_id=supervisor_id)


@router.patch("/{supervisor_id}", response_model=SupervisorPermissions)
def update_permission(
    supervisor_id: UUID,
    payload: PermissionUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorPermissions:
    """
    Update a single permission for a supervisor.

    Expected service method:
        update_permission(supervisor_id: UUID, data: PermissionUpdate) -> SupervisorPermissions
    """
    service = _get_service(session)
    return service.update_permission(
        supervisor_id=supervisor_id,
        data=payload,
    )


@router.patch("/{supervisor_id}/bulk", response_model=SupervisorPermissions)
def bulk_update_permissions(
    supervisor_id: UUID,
    payload: BulkPermissionUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorPermissions:
    """
    Bulk update multiple permissions for a supervisor.

    Expected service method:
        bulk_update_permissions(supervisor_id: UUID, data: BulkPermissionUpdate) -> SupervisorPermissions
    """
    service = _get_service(session)
    return service.bulk_update_permissions(
        supervisor_id=supervisor_id,
        data=payload,
    )


@router.post("/{supervisor_id}/template", response_model=SupervisorPermissions)
def apply_permission_template(
    supervisor_id: UUID,
    payload: ApplyPermissionTemplate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorPermissions:
    """
    Apply a predefined permission template to a supervisor.

    Expected service method:
        apply_template(supervisor_id: UUID, data: ApplyPermissionTemplate) -> SupervisorPermissions
    """
    service = _get_service(session)
    return service.apply_template(
        supervisor_id=supervisor_id,
        data=payload,
    )


@router.post("/{supervisor_id}/check", response_model=PermissionCheckResponse)
def check_permission_for_supervisor(
    supervisor_id: UUID,
    payload: PermissionCheckRequest,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> PermissionCheckResponse:
    """
    Check if a supervisor has a specific permission / within limits.

    Expected service method:
        check_permission(supervisor_id: UUID, data: PermissionCheckRequest) -> PermissionCheckResponse
    """
    service = _get_service(session)
    return service.check_permission(
        supervisor_id=supervisor_id,
        data=payload,
    )


@router.post("/me/check", response_model=PermissionCheckResponse)
def check_my_permission(
    payload: PermissionCheckRequest,
    current_user: CurrentUser = Depends(get_current_supervisor),
    session: Session = Depends(get_session),
) -> PermissionCheckResponse:
    """
    Check a permission for the authenticated supervisor.

    Convenience wrapper around the generic check endpoint.
    """
    service = _get_service(session)
    return service.check_permission_for_user(
        user_id=current_user.id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\supervisors\supervisors.py ---
# app/api/v1/supervisors/supervisors.py
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.supervisor import SupervisorService
from app.schemas.supervisor.supervisor_base import (
    SupervisorCreate,
    SupervisorUpdate,
    SupervisorStatusUpdate,
    SupervisorReassignment,
)
from app.schemas.supervisor.supervisor_response import (
    SupervisorDetail,
    SupervisorListItem,
)
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Supervisors"])


def _get_service(session: Session) -> SupervisorService:
    """Helper to construct SupervisorService with a UnitOfWork."""
    uow = UnitOfWork(session)
    return SupervisorService(uow)


@router.get("/", response_model=List[SupervisorListItem])
def list_supervisors(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Filter supervisors by hostel_id (optional)",
    ),
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> List[SupervisorListItem]:
    """
    List supervisors, optionally filtered by hostel.

    Expected service method:
        list_supervisors(hostel_id: Optional[UUID]) -> list[SupervisorListItem]
    """
    service = _get_service(session)
    return service.list_supervisors(hostel_id=hostel_id)


@router.get("/{supervisor_id}", response_model=SupervisorDetail)
def get_supervisor(
    supervisor_id: UUID,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorDetail:
    """
    Get detailed information for a single supervisor.

    Expected service method:
        get_supervisor_detail(supervisor_id: UUID) -> SupervisorDetail
    """
    service = _get_service(session)
    return service.get_supervisor_detail(supervisor_id=supervisor_id)


@router.post(
    "/",
    response_model=SupervisorDetail,
    status_code=status.HTTP_201_CREATED,
)
def create_supervisor(
    payload: SupervisorCreate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorDetail:
    """
    Create a new supervisor.

    Expected service method:
        create_supervisor(data: SupervisorCreate) -> SupervisorDetail
    """
    service = _get_service(session)
    return service.create_supervisor(data=payload)


@router.patch("/{supervisor_id}", response_model=SupervisorDetail)
def update_supervisor(
    supervisor_id: UUID,
    payload: SupervisorUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorDetail:
    """
    Update supervisor details.

    Expected service method:
        update_supervisor(supervisor_id: UUID, data: SupervisorUpdate) -> SupervisorDetail
    """
    service = _get_service(session)
    return service.update_supervisor(
        supervisor_id=supervisor_id,
        data=payload,
    )


@router.patch("/{supervisor_id}/status", response_model=SupervisorDetail)
def update_supervisor_status(
    supervisor_id: UUID,
    payload: SupervisorStatusUpdate,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorDetail:
    """
    Update supervisor status (active/suspended/etc.).

    Expected service method:
        update_supervisor_status(supervisor_id: UUID, data: SupervisorStatusUpdate) -> SupervisorDetail
    """
    service = _get_service(session)
    return service.update_supervisor_status(
        supervisor_id=supervisor_id,
        data=payload,
    )


@router.post("/{supervisor_id}/reassign", response_model=SupervisorDetail)
def reassign_supervisor(
    supervisor_id: UUID,
    payload: SupervisorReassignment,
    session: Session = Depends(get_session),
    current_user: CurrentUser = Depends(get_current_user),
) -> SupervisorDetail:
    """
    Reassign a supervisor (e.g., move primary hostel).

    Expected service method:
        reassign_supervisor(supervisor_id: UUID, data: SupervisorReassignment) -> SupervisorDetail
    """
    service = _get_service(session)
    return service.reassign_supervisor(
        supervisor_id=supervisor_id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\supervisors\__init__.py ---
# app/api/v1/supervisors/__init__.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core.security import decode_token, TokenDecodeError
from app.schemas.common.enums import UserRole

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")


@dataclass
class CurrentUser:
    """Minimal representation of the authenticated user."""
    id: UUID
    role: UserRole


def get_current_user(token: str = Depends(oauth2_scheme)) -> CurrentUser:
    """
    Decode JWT and return minimal CurrentUser.

    Expects payload to contain either:
      - sub (user id) and role
      - or user_id and user_role

    Adjust this to match your actual TokenPayload.
    """
    try:
        payload: dict[str, Any] = decode_token(token)
    except TokenDecodeError as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        ) from exc

    user_id_raw = payload.get("sub") or payload.get("user_id")
    role_raw = payload.get("role") or payload.get("user_role")

    if not user_id_raw or not role_raw:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    try:
        user_id = UUID(str(user_id_raw))
        role = UserRole(str(role_raw))
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        ) from exc

    return CurrentUser(id=user_id, role=role)


def get_current_supervisor(current_user: CurrentUser = Depends(get_current_user)) -> CurrentUser:
    """Ensure the authenticated user is a SUPERVISOR."""
    if current_user.role is not UserRole.SUPERVISOR:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only supervisors can access this endpoint",
        )
    return current_user


# Import sub-routers and mount them under /supervisors in the main API router.
from . import supervisors, dashboard, assignments, permissions, performance, activity  # noqa: E402

# CRUD / listing for supervisors
router.include_router(supervisors.router)
# Self dashboard
router.include_router(dashboard.router, prefix="/dashboard")
# Hostel assignments
router.include_router(assignments.router, prefix="/assignments")
# Permissions management
router.include_router(permissions.router, prefix="/permissions")
# Performance reports
router.include_router(performance.router, prefix="/performance")
# Activity logs
router.include_router(activity.router, prefix="/activity")

__all__ = [
    "router",
    "CurrentUser",
    "get_current_user",
    "get_current_supervisor",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\supervisors\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\users =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\users\activity.py ---
# app/api/v1/users/activity.py
from __future__ import annotations

from typing import Any, List

from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.users import UserActivityService
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Users - Activity"])


def _get_activity_service(session: Session) -> UserActivityService:
    uow = UnitOfWork(session)
    return UserActivityService(uow)


@router.get("/", response_model=List[dict])
def list_my_activity(
    limit: int = Query(100, ge=1, le=500, description="Maximum number of records to return"),
    current_user: CurrentUser = Depends(get_current_user),
    session: Session = Depends(get_session),
) -> list[dict[str, Any]]:
    """
    List recent activity for the authenticated user.

    If you later add dedicated Pydantic schemas for user activity
    (e.g., UserActivityLogResponse), you can switch the response_model.
    """
    service = _get_activity_service(session)
    # Expected service method:
    #   list_activity_for_user(user_id: UUID, limit: int) -> list[BaseSchema | dict]
    activities = service.list_activity_for_user(
        user_id=current_user.id,
        limit=limit,
    )

    # Assume service returns serializable objects (either dicts or Pydantic models).
    # If they're Pydantic models, FastAPI will handle serialization.
    return activities

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\users\me.py ---
# app/api/v1/users/me.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.users import UserService
from app.schemas.user.user_response import UserDetail, UserResponse
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Users - Me"])


def _get_user_service(session: Session) -> UserService:
    """Helper to construct UserService with a UnitOfWork."""
    uow = UnitOfWork(session)
    return UserService(uow)


@router.get("/", response_model=UserDetail)
def get_me(
    current_user: CurrentUser = Depends(get_current_user),
    session: Session = Depends(get_session),
) -> UserDetail:
    """
    Return full details of the authenticated user.
    """
    service = _get_user_service(session)
    # Expected service method: get_user_detail(user_id: UUID) -> UserDetail
    return service.get_user_detail(user_id=current_user.id)


@router.get("/summary", response_model=UserResponse)
def get_me_summary(
    current_user: CurrentUser = Depends(get_current_user),
    session: Session = Depends(get_session),
) -> UserResponse:
    """
    Lightweight summary of the authenticated user (for headers, etc.).
    """
    service = _get_user_service(session)
    # Expected service method: get_user_summary(user_id: UUID) -> UserResponse
    return service.get_user_summary(user_id=current_user.id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\users\profile.py ---
# app/api/v1/users/profile.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.users import UserProfileService
from app.schemas.user.user_profile import (
    ProfileUpdate,
    ProfileImageUpdate,
    ContactInfoUpdate,
    NotificationPreferencesUpdate,
)
from app.schemas.user.user_response import UserDetail
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Users - Profile"])


def _get_profile_service(session: Session) -> UserProfileService:
    uow = UnitOfWork(session)
    return UserProfileService(uow)


@router.patch("", response_model=UserDetail)
def update_profile(
    payload: ProfileUpdate,
    current_user: CurrentUser = Depends(get_current_user),
    session: Session = Depends(get_session),
) -> UserDetail:
    """
    Update general profile fields (name, DOB, gender, etc.) for the current user.
    """
    service = _get_profile_service(session)
    # Expected service method:
    #   update_profile(user_id: UUID, data: ProfileUpdate) -> UserDetail
    return service.update_profile(user_id=current_user.id, data=payload)


@router.patch("/image", response_model=UserDetail)
def update_profile_image(
    payload: ProfileImageUpdate,
    current_user: CurrentUser = Depends(get_current_user),
    session: Session = Depends(get_session),
) -> UserDetail:
    """
    Update the profile image URL or upload reference for the current user.
    """
    service = _get_profile_service(session)
    # Expected service method:
    #   update_profile_image(user_id: UUID, data: ProfileImageUpdate) -> UserDetail
    return service.update_profile_image(user_id=current_user.id, data=payload)


@router.patch("/contact", response_model=UserDetail)
def update_contact_info(
    payload: ContactInfoUpdate,
    current_user: CurrentUser = Depends(get_current_user),
    session: Session = Depends(get_session),
) -> UserDetail:
    """
    Update contact information (email/phone/address/emergency) for the current user.
    """
    service = _get_profile_service(session)
    # Expected service method:
    #   update_contact_info(user_id: UUID, data: ContactInfoUpdate) -> UserDetail
    return service.update_contact_info(user_id=current_user.id, data=payload)


@router.patch("/notifications", response_model=UserDetail)
def update_notification_preferences(
    payload: NotificationPreferencesUpdate,
    current_user: CurrentUser = Depends(get_current_user),
    session: Session = Depends(get_session),
) -> UserDetail:
    """
    Update high-level notification preferences for the current user.
    """
    service = _get_profile_service(session)
    # Expected service method:
    #   update_notification_preferences(user_id: UUID, data: NotificationPreferencesUpdate) -> UserDetail
    return service.update_notification_preferences(
        user_id=current_user.id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\users\sessions.py ---
# app/api/v1/users/sessions.py
from __future__ import annotations

from typing import Any

from fastapi import APIRouter, Depends, Response, status
from app.services.auth import SessionService
from app.schemas.user.user_session import (
    ActiveSessionsList,
    RevokeSessionRequest,
    RevokeAllSessionsRequest,
)
from . import CurrentUser, get_current_user

router = APIRouter(tags=["Users - Sessions"])


def get_session_service() -> SessionService:
    """
    Construct a SessionService.

    Adjust this to inject a concrete SessionStore or config if needed.
    """
    return SessionService()


@router.get("/", response_model=ActiveSessionsList)
def list_my_sessions(
    current_user: CurrentUser = Depends(get_current_user),
    session_service: SessionService = Depends(get_session_service),
) -> ActiveSessionsList:
    """
    List all active sessions for the authenticated user.
    """
    # Expected service method:
    #   list_active_sessions(user_id: UUID) -> ActiveSessionsList
    return session_service.list_active_sessions(user_id=current_user.id)


@router.post("/revoke", status_code=status.HTTP_204_NO_CONTENT)
def revoke_session(
    payload: RevokeSessionRequest,
    current_user: CurrentUser = Depends(get_current_user),
    session_service: SessionService = Depends(get_session_service),
) -> Response:
    """
    Revoke a single session for the authenticated user.
    """
    # Expected payload field: session_id (str or UUID-like)
    # Expected service method:
    #   revoke_session(user_id: UUID, session_id: str) -> None
    session_service.revoke_session(
        user_id=current_user.id,
        session_id=str(payload.session_id),
    )
    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.post("/revoke-all", status_code=status.HTTP_204_NO_CONTENT)
def revoke_all_sessions(
    payload: RevokeAllSessionsRequest | None = None,
    current_user: CurrentUser = Depends(get_current_user),
    session_service: SessionService = Depends(get_session_service),
) -> Response:
    """
    Revoke all sessions for the authenticated user.

    The payload is optional; included only to match your schema.
    """
    # Expected service method:
    #   revoke_all_sessions(user_id: UUID) -> None
    session_service.revoke_all_sessions(user_id=current_user.id)
    return Response(status_code=status.HTTP_204_NO_CONTENT)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\users\__init__.py ---
# app/api/v1/users/__init__.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core.security import decode_token, TokenDecodeError
from app.schemas.common.enums import UserRole

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")


@dataclass
class CurrentUser:
    """Minimal representation of the authenticated user."""
    id: UUID
    role: UserRole


def get_current_user(token: str = Depends(oauth2_scheme)) -> CurrentUser:
    """
    Decode JWT and return minimal CurrentUser.

    Expects payload to contain either:
      - sub (user id as string) and role
      - or user_id and user_role

    Adjust this to match your actual TokenPayload.
    """
    try:
        payload: dict[str, Any] = decode_token(token)
    except TokenDecodeError as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        ) from exc

    user_id_raw = payload.get("sub") or payload.get("user_id")
    role_raw = payload.get("role") or payload.get("user_role")

    if not user_id_raw or not role_raw:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    try:
        user_id = UUID(str(user_id_raw))
        role = UserRole(str(role_raw))
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        ) from exc

    return CurrentUser(id=user_id, role=role)


# Import sub-routers and mount them under /users in the main API router.
from . import me, profile, sessions, activity  # noqa: E402

router.include_router(me.router, prefix="/me")
router.include_router(profile.router, prefix="/profile")
router.include_router(sessions.router, prefix="/sessions")
router.include_router(activity.router, prefix="/activity")

__all__ = [
    "router",
    "CurrentUser",
    "get_current_user",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\users\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\visitors =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\visitors\dashboard.py ---
# app/api/v1/visitors/dashboard.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.visitor import VisitorDashboardService
from app.schemas.visitor.visitor_dashboard import VisitorDashboard
from . import CurrentUser, get_current_visitor

router = APIRouter(tags=["Visitor - Dashboard"])


def _get_service(session: Session) -> VisitorDashboardService:
    uow = UnitOfWork(session)
    return VisitorDashboardService(uow)


@router.get("/", response_model=VisitorDashboard)
def get_dashboard(
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> VisitorDashboard:
    """
    Return the visitor dashboard for the authenticated visitor.
    """
    service = _get_service(session)
    # Expected service method:
    #   get_dashboard_for_user(user_id: UUID) -> VisitorDashboard
    return service.get_dashboard_for_user(user_id=current_user.id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\visitors\favorites.py ---
# app/api/v1/visitors/favorites.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, Query, Response, status
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.visitor import FavoritesService
from app.schemas.visitor.visitor_favorites import (
    FavoriteRequest,
    FavoriteUpdate,
    FavoritesList,
    FavoriteHostelItem,
    FavoritesExport,
    FavoriteComparison,
)
from . import CurrentUser, get_current_visitor

router = APIRouter(tags=["Visitor - Favorites"])


def _get_service(session: Session) -> FavoritesService:
    uow = UnitOfWork(session)
    return FavoritesService(uow)


@router.get("/", response_model=FavoritesList)
def list_favorites(
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> FavoritesList:
    """
    List all favorite hostels for the authenticated visitor.
    """
    service = _get_service(session)
    # Expected service method:
    #   list_favorites_for_user(user_id: UUID) -> FavoritesList
    return service.list_favorites_for_user(user_id=current_user.id)


@router.post(
    "/",
    response_model=FavoriteHostelItem,
    status_code=status.HTTP_201_CREATED,
)
def add_favorite(
    payload: FavoriteRequest,
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> FavoriteHostelItem:
    """
    Add a hostel to the visitor's favorites (or update if already exists).
    """
    service = _get_service(session)
    # Expected service method:
    #   add_favorite(user_id: UUID, data: FavoriteRequest) -> FavoriteHostelItem
    return service.add_favorite(user_id=current_user.id, data=payload)


@router.patch(
    "/{hostel_id}",
    response_model=FavoriteHostelItem,
)
def update_favorite(
    hostel_id: UUID,
    payload: FavoriteUpdate,
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> FavoriteHostelItem:
    """
    Update metadata (e.g., notes) for a favorite hostel.
    """
    service = _get_service(session)
    # Expected service method:
    #   update_favorite(user_id: UUID, hostel_id: UUID, data: FavoriteUpdate) -> FavoriteHostelItem
    return service.update_favorite(
        user_id=current_user.id,
        hostel_id=hostel_id,
        data=payload,
    )


@router.delete("/{hostel_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_favorite(
    hostel_id: UUID,
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> Response:
    """
    Remove a hostel from the visitor's favorites.
    """
    service = _get_service(session)
    # Expected service method:
    #   remove_favorite(user_id: UUID, hostel_id: UUID) -> None
    service.remove_favorite(user_id=current_user.id, hostel_id=hostel_id)
    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.get("/export", response_model=FavoritesExport)
def export_favorites(
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> FavoritesExport:
    """
    Export the visitor's favorites (for now as a structured JSON model).
    """
    service = _get_service(session)
    # Expected service method:
    #   export_favorites_for_user(user_id: UUID) -> FavoritesExport
    return service.export_favorites_for_user(user_id=current_user.id)


@router.get("/compare", response_model=FavoriteComparison)
def compare_favorites(
    hostel_ids: List[UUID] = Query(..., description="Hostel IDs to compare (2-4 ids recommended)"),
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> FavoriteComparison:
    """
    Compare a subset of favorite hostels.
    """
    service = _get_service(session)
    # Expected service method:
    #   compare_favorites(user_id: UUID, hostel_ids: List[UUID]) -> FavoriteComparison
    return service.compare_favorites(
        user_id=current_user.id,
        hostel_ids=hostel_ids,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\visitors\preferences.py ---
# app/api/v1/visitors/preferences.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.visitor import VisitorPreferencesService
from app.schemas.visitor.visitor_preferences import (
    VisitorPreferences,
    PreferenceUpdate,
)
from . import CurrentUser, get_current_visitor

router = APIRouter(tags=["Visitor - Preferences"])


def _get_service(session: Session) -> VisitorPreferencesService:
    uow = UnitOfWork(session)
    return VisitorPreferencesService(uow)


@router.get("/", response_model=VisitorPreferences)
def get_preferences(
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> VisitorPreferences:
    """
    Get the current visitor's preferences and notification settings.
    """
    service = _get_service(session)
    # Expected service method:
    #   get_preferences_for_user(user_id: UUID) -> VisitorPreferences
    return service.get_preferences_for_user(user_id=current_user.id)


@router.patch("", response_model=VisitorPreferences)
def update_preferences(
    payload: PreferenceUpdate,
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> VisitorPreferences:
    """
    Partially update the current visitor's preferences.
    """
    service = _get_service(session)
    # Expected service method:
    #   update_preferences_for_user(user_id: UUID, data: PreferenceUpdate) -> VisitorPreferences
    return service.update_preferences_for_user(
        user_id=current_user.id,
        data=payload,
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\visitors\profile.py ---
# app/api/v1/visitors/profile.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.visitor import VisitorService
from app.schemas.visitor.visitor_base import VisitorUpdate
from app.schemas.visitor.visitor_response import VisitorDetail, VisitorProfile
from . import CurrentUser, get_current_visitor

router = APIRouter(tags=["Visitor - Profile"])


def _get_service(session: Session) -> VisitorService:
    """Helper to construct VisitorService with a UnitOfWork."""
    uow = UnitOfWork(session)
    return VisitorService(uow)


@router.get("/me", response_model=VisitorDetail)
def get_my_profile(
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> VisitorDetail:
    """
    Return the detailed visitor profile for the authenticated visitor.
    """
    service = _get_service(session)
    # Expected service method: get_visitor_detail(user_id: UUID) -> VisitorDetail
    return service.get_visitor_detail(user_id=current_user.id)


@router.get("/me/summary", response_model=VisitorProfile)
def get_my_profile_summary(
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> VisitorProfile:
    """
    Lightweight summary/profile for dashboard/header usage.
    """
    service = _get_service(session)
    # Expected service method: get_visitor_profile_summary(user_id: UUID) -> VisitorProfile
    return service.get_visitor_profile_summary(user_id=current_user.id)


@router.patch("/me", response_model=VisitorDetail)
def update_my_profile(
    payload: VisitorUpdate,
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> VisitorDetail:
    """
    Partially update the visitor profile of the authenticated user.
    """
    service = _get_service(session)
    # Expected service method:
    #   update_visitor_profile(user_id: UUID, data: VisitorUpdate) -> VisitorDetail
    return service.update_visitor_profile(user_id=current_user.id, data=payload)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\visitors\search.py ---
# app/api/v1/visitors/search.py
from __future__ import annotations

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core import get_session
from app.services import UnitOfWork
from app.services.visitor import VisitorHostelSearchService
from app.schemas.hostel.hostel_search import (
    HostelSearchRequest,
    HostelSearchResponse,
)
from . import CurrentUser, get_current_visitor

router = APIRouter(tags=["Visitor - Search"])


def _get_service(session: Session) -> VisitorHostelSearchService:
    uow = UnitOfWork(session)
    return VisitorHostelSearchService(uow)


@router.post("/", response_model=HostelSearchResponse)
def search_hostels(
    payload: HostelSearchRequest,
    session: Session = Depends(get_session),
) -> HostelSearchResponse:
    """
    Public / generic hostel search over the visitor-facing index.

    This does not require authentication; if you want to make this
    visitor-only, add get_current_visitor as a dependency.
    """
    service = _get_service(session)
    # Expected service method:
    #   search(request: HostelSearchRequest) -> HostelSearchResponse
    return service.search(request=payload)


@router.get("/recommended", response_model=HostelSearchResponse)
def recommended_hostels(
    current_user: CurrentUser = Depends(get_current_visitor),
    session: Session = Depends(get_session),
) -> HostelSearchResponse:
    """
    Recommend hostels based on the visitor's saved preferences and behavior.
    """
    service = _get_service(session)
    # Expected service method:
    #   search_by_preferences(user_id: UUID) -> HostelSearchResponse
    return service.search_by_preferences(user_id=current_user.id)

# --- File: D:\Last Github Push\Last\HOStel-back\app\api\v1\visitors\__init__.py ---
# app/api/v1/visitors/__init__.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core.security import decode_token, TokenDecodeError
from app.schemas.common.enums import UserRole

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")


@dataclass
class CurrentUser:
    """Minimal representation of the authenticated user for visitor APIs."""
    id: UUID
    role: UserRole


def get_current_user(token: str = Depends(oauth2_scheme)) -> CurrentUser:
    """
    Decode JWT and return minimal CurrentUser.

    Expects payload to contain either:
      - sub (user id as string) and role
      - or user_id and user_role

    Adjust this if your TokenPayload uses different claim names.
    """
    try:
        payload: dict[str, Any] = decode_token(token)
    except TokenDecodeError as exc:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        ) from exc

    user_id_raw = payload.get("sub") or payload.get("user_id")
    role_raw = payload.get("role") or payload.get("user_role")

    if not user_id_raw or not role_raw:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    try:
        user_id = UUID(str(user_id_raw))
        role = UserRole(str(role_raw))
    except Exception as exc:  # ValueError, KeyError, etc.
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        ) from exc

    return CurrentUser(id=user_id, role=role)


def get_current_visitor(current_user: CurrentUser = Depends(get_current_user)) -> CurrentUser:
    """Ensure the authenticated user is a VISITOR."""
    if current_user.role is not UserRole.VISITOR:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only visitors can access this endpoint",
        )
    return current_user


# Import sub-routers and mount them under /visitors in the main API router.
from . import profile, dashboard, favorites, preferences, search  # noqa: E402

router.include_router(profile.router, prefix="/profile")
router.include_router(dashboard.router, prefix="/dashboard")
router.include_router(favorites.router, prefix="/favorites")
router.include_router(preferences.router, prefix="/preferences")
router.include_router(search.router, prefix="/search")

__all__ = [
    "router",
    "CurrentUser",
    "get_current_user",
    "get_current_visitor",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\visitors\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\api\v1\__pycache__ =====
