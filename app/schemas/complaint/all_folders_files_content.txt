### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_analytics.py ---
"""
Complaint analytics and reporting schemas.

Provides comprehensive analytics, metrics, and insights
for complaint management performance.
"""

from __future__ import annotations

from datetime import date as Date
from decimal import Decimal
from typing import Annotated, Dict, List, Optional

from pydantic import ConfigDict, Field, field_validator, model_validator

from app.schemas.common.base import BaseSchema

__all__ = [
    "ComplaintAnalytics",
    "ResolutionMetrics",
    "CategoryAnalysis",
    "CategoryMetrics",
    "ComplaintTrendPoint",
    "StaffPerformance",
    "ComplaintHeatmap",
    "RoomComplaintCount",
]


class ResolutionMetrics(BaseSchema):
    """
    Detailed complaint resolution performance metrics.
    
    Tracks resolution efficiency and quality indicators.
    """
    model_config = ConfigDict(from_attributes=True)

    total_resolved: int = Field(..., ge=0, description="Total resolved count")

    # Time metrics (in hours)
    # Note: Pydantic v2 requires Decimal constraints in Annotated for optional fields
    average_resolution_time_hours: Annotated[
        Decimal,
        Field(ge=Decimal("0"), description="Average resolution time (hours)")
    ]
    median_resolution_time_hours: Annotated[
        Decimal,
        Field(ge=Decimal("0"), description="Median resolution time (hours)")
    ]
    fastest_resolution_hours: Annotated[
        Decimal,
        Field(ge=Decimal("0"), description="Fastest resolution time (hours)")
    ]
    slowest_resolution_hours: Annotated[
        Decimal,
        Field(ge=Decimal("0"), description="Slowest resolution time (hours)")
    ]

    # Performance rates
    resolution_rate: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="% of complaints resolved"
        )
    ]
    same_day_resolution_rate: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="% resolved within 24 hours"
        )
    ]

    # Escalation metrics
    escalation_rate: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="% of complaints escalated"
        )
    ]

    # Quality metrics
    reopen_rate: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="% of resolved complaints reopened"
        )
    ]


class CategoryMetrics(BaseSchema):
    """
    Metrics for a single complaint category.
    
    Provides detailed performance data per category.
    """
    model_config = ConfigDict(from_attributes=True)

    category: str = Field(..., description="Category name")
    total_complaints: int = Field(..., ge=0, description="Total complaints")
    open_complaints: int = Field(..., ge=0, description="Open complaints")
    resolved_complaints: int = Field(..., ge=0, description="Resolved complaints")

    average_resolution_time_hours: Annotated[
        Decimal,
        Field(ge=Decimal("0"), description="Average resolution time (hours)")
    ]
    resolution_rate: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="Resolution rate percentage"
        )
    ]

    percentage_of_total: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="% of total complaints"
        )
    ]


class CategoryAnalysis(BaseSchema):
    """
    Category-wise complaint analysis.
    
    Identifies problem areas and trends by category.
    """
    model_config = ConfigDict(from_attributes=True)

    categories: List[CategoryMetrics] = Field(
        default_factory=list,
        description="Metrics for each category",
    )

    most_common_category: str = Field(
        ...,
        description="Category with most complaints",
    )
    most_problematic_category: str = Field(
        ...,
        description="Category with longest avg resolution time",
    )


class ComplaintTrendPoint(BaseSchema):
    """
    Time-series data point for complaint trends.
    
    Represents complaint metrics for a specific period.
    """
    model_config = ConfigDict(from_attributes=True)

    period: str = Field(
        ...,
        description="Time period (Date, week, or month)",
        examples=["2024-01-15", "2024-W03", "2024-01"],
    )
    total_complaints: int = Field(..., ge=0, description="Total complaints")
    open_complaints: int = Field(..., ge=0, description="Open complaints")
    resolved_complaints: int = Field(..., ge=0, description="Resolved complaints")

    # Priority breakdown
    urgent_count: int = Field(..., ge=0, description="Urgent priority count")
    high_count: int = Field(..., ge=0, description="High priority count")
    medium_count: int = Field(..., ge=0, description="Medium priority count")
    low_count: int = Field(..., ge=0, description="Low priority count")


class StaffPerformance(BaseSchema):
    """
    Individual staff member complaint resolution performance.
    
    Tracks productivity and quality metrics per staff member.
    """
    model_config = ConfigDict(from_attributes=True)

    staff_id: str = Field(..., description="Staff member user ID")
    staff_name: str = Field(..., description="Staff member name")
    staff_role: str = Field(..., description="Staff member role")

    complaints_assigned: int = Field(
        ...,
        ge=0,
        description="Total complaints assigned",
    )
    complaints_resolved: int = Field(
        ...,
        ge=0,
        description="Total complaints resolved",
    )

    average_resolution_time_hours: Annotated[
        Decimal,
        Field(ge=Decimal("0"), description="Average resolution time (hours)")
    ]
    resolution_rate: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="Resolution rate percentage"
        )
    ]

    average_rating: Optional[Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("5"),
            description="Average feedback rating (1-5)"
        )
    ]] = None


class RoomComplaintCount(BaseSchema):
    """
    Complaint count and analysis for specific room.
    
    Helps identify problematic rooms.
    """
    model_config = ConfigDict(from_attributes=True)

    room_id: str = Field(..., description="Room identifier")
    room_number: str = Field(..., description="Room number")
    complaint_count: int = Field(..., ge=0, description="Total complaints")

    most_common_category: str = Field(
        ...,
        description="Most frequent complaint category",
    )


class ComplaintHeatmap(BaseSchema):
    """
    Complaint heatmap for pattern analysis.
    
    Identifies temporal and spatial complaint patterns.
    """
    model_config = ConfigDict(from_attributes=True)

    hostel_id: str = Field(..., description="Hostel identifier")

    # Temporal patterns
    complaints_by_hour: Dict[int, int] = Field(
        default_factory=dict,
        description="Complaint count by hour of day (0-23)",
    )
    complaints_by_day: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaint count by day of week",
    )

    # Spatial patterns
    complaints_by_room: List[RoomComplaintCount] = Field(
        default_factory=list,
        description="Complaint count by room",
    )
    complaints_by_floor: Dict[int, int] = Field(
        default_factory=dict,
        description="Complaint count by floor number",
    )

    @field_validator("complaints_by_hour")
    @classmethod
    def validate_hour_keys(cls, v: Dict[int, int]) -> Dict[int, int]:
        """Validate hour keys are in valid range (0-23)."""
        for hour in v.keys():
            if not 0 <= hour <= 23:
                raise ValueError(f"Invalid hour: {hour}. Must be 0-23")
        return v


class ComplaintAnalytics(BaseSchema):
    """
    Comprehensive complaint analytics dashboard.
    
    Provides holistic view of complaint management performance.
    """
    model_config = ConfigDict(from_attributes=True)

    hostel_id: Optional[str] = Field(
        default=None,
        description="Hostel ID (None for system-wide analytics)",
    )
    period_start: Date = Field(..., description="Analytics period start")
    period_end: Date = Field(..., description="Analytics period end")

    # Summary counts
    total_complaints: int = Field(..., ge=0, description="Total complaints")
    open_complaints: int = Field(..., ge=0, description="Open complaints")
    resolved_complaints: int = Field(..., ge=0, description="Resolved complaints")
    closed_complaints: int = Field(..., ge=0, description="Closed complaints")

    # Detailed metrics
    resolution_metrics: ResolutionMetrics = Field(
        ...,
        description="Resolution performance metrics",
    )

    category_analysis: CategoryAnalysis = Field(
        ...,
        description="Category-wise breakdown",
    )

    priority_distribution: Dict[str, int] = Field(
        default_factory=dict,
        description="Distribution by priority level",
    )

    complaint_trend: List[ComplaintTrendPoint] = Field(
        default_factory=list,
        description="Time-series trend data",
    )

    # SLA metrics
    sla_compliance_rate: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="SLA compliance percentage"
        )
    ]
    sla_breached_count: int = Field(
        ...,
        ge=0,
        description="SLA breached complaint count",
    )

    # Staff performance
    top_resolvers: List[StaffPerformance] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 complaint resolvers",
    )

    @model_validator(mode="after")
    def validate_period_range(self) -> "ComplaintAnalytics":
        """Validate analytics period is logical."""
        if self.period_end < self.period_start:
            raise ValueError("period_end must be >= period_start")
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_assignment.py ---
"""
Complaint assignment and reassignment schemas.

Handles complaint assignment to staff members, reassignments,
bulk operations, and unassignment flows.
"""

from __future__ import annotations

from datetime import datetime, timezone
from typing import List, Optional

from pydantic import ConfigDict, Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "AssignmentRequest",
    "AssignmentResponse",
    "ReassignmentRequest",
    "BulkAssignment",
    "UnassignRequest",
    "AssignmentHistory",
]


class AssignmentRequest(BaseCreateSchema):
    """
    Request to assign complaint to a staff member.
    
    Supports optional estimated resolution time and notes
    for assignment context.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to assign",
    )
    assigned_to: str = Field(
        ...,
        description="User ID of assignee (supervisor/staff)",
    )

    estimated_resolution_time: Optional[datetime] = Field(
        default=None,
        description="Estimated resolution timestamp",
    )

    assignment_notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Assignment context or instructions",
    )

    @field_validator("assignment_notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize assignment notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("estimated_resolution_time")
    @classmethod
    def validate_estimated_time(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Ensure estimated resolution time is in the future."""
        if v is not None:
            now = datetime.now(timezone.utc)
            # Handle timezone-naive datetime
            if v.tzinfo is None:
                v = v.replace(tzinfo=timezone.utc)
            if v <= now:
                raise ValueError(
                    "Estimated resolution time must be in the future"
                )
        return v


class AssignmentResponse(BaseSchema):
    """
    Response after successful complaint assignment.
    
    Provides confirmation details and assignment metadata.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(..., description="Assigned complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    assigned_to: str = Field(..., description="Assignee user ID")
    assigned_to_name: str = Field(..., description="Assignee name")
    assigned_by: str = Field(..., description="User who performed assignment")
    assigned_by_name: str = Field(..., description="Assigner name")

    assigned_at: datetime = Field(..., description="Assignment timestamp")

    message: str = Field(
        ...,
        description="Confirmation message",
        examples=["Complaint assigned successfully"],
    )


class ReassignmentRequest(BaseCreateSchema):
    """
    Request to reassign complaint to different staff member.
    
    Requires reason for reassignment to maintain audit trail.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to reassign",
    )
    new_assigned_to: str = Field(
        ...,
        description="New assignee user ID",
    )

    reassignment_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for reassignment (mandatory)",
    )

    notify_previous_assignee: bool = Field(
        default=True,
        description="Send notification to previous assignee",
    )

    @field_validator("reassignment_reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reassignment reason."""
        v = v.strip()
        if not v:
            raise ValueError("Reassignment reason cannot be empty")
        
        word_count = len(v.split())
        if word_count < 3:
            raise ValueError(
                "Reassignment reason must be at least 3 words"
            )
        
        return v


class BulkAssignment(BaseCreateSchema):
    """
    Bulk assignment of multiple complaints to one assignee.
    
    Useful for distributing workload efficiently.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of complaint IDs to assign (max 50)",
    )
    assigned_to: str = Field(
        ...,
        description="User ID of assignee for all complaints",
    )

    assignment_notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Common assignment notes",
    )

    @field_validator("complaint_ids")
    @classmethod
    def validate_complaint_ids_unique(cls, v: List[str]) -> List[str]:
        """Ensure complaint IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Complaint IDs must be unique")
        
        if len(v) > 50:
            raise ValueError("Cannot assign more than 50 complaints at once")
        
        return v

    @field_validator("assignment_notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize assignment notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v


class UnassignRequest(BaseCreateSchema):
    """
    Request to unassign complaint from current assignee.
    
    Requires reason for accountability.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to unassign",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for unassignment",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate unassignment reason."""
        v = v.strip()
        if not v:
            raise ValueError("Unassignment reason cannot be empty")
        
        word_count = len(v.split())
        if word_count < 3:
            raise ValueError(
                "Unassignment reason must be at least 3 words"
            )
        
        return v


class AssignmentHistory(BaseSchema):
    """
    Assignment history entry for audit trail.
    
    Tracks all assignment changes for a complaint.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(..., description="Complaint ID")
    
    assigned_to: str = Field(..., description="Assignee user ID")
    assigned_to_name: str = Field(..., description="Assignee name")
    
    assigned_by: str = Field(..., description="Assigner user ID")
    assigned_by_name: str = Field(..., description="Assigner name")
    
    assigned_at: datetime = Field(..., description="Assignment timestamp")
    unassigned_at: Optional[datetime] = Field(
        default=None,
        description="Unassignment timestamp",
    )
    
    reason: Optional[str] = Field(
        default=None,
        description="Assignment/reassignment reason",
    )
    
    duration_hours: Optional[int] = Field(
        default=None,
        ge=0,
        description="Duration assigned (hours)",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_base.py ---
"""
Core complaint schemas with enhanced validation and type safety.

This module provides base schemas for complaint creation, updates, and status management
with comprehensive field validation and business rule enforcement.
"""

from __future__ import annotations

from typing import List, Optional

from pydantic import ConfigDict, Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import ComplaintCategory, ComplaintStatus, Priority

__all__ = [
    "ComplaintBase",
    "ComplaintCreate",
    "ComplaintUpdate",
    "ComplaintStatusUpdate",
]


class ComplaintBase(BaseSchema):
    """
    Base complaint schema with core fields and validation.
    
    This schema defines the fundamental structure of a complaint including
    identification, categorization, priority, and location details.
    """
    model_config = ConfigDict(from_attributes=True)

    hostel_id: str = Field(
        ...,
        description="Hostel identifier where complaint originated",
    )
    raised_by: str = Field(
        ...,
        description="User ID who raised the complaint",
    )
    student_id: Optional[str] = Field(
        default=None,
        description="Student ID if complaint raised by a student",
    )

    # Complaint content
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Brief complaint title/summary",
    )
    description: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed complaint description",
    )

    # Classification
    category: ComplaintCategory = Field(
        ...,
        description="Primary complaint category",
    )
    sub_category: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Optional sub-category for finer classification",
    )

    # Priority
    priority: Priority = Field(
        default=Priority.MEDIUM,
        description="Complaint priority level (defaults to medium)",
    )

    # Location details
    room_id: Optional[str] = Field(
        default=None,
        description="Room identifier if complaint is room-specific",
    )
    location_details: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Detailed location information within hostel",
    )

    # Attachments
    attachments: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="URLs of supporting documents/photos (max 10)",
    )

    @field_validator("title")
    @classmethod
    def validate_title(cls, v: str) -> str:
        """
        Validate and normalize complaint title.
        
        Ensures title is meaningful and properly formatted.
        """
        v = v.strip()
        if not v:
            raise ValueError("Title cannot be empty or whitespace only")
        if v.isdigit():
            raise ValueError("Title cannot consist of only numbers")
        return v

    @field_validator("description")
    @classmethod
    def validate_description(cls, v: str) -> str:
        """
        Validate and normalize complaint description.
        
        Ensures description provides sufficient detail.
        """
        v = v.strip()
        if not v:
            raise ValueError("Description cannot be empty or whitespace only")
        
        # Check for minimum word count (at least 5 words)
        word_count = len(v.split())
        if word_count < 5:
            raise ValueError(
                "Description must contain at least 5 words for clarity"
            )
        
        return v

    @field_validator("sub_category")
    @classmethod
    def validate_sub_category(cls, v: Optional[str]) -> Optional[str]:
        """Normalize sub-category if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("location_details")
    @classmethod
    def validate_location_details(cls, v: Optional[str]) -> Optional[str]:
        """Normalize location details if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("attachments")
    @classmethod
    def validate_attachments_limit(cls, v: List[HttpUrl]) -> List[HttpUrl]:
        """Ensure attachment count doesn't exceed limit."""
        if len(v) > 10:
            raise ValueError("Maximum 10 attachments allowed per complaint")
        return v

    @model_validator(mode="after")
    def validate_location_consistency(self) -> "ComplaintBase":
        """
        Validate location-related fields are consistent.
        
        If room_id is provided, location_details should also be provided
        for better context.
        """
        if self.room_id and not self.location_details:
            # This is a soft validation - log warning but don't fail
            pass
        
        return self


class ComplaintCreate(ComplaintBase, BaseCreateSchema):
    """
    Schema for creating a new complaint.
    
    Inherits all validation from ComplaintBase and adds any
    create-specific validation if needed.
    """
    model_config = ConfigDict(from_attributes=True)

    @model_validator(mode="after")
    def validate_create_specific_rules(self) -> "ComplaintCreate":
        """
        Enforce creation-specific business rules.
        
        Additional validation that only applies during complaint creation.
        """
        # Ensure high/urgent priority complaints have location details
        if self.priority in [Priority.HIGH, Priority.URGENT, Priority.CRITICAL]:
            if not self.location_details and not self.room_id:
                raise ValueError(
                    f"High priority complaints ({self.priority.value}) "
                    "must include location details or room ID"
                )
        
        return self


class ComplaintUpdate(BaseUpdateSchema):
    """
    Schema for updating existing complaint.
    
    All fields are optional to support partial updates.
    Includes validation to ensure meaningful updates.
    """
    model_config = ConfigDict(from_attributes=True)

    title: Optional[str] = Field(
        default=None,
        min_length=5,
        max_length=255,
        description="Updated complaint title",
    )
    description: Optional[str] = Field(
        default=None,
        min_length=20,
        max_length=2000,
        description="Updated complaint description",
    )
    category: Optional[ComplaintCategory] = Field(
        default=None,
        description="Updated complaint category",
    )
    sub_category: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Updated sub-category",
    )
    priority: Optional[Priority] = Field(
        default=None,
        description="Updated priority level",
    )
    location_details: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Updated location details",
    )
    attachments: Optional[List[HttpUrl]] = Field(
        default=None,
        max_length=10,
        description="Updated attachments list",
    )
    status: Optional[ComplaintStatus] = Field(
        default=None,
        description="Updated complaint status",
    )

    @field_validator("title")
    @classmethod
    def validate_title(cls, v: Optional[str]) -> Optional[str]:
        """Validate title if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError("Title cannot be empty or whitespace only")
            if v.isdigit():
                raise ValueError("Title cannot consist of only numbers")
        return v

    @field_validator("description")
    @classmethod
    def validate_description(cls, v: Optional[str]) -> Optional[str]:
        """Validate description if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError("Description cannot be empty or whitespace only")
            
            word_count = len(v.split())
            if word_count < 5:
                raise ValueError(
                    "Description must contain at least 5 words for clarity"
                )
        return v

    @field_validator("attachments")
    @classmethod
    def validate_attachments_limit(cls, v: Optional[List[HttpUrl]]) -> Optional[List[HttpUrl]]:
        """Ensure attachment count doesn't exceed limit."""
        if v is not None and len(v) > 10:
            raise ValueError("Maximum 10 attachments allowed per complaint")
        return v

    @model_validator(mode="after")
    def validate_has_updates(self) -> "ComplaintUpdate":
        """
        Ensure at least one field is being updated.
        
        Prevents empty update requests.
        """
        update_fields = {
            k: v for k, v in self.model_dump(exclude_unset=True).items()
            if v is not None
        }
        
        if not update_fields:
            raise ValueError("At least one field must be provided for update")
        
        return self


class ComplaintStatusUpdate(BaseUpdateSchema):
    """
    Dedicated schema for complaint status updates.
    
    Provides focused status change functionality with
    mandatory change notes for audit trail.
    """
    model_config = ConfigDict(from_attributes=True)

    status: ComplaintStatus = Field(
        ...,
        description="New complaint status",
    )
    notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason or notes for status change",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize status change notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @model_validator(mode="after")
    def validate_status_change_requirements(self) -> "ComplaintStatusUpdate":
        """
        Enforce business rules for status changes.
        
        Certain status transitions require mandatory notes.
        """
        # Statuses that require explanatory notes
        statuses_requiring_notes = {
            ComplaintStatus.REJECTED,
            ComplaintStatus.ON_HOLD,
            ComplaintStatus.CLOSED,
            ComplaintStatus.REOPENED,
        }
        
        if self.status in statuses_requiring_notes and not self.notes:
            raise ValueError(
                f"Status change to '{self.status.value}' requires explanatory notes"
            )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_comments.py ---
"""
Complaint discussion and comments schemas.

Handles internal notes and public comments on complaints
with support for attachments and mentions.
"""

from __future__ import annotations

from datetime import datetime
from typing import List, Optional

from pydantic import ConfigDict, Field, HttpUrl, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "CommentCreate",
    "CommentResponse",
    "CommentList",
    "CommentUpdate",
    "CommentDelete",
    "MentionNotification",
]


class CommentCreate(BaseCreateSchema):
    """
    Create comment on complaint.
    
    Supports both public comments and internal notes
    with optional attachments.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to comment on",
    )

    comment_text: str = Field(
        ...,
        min_length=5,
        max_length=1000,
        description="Comment text content",
    )

    is_internal: bool = Field(
        default=False,
        description="Internal note (staff only) vs public comment",
    )

    attachments: List[HttpUrl] = Field(
        default_factory=list,
        max_length=5,
        description="Comment attachments (max 5)",
    )

    @field_validator("comment_text")
    @classmethod
    def validate_comment_text(cls, v: str) -> str:
        """Validate comment text quality."""
        v = v.strip()
        if not v:
            raise ValueError("Comment text cannot be empty")
        
        # Ensure meaningful content
        if len(v) < 5:
            raise ValueError("Comment must be at least 5 characters")
        
        return v

    @field_validator("attachments")
    @classmethod
    def validate_attachments_limit(cls, v: List[HttpUrl]) -> List[HttpUrl]:
        """Ensure attachment count doesn't exceed limit."""
        if len(v) > 5:
            raise ValueError("Maximum 5 attachments allowed per comment")
        return v


class CommentResponse(BaseResponseSchema):
    """
    Comment response with author information.
    
    Includes metadata about comment author and timing.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(..., description="Associated complaint ID")

    commented_by: str = Field(..., description="Commenter user ID")
    commented_by_name: str = Field(..., description="Commenter name")
    commented_by_role: str = Field(..., description="Commenter role")

    comment_text: str = Field(..., description="Comment content")
    is_internal: bool = Field(..., description="Internal note flag")

    attachments: List[str] = Field(
        default_factory=list,
        description="Attachment URLs",
    )

    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")

    is_edited: bool = Field(
        default=False,
        description="Whether comment was edited",
    )


class CommentList(BaseSchema):
    """
    List of comments for a complaint.
    
    Provides summary statistics and comment thread.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(..., description="Complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    total_comments: int = Field(..., ge=0, description="Total comment count")
    public_comments: int = Field(..., ge=0, description="Public comment count")
    internal_notes: int = Field(..., ge=0, description="Internal note count")

    comments: List[CommentResponse] = Field(
        default_factory=list,
        description="List of comments (sorted by creation time)",
    )


class CommentUpdate(BaseCreateSchema):
    """
    Update existing comment.
    
    Allows modification of comment text only.
    """
    model_config = ConfigDict(from_attributes=True)

    comment_id: str = Field(
        ...,
        description="Comment identifier to update",
    )
    comment_text: str = Field(
        ...,
        min_length=5,
        max_length=1000,
        description="Updated comment text",
    )

    @field_validator("comment_text")
    @classmethod
    def validate_comment_text(cls, v: str) -> str:
        """Validate comment text quality."""
        v = v.strip()
        if not v:
            raise ValueError("Comment text cannot be empty")
        
        if len(v) < 5:
            raise ValueError("Comment must be at least 5 characters")
        
        return v


class CommentDelete(BaseCreateSchema):
    """
    Delete comment request.
    
    Optional reason for deletion audit trail.
    """
    model_config = ConfigDict(from_attributes=True)

    comment_id: str = Field(
        ...,
        description="Comment identifier to delete",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=200,
        description="Deletion reason (optional)",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: Optional[str]) -> Optional[str]:
        """Normalize deletion reason if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v


class MentionNotification(BaseSchema):
    """
    Notification when user is mentioned in comment.
    
    Supports @mention functionality in comments.
    """
    model_config = ConfigDict(from_attributes=True)

    comment_id: str = Field(..., description="Comment ID with mention")
    complaint_id: str = Field(..., description="Associated complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    mentioned_by: str = Field(..., description="User who mentioned")
    mentioned_by_name: str = Field(..., description="Mentioner name")

    comment_excerpt: str = Field(
        ...,
        max_length=200,
        description="Comment excerpt (first 200 chars)",
    )

    comment_url: str = Field(
        ...,
        description="Direct URL to comment",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_escalation.py ---
"""
Complaint escalation schemas with comprehensive tracking.

Handles complaint escalation workflow, auto-escalation rules,
and escalation history management.
"""

from __future__ import annotations

from datetime import datetime
from typing import List, Optional

from pydantic import ConfigDict, Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "EscalationRequest",
    "EscalationResponse",
    "EscalationHistory",
    "EscalationEntry",
    "AutoEscalationRule",
]


class EscalationRequest(BaseCreateSchema):
    """
    Request to escalate complaint to higher authority.
    
    Requires detailed reason and supports priority increase
    and urgency flags.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to escalate",
    )
    escalate_to: str = Field(
        ...,
        description="User ID to escalate to (admin/supervisor)",
    )

    escalation_reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Detailed escalation reason",
    )

    increase_priority: bool = Field(
        default=True,
        description="Automatically increase priority level",
    )

    is_urgent: bool = Field(
        default=False,
        description="Mark as urgent escalation",
    )

    @field_validator("escalation_reason")
    @classmethod
    def validate_escalation_reason(cls, v: str) -> str:
        """Validate escalation reason quality."""
        v = v.strip()
        if not v:
            raise ValueError("Escalation reason cannot be empty")
        
        word_count = len(v.split())
        if word_count < 5:
            raise ValueError(
                "Escalation reason must contain at least 5 words "
                "for proper documentation"
            )
        
        return v


class EscalationResponse(BaseSchema):
    """
    Response after successful escalation.
    
    Provides confirmation and updated complaint details.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(..., description="Escalated complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    escalated: bool = Field(..., description="Escalation confirmation flag")
    escalated_to: str = Field(..., description="Escalated to user ID")
    escalated_to_name: str = Field(..., description="Escalated to name")
    escalated_by: str = Field(..., description="Escalator user ID")
    escalated_by_name: str = Field(..., description="Escalator name")
    escalated_at: datetime = Field(..., description="Escalation timestamp")

    new_priority: str = Field(
        ...,
        description="Updated priority level after escalation",
    )

    message: str = Field(
        ...,
        description="Confirmation message",
        examples=["Complaint escalated successfully"],
    )


class EscalationEntry(BaseResponseSchema):
    """
    Individual escalation entry in history.
    
    Tracks single escalation event with complete metadata.
    """
    model_config = ConfigDict(from_attributes=True)

    escalated_to: str = Field(..., description="Escalated to user ID")
    escalated_to_name: str = Field(..., description="Escalated to name")
    escalated_by: str = Field(..., description="Escalator user ID")
    escalated_by_name: str = Field(..., description="Escalator name")
    escalated_at: datetime = Field(..., description="Escalation timestamp")

    reason: str = Field(..., description="Escalation reason")

    # State before/after
    status_before: str = Field(..., description="Status before escalation")
    priority_before: str = Field(..., description="Priority before escalation")
    priority_after: str = Field(..., description="Priority after escalation")

    # Response tracking
    response_time_hours: Optional[int] = Field(
        default=None,
        ge=0,
        description="Time taken to respond (hours)",
    )
    resolved_after_escalation: bool = Field(
        ...,
        description="Whether resolved after this escalation",
    )


class EscalationHistory(BaseSchema):
    """
    Complete escalation history for a complaint.
    
    Provides audit trail of all escalations.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(..., description="Complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    escalations: List[EscalationEntry] = Field(
        default_factory=list,
        description="List of escalation entries",
    )
    total_escalations: int = Field(
        ...,
        ge=0,
        description="Total escalation count",
    )


class AutoEscalationRule(BaseSchema):
    """
    Auto-escalation rule configuration.
    
    Defines automatic escalation triggers based on time
    and SLA conditions.
    """
    model_config = ConfigDict(from_attributes=True)

    hostel_id: str = Field(
        ...,
        description="Hostel identifier for rule scope",
    )

    # Trigger conditions
    escalate_after_hours: int = Field(
        default=24,
        ge=1,
        le=168,  # Max 1 week
        description="Hours before auto-escalation (default 24)",
    )
    escalate_on_sla_breach: bool = Field(
        default=True,
        description="Auto-escalate on SLA breach",
    )

    # Priority-specific rules
    urgent_escalation_hours: int = Field(
        default=4,
        ge=1,
        le=24,
        description="Escalation threshold for urgent complaints (hours)",
    )
    high_escalation_hours: int = Field(
        default=12,
        ge=1,
        le=48,
        description="Escalation threshold for high priority (hours)",
    )
    medium_escalation_hours: int = Field(
        default=24,
        ge=1,
        le=72,
        description="Escalation threshold for medium priority (hours)",
    )

    # Escalation chain
    first_escalation_to: str = Field(
        ...,
        description="First level escalation target user ID",
    )
    second_escalation_to: Optional[str] = Field(
        default=None,
        description="Second level escalation target (if first unresolved)",
    )

    is_active: bool = Field(
        default=True,
        description="Rule active status",
    )

    @model_validator(mode="after")
    def validate_escalation_thresholds(self) -> "AutoEscalationRule":
        """
        Validate escalation time thresholds are logical.
        
        Ensures urgent < high < medium.
        """
        if not (
            self.urgent_escalation_hours
            < self.high_escalation_hours
            < self.medium_escalation_hours
        ):
            raise ValueError(
                "Escalation thresholds must follow: "
                "urgent < high < medium"
            )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_feedback.py ---
"""
Complaint feedback and satisfaction schemas.

Handles student feedback collection, ratings, and
feedback analytics for service improvement.
"""

from __future__ import annotations

from datetime import date as Date, datetime
from decimal import Decimal
from typing import Annotated, Dict, List, Optional

from pydantic import ConfigDict, Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "FeedbackRequest",
    "FeedbackResponse",
    "FeedbackSummary",
    "FeedbackAnalysis",
    "RatingTrendPoint",
]


class FeedbackRequest(BaseCreateSchema):
    """
    Submit feedback on resolved complaint.
    
    Collects rating, detailed feedback, and satisfaction metrics.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to provide feedback for",
    )

    rating: int = Field(
        ...,
        ge=1,
        le=5,
        description="Overall rating (1-5 stars)",
    )

    feedback: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Detailed feedback comments",
    )

    # Satisfaction questions
    issue_resolved_satisfactorily: bool = Field(
        ...,
        description="Was the issue resolved to your satisfaction?",
    )
    response_time_satisfactory: bool = Field(
        ...,
        description="Was the response time acceptable?",
    )
    staff_helpful: bool = Field(
        ...,
        description="Was the staff helpful and professional?",
    )

    would_recommend: Optional[bool] = Field(
        default=None,
        description="Would you recommend this complaint system?",
    )

    @field_validator("feedback")
    @classmethod
    def validate_feedback(cls, v: Optional[str]) -> Optional[str]:
        """Normalize feedback text if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("rating")
    @classmethod
    def validate_rating_for_poor_scores(cls, v: int) -> int:
        """
        Encourage feedback text for low ratings.
        
        Note: This is advisory validation, not enforced.
        """
        # Could log warning if rating <= 2 and no feedback
        # but not enforcing to avoid friction
        return v


class FeedbackResponse(BaseResponseSchema):
    """
    Feedback submission response.
    
    Confirms feedback receipt and provides summary.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(..., description="Complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    rating: int = Field(..., description="Submitted rating")
    feedback: Optional[str] = Field(default=None, description="Submitted feedback")

    submitted_by: str = Field(..., description="Feedback submitter user ID")
    submitted_at: datetime = Field(..., description="Submission timestamp")

    message: str = Field(
        ...,
        description="Confirmation message",
        examples=["Thank you for your feedback!"],
    )


class FeedbackSummary(BaseSchema):
    """
    Feedback summary for hostel or supervisor.
    
    Provides aggregate feedback metrics and insights.
    """
    model_config = ConfigDict(from_attributes=True)

    entity_id: str = Field(
        ...,
        description="Entity identifier (hostel or supervisor)",
    )
    entity_type: str = Field(
        ...,
        pattern=r"^(hostel|supervisor)$",
        description="Entity type: hostel or supervisor",
    )

    # Time period
    period_start: Date = Field(..., description="Summary period start Date")
    period_end: Date = Field(..., description="Summary period end Date")

    # Overall statistics
    total_feedbacks: int = Field(..., ge=0, description="Total feedback count")
    average_rating: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("5"),
            description="Average rating (0-5)"
        )
    ]

    # Rating distribution
    rating_5_count: int = Field(..., ge=0, description="5-star rating count")
    rating_4_count: int = Field(..., ge=0, description="4-star rating count")
    rating_3_count: int = Field(..., ge=0, description="3-star rating count")
    rating_2_count: int = Field(..., ge=0, description="2-star rating count")
    rating_1_count: int = Field(..., ge=0, description="1-star rating count")

    # Satisfaction metrics (percentages)
    resolution_satisfaction_rate: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="% satisfied with issue resolution"
        )
    ]
    response_time_satisfaction_rate: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="% satisfied with response time"
        )
    ]
    staff_helpfulness_rate: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="% who found staff helpful"
        )
    ]

    # Recommendation
    recommendation_rate: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="% who would recommend the system"
        )
    ]

    # Sentiment analysis
    positive_feedback_count: int = Field(
        ...,
        ge=0,
        description="Positive feedback count",
    )
    negative_feedback_count: int = Field(
        ...,
        ge=0,
        description="Negative feedback count",
    )
    common_themes: List[str] = Field(
        default_factory=list,
        description="Common themes from feedback analysis",
    )


class RatingTrendPoint(BaseSchema):
    """
    Data point for rating trend analysis.
    
    Represents rating metrics for a specific time period.
    """
    model_config = ConfigDict(from_attributes=True)

    period: str = Field(
        ...,
        description="Time period (Date, week, or month)",
        examples=["2024-01", "Week 1", "2024-01-15"],
    )
    average_rating: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("5"),
            description="Average rating for period"
        )
    ]
    feedback_count: int = Field(
        ...,
        ge=0,
        description="Number of feedbacks in period",
    )


class FeedbackAnalysis(BaseSchema):
    """
    Detailed feedback analysis with trends.
    
    Provides deep insights into feedback patterns.
    """
    model_config = ConfigDict(from_attributes=True)

    hostel_id: str = Field(..., description="Hostel identifier")
    period_start: Date = Field(..., description="Analysis period start")
    period_end: Date = Field(..., description="Analysis period end")

    # Trend data
    rating_trend: List[RatingTrendPoint] = Field(
        default_factory=list,
        description="Rating trend over time",
    )

    # Category analysis
    feedback_by_category: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Average rating by complaint category",
    )

    # Priority analysis
    feedback_by_priority: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Average rating by priority level",
    )

    # Response time impact
    avg_rating_quick_response: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("5"),
            description="Average rating for quick responses"
        )
    ]
    avg_rating_slow_response: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("5"),
            description="Average rating for slow responses"
        )
    ]

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_filters.py ---
"""
Complaint filtering and search schemas.

Provides comprehensive filtering, searching, and sorting
capabilities for complaint queries.
"""

from __future__ import annotations

from datetime import date as Date
from typing import List, Optional

from pydantic import ConfigDict, Field, field_validator, model_validator

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import ComplaintCategory, ComplaintStatus, Priority

__all__ = [
    "ComplaintFilterParams",
    "ComplaintSearchRequest",
    "ComplaintSortOptions",
    "ComplaintExportRequest",
]


class ComplaintFilterParams(BaseFilterSchema):
    """
    Comprehensive complaint filter parameters.
    
    Supports filtering by multiple dimensions for flexible queries.
    """
    model_config = ConfigDict(from_attributes=True)

    # Text search
    search: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=255,
        description="Search in title, description, complaint number",
    )

    # Hostel filters
    hostel_id: Optional[str] = Field(
        default=None,
        description="Filter by single hostel",
    )
    hostel_ids: Optional[List[str]] = Field(
        default=None,
        max_length=50,
        description="Filter by multiple hostels (max 50)",
    )

    # User filters
    raised_by: Optional[str] = Field(
        default=None,
        description="Filter by complainant user ID",
    )
    student_id: Optional[str] = Field(
        default=None,
        description="Filter by student ID",
    )

    # Assignment filters
    assigned_to: Optional[str] = Field(
        default=None,
        description="Filter by assigned staff member",
    )
    unassigned_only: Optional[bool] = Field(
        default=None,
        description="Show only unassigned complaints",
    )

    # Category filters
    category: Optional[ComplaintCategory] = Field(
        default=None,
        description="Filter by single category",
    )
    categories: Optional[List[ComplaintCategory]] = Field(
        default=None,
        max_length=20,
        description="Filter by multiple categories",
    )

    # Priority filters
    priority: Optional[Priority] = Field(
        default=None,
        description="Filter by single priority",
    )
    priorities: Optional[List[Priority]] = Field(
        default=None,
        max_length=10,
        description="Filter by multiple priorities",
    )

    # Status filters
    status: Optional[ComplaintStatus] = Field(
        default=None,
        description="Filter by single status",
    )
    statuses: Optional[List[ComplaintStatus]] = Field(
        default=None,
        max_length=10,
        description="Filter by multiple statuses",
    )

    # Date range filters
    opened_date_from: Optional[Date] = Field(
        default=None,
        description="Opened Date range start (inclusive)",
    )
    opened_date_to: Optional[Date] = Field(
        default=None,
        description="Opened Date range end (inclusive)",
    )
    resolved_date_from: Optional[Date] = Field(
        default=None,
        description="Resolved Date range start",
    )
    resolved_date_to: Optional[Date] = Field(
        default=None,
        description="Resolved Date range end",
    )

    # Special filters
    sla_breached_only: Optional[bool] = Field(
        default=None,
        description="Show only SLA breached complaints",
    )
    escalated_only: Optional[bool] = Field(
        default=None,
        description="Show only escalated complaints",
    )

    # Location filters
    room_id: Optional[str] = Field(
        default=None,
        description="Filter by specific room",
    )

    # Age filters
    age_hours_min: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum complaint age in hours",
    )
    age_hours_max: Optional[int] = Field(
        default=None,
        ge=0,
        description="Maximum complaint age in hours",
    )

    @field_validator("search")
    @classmethod
    def validate_search(cls, v: Optional[str]) -> Optional[str]:
        """Normalize search query."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("hostel_ids", "categories", "priorities", "statuses")
    @classmethod
    def validate_list_length(cls, v: Optional[List]) -> Optional[List]:
        """Ensure filter lists don't exceed reasonable limits."""
        if v is not None and len(v) > 50:
            raise ValueError("Too many items in filter list (max 50)")
        return v

    @model_validator(mode="after")
    def validate_date_and_age_ranges(self) -> "ComplaintFilterParams":
        """Validate Date and age ranges are logical."""
        # Validate opened Date range
        if self.opened_date_to is not None and self.opened_date_from is not None:
            if self.opened_date_to < self.opened_date_from:
                raise ValueError("opened_date_to must be >= opened_date_from")
        
        # Validate resolved Date range
        if self.resolved_date_to is not None and self.resolved_date_from is not None:
            if self.resolved_date_to < self.resolved_date_from:
                raise ValueError("resolved_date_to must be >= resolved_date_from")
        
        # Validate age range
        if self.age_hours_max is not None and self.age_hours_min is not None:
            if self.age_hours_max < self.age_hours_min:
                raise ValueError("age_hours_max must be >= age_hours_min")
        
        return self


class ComplaintSearchRequest(BaseFilterSchema):
    """
    Full-text search request for complaints.
    
    Supports configurable search fields and filters.
    """
    model_config = ConfigDict(from_attributes=True)

    query: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Search query string",
    )
    hostel_id: Optional[str] = Field(
        default=None,
        description="Limit search to specific hostel",
    )

    # Search scope configuration
    search_in_title: bool = Field(
        default=True,
        description="Include title in search",
    )
    search_in_description: bool = Field(
        default=True,
        description="Include description in search",
    )
    search_in_number: bool = Field(
        default=True,
        description="Include complaint number in search",
    )

    # Optional filters
    status: Optional[ComplaintStatus] = Field(
        default=None,
        description="Filter by status",
    )
    priority: Optional[Priority] = Field(
        default=None,
        description="Filter by priority",
    )

    # Pagination
    page: int = Field(
        default=1,
        ge=1,
        description="Page number",
    )
    page_size: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Results per page (1-100)",
    )

    @field_validator("query")
    @classmethod
    def validate_query(cls, v: str) -> str:
        """Normalize search query."""
        v = v.strip()
        if not v:
            raise ValueError("Search query cannot be empty")
        return v


class ComplaintSortOptions(BaseFilterSchema):
    """
    Sorting options for complaint queries.
    
    Defines available sort fields and order.
    """
    model_config = ConfigDict(from_attributes=True)

    sort_by: str = Field(
        default="opened_at",
        pattern=r"^(opened_at|priority|status|category|age|updated_at|resolved_at)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        default="desc",
        pattern=r"^(asc|desc)$",
        description="Sort order: ascending or descending",
    )

    @field_validator("sort_by", "sort_order")
    @classmethod
    def normalize_sort_params(cls, v: str) -> str:
        """Normalize sort parameters to lowercase."""
        return v.lower().strip()


class ComplaintExportRequest(BaseFilterSchema):
    """
    Export complaints to various formats.
    
    Supports CSV, Excel, and PDF exports with configurable fields.
    """
    model_config = ConfigDict(from_attributes=True)

    hostel_id: Optional[str] = Field(
        default=None,
        description="Limit export to specific hostel",
    )
    filters: Optional[ComplaintFilterParams] = Field(
        default=None,
        description="Apply filters to export",
    )

    format: str = Field(
        default="csv",
        pattern=r"^(csv|excel|pdf)$",
        description="Export format: csv, excel, or pdf",
    )

    # Export options
    include_comments: bool = Field(
        default=False,
        description="Include comments in export",
    )
    include_resolution_details: bool = Field(
        default=True,
        description="Include resolution details",
    )
    include_feedback: bool = Field(
        default=True,
        description="Include student feedback",
    )

    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize export format to lowercase."""
        return v.lower().strip()

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_resolution.py ---
"""
Complaint resolution and closure schemas.

Handles complaint resolution workflow including marking as resolved,
reopening, and final closure with comprehensive validation.
"""

from __future__ import annotations

from datetime import date as Date, datetime
from typing import List, Optional

from pydantic import ConfigDict, Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "ResolutionRequest",
    "ResolutionResponse",
    "ResolutionUpdate",
    "ReopenRequest",
    "CloseRequest",
]


class ResolutionRequest(BaseCreateSchema):
    """
    Request to mark complaint as resolved.
    
    Requires detailed resolution notes and supports
    optional proof attachments and follow-up scheduling.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to resolve",
    )

    resolution_notes: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed resolution description",
    )

    resolution_attachments: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="Proof of resolution (photos/documents)",
    )

    actual_resolution_time: Optional[datetime] = Field(
        default=None,
        description="Actual time resolution was completed",
    )

    # Follow-up tracking
    follow_up_required: bool = Field(
        default=False,
        description="Whether follow-up check is needed",
    )
    follow_up_date: Optional[Date] = Field(
        default=None,
        description="Scheduled follow-up Date",
    )
    follow_up_notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Follow-up instructions",
    )

    @field_validator("resolution_notes")
    @classmethod
    def validate_resolution_notes(cls, v: str) -> str:
        """Validate resolution notes quality."""
        v = v.strip()
        if not v:
            raise ValueError("Resolution notes cannot be empty")
        
        word_count = len(v.split())
        if word_count < 10:
            raise ValueError(
                "Resolution notes must contain at least 10 words "
                "for proper documentation"
            )
        
        return v

    @field_validator("resolution_attachments")
    @classmethod
    def validate_attachments_limit(cls, v: List[HttpUrl]) -> List[HttpUrl]:
        """Ensure attachment count doesn't exceed limit."""
        if len(v) > 10:
            raise ValueError(
                "Maximum 10 resolution attachments allowed"
            )
        return v

    @field_validator("follow_up_date")
    @classmethod
    def validate_follow_up_date(cls, v: Optional[Date]) -> Optional[Date]:
        """Ensure follow-up Date is in the future."""
        if v is not None and v <= Date.today():
            raise ValueError(
                "Follow-up Date must be in the future"
            )
        return v

    @model_validator(mode="after")
    def validate_follow_up_consistency(self) -> "ResolutionRequest":
        """
        Validate follow-up fields are consistent.
        
        If follow_up_required is True, follow_up_date must be provided.
        """
        if self.follow_up_required and not self.follow_up_date:
            raise ValueError(
                "Follow-up Date is required when follow-up is marked as needed"
            )
        
        return self


class ResolutionResponse(BaseSchema):
    """
    Response after successful complaint resolution.
    
    Provides confirmation and resolution metrics.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(..., description="Resolved complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    resolved: bool = Field(..., description="Resolution confirmation flag")
    resolved_at: datetime = Field(..., description="Resolution timestamp")
    resolved_by: str = Field(..., description="Resolver user ID")
    resolved_by_name: str = Field(..., description="Resolver name")

    resolution_notes: str = Field(..., description="Resolution description")

    # Performance metrics
    time_to_resolve_hours: int = Field(
        ...,
        ge=0,
        description="Total resolution time in hours",
    )
    sla_met: bool = Field(
        ...,
        description="Whether SLA was met for this resolution",
    )

    message: str = Field(
        ...,
        description="Confirmation message",
        examples=["Complaint resolved successfully"],
    )


class ResolutionUpdate(BaseCreateSchema):
    """
    Update resolution details for already resolved complaint.
    
    Allows modification of resolution notes and attachments.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(
        ...,
        description="Complaint identifier",
    )

    resolution_notes: Optional[str] = Field(
        default=None,
        min_length=20,
        max_length=2000,
        description="Updated resolution notes",
    )
    resolution_attachments: Optional[List[HttpUrl]] = Field(
        default=None,
        max_length=10,
        description="Updated resolution attachments",
    )
    follow_up_notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Updated follow-up notes",
    )

    @field_validator("resolution_notes")
    @classmethod
    def validate_resolution_notes(cls, v: Optional[str]) -> Optional[str]:
        """Validate resolution notes if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError("Resolution notes cannot be empty")
            
            word_count = len(v.split())
            if word_count < 10:
                raise ValueError(
                    "Resolution notes must contain at least 10 words"
                )
        
        return v

    @field_validator("resolution_attachments")
    @classmethod
    def validate_attachments_limit(
        cls,
        v: Optional[List[HttpUrl]]
    ) -> Optional[List[HttpUrl]]:
        """Ensure attachment count doesn't exceed limit."""
        if v is not None and len(v) > 10:
            raise ValueError(
                "Maximum 10 resolution attachments allowed"
            )
        return v

    @model_validator(mode="after")
    def validate_has_updates(self) -> "ResolutionUpdate":
        """Ensure at least one field is being updated."""
        update_fields = {
            k: v for k, v in self.model_dump(exclude_unset=True).items()
            if v is not None and k != "complaint_id"
        }
        
        if not update_fields:
            raise ValueError(
                "At least one field must be provided for update"
            )
        
        return self


class ReopenRequest(BaseCreateSchema):
    """
    Request to reopen a resolved/closed complaint.
    
    Requires detailed reason and supports additional information.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to reopen",
    )

    reopen_reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Detailed reason for reopening",
    )

    additional_issues: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Additional issues discovered",
    )
    new_attachments: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="New supporting attachments",
    )

    @field_validator("reopen_reason")
    @classmethod
    def validate_reopen_reason(cls, v: str) -> str:
        """Validate reopen reason quality."""
        v = v.strip()
        if not v:
            raise ValueError("Reopen reason cannot be empty")
        
        word_count = len(v.split())
        if word_count < 5:
            raise ValueError(
                "Reopen reason must contain at least 5 words "
                "for proper documentation"
            )
        
        return v

    @field_validator("additional_issues")
    @classmethod
    def validate_additional_issues(cls, v: Optional[str]) -> Optional[str]:
        """Normalize additional issues if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("new_attachments")
    @classmethod
    def validate_attachments_limit(cls, v: List[HttpUrl]) -> List[HttpUrl]:
        """Ensure attachment count doesn't exceed limit."""
        if len(v) > 10:
            raise ValueError(
                "Maximum 10 new attachments allowed"
            )
        return v


class CloseRequest(BaseCreateSchema):
    """
    Request to close complaint (final state).
    
    Optional closure notes and student confirmation.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to close",
    )

    closure_notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Final closure notes",
    )

    student_confirmed: bool = Field(
        default=False,
        description="Student confirmed resolution satisfaction",
    )

    @field_validator("closure_notes")
    @classmethod
    def validate_closure_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize closure notes if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_response.py ---
"""
Complaint response schemas for API outputs.

Provides comprehensive response models for different complaint views:
- Summary responses for list views
- Detailed responses for single complaint views
- Dashboard summary statistics
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Annotated, Dict, List, Optional

from pydantic import ConfigDict, Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import ComplaintCategory, ComplaintStatus, Priority

__all__ = [
    "ComplaintResponse",
    "ComplaintDetail",
    "ComplaintListItem",
    "ComplaintSummary",
    "ComplaintStats",
]


class ComplaintResponse(BaseResponseSchema):
    """
    Standard complaint response with essential fields.
    
    Used for list views and general complaint information.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_number: str = Field(
        ...,
        description="Unique complaint reference number",
    )
    hostel_id: str = Field(
        ...,
        description="Associated hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Associated hostel name for display",
    )

    # Complainant information
    raised_by: str = Field(
        ...,
        description="User ID who raised the complaint",
    )
    raised_by_name: str = Field(
        ...,
        description="Display name of complainant",
    )
    student_id: Optional[str] = Field(
        default=None,
        description="Student ID if applicable",
    )

    # Core complaint fields
    title: str = Field(
        ...,
        description="Complaint title",
    )
    category: ComplaintCategory = Field(
        ...,
        description="Complaint category",
    )
    priority: Priority = Field(
        ...,
        description="Priority level",
    )
    status: ComplaintStatus = Field(
        ...,
        description="Current status",
    )

    # Assignment
    assigned_to: Optional[str] = Field(
        default=None,
        description="Assigned staff member ID",
    )
    assigned_to_name: Optional[str] = Field(
        default=None,
        description="Assigned staff member name",
    )

    # Timestamps
    opened_at: datetime = Field(
        ...,
        description="Complaint creation timestamp",
    )
    resolved_at: Optional[datetime] = Field(
        default=None,
        description="Resolution timestamp",
    )

    # Metrics
    sla_breach: bool = Field(
        ...,
        description="Whether complaint has breached SLA",
    )
    age_hours: int = Field(
        ...,
        ge=0,
        description="Age of complaint in hours",
    )

    @computed_field  # type: ignore[misc]
    @property
    def is_overdue(self) -> bool:
        """Determine if complaint is overdue based on priority and age."""
        # Define SLA thresholds in hours by priority
        sla_thresholds = {
            Priority.CRITICAL: 2,
            Priority.URGENT: 4,
            Priority.HIGH: 12,
            Priority.MEDIUM: 24,
            Priority.LOW: 48,
        }
        
        threshold = sla_thresholds.get(self.priority, 24)
        return self.age_hours > threshold and self.status not in [
            ComplaintStatus.RESOLVED,
            ComplaintStatus.CLOSED,
        ]


class ComplaintDetail(BaseResponseSchema):
    """
    Comprehensive complaint details with full information.
    
    Used for single complaint view with complete audit trail
    and relationship information.
    """
    model_config = ConfigDict(from_attributes=True)

    complaint_number: str = Field(
        ...,
        description="Unique complaint reference number",
    )

    # Hostel information
    hostel_id: str = Field(..., description="Hostel identifier")
    hostel_name: str = Field(..., description="Hostel name")

    # Complainant information (detailed)
    raised_by: str = Field(..., description="User ID of complainant")
    raised_by_name: str = Field(..., description="Complainant name")
    raised_by_email: str = Field(..., description="Complainant email")
    raised_by_phone: str = Field(..., description="Complainant phone")

    student_id: Optional[str] = Field(default=None, description="Student ID")
    student_name: Optional[str] = Field(default=None, description="Student name")
    room_number: Optional[str] = Field(default=None, description="Room number")

    # Complaint content
    title: str = Field(..., description="Complaint title")
    description: str = Field(..., description="Detailed description")
    category: ComplaintCategory = Field(..., description="Category")
    sub_category: Optional[str] = Field(default=None, description="Sub-category")
    priority: Priority = Field(..., description="Priority level")

    # Location
    room_id: Optional[str] = Field(default=None, description="Room ID")
    location_details: Optional[str] = Field(default=None, description="Location details")

    # Media
    attachments: List[str] = Field(
        default_factory=list,
        description="Attachment URLs",
    )

    # Assignment history
    assigned_to: Optional[str] = Field(default=None, description="Current assignee ID")
    assigned_to_name: Optional[str] = Field(default=None, description="Current assignee name")
    assigned_by: Optional[str] = Field(default=None, description="Assigned by user ID")
    assigned_by_name: Optional[str] = Field(default=None, description="Assigned by name")
    assigned_at: Optional[datetime] = Field(default=None, description="Assignment timestamp")
    reassigned_count: int = Field(
        default=0,
        ge=0,
        description="Number of times complaint was reassigned",
    )

    # Status workflow
    status: ComplaintStatus = Field(..., description="Current status")
    opened_at: datetime = Field(..., description="Creation timestamp")
    in_progress_at: Optional[datetime] = Field(
        default=None,
        description="When complaint moved to in-progress",
    )
    resolved_at: Optional[datetime] = Field(
        default=None,
        description="Resolution timestamp",
    )
    closed_at: Optional[datetime] = Field(default=None, description="Closure timestamp")
    closed_by: Optional[str] = Field(default=None, description="User who closed complaint")
    closed_by_name: Optional[str] = Field(default=None, description="Closer name")

    # Resolution details
    resolution_notes: Optional[str] = Field(
        default=None,
        description="Resolution description",
    )
    resolution_attachments: List[str] = Field(
        default_factory=list,
        description="Resolution proof URLs",
    )
    estimated_resolution_time: Optional[datetime] = Field(
        default=None,
        description="Estimated resolution time",
    )
    actual_resolution_time: Optional[datetime] = Field(
        default=None,
        description="Actual resolution time",
    )

    # Feedback
    student_feedback: Optional[str] = Field(default=None, description="Student feedback")
    student_rating: Optional[int] = Field(
        default=None,
        ge=1,
        le=5,
        description="Student rating (1-5)",
    )
    feedback_submitted_at: Optional[datetime] = Field(
        default=None,
        description="Feedback submission timestamp",
    )

    # SLA tracking
    sla_breach: bool = Field(..., description="SLA breach status")
    sla_breach_reason: Optional[str] = Field(
        default=None,
        description="Reason for SLA breach",
    )

    # Escalation
    escalated: bool = Field(default=False, description="Escalation status")
    escalated_to: Optional[str] = Field(default=None, description="Escalated to user ID")
    escalated_to_name: Optional[str] = Field(default=None, description="Escalated to name")
    escalated_at: Optional[datetime] = Field(default=None, description="Escalation timestamp")
    escalation_reason: Optional[str] = Field(default=None, description="Escalation reason")

    # Admin override
    overridden_by_admin: bool = Field(
        default=False,
        description="Admin override flag",
    )
    override_admin_id: Optional[str] = Field(default=None, description="Override admin ID")
    override_timestamp: Optional[datetime] = Field(
        default=None,
        description="Override timestamp",
    )
    override_reason: Optional[str] = Field(default=None, description="Override reason")

    # Engagement metrics
    total_comments: int = Field(
        default=0,
        ge=0,
        description="Total comment count",
    )

    # Time metrics
    age_hours: int = Field(..., ge=0, description="Complaint age in hours")
    time_to_resolve_hours: Optional[int] = Field(
        default=None,
        ge=0,
        description="Time taken to resolve (hours)",
    )

    @computed_field  # type: ignore[misc]
    @property
    def is_active(self) -> bool:
        """Check if complaint is in an active state."""
        active_statuses = {
            ComplaintStatus.OPEN,
            ComplaintStatus.ASSIGNED,
            ComplaintStatus.IN_PROGRESS,
            ComplaintStatus.REOPENED,
        }
        return self.status in active_statuses

    @computed_field  # type: ignore[misc]
    @property
    def resolution_efficiency(self) -> Optional[str]:
        """
        Calculate resolution efficiency rating.
        
        Returns:
            Efficiency rating: 'excellent', 'good', 'average', 'poor', or None
        """
        if not self.time_to_resolve_hours:
            return None
        
        # Define efficiency thresholds based on priority
        thresholds = {
            Priority.CRITICAL: {"excellent": 1, "good": 2, "average": 4},
            Priority.URGENT: {"excellent": 2, "good": 4, "average": 8},
            Priority.HIGH: {"excellent": 6, "good": 12, "average": 24},
            Priority.MEDIUM: {"excellent": 12, "good": 24, "average": 48},
            Priority.LOW: {"excellent": 24, "good": 48, "average": 72},
        }
        
        threshold = thresholds.get(self.priority, thresholds[Priority.MEDIUM])
        hours = self.time_to_resolve_hours
        
        if hours <= threshold["excellent"]:
            return "excellent"
        elif hours <= threshold["good"]:
            return "good"
        elif hours <= threshold["average"]:
            return "average"
        else:
            return "poor"


class ComplaintListItem(BaseSchema):
    """
    Lightweight complaint item for list views.
    
    Optimized for performance with minimal fields
    for table/grid displays.
    """
    model_config = ConfigDict(from_attributes=True)

    id: str = Field(..., description="Complaint ID")
    complaint_number: str = Field(..., description="Reference number")
    title: str = Field(..., description="Complaint title")

    category: str = Field(..., description="Category name")
    priority: str = Field(..., description="Priority level")
    status: ComplaintStatus = Field(..., description="Current status")

    raised_by_name: str = Field(..., description="Complainant name")
    room_number: Optional[str] = Field(default=None, description="Room number")

    assigned_to_name: Optional[str] = Field(default=None, description="Assignee name")

    opened_at: datetime = Field(..., description="Creation timestamp")
    age_hours: int = Field(..., ge=0, description="Age in hours")

    sla_breach: bool = Field(..., description="SLA breach status")

    @computed_field  # type: ignore[misc]
    @property
    def status_color(self) -> str:
        """
        Get status color code for UI display.
        
        Returns:
            Color code string for status badge
        """
        color_map = {
            ComplaintStatus.OPEN: "red",
            ComplaintStatus.ASSIGNED: "orange",
            ComplaintStatus.IN_PROGRESS: "blue",
            ComplaintStatus.ON_HOLD: "yellow",
            ComplaintStatus.RESOLVED: "green",
            ComplaintStatus.CLOSED: "gray",
            ComplaintStatus.REOPENED: "purple",
        }
        return color_map.get(self.status, "gray")

    @computed_field  # type: ignore[misc]
    @property
    def priority_weight(self) -> int:
        """
        Get numeric priority weight for sorting.
        
        Returns:
            Integer weight (higher = more urgent)
        """
        weight_map = {
            "critical": 5,
            "urgent": 4,
            "high": 3,
            "medium": 2,
            "low": 1,
        }
        return weight_map.get(self.priority.lower(), 2)


class ComplaintSummary(BaseSchema):
    """
    Complaint statistics summary for dashboard.
    
    Provides aggregate metrics for a hostel or supervisor.
    """
    model_config = ConfigDict(from_attributes=True)

    hostel_id: str = Field(..., description="Hostel identifier")

    total_complaints: int = Field(..., ge=0, description="Total complaint count")
    open_complaints: int = Field(..., ge=0, description="Open complaints")
    in_progress_complaints: int = Field(..., ge=0, description="In-progress complaints")
    resolved_complaints: int = Field(..., ge=0, description="Resolved complaints")

    high_priority_count: int = Field(..., ge=0, description="High priority count")
    urgent_priority_count: int = Field(..., ge=0, description="Urgent priority count")

    sla_breached_count: int = Field(..., ge=0, description="SLA breached count")

    average_resolution_time_hours: Annotated[
        Decimal,
        Field(ge=Decimal("0"), description="Average resolution time in hours")
    ]

    @computed_field  # type: ignore[misc]
    @property
    def resolution_rate(self) -> float:
        """
        Calculate complaint resolution rate percentage.
        
        Returns:
            Resolution rate as percentage (0-100)
        """
        if self.total_complaints == 0:
            return 0.0
        return round(
            (self.resolved_complaints / self.total_complaints) * 100,
            2
        )

    @computed_field  # type: ignore[misc]
    @property
    def sla_compliance_rate(self) -> float:
        """
        Calculate SLA compliance rate percentage.
        
        Returns:
            SLA compliance rate as percentage (0-100)
        """
        if self.total_complaints == 0:
            return 100.0
        
        compliant = self.total_complaints - self.sla_breached_count
        return round((compliant / self.total_complaints) * 100, 2)


class ComplaintStats(BaseSchema):
    """
    Extended complaint statistics with breakdown details.
    
    Provides comprehensive analytics for reporting.
    """
    model_config = ConfigDict(from_attributes=True)

    total: int = Field(..., ge=0, description="Total complaints")
    
    # Status breakdown
    by_status: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaint count by status",
    )
    
    # Priority breakdown
    by_priority: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaint count by priority",
    )
    
    # Category breakdown
    by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaint count by category",
    )
    
    # Time-based metrics
    avg_resolution_hours: Optional[Annotated[
        Decimal,
        Field(ge=Decimal("0"), description="Average resolution time")
    ]] = None
    median_resolution_hours: Optional[Annotated[
        Decimal,
        Field(ge=Decimal("0"), description="Median resolution time")
    ]] = None
    
    # Performance indicators
    sla_compliance_percentage: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="SLA compliance percentage"
        )
    ]
    resolution_percentage: Annotated[
        Decimal,
        Field(
            ge=Decimal("0"),
            le=Decimal("100"),
            description="Resolution percentage"
        )
    ]

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\__init__.py ---
"""
Complaint schemas package.

Comprehensive complaint management schemas including creation, updates,
assignments, resolution, escalation, feedback, and analytics.

Example:
    from app.schemas.complaint import ComplaintCreate, ComplaintDetail
"""

from __future__ import annotations

from app.schemas.complaint.complaint_analytics import (
    CategoryAnalysis,
    CategoryMetrics,
    ComplaintAnalytics,
    ComplaintHeatmap,
    ComplaintTrendPoint,
    ResolutionMetrics,
    RoomComplaintCount,
    StaffPerformance,
)
from app.schemas.complaint.complaint_assignment import (
    AssignmentHistory,
    AssignmentRequest,
    AssignmentResponse,
    BulkAssignment,
    ReassignmentRequest,
    UnassignRequest,
)
from app.schemas.complaint.complaint_base import (
    ComplaintBase,
    ComplaintCreate,
    ComplaintStatusUpdate,
    ComplaintUpdate,
)
from app.schemas.complaint.complaint_comments import (
    CommentCreate,
    CommentDelete,
    CommentList,
    CommentResponse,
    CommentUpdate,
    MentionNotification,
)
from app.schemas.complaint.complaint_escalation import (
    AutoEscalationRule,
    EscalationEntry,
    EscalationHistory,
    EscalationRequest,
    EscalationResponse,
)
from app.schemas.complaint.complaint_feedback import (
    FeedbackAnalysis,
    FeedbackRequest,
    FeedbackResponse,
    FeedbackSummary,
    RatingTrendPoint,
)
from app.schemas.complaint.complaint_filters import (
    ComplaintExportRequest,
    ComplaintFilterParams,
    ComplaintSearchRequest,
    ComplaintSortOptions,
)
from app.schemas.complaint.complaint_resolution import (
    CloseRequest,
    ReopenRequest,
    ResolutionRequest,
    ResolutionResponse,
    ResolutionUpdate,
)
from app.schemas.complaint.complaint_response import (
    ComplaintDetail,
    ComplaintListItem,
    ComplaintResponse,
    ComplaintStats,
    ComplaintSummary,
)

__all__ = [
    # Base schemas
    "ComplaintBase",
    "ComplaintCreate",
    "ComplaintUpdate",
    "ComplaintStatusUpdate",
    # Response schemas
    "ComplaintResponse",
    "ComplaintDetail",
    "ComplaintListItem",
    "ComplaintSummary",
    "ComplaintStats",
    # Assignment schemas
    "AssignmentRequest",
    "AssignmentResponse",
    "ReassignmentRequest",
    "BulkAssignment",
    "UnassignRequest",
    "AssignmentHistory",
    # Resolution schemas
    "ResolutionRequest",
    "ResolutionResponse",
    "ResolutionUpdate",
    "ReopenRequest",
    "CloseRequest",
    # Escalation schemas
    "EscalationRequest",
    "EscalationResponse",
    "EscalationHistory",
    "EscalationEntry",
    "AutoEscalationRule",
    # Feedback schemas
    "FeedbackRequest",
    "FeedbackResponse",
    "FeedbackSummary",
    "FeedbackAnalysis",
    "RatingTrendPoint",
    # Comment schemas
    "CommentCreate",
    "CommentResponse",
    "CommentList",
    "CommentUpdate",
    "CommentDelete",
    "MentionNotification",
    # Filter schemas
    "ComplaintFilterParams",
    "ComplaintSearchRequest",
    "ComplaintSortOptions",
    "ComplaintExportRequest",
    # Analytics schemas
    "ComplaintAnalytics",
    "ResolutionMetrics",
    "CategoryAnalysis",
    "CategoryMetrics",
    "ComplaintTrendPoint",
    "StaffPerformance",
    "ComplaintHeatmap",
    "RoomComplaintCount",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\__pycache__ =====
