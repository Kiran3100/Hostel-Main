### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\admin ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\admin =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\admin_hostel_assignment.py ---
"""
Enhanced admin-hostel assignment schemas with comprehensive validation and performance optimizations.

Provides robust assignment management with audit trails, bulk operations,
and detailed permission tracking for multi-hostel administration.

Fully migrated to Pydantic v2 with proper Decimal field handling.
"""

from __future__ import annotations

from datetime import datetime
from datetime import date as Date
from decimal import Decimal
from typing import Annotated, Any, Dict, List, Optional, Union
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator, ConfigDict

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import PermissionLevel

__all__ = [
    "AdminHostelAssignment",
    "AssignmentCreate",
    "AssignmentUpdate",
    "BulkAssignment",
    "RevokeAssignment",
    "AssignmentList",
    "HostelAdminList",
    "HostelAdminItem",
]


class AdminHostelAssignment(BaseResponseSchema):
    """
    Enhanced admin-hostel assignment with comprehensive tracking and analytics.
    
    Provides complete assignment information including permissions, activity tracking,
    and performance metrics for effective multi-hostel management.
    """
    
    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "assignment_id": "123e4567-e89b-12d3-a456-426614174000",
                "admin_id": "123e4567-e89b-12d3-a456-426614174001",
                "admin_name": "John Doe",
                "admin_email": "john@example.com",
                "hostel_id": "123e4567-e89b-12d3-a456-426614174002",
                "hostel_name": "Campus Hostel A",
                "hostel_city": "Mumbai",
                "hostel_type": "boys",
                "assigned_date": "2024-01-01",
                "permission_level": "FULL_ACCESS",
                "is_active": True,
                "is_primary": True,
            }
        }
    )
    
    # Core assignment identifiers
    assignment_id: UUID = Field(..., description="Unique assignment identifier")
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")
    
    # Hostel information
    hostel_id: UUID = Field(..., description="Assigned hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type (boys/girls/co-ed)")
    
    # Assignment metadata
    assigned_by: Optional[UUID] = Field(None, description="Admin who created this assignment")
    assigned_by_name: Optional[str] = Field(None, description="Name of assigning admin")
    assigned_date: Date = Field(..., description="Date assignment was created")
    
    # Permission configuration
    permission_level: PermissionLevel = Field(..., description="Overall permission level")
    permissions: Dict[str, Union[bool, int, str]] = Field(
        default_factory=dict,
        description="Granular permissions for this hostel assignment"
    )
    
    # Assignment status
    is_active: bool = Field(True, description="Assignment is currently active")
    is_primary: bool = Field(False, description="Primary hostel for this admin")
    
    # Revocation tracking
    revoked_date: Optional[Date] = Field(None, description="Date assignment was revoked")
    revoked_by: Optional[UUID] = Field(None, description="Admin who revoked assignment")
    revoke_reason: Optional[str] = Field(None, description="Reason for revocation")
    
    # Activity and performance tracking
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    total_session_time_minutes: int = Field(0, ge=0, description="Total time spent in hostel")
    
    # Performance metrics
    decisions_made: int = Field(0, ge=0, description="Total decisions made for this hostel")
    
    # Pydantic v2: Decimal fields with constraints using ge/le instead of max_digits/decimal_places
    avg_response_time_minutes: Optional[Decimal] = Field(
        None, ge=Decimal("0"), description="Average response time for this hostel"
    )
    satisfaction_score: Optional[Decimal] = Field(
        None, ge=Decimal("0"), le=Decimal("5"), description="Admin satisfaction score for this hostel"
    )

    @computed_field
    @property
    def assignment_duration_days(self) -> int:
        """Calculate total assignment duration in days."""
        end_date = self.revoked_date or Date.today()
        return max(0, (end_date - self.assigned_date).days)

    @computed_field
    @property
    def is_recently_accessed(self) -> bool:
        """Check if hostel was accessed within last 24 hours."""
        if not self.last_accessed:
            return False
        hours_since_access = (datetime.utcnow() - self.last_accessed).total_seconds() / 3600
        return hours_since_access <= 24

    @computed_field
    @property
    def permission_summary(self) -> str:
        """Generate human-readable permission summary."""
        level_descriptions = {
            PermissionLevel.FULL_ACCESS: "Full Administrative Access",
            PermissionLevel.LIMITED_ACCESS: "Limited Access with Restrictions",
            PermissionLevel.VIEW_ONLY: "Read-Only Access"
        }
        return level_descriptions.get(self.permission_level, "Unknown Access Level")

    @computed_field
    @property
    def activity_level(self) -> str:
        """Categorize admin activity level for this hostel."""
        if self.access_count == 0:
            return "No Activity"
        elif self.access_count < 10:
            return "Low Activity"
        elif self.access_count < 50:
            return "Moderate Activity"
        elif self.access_count < 100:
            return "High Activity"
        else:
            return "Very High Activity"

    @computed_field
    @property
    def avg_session_duration_minutes(self) -> Decimal:
        """Calculate average session duration."""
        if self.access_count == 0:
            return Decimal("0.00")
        return Decimal(self.total_session_time_minutes / self.access_count).quantize(Decimal("0.01"))


class AssignmentCreate(BaseCreateSchema):
    """
    Enhanced assignment creation with comprehensive validation.
    
    Supports flexible permission configuration and proper validation
    for different access levels and assignment scenarios.
    """
    
    model_config = ConfigDict(validate_assignment=True)
    
    admin_id: UUID = Field(..., description="Admin user ID to assign")
    hostel_id: UUID = Field(..., description="Hostel ID for assignment")
    
    permission_level: PermissionLevel = Field(
        PermissionLevel.FULL_ACCESS,
        description="Permission level for this assignment"
    )
    
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None,
        description="Specific permissions (required for LIMITED_ACCESS level)"
    )
    
    is_primary: bool = Field(False, description="Set as primary hostel for admin")
    
    # Assignment metadata
    assignment_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Administrative notes about this assignment"
    )
    effective_date: Optional[Date] = Field(
        None,
        description="Effective Date for assignment (defaults to today)"
    )
    
    # Notification preferences
    notify_admin: bool = Field(True, description="Send notification to admin about assignment")
    send_welcome_email: bool = Field(True, description="Send welcome email with hostel details")

    @model_validator(mode="after")
    def validate_assignment_requirements(self) -> "AssignmentCreate":
        """Validate assignment-specific business rules."""
        # Require permissions for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS:
            if not self.permissions:
                raise ValueError(
                    "Specific permissions are required when permission_level is LIMITED_ACCESS"
                )
            if not isinstance(self.permissions, dict) or len(self.permissions) == 0:
                raise ValueError("Permissions must be a non-empty dictionary for LIMITED_ACCESS")
        
        # Validate effective Date
        if self.effective_date:
            if self.effective_date < Date.today():
                # Allow past dates for historical assignments but validate reasonableness
                days_past = (Date.today() - self.effective_date).days
                if days_past > 365:  # More than 1 year in past
                    raise ValueError("Effective Date cannot be more than 1 year in the past")
            elif self.effective_date > Date.today():
                # Allow future dates for scheduled assignments
                days_future = (self.effective_date - Date.today()).days
                if days_future > 90:  # More than 3 months in future
                    raise ValueError("Effective Date cannot be more than 90 days in the future")
        
        return self

    @field_validator("permissions")
    @classmethod
    def validate_permissions_structure(
        cls, v: Optional[Dict[str, Union[bool, int, str]]]
    ) -> Optional[Dict[str, Union[bool, int, str]]]:
        """Validate permissions dictionary structure and values."""
        if v is None:
            return None
        
        # Define valid permission keys
        valid_permission_keys = {
            "can_manage_rooms", "can_manage_students", "can_approve_bookings",
            "can_manage_fees", "can_view_financials", "can_manage_supervisors",
            "can_override_decisions", "can_export_data", "can_delete_records",
            "can_manage_hostel_settings", "can_view_analytics", "can_manage_announcements"
        }
        
        # Validate each permission
        for key, value in v.items():
            if key not in valid_permission_keys:
                raise ValueError(f"Invalid permission key: {key}")
            
            # Validate value types
            if not isinstance(value, (bool, int, str)):
                raise ValueError(f"Invalid permission value type for {key}: {type(value)}")
            
            # Validate specific permission constraints
            if key.endswith("_threshold") and isinstance(value, (int, float)):
                if value < 0:
                    raise ValueError(f"Threshold values must be non-negative: {key}")
        
        return v

    @field_validator("assignment_notes")
    @classmethod
    def validate_assignment_notes(cls, v: Optional[str]) -> Optional[str]:
        """Validate and clean assignment notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v


class AssignmentUpdate(BaseUpdateSchema):
    """
    Enhanced assignment update with selective field modifications.
    
    Allows partial updates while maintaining data consistency
    and proper validation for permission changes.
    """
    
    model_config = ConfigDict(validate_assignment=True)
    
    permission_level: Optional[PermissionLevel] = Field(
        None, description="Updated permission level"
    )
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None, description="Updated specific permissions"
    )
    is_primary: Optional[bool] = Field(None, description="Update primary hostel status")
    is_active: Optional[bool] = Field(None, description="Update assignment active status")
    
    assignment_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Updated assignment notes"
    )
    
    # Update metadata
    update_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for this update"
    )

    @model_validator(mode="after")
    def validate_update_consistency(self) -> "AssignmentUpdate":
        """Validate update field consistency and business rules."""
        # Ensure permissions are provided for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS:
            if self.permissions is None:
                raise ValueError(
                    "Permissions must be specified when updating to LIMITED_ACCESS level"
                )
        
        # Validate that at least one field is being updated
        update_fields = [
            self.permission_level, self.permissions, self.is_primary,
            self.is_active, self.assignment_notes
        ]
        if all(field is None for field in update_fields):
            raise ValueError("At least one field must be specified for update")
        
        return self

    @field_validator("permissions")
    @classmethod
    def validate_permissions_structure(
        cls, v: Optional[Dict[str, Union[bool, int, str]]]
    ) -> Optional[Dict[str, Union[bool, int, str]]]:
        """Validate permissions dictionary structure and values."""
        if v is None:
            return None
        
        # Define valid permission keys
        valid_permission_keys = {
            "can_manage_rooms", "can_manage_students", "can_approve_bookings",
            "can_manage_fees", "can_view_financials", "can_manage_supervisors",
            "can_override_decisions", "can_export_data", "can_delete_records",
            "can_manage_hostel_settings", "can_view_analytics", "can_manage_announcements"
        }
        
        # Validate each permission
        for key, value in v.items():
            if key not in valid_permission_keys:
                raise ValueError(f"Invalid permission key: {key}")
            
            # Validate value types
            if not isinstance(value, (bool, int, str)):
                raise ValueError(f"Invalid permission value type for {key}: {type(value)}")
            
            # Validate specific permission constraints
            if key.endswith("_threshold") and isinstance(value, (int, float)):
                if value < 0:
                    raise ValueError(f"Threshold values must be non-negative: {key}")
        
        return v


class BulkAssignment(BaseCreateSchema):
    """
    Enhanced bulk assignment with comprehensive validation and options.
    
    Supports efficient batch operations while maintaining data integrity
    and providing flexible assignment strategies.
    """
    
    model_config = ConfigDict(validate_assignment=True)
    
    admin_id: UUID = Field(..., description="Admin user ID for all assignments")
    hostel_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of hostel IDs for bulk assignment (max 50)"
    )
    
    permission_level: PermissionLevel = Field(
        PermissionLevel.FULL_ACCESS,
        description="Permission level for all assignments"
    )
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None,
        description="Permissions applied to all assignments"
    )
    
    primary_hostel_id: Optional[UUID] = Field(
        None,
        description="Which hostel should be set as primary (must be in hostel_ids)"
    )
    
    # Bulk operation strategies
    skip_existing: bool = Field(
        True,
        description="Skip hostels where admin already has active assignment"
    )
    update_existing: bool = Field(
        False,
        description="Update existing assignments with new permissions"
    )
    force_primary: bool = Field(
        False,
        description="Force primary hostel change even if admin has existing primary"
    )
    
    # Metadata and notifications
    bulk_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Notes applied to all assignments in this bulk operation"
    )
    notify_admin: bool = Field(True, description="Send notification about bulk assignment")
    send_summary_email: bool = Field(True, description="Send summary email after completion")

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_hostel_ids(cls, v: List[UUID]) -> List[UUID]:
        """Ensure hostel IDs are unique and validate list size."""
        if len(v) != len(set(v)):
            raise ValueError("Hostel IDs must be unique in bulk assignment")
        
        if len(v) > 50:
            raise ValueError("Cannot assign more than 50 hostels in a single bulk operation")
        
        return v

    @model_validator(mode="after")
    def validate_bulk_assignment_logic(self) -> "BulkAssignment":
        """Validate bulk assignment business logic and constraints."""
        # Validate primary hostel selection
        if self.primary_hostel_id and self.primary_hostel_id not in self.hostel_ids:
            raise ValueError("Primary hostel ID must be included in the hostel_ids list")
        
        # Validate operation strategy
        if self.skip_existing and self.update_existing:
            raise ValueError(
                "Cannot both skip_existing and update_existing. Choose one strategy."
            )
        
        # Validate permissions for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS and not self.permissions:
            raise ValueError(
                "Permissions must be specified for LIMITED_ACCESS level in bulk assignment"
            )
        
        return self

    @field_validator("permissions")
    @classmethod
    def validate_permissions_structure(
        cls, v: Optional[Dict[str, Union[bool, int, str]]]
    ) -> Optional[Dict[str, Union[bool, int, str]]]:
        """Validate permissions dictionary structure and values."""
        if v is None:
            return None
        
        # Define valid permission keys
        valid_permission_keys = {
            "can_manage_rooms", "can_manage_students", "can_approve_bookings",
            "can_manage_fees", "can_view_financials", "can_manage_supervisors",
            "can_override_decisions", "can_export_data", "can_delete_records",
            "can_manage_hostel_settings", "can_view_analytics", "can_manage_announcements"
        }
        
        # Validate each permission
        for key, value in v.items():
            if key not in valid_permission_keys:
                raise ValueError(f"Invalid permission key: {key}")
            
            # Validate value types
            if not isinstance(value, (bool, int, str)):
                raise ValueError(f"Invalid permission value type for {key}: {type(value)}")
            
            # Validate specific permission constraints
            if key.endswith("_threshold") and isinstance(value, (int, float)):
                if value < 0:
                    raise ValueError(f"Threshold values must be non-negative: {key}")
        
        return v


class RevokeAssignment(BaseCreateSchema):
    """
    Enhanced assignment revocation with comprehensive audit trail.
    
    Provides detailed revocation tracking with proper validation
    and support for different revocation scenarios.
    """
    
    model_config = ConfigDict(validate_assignment=True)
    
    assignment_id: UUID = Field(..., description="Assignment ID to revoke")
    revoke_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for assignment revocation"
    )
    
    # Revocation timing and options
    effective_date: Optional[Date] = Field(
        None,
        description="Effective revocation Date (defaults to today)"
    )
    immediate_revocation: bool = Field(
        True,
        description="Revoke immediately or schedule for effective_date"
    )
    
    # Transition management
    transfer_to_admin_id: Optional[UUID] = Field(
        None,
        description="Transfer responsibilities to another admin"
    )
    handover_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Handover notes for responsibility transfer"
    )
    
    # Notification preferences
    notify_affected_admin: bool = Field(True, description="Notify admin being revoked")
    notify_hostel_supervisors: bool = Field(True, description="Notify hostel supervisors")
    
    # Data retention
    retain_access_logs: bool = Field(True, description="Retain access logs for audit")
    archive_permissions: bool = Field(True, description="Archive permission history")

    @field_validator("revoke_reason")
    @classmethod
    def validate_revoke_reason(cls, v: str) -> str:
        """Validate and normalize revocation reason."""
        reason = v.strip()
        if len(reason) < 10:
            raise ValueError("Revocation reason must be at least 10 characters")
        
        # Remove excessive whitespace
        reason = " ".join(reason.split())
        return reason

    @field_validator("effective_date")
    @classmethod
    def validate_effective_date(cls, v: Optional[Date]) -> Optional[Date]:
        """Validate revocation effective Date."""
        if v is not None:
            today = Date.today()
            
            # Allow past dates for historical revocations
            if v < today:
                days_past = (today - v).days
                if days_past > 30:  # More than 30 days in past
                    raise ValueError("Effective Date cannot be more than 30 days in the past")
            
            # Allow future dates for scheduled revocations
            elif v > today:
                days_future = (v - today).days
                if days_future > 90:  # More than 90 days in future
                    raise ValueError("Effective Date cannot be more than 90 days in the future")
        
        return v

    @model_validator(mode="after")
    def validate_revocation_logic(self) -> "RevokeAssignment":
        """Validate revocation business logic."""
        # Validate transfer requirements
        if self.transfer_to_admin_id:
            if not self.handover_notes:
                raise ValueError(
                    "Handover notes are required when transferring to another admin"
                )
        
        # Validate immediate vs scheduled revocation
        if not self.immediate_revocation and not self.effective_date:
            raise ValueError(
                "Effective Date must be specified for non-immediate revocation"
            )
        
        if self.immediate_revocation and self.effective_date and self.effective_date != Date.today():
            raise ValueError(
                "Immediate revocation cannot have future effective Date"
            )
        
        return self


class AssignmentList(BaseSchema):
    """
    Enhanced assignment list with comprehensive admin overview.
    
    Provides aggregated view of all assignments for an admin
    with summary statistics and quick access information.
    """
    
    model_config = ConfigDict()
    
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")
    
    # Assignment statistics
    total_hostels: int = Field(..., ge=0, description="Total hostels assigned")
    active_hostels: int = Field(..., ge=0, description="Currently active assignments")
    inactive_hostels: int = Field(..., ge=0, description="Inactive assignments")
    
    # Primary hostel information
    primary_hostel_id: Optional[UUID] = Field(None, description="Primary hostel ID")
    primary_hostel_name: Optional[str] = Field(None, description="Primary hostel name")
    
    # Activity summary
    last_activity: Optional[datetime] = Field(None, description="Last activity across all hostels")
    total_access_count: int = Field(0, ge=0, description="Total access count across hostels")
    
    # Assignment details
    assignments: List[AdminHostelAssignment] = Field(
        default_factory=list,
        description="Detailed assignment information"
    )
    
    # Performance metrics - Pydantic v2: use ge constraint instead of max_digits/decimal_places
    avg_response_time_minutes: Optional[Decimal] = Field(
        None, ge=Decimal("0"), description="Average response time across all hostels"
    )
    total_decisions_made: int = Field(0, ge=0, description="Total decisions across hostels")

    @computed_field
    @property
    def assignment_utilization_rate(self) -> Decimal:
        """Calculate assignment utilization rate."""
        if self.total_hostels == 0:
            return Decimal("0.00")
        return Decimal((self.active_hostels / self.total_hostels * 100)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def most_active_hostel(self) -> Optional[str]:
        """Identify most active hostel by access count."""
        if not self.assignments:
            return None
        
        most_active = max(self.assignments, key=lambda x: x.access_count)
        return most_active.hostel_name if most_active.access_count > 0 else None

    @computed_field
    @property
    def permission_distribution(self) -> Dict[str, int]:
        """Calculate distribution of permission levels."""
        distribution = {level.value: 0 for level in PermissionLevel}
        
        for assignment in self.assignments:
            if assignment.is_active:
                distribution[assignment.permission_level.value] += 1
        
        return distribution


class HostelAdminList(BaseSchema):
    """
    Enhanced hostel admin list with comprehensive hostel overview.
    
    Provides detailed view of all admins assigned to a specific hostel
    with their permissions and activity levels.
    """
    
    model_config = ConfigDict()
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Admin statistics
    total_admins: int = Field(..., ge=0, description="Total assigned admins")
    active_admins: int = Field(..., ge=0, description="Currently active admin assignments")
    
    # Primary admin information
    primary_admin_id: Optional[UUID] = Field(None, description="Primary admin ID")
    primary_admin_name: Optional[str] = Field(None, description="Primary admin name")
    
    # Coverage information
    coverage_24x7: bool = Field(False, description="24x7 admin coverage available")
    last_admin_activity: Optional[datetime] = Field(None, description="Last admin activity")
    
    # Admin details
    admins: List["HostelAdminItem"] = Field(
        default_factory=list,
        description="Detailed admin assignment information"
    )

    @computed_field
    @property
    def admin_coverage_score(self) -> Decimal:
        """Calculate admin coverage adequacy score."""
        if self.total_admins == 0:
            return Decimal("0.00")
        
        # Base score from admin count (max 50 points)
        count_score = min(self.total_admins * 25, 50)
        
        # Activity score (max 30 points)
        activity_score = 30 if self.active_admins > 0 else 0
        
        # Coverage score (max 20 points)
        coverage_score = 20 if self.coverage_24x7 else 10
        
        total_score = count_score + activity_score + coverage_score
        return Decimal(str(total_score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def permission_coverage(self) -> Dict[str, bool]:
        """Check if all critical permissions are covered by at least one admin."""
        critical_permissions = [
            "can_manage_students", "can_approve_bookings", "can_manage_fees",
            "can_override_decisions", "can_manage_supervisors"
        ]
        
        coverage = {}
        for permission in critical_permissions:
            coverage[permission] = any(
                admin.permission_level == PermissionLevel.FULL_ACCESS or
                admin.has_specific_permission(permission)
                for admin in self.admins
                if admin.is_active
            )
        
        return coverage


class HostelAdminItem(BaseSchema):
    """
    Enhanced admin item with detailed assignment information.
    
    Represents individual admin assignment within hostel admin list
    with comprehensive permission and activity tracking.
    """
    
    model_config = ConfigDict()
    
    # Admin identification
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")
    
    # Assignment details
    assignment_id: UUID = Field(..., description="Assignment ID")
    permission_level: PermissionLevel = Field(..., description="Permission level")
    is_primary: bool = Field(False, description="Primary admin for this hostel")
    is_active: bool = Field(True, description="Assignment is active")
    
    # Assignment metadata
    assigned_date: Date = Field(..., description="Assignment creation Date")
    assigned_by_name: Optional[str] = Field(None, description="Name of assigning admin")
    
    # Activity tracking
    last_active: Optional[datetime] = Field(None, description="Last activity timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    
    # Pydantic v2: Decimal with ge constraint
    avg_session_duration_minutes: Optional[Decimal] = Field(
        None, ge=Decimal("0"), description="Average session duration"
    )
    
    # Performance metrics
    decisions_made: int = Field(0, ge=0, description="Total decisions made")
    response_time_avg_minutes: Optional[Decimal] = Field(
        None, ge=Decimal("0"), description="Average response time"
    )
    
    # Specific permissions (for limited access)
    specific_permissions: Dict[str, Union[bool, int, str]] = Field(
        default_factory=dict,
        description="Specific permissions for limited access admins"
    )

    @computed_field
    @property
    def assignment_duration_days(self) -> int:
        """Calculate assignment duration in days."""
        return (Date.today() - self.assigned_date).days

    @computed_field
    @property
    def activity_status(self) -> str:
        """Determine admin activity status."""
        if not self.last_active:
            return "Never Active"
        
        hours_since_activity = (datetime.utcnow() - self.last_active).total_seconds() / 3600
        
        if hours_since_activity <= 1:
            return "Online"
        elif hours_since_activity <= 24:
            return "Recently Active"
        elif hours_since_activity <= 168:  # 1 week
            return "Active This Week"
        else:
            return "Inactive"

    @computed_field
    @property
    def permission_summary(self) -> str:
        """Generate human-readable permission summary."""
        if self.permission_level == PermissionLevel.FULL_ACCESS:
            return "Full Administrative Access"
        elif self.permission_level == PermissionLevel.LIMITED_ACCESS:
            perm_count = len([p for p in self.specific_permissions.values() if p is True])
            return f"Limited Access ({perm_count} permissions)"
        else:
            return "View Only Access"

    def has_specific_permission(self, permission_key: str) -> bool:
        """Check if admin has a specific permission."""
        if self.permission_level == PermissionLevel.FULL_ACCESS:
            return True
        elif self.permission_level == PermissionLevel.LIMITED_ACCESS:
            return self.specific_permissions.get(permission_key, False) is True
        else:
            return False

    @computed_field
    @property
    def performance_score(self) -> Decimal:
        """Calculate overall performance score for this admin-hostel assignment."""
        score = Decimal("0.00")
        
        # Activity score (40 points max)
        if self.access_count > 0:
            activity_score = min(self.access_count * 2, 40)
            score += Decimal(str(activity_score))
        
        # Decision making score (30 points max)
        if self.decisions_made > 0:
            decision_score = min(self.decisions_made * 3, 30)
            score += Decimal(str(decision_score))
        
        # Response time score (30 points max)
        if self.response_time_avg_minutes:
            # Better response time = higher score
            # Assuming 30 minutes or less is excellent (30 points)
            # More than 120 minutes is poor (0 points)
            response_minutes = float(self.response_time_avg_minutes)
            if response_minutes <= 30:
                response_score = 30
            elif response_minutes >= 120:
                response_score = 0
            else:
                # Linear interpolation
                response_score = 30 * (1 - (response_minutes - 30) / 90)
            score += Decimal(str(response_score))
        
        return score.quantize(Decimal("0.01"))

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\admin_override.py ---
"""
Admin override schemas for supervisor decision management.

Provides structured requests and logs for admin overrides of supervisor actions,
with comprehensive analytics and audit trail support.

Fully migrated to Pydantic v2.
"""

from __future__ import annotations

from datetime import datetime
from datetime import date as Date
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator, ConfigDict

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "AdminOverrideRequest",
    "OverrideLog",
    "OverrideReason",
    "OverrideSummary",
    "SupervisorOverrideStats",
]


# Constants
VALID_OVERRIDE_TYPES = {
    "complaint_reassignment",
    "complaint_closure",
    "maintenance_approval",
    "maintenance_rejection",
    "fee_waiver",
    "booking_override",
    "student_action",
    "policy_exception",
}

VALID_ENTITY_TYPES = {
    "complaint",
    "maintenance_request",
    "booking",
    "fee_transaction",
    "student_record",
    "policy_violation",
}

VALID_TRENDS = {"increasing", "decreasing", "stable"}
VALID_SUPERVISOR_TRENDS = {"improving", "declining", "stable"}

MIN_REASON_LENGTH = 20
MAX_REASON_LENGTH = 1000


class AdminOverrideRequest(BaseCreateSchema):
    """
    Request to override supervisor decision with comprehensive validation.

    Ensures all override requests are properly documented and justified
    with appropriate context and reasoning.
    """
    
    model_config = ConfigDict(validate_assignment=True)

    supervisor_id: Optional[UUID] = Field(
        None, description="Supervisor whose action is being overridden"
    )
    hostel_id: UUID = Field(..., description="Hostel where override occurs")

    override_type: str = Field(
        ...,
        description="Type of override (complaint_reassignment, maintenance_approval, etc.)",
    )

    entity_type: str = Field(
        ..., description="Type of entity (complaint, maintenance_request, etc.)"
    )
    entity_id: UUID = Field(..., description="ID of entity being modified")

    reason: str = Field(
        ...,
        min_length=MIN_REASON_LENGTH,
        max_length=MAX_REASON_LENGTH,
        description="Detailed reason for override",
    )

    # Original and new values
    original_action: Optional[Dict[str, Any]] = Field(
        None, description="Original supervisor action"
    )
    override_action: Dict[str, Any] = Field(..., description="Admin's override action")

    # Notification
    notify_supervisor: bool = Field(True, description="Notify supervisor of override")

    @field_validator("reason")
    @classmethod
    def normalize_reason(cls, v: str) -> str:
        """Normalize and validate reason text."""
        text = " ".join(v.strip().split())
        if len(text) < MIN_REASON_LENGTH:
            raise ValueError(
                f"Reason must be at least {MIN_REASON_LENGTH} characters after normalization"
            )

        # Check for placeholder text
        placeholder_phrases = [
            "override",
            "because",
            "admin decision",
            "test",
            "no reason",
        ]
        if text.lower() in placeholder_phrases:
            raise ValueError(
                "Please provide a specific, meaningful reason for the override"
            )

        return text

    @field_validator("override_type")
    @classmethod
    def validate_override_type(cls, v: str) -> str:
        """Validate and normalize override type."""
        normalized = v.strip().lower()
        if normalized not in VALID_OVERRIDE_TYPES:
            raise ValueError(
                f"Invalid override type: '{v}'. Valid types: {', '.join(sorted(VALID_OVERRIDE_TYPES))}"
            )
        return normalized

    @field_validator("entity_type")
    @classmethod
    def validate_entity_type(cls, v: str) -> str:
        """Validate and normalize entity type."""
        normalized = v.strip().lower()
        if normalized not in VALID_ENTITY_TYPES:
            raise ValueError(
                f"Invalid entity type: '{v}'. Valid types: {', '.join(sorted(VALID_ENTITY_TYPES))}"
            )
        return normalized

    @field_validator("override_action")
    @classmethod
    def validate_override_action(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        """Validate override action is not empty."""
        if not v:
            raise ValueError("Override action cannot be empty")
        return v

    @model_validator(mode="after")
    def validate_supervisor_requirement(self) -> "AdminOverrideRequest":
        """Validate supervisor_id is required for certain override types."""
        supervisor_required_types = {
            "complaint_reassignment",
            "complaint_closure",
            "maintenance_approval",
            "maintenance_rejection",
        }

        if self.override_type in supervisor_required_types and not self.supervisor_id:
            raise ValueError(
                f"supervisor_id is required for override type: {self.override_type}"
            )

        return self


class OverrideLog(BaseResponseSchema):
    """
    Override log entry with comprehensive tracking.

    Maintains complete audit trail of all override actions
    for accountability and analysis.
    """
    
    model_config = ConfigDict()

    admin_id: UUID = Field(..., description="Admin who performed override")
    admin_name: str = Field(..., min_length=1, description="Admin full name")
    supervisor_id: Optional[UUID] = Field(None, description="Affected supervisor ID")
    supervisor_name: Optional[str] = Field(None, description="Affected supervisor name")

    hostel_id: UUID = Field(..., description="Hostel where override occurred")
    hostel_name: str = Field(..., min_length=1, description="Hostel name")

    override_type: str = Field(..., description="Type of override")
    entity_type: str = Field(..., description="Type of entity")
    entity_id: UUID = Field(..., description="Entity ID")

    reason: str = Field(..., description="Override reason")

    original_action: Optional[Dict[str, Any]] = Field(
        None, description="Original supervisor action"
    )
    override_action: Dict[str, Any] = Field(..., description="Override action taken")

    created_at: datetime = Field(..., description="Override timestamp")

    @computed_field
    @property
    def short_reason(self) -> str:
        """Shortened reason for list displays."""
        max_length = 80
        if len(self.reason) <= max_length:
            return self.reason
        return self.reason[: max_length - 3] + "..."

    @computed_field
    @property
    def override_category(self) -> str:
        """Categorize override by entity type."""
        category_map = {
            "complaint": "Complaint Management",
            "maintenance_request": "Maintenance Operations",
            "booking": "Booking Management",
            "fee_transaction": "Financial Operations",
            "student_record": "Student Management",
            "policy_violation": "Policy Enforcement",
        }
        return category_map.get(self.entity_type, "Other")

    @computed_field
    @property
    def hours_since_override(self) -> int:
        """Calculate hours since override occurred."""
        delta = datetime.utcnow() - self.created_at
        return int(delta.total_seconds() // 3600)


class OverrideReason(BaseSchema):
    """
    Predefined override reasons for standardization.

    Provides common override reasons to ensure consistency
    and facilitate analytics.
    """
    
    model_config = ConfigDict()

    reason_code: str = Field(..., min_length=1, description="Unique reason code")
    reason_text: str = Field(..., min_length=10, description="Reason description")
    category: str = Field(..., min_length=1, description="Reason category")
    requires_detailed_explanation: bool = Field(
        ..., description="Whether detailed explanation is required"
    )

    @field_validator("reason_code")
    @classmethod
    def validate_reason_code(cls, v: str) -> str:
        """Validate and normalize reason code."""
        code = v.strip().upper()
        if not code:
            raise ValueError("Reason code cannot be empty")
        # Ensure alphanumeric with underscores
        if not code.replace("_", "").isalnum():
            raise ValueError(
                "Reason code must contain only letters, numbers, and underscores"
            )
        return code


class OverrideSummary(BaseSchema):
    """
    Summary of admin overrides for a specific period.

    Provides aggregated view of override patterns and trends
    for management oversight and decision-making.
    """
    
    model_config = ConfigDict()

    admin_id: UUID = Field(..., description="Admin user ID")
    period_start: Date = Field(..., description="Summary period start Date")
    period_end: Date = Field(..., description="Summary period end Date")

    total_overrides: int = Field(..., ge=0, description="Total overrides in period")

    # By type
    overrides_by_type: Dict[str, int] = Field(
        default_factory=dict, description="Breakdown by override type"
    )

    # By supervisor - Pydantic v2: Dict keys must be JSON-serializable (strings)
    overrides_by_supervisor: Dict[str, int] = Field(
        default_factory=dict, description="Breakdown by supervisor"
    )

    # By hostel - Pydantic v2: Dict keys must be JSON-serializable (strings)
    overrides_by_hostel: Dict[str, int] = Field(
        default_factory=dict, description="Breakdown by hostel"
    )

    # Trend
    override_trend: str = Field(
        ..., description="Override trend (increasing/decreasing/stable)"
    )

    @computed_field
    @property
    def average_overrides_per_day(self) -> Decimal:
        """Average overrides per day in the period."""
        days = max(1, (self.period_end - self.period_start).days)
        avg = Decimal(self.total_overrides) / Decimal(days)
        return avg.quantize(Decimal("0.01"))

    @computed_field
    @property
    def most_overridden_supervisor(self) -> Optional[str]:
        """Identify supervisor with most overrides."""
        if not self.overrides_by_supervisor:
            return None
        return max(self.overrides_by_supervisor, key=self.overrides_by_supervisor.get)  # type: ignore

    @computed_field
    @property
    def most_common_override_type(self) -> Optional[str]:
        """Identify most common override type."""
        if not self.overrides_by_type:
            return None
        return max(self.overrides_by_type, key=self.overrides_by_type.get)  # type: ignore

    @computed_field
    @property
    def override_concentration(self) -> Decimal:
        """
        Calculate override concentration (0-100).
        Higher values indicate overrides concentrated on few supervisors.
        """
        if not self.overrides_by_supervisor or self.total_overrides == 0:
            return Decimal("0.00")

        # Calculate Herfindahl-Hirschman Index (HHI) simplified
        supervisor_counts = list(self.overrides_by_supervisor.values())
        shares = [
            (count / self.total_overrides) ** 2 for count in supervisor_counts
        ]
        hhi = sum(shares) * 100

        return Decimal(str(hhi)).quantize(Decimal("0.01"))

    @field_validator("override_trend")
    @classmethod
    def validate_trend(cls, v: str) -> str:
        """Validate trend value."""
        if v not in VALID_TRENDS:
            raise ValueError(
                f"Invalid trend value: '{v}'. Must be one of: {', '.join(VALID_TRENDS)}"
            )
        return v

    @model_validator(mode="after")
    def validate_period_dates(self) -> "OverrideSummary":
        """Validate period dates are logical."""
        if self.period_end < self.period_start:
            raise ValueError("period_end must be after period_start")

        if (self.period_end - self.period_start).days > 365:
            raise ValueError("Summary period cannot exceed 365 days")

        return self


class SupervisorOverrideStats(BaseSchema):
    """
    Override statistics for a specific supervisor.

    Provides detailed override metrics to identify patterns
    and areas for supervisor development or support.
    """
    
    model_config = ConfigDict()

    supervisor_id: UUID = Field(..., description="Supervisor user ID")
    supervisor_name: str = Field(..., min_length=1, description="Supervisor full name")

    total_actions: int = Field(..., ge=0, description="Total actions taken by supervisor")
    total_overrides: int = Field(..., ge=0, description="Total actions overridden")
    
    # Pydantic v2: Decimal with ge/le constraints
    override_rate: Decimal = Field(
        ..., ge=Decimal("0"), le=Decimal("100"), description="Percentage of actions overridden"
    )

    # By type
    overrides_by_type: Dict[str, int] = Field(
        default_factory=dict, description="Breakdown by override type"
    )

    # Common reasons
    common_override_reasons: List[str] = Field(
        default_factory=list, description="Most common override reasons"
    )

    # Trend
    recent_trend: str = Field(
        ...,
        description="Recent trend in override rate (improving/declining/stable)",
    )

    @computed_field
    @property
    def is_concerning(self) -> bool:
        """Whether override rate is concerning (> 10%)."""
        return float(self.override_rate) > 10.0

    @computed_field
    @property
    def performance_indicator(self) -> str:
        """Overall performance indicator based on override rate."""
        rate = float(self.override_rate)
        if rate <= 5:
            return "Excellent"
        elif rate <= 10:
            return "Good"
        elif rate <= 20:
            return "Needs Improvement"
        else:
            return "Critical"

    @computed_field
    @property
    def most_overridden_category(self) -> Optional[str]:
        """Identify category with most overrides."""
        if not self.overrides_by_type:
            return None
        return max(self.overrides_by_type, key=self.overrides_by_type.get)  # type: ignore

    @field_validator("override_rate")
    @classmethod
    def validate_override_rate(cls, v: Decimal) -> Decimal:
        """Validate override rate is within bounds."""
        if v < 0 or v > 100:
            raise ValueError("Override rate must be between 0 and 100")
        return v.quantize(Decimal("0.01"))

    @field_validator("recent_trend")
    @classmethod
    def validate_trend(cls, v: str) -> str:
        """Validate trend value."""
        if v not in VALID_SUPERVISOR_TRENDS:
            raise ValueError(
                f"Invalid trend: '{v}'. Must be one of: {', '.join(VALID_SUPERVISOR_TRENDS)}"
            )
        return v

    @model_validator(mode="after")
    def validate_stats_consistency(self) -> "SupervisorOverrideStats":
        """Validate statistical consistency."""
        if self.total_overrides > self.total_actions:
            raise ValueError("total_overrides cannot exceed total_actions")

        # Validate override rate calculation
        if self.total_actions > 0:
            calculated_rate = Decimal(self.total_overrides) / Decimal(
                self.total_actions
            ) * 100
            calculated_rate = calculated_rate.quantize(Decimal("0.01"))

            # Allow small rounding difference
            if abs(calculated_rate - self.override_rate) > Decimal("0.1"):
                raise ValueError(
                    f"override_rate {self.override_rate} doesn't match calculated rate {calculated_rate}"
                )

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\admin_permissions.py ---
"""
Admin permission schemas for hostel-level access control.

Defines comprehensive permission structures and role mappings
for fine-grained authorization and access management.

Migrated to Pydantic v2.
"""

from __future__ import annotations

from typing import Dict, List, Optional, Set
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import UserRole

__all__ = [
    "AdminPermissions",
    "PermissionMatrix",
    "RolePermissions",
    "PermissionCheck",
]


# Permission categories for organization
ROOM_PERMISSIONS = {"can_manage_rooms", "can_manage_beds"}
STUDENT_PERMISSIONS = {
    "can_manage_students",
    "can_check_in_students",
    "can_check_out_students",
}
BOOKING_PERMISSIONS = {"can_approve_bookings", "can_manage_waitlist"}
FEE_PERMISSIONS = {"can_manage_fees", "can_process_payments", "can_issue_refunds"}
SUPERVISOR_PERMISSIONS = {
    "can_manage_supervisors",
    "can_configure_supervisor_permissions",
    "can_override_supervisor_actions",
}
FINANCIAL_PERMISSIONS = {"can_view_financials", "can_export_financial_data"}
HOSTEL_PERMISSIONS = {
    "can_manage_hostel_settings",
    "can_manage_hostel_profile",
    "can_toggle_public_visibility",
}
DATA_PERMISSIONS = {"can_delete_records", "can_export_data", "can_import_data"}

ALL_PERMISSION_KEYS: Set[str] = (
    ROOM_PERMISSIONS
    | STUDENT_PERMISSIONS
    | BOOKING_PERMISSIONS
    | FEE_PERMISSIONS
    | SUPERVISOR_PERMISSIONS
    | FINANCIAL_PERMISSIONS
    | HOSTEL_PERMISSIONS
    | DATA_PERMISSIONS
)


class AdminPermissions(BaseSchema):
    """
    Admin-specific permissions for a hostel.

    Provides granular control over admin capabilities with
    sensible defaults and comprehensive coverage of all admin functions.
    """

    # Room management
    can_manage_rooms: bool = Field(True, description="Can create/edit/delete rooms")
    can_manage_beds: bool = Field(True, description="Can manage bed assignments")

    # Student management
    can_manage_students: bool = Field(True, description="Can add/edit/remove students")
    can_check_in_students: bool = Field(True, description="Can check-in students")
    can_check_out_students: bool = Field(True, description="Can check-out students")

    # Booking management
    can_approve_bookings: bool = Field(True, description="Can approve/reject bookings")
    can_manage_waitlist: bool = Field(True, description="Can manage waitlist")

    # Fee management
    can_manage_fees: bool = Field(True, description="Can configure fee structures")
    can_process_payments: bool = Field(True, description="Can process manual payments")
    can_issue_refunds: bool = Field(True, description="Can issue refunds")

    # Supervisor management
    can_manage_supervisors: bool = Field(True, description="Can assign/remove supervisors")
    can_configure_supervisor_permissions: bool = Field(
        True, description="Can modify supervisor permissions"
    )
    can_override_supervisor_actions: bool = Field(
        True, description="Can override supervisor decisions"
    )

    # Financial access
    can_view_financials: bool = Field(True, description="Can view financial reports")
    can_export_financial_data: bool = Field(
        True, description="Can export financial data"
    )

    # Hostel configuration
    can_manage_hostel_settings: bool = Field(
        True, description="Can modify hostel settings"
    )
    can_manage_hostel_profile: bool = Field(
        True, description="Can edit public hostel profile"
    )
    can_toggle_public_visibility: bool = Field(
        True, description="Can make hostel public/private"
    )

    # Data management
    can_delete_records: bool = Field(
        False, description="Can permanently delete records"
    )
    can_export_data: bool = Field(True, description="Can export data")
    can_import_data: bool = Field(True, description="Can bulk import data")

    def has_permission(self, permission_key: str) -> bool:
        """Check if specific permission is granted."""
        if permission_key not in ALL_PERMISSION_KEYS:
            return False
        return bool(getattr(self, permission_key, False))

    def get_granted_permissions(self) -> List[str]:
        """Get list of all granted permissions."""
        return [key for key in ALL_PERMISSION_KEYS if self.has_permission(key)]

    def get_denied_permissions(self) -> List[str]:
        """Get list of all denied permissions."""
        return [key for key in ALL_PERMISSION_KEYS if not self.has_permission(key)]

    @property
    def permission_count(self) -> int:
        """Count of granted permissions."""
        return len(self.get_granted_permissions())

    @property
    def has_full_access(self) -> bool:
        """Check if has all permissions."""
        return self.permission_count == len(ALL_PERMISSION_KEYS)

    @property
    def has_limited_access(self) -> bool:
        """Check if has limited permissions."""
        return 0 < self.permission_count < len(ALL_PERMISSION_KEYS)

    @property
    def has_no_access(self) -> bool:
        """Check if has no permissions."""
        return self.permission_count == 0


class PermissionMatrix(BaseSchema):
    """
    Permission matrix showing capabilities for each role.

    Provides comprehensive mapping of roles to permissions
    for authorization and UI rendering.
    """

    # Note: In Pydantic v2, Dict keys must be JSON-serializable strings
    # We'll use role.value (string) as keys instead of UserRole enum directly
    permissions: Dict[str, List[str]] = Field(
        ..., description="Map of role value to list of permission keys"
    )

    @field_validator("permissions")
    @classmethod
    def validate_permissions(cls, v: Dict[str, List[str]]) -> Dict[str, List[str]]:
        """Validate permission keys are valid."""
        # Validate that role keys are valid
        valid_role_values = {role.value for role in UserRole}
        
        for role_str, perms in v.items():
            if role_str not in valid_role_values:
                raise ValueError(f"Invalid role: {role_str}")
            
            invalid_perms = set(perms) - ALL_PERMISSION_KEYS
            if invalid_perms:
                raise ValueError(
                    f"Invalid permissions for role {role_str}: {', '.join(invalid_perms)}"
                )
        return v

    def get_role_permissions(self, role: UserRole) -> List[str]:
        """Get permissions for a specific role."""
        return self.permissions.get(role.value, [])

    def role_has_permission(self, role: UserRole, permission_key: str) -> bool:
        """Check if role has specific permission."""
        return permission_key in self.permissions.get(role.value, [])


class RolePermissions(BaseSchema):
    """
    Permissions for a specific role with metadata.

    Provides detailed information about role capabilities
    with descriptions for documentation and UI display.
    """

    role: UserRole = Field(..., description="User role")
    permissions: List[str] = Field(..., description="List of permission keys")
    description: str = Field(..., min_length=10, description="Role description")

    @field_validator("permissions")
    @classmethod
    def validate_permissions(cls, v: List[str]) -> List[str]:
        """Validate all permission keys are valid."""
        invalid = set(v) - ALL_PERMISSION_KEYS
        if invalid:
            raise ValueError(
                f"Invalid permission keys: {', '.join(invalid)}. "
                f"Valid keys: {', '.join(sorted(ALL_PERMISSION_KEYS))}"
            )
        # Remove duplicates while preserving order
        seen = set()
        unique_perms = []
        for perm in v:
            if perm not in seen:
                seen.add(perm)
                unique_perms.append(perm)
        return unique_perms

    @property
    def permission_categories(self) -> Dict[str, List[str]]:
        """Organize permissions by category."""
        categories = {
            "Room Management": [],
            "Student Management": [],
            "Booking Management": [],
            "Fee Management": [],
            "Supervisor Management": [],
            "Financial Access": [],
            "Hostel Configuration": [],
            "Data Management": [],
        }

        for perm in self.permissions:
            if perm in ROOM_PERMISSIONS:
                categories["Room Management"].append(perm)
            elif perm in STUDENT_PERMISSIONS:
                categories["Student Management"].append(perm)
            elif perm in BOOKING_PERMISSIONS:
                categories["Booking Management"].append(perm)
            elif perm in FEE_PERMISSIONS:
                categories["Fee Management"].append(perm)
            elif perm in SUPERVISOR_PERMISSIONS:
                categories["Supervisor Management"].append(perm)
            elif perm in FINANCIAL_PERMISSIONS:
                categories["Financial Access"].append(perm)
            elif perm in HOSTEL_PERMISSIONS:
                categories["Hostel Configuration"].append(perm)
            elif perm in DATA_PERMISSIONS:
                categories["Data Management"].append(perm)

        # Remove empty categories
        return {k: v for k, v in categories.items() if v}


class PermissionCheck(BaseSchema):
    """
    Permission check request and result.

    Used to verify if a user has specific permission
    with detailed reasoning for access decisions.
    """

    user_id: UUID = Field(..., description="User ID to check")
    hostel_id: UUID = Field(..., description="Hostel ID context")
    permission_key: str = Field(..., description="Permission key to check")

    has_permission: bool = Field(..., description="Whether user has permission")
    reason: Optional[str] = Field(None, description="Reason if permission denied")

    @field_validator("permission_key")
    @classmethod
    def validate_permission_key(cls, v: str) -> str:
        """Validate permission key is valid."""
        value = v.strip()
        if not value:
            raise ValueError("permission_key cannot be empty")

        if value not in ALL_PERMISSION_KEYS:
            raise ValueError(
                f"Invalid permission key: '{value}'. "
                f"Valid keys: {', '.join(sorted(ALL_PERMISSION_KEYS))}"
            )

        return value

    @model_validator(mode="after")
    def validate_reason_requirement(self) -> "PermissionCheck":
        """Validate reason is provided when permission is denied."""
        if not self.has_permission and not self.reason:
            raise ValueError("reason is required when permission is denied")
        return self

    @property
    def access_status(self) -> str:
        """Get human-readable access status."""
        return "Granted" if self.has_permission else "Denied"

    @property
    def permission_category(self) -> str:
        """Get category of checked permission."""
        if self.permission_key in ROOM_PERMISSIONS:
            return "Room Management"
        elif self.permission_key in STUDENT_PERMISSIONS:
            return "Student Management"
        elif self.permission_key in BOOKING_PERMISSIONS:
            return "Booking Management"
        elif self.permission_key in FEE_PERMISSIONS:
            return "Fee Management"
        elif self.permission_key in SUPERVISOR_PERMISSIONS:
            return "Supervisor Management"
        elif self.permission_key in FINANCIAL_PERMISSIONS:
            return "Financial Access"
        elif self.permission_key in HOSTEL_PERMISSIONS:
            return "Hostel Configuration"
        elif self.permission_key in DATA_PERMISSIONS:
            return "Data Management"
        else:
            return "Unknown"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\hostel_context.py ---
"""
Enhanced hostel context management for multi-hostel admin operations.

Provides robust context switching, session tracking, and history management
for seamless multi-hostel administration with comprehensive audit trails.

Fully migrated to Pydantic v2.
"""

from __future__ import annotations

from datetime import datetime, timedelta
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator, ConfigDict

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "HostelContext",
    "HostelSwitchRequest",
    "ActiveHostelResponse",
    "ContextHistory",
    "ContextSwitch",
]


# Constants
STALE_SESSION_MINUTES = 30
RECENT_ACCESS_HOURS = 24
MAX_RETURN_URL_LENGTH = 500
MAX_SWITCH_REASON_LENGTH = 200
MIN_PRODUCTIVE_SESSION_MINUTES = 5
EXCELLENT_ACTIONS_PER_MINUTE = 0.5

HEALTH_SCORE_WEIGHTS = {
    "occupancy": 0.4,
    "tasks": 0.3,
    "alerts": 0.3,
}

ACTIVITY_TRIGGERS = {
    "manual",
    "automatic",
    "notification",
    "alert",
    "scheduled",
}


class HostelContext(BaseSchema):
    """
    Enhanced current hostel context for multi-hostel admin with real-time metrics.

    Maintains active hostel state with comprehensive permission information,
    session tracking, and quick access to relevant statistics.
    """
    
    model_config = ConfigDict()

    # Admin and context identifiers
    admin_id: UUID = Field(..., description="Admin user ID")
    context_id: UUID = Field(..., description="Unique context session ID")

    # Active hostel information
    active_hostel_id: UUID = Field(..., description="Currently active hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Active hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type classification")

    # Permission information for active hostel
    permission_level: str = Field(..., description="Permission level for active hostel")
    permissions: dict = Field(
        default_factory=dict, description="Detailed permissions for active hostel"
    )

    # Context session tracking
    context_started_at: datetime = Field(..., description="Context session start time")
    last_accessed_at: datetime = Field(..., description="Last activity timestamp")
    session_duration_minutes: int = Field(0, ge=0, description="Current session duration")

    # Quick statistics for active hostel
    total_students: int = Field(0, ge=0, description="Total students in active hostel")
    active_students: int = Field(0, ge=0, description="Currently active students")
    
    # Pydantic v2: Decimal with ge/le constraints
    occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=Decimal("0"), le=Decimal("100"), description="Current occupancy rate"
    )

    # Pending tasks and alerts
    pending_tasks: int = Field(0, ge=0, description="Pending tasks count")
    urgent_alerts: int = Field(0, ge=0, description="Urgent alerts count")
    unread_notifications: int = Field(0, ge=0, description="Unread notifications count")

    # Revenue snapshot - Pydantic v2: Decimal with ge constraint
    revenue_this_month: Decimal = Field(
        Decimal("0.00"), ge=Decimal("0"), description="Revenue for current month"
    )
    outstanding_payments: Decimal = Field(
        Decimal("0.00"), ge=Decimal("0"), description="Outstanding payment amount"
    )

    # Context metadata
    previous_hostel_id: Optional[UUID] = Field(None, description="Previously active hostel")
    switch_count: int = Field(0, ge=0, description="Number of context switches in session")

    @computed_field
    @property
    def session_active_duration(self) -> str:
        """Calculate and format active session duration."""
        duration = datetime.utcnow() - self.context_started_at

        total_seconds = int(duration.total_seconds())
        hours = total_seconds // 3600
        minutes = (total_seconds % 3600) // 60

        if hours > 0:
            return f"{hours}h {minutes}m"
        else:
            return f"{minutes}m"

    @computed_field
    @property
    def context_health_score(self) -> Decimal:
        """Calculate context health score based on hostel metrics."""
        score = Decimal("0.00")

        # Occupancy contribution (40 points)
        occupancy_score = self.occupancy_percentage * Decimal(str(HEALTH_SCORE_WEIGHTS["occupancy"]))
        score += occupancy_score

        # Task management (30 points)
        task_weight = Decimal(str(HEALTH_SCORE_WEIGHTS["tasks"] * 100))
        if self.pending_tasks == 0:
            score += task_weight
        elif self.pending_tasks <= 5:
            score += task_weight * Decimal("0.67")
        elif self.pending_tasks <= 10:
            score += task_weight * Decimal("0.33")

        # Alert status (30 points)
        alert_weight = Decimal(str(HEALTH_SCORE_WEIGHTS["alerts"] * 100))
        if self.urgent_alerts == 0:
            score += alert_weight
        elif self.urgent_alerts <= 2:
            score += alert_weight * Decimal("0.5")

        return score.quantize(Decimal("0.01"))

    @computed_field
    @property
    def requires_attention(self) -> bool:
        """Determine if active hostel requires immediate attention."""
        return (
            self.urgent_alerts > 0
            or self.pending_tasks > 10
            or self.occupancy_percentage < Decimal("50.00")
            or self.outstanding_payments > self.revenue_this_month
        )

    @computed_field
    @property
    def is_stale_session(self) -> bool:
        """Check if context session is stale (no activity for 30+ minutes)."""
        inactive_duration = datetime.utcnow() - self.last_accessed_at
        return inactive_duration > timedelta(minutes=STALE_SESSION_MINUTES)

    @computed_field
    @property
    def attention_priority(self) -> str:
        """Determine attention priority level."""
        if self.urgent_alerts > 5:
            return "Critical"
        elif self.urgent_alerts > 0 or self.pending_tasks > 20:
            return "High"
        elif self.pending_tasks > 10 or self.occupancy_percentage < Decimal("60.00"):
            return "Medium"
        else:
            return "Low"

    @field_validator("hostel_type")
    @classmethod
    def validate_hostel_type(cls, v: str) -> str:
        """Validate hostel type."""
        valid_types = {"boys", "girls", "co-ed", "coed", "mixed"}
        normalized = v.strip().lower()
        if normalized not in valid_types:
            raise ValueError(f"Invalid hostel type: {v}")
        return "co-ed" if normalized in {"coed", "mixed"} else normalized

    @model_validator(mode="after")
    def validate_session_consistency(self) -> "HostelContext":
        """Validate session timing consistency."""
        if self.last_accessed_at < self.context_started_at:
            raise ValueError("last_accessed_at cannot be before context_started_at")

        # Calculate expected duration
        expected_duration = int(
            (self.last_accessed_at - self.context_started_at).total_seconds() / 60
        )

        # Allow some tolerance for concurrent updates
        # Pydantic v2: Cannot log warnings from validators
        # Application code should handle logging if needed
        if abs(expected_duration - self.session_duration_minutes) > 5:
            pass

        return self


class HostelSwitchRequest(BaseCreateSchema):
    """
    Enhanced hostel context switch request with validation and options.

    Supports seamless context switching with proper validation,
    session management, and optional data refresh preferences.
    """
    
    model_config = ConfigDict(validate_assignment=True)

    hostel_id: UUID = Field(..., description="Target hostel ID to switch to")

    # Switch preferences
    save_current_session: bool = Field(
        True, description="Save current session state before switching"
    )
    refresh_dashboard: bool = Field(
        True, description="Refresh dashboard data after switch"
    )
    load_pending_tasks: bool = Field(
        True, description="Load pending tasks for new context"
    )

    # Navigation context
    return_url: Optional[str] = Field(
        None, max_length=MAX_RETURN_URL_LENGTH, description="URL to navigate to after switch"
    )
    switch_reason: Optional[str] = Field(
        None, max_length=MAX_SWITCH_REASON_LENGTH, description="Reason for context switch (for analytics)"
    )

    @field_validator("return_url")
    @classmethod
    def validate_return_url(cls, v: Optional[str]) -> Optional[str]:
        """Validate return URL format."""
        if v is not None:
            v = v.strip()
            if not v:
                return None

            # Basic URL validation
            if not v.startswith(("/", "http://", "https://")):
                raise ValueError(
                    "Invalid return URL format. Must start with /, http://, or https://"
                )

            # Prevent potential XSS
            dangerous_patterns = ["javascript:", "data:", "vbscript:"]
            if any(pattern in v.lower() for pattern in dangerous_patterns):
                raise ValueError("Return URL contains potentially dangerous content")

        return v

    @field_validator("switch_reason")
    @classmethod
    def validate_switch_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize switch reason."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            v = " ".join(v.split())  # Normalize whitespace
        return v


class ActiveHostelResponse(BaseSchema):
    """
    Enhanced response after successful hostel context switch.

    Provides comprehensive information about the newly active hostel
    with permissions, statistics, and navigation guidance.
    """
    
    model_config = ConfigDict()

    # Context identifiers
    admin_id: UUID = Field(..., description="Admin user ID")
    context_id: UUID = Field(..., description="New context session ID")

    # Previous and current hostel information
    previous_hostel_id: Optional[UUID] = Field(None, description="Previous active hostel ID")
    previous_hostel_name: Optional[str] = Field(None, description="Previous hostel name")

    active_hostel_id: UUID = Field(..., description="Newly active hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Active hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")

    # Permission configuration for new context
    permission_level: str = Field(..., description="Permission level for new hostel")
    permissions: dict = Field(default_factory=dict, description="Detailed permissions")

    # Context timing
    switched_at: datetime = Field(..., description="Context switch timestamp")
    previous_session_duration_minutes: Optional[int] = Field(
        None, ge=0, description="Duration of previous session"
    )

    # Quick statistics for new hostel - Pydantic v2: Decimal with constraints
    total_students: int = Field(0, ge=0, description="Total students")
    occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=Decimal("0"), le=Decimal("100")
    )
    pending_tasks: int = Field(0, ge=0, description="Pending tasks")
    urgent_alerts: int = Field(0, ge=0, description="Urgent alerts")

    # Response metadata
    message: str = Field(..., min_length=1, description="Success message")
    dashboard_url: Optional[str] = Field(None, description="Dashboard URL for new context")

    # Navigation suggestions
    suggested_actions: List[str] = Field(
        default_factory=list, description="Suggested next actions based on hostel state"
    )

    @computed_field
    @property
    def switch_summary(self) -> str:
        """Generate human-readable switch summary."""
        if self.previous_hostel_name:
            return f"Switched from {self.previous_hostel_name} to {self.hostel_name}"
        else:
            return f"Activated context for {self.hostel_name}"

    @computed_field
    @property
    def requires_immediate_action(self) -> bool:
        """Check if new context requires immediate action."""
        return self.urgent_alerts > 0 or self.pending_tasks > 5

    @computed_field
    @property
    def hostel_health_indicator(self) -> str:
        """Generate health indicator for newly active hostel."""
        if self.urgent_alerts > 0:
            return "critical"
        elif self.pending_tasks > 10:
            return "warning"
        elif self.occupancy_percentage < Decimal("60.00"):
            return "attention"
        else:
            return "healthy"

    @computed_field
    @property
    def priority_level(self) -> int:
        """Calculate priority level (1-5, where 5 is highest)."""
        if self.urgent_alerts > 5:
            return 5
        elif self.urgent_alerts > 0:
            return 4
        elif self.pending_tasks > 10:
            return 3
        elif self.pending_tasks > 5:
            return 2
        else:
            return 1

    @model_validator(mode="after")
    def populate_suggested_actions(self) -> "ActiveHostelResponse":
        """Populate suggested actions based on hostel state."""
        if not self.suggested_actions:
            actions = []

            if self.urgent_alerts > 0:
                actions.append(f"Review {self.urgent_alerts} urgent alerts")

            if self.pending_tasks > 10:
                actions.append(f"Process {self.pending_tasks} pending tasks")

            if self.occupancy_percentage < Decimal("50.00"):
                actions.append("Review low occupancy and marketing strategy")

            if self.occupancy_percentage > Decimal("95.00"):
                actions.append("Check waitlist for high occupancy")

            if not actions:
                actions.append("Dashboard is up to date")

            self.suggested_actions = actions

        return self


class ContextSwitch(BaseSchema):
    """
    Enhanced individual context switch record with comprehensive tracking.

    Represents a single hostel context switch with timing, reason,
    and session metrics for analytics and audit purposes.
    """
    
    model_config = ConfigDict()

    # Switch identification
    switch_id: UUID = Field(..., description="Unique switch record ID")
    admin_id: UUID = Field(..., description="Admin user ID")

    # Source and destination hostels
    from_hostel_id: Optional[UUID] = Field(None, description="Source hostel ID")
    from_hostel_name: Optional[str] = Field(None, description="Source hostel name")
    to_hostel_id: UUID = Field(..., description="Destination hostel ID")
    to_hostel_name: str = Field(..., min_length=1, description="Destination hostel name")

    # Switch timing
    switched_at: datetime = Field(..., description="Switch timestamp")
    session_duration_minutes: Optional[int] = Field(
        None, ge=0, description="Duration spent in previous hostel (if applicable)"
    )

    # Switch context
    switch_reason: Optional[str] = Field(None, description="Reason for switch")
    triggered_by: str = Field(
        "manual",
        description="What triggered the switch (manual, automatic, notification, alert, scheduled)",
    )

    # Activity metrics during session
    actions_performed: int = Field(0, ge=0, description="Actions performed in session")
    decisions_made: int = Field(0, ge=0, description="Decisions made in session")

    # Navigation context
    source_page: Optional[str] = Field(None, description="Page where switch was initiated")
    destination_page: Optional[str] = Field(None, description="Landing page after switch")

    @computed_field
    @property
    def session_productivity_score(self) -> Decimal:
        """Calculate productivity score for the session."""
        if self.session_duration_minutes is None or self.session_duration_minutes == 0:
            return Decimal("0.00")

        # Calculate actions per minute
        actions_per_minute = Decimal(self.actions_performed) / Decimal(
            self.session_duration_minutes
        )

        # Score based on actions per minute (capped at 100)
        score = min(
            (actions_per_minute / Decimal(str(EXCELLENT_ACTIONS_PER_MINUTE))) * 100, 100
        )

        return Decimal(str(score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def was_productive_session(self) -> bool:
        """Determine if session was productive (made meaningful progress)."""
        if self.session_duration_minutes is None:
            return False

        # Consider productive if:
        # - At least 5 minutes AND at least 1 action OR
        # - At least 1 decision made
        return (
            self.session_duration_minutes >= MIN_PRODUCTIVE_SESSION_MINUTES
            and self.actions_performed > 0
        ) or self.decisions_made > 0

    @computed_field
    @property
    def switch_type_description(self) -> str:
        """Generate human-readable switch type description."""
        type_map = {
            "manual": "User-initiated switch",
            "automatic": "Automatic context switch",
            "notification": "Triggered by notification",
            "alert": "Triggered by alert",
            "scheduled": "Scheduled context switch",
        }
        return type_map.get(self.triggered_by, "Unknown switch type")

    @computed_field
    @property
    def efficiency_rating(self) -> str:
        """Rate session efficiency."""
        score = float(self.session_productivity_score)

        if score >= 80:
            return "Excellent"
        elif score >= 60:
            return "Good"
        elif score >= 40:
            return "Fair"
        elif score > 0:
            return "Poor"
        else:
            return "No Activity"

    @field_validator("triggered_by")
    @classmethod
    def validate_triggered_by(cls, v: str) -> str:
        """Validate trigger type."""
        normalized = v.strip().lower()
        if normalized not in ACTIVITY_TRIGGERS:
            raise ValueError(
                f"Invalid trigger type: '{v}'. Valid types: {', '.join(ACTIVITY_TRIGGERS)}"
            )
        return normalized


class ContextHistory(BaseSchema):
    """
    Enhanced context switch history with analytics and insights.

    Provides comprehensive historical view of all context switches
    with usage patterns, productivity metrics, and recommendations.
    """
    
    model_config = ConfigDict()

    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., min_length=1, description="Admin full name")

    # History period
    history_start: datetime = Field(..., description="History period start")
    history_end: datetime = Field(..., description="History period end")

    # Switch records
    switches: List[ContextSwitch] = Field(
        default_factory=list, description="Chronological list of context switches"
    )

    # Aggregate statistics
    total_switches: int = Field(0, ge=0, description="Total number of switches")
    unique_hostels_accessed: int = Field(0, ge=0, description="Unique hostels accessed")
    total_session_time_minutes: int = Field(
        0, ge=0, description="Total time across all sessions"
    )

    # Most accessed hostel
    most_accessed_hostel_id: Optional[UUID] = Field(
        None, description="Most frequently accessed hostel"
    )
    most_accessed_hostel_name: Optional[str] = Field(
        None, description="Most accessed hostel name"
    )
    most_accessed_count: int = Field(0, ge=0, description="Access count for most accessed hostel")

    # Usage patterns - Pydantic v2: Decimal with ge constraint
    avg_session_duration_minutes: Decimal = Field(
        Decimal("0.00"), ge=Decimal("0"), description="Average session duration"
    )
    avg_switches_per_day: Decimal = Field(
        Decimal("0.00"), ge=Decimal("0"), description="Average switches per day"
    )

    # Productivity metrics
    total_actions_performed: int = Field(0, ge=0, description="Total actions across all sessions")
    total_decisions_made: int = Field(0, ge=0, description="Total decisions across all sessions")
    productivity_score: Decimal = Field(
        Decimal("0.00"), ge=Decimal("0"), le=Decimal("100"), description="Overall productivity score"
    )

    @computed_field
    @property
    def history_duration_days(self) -> int:
        """Calculate history period duration in days."""
        duration = (self.history_end - self.history_start).days
        return max(1, duration)

    @computed_field
    @property
    def switch_frequency_pattern(self) -> str:
        """Determine switch frequency pattern."""
        switches_per_day = float(self.avg_switches_per_day)

        if switches_per_day < 2:
            return "Low Frequency"
        elif switches_per_day < 5:
            return "Moderate Frequency"
        elif switches_per_day < 10:
            return "High Frequency"
        else:
            return "Very High Frequency"

    @computed_field
    @property
    def session_efficiency_score(self) -> Decimal:
        """Calculate session efficiency score."""
        if self.total_switches == 0:
            return Decimal("0.00")

        # Calculate average actions per switch
        avg_actions = Decimal(self.total_actions_performed) / Decimal(self.total_switches)

        # Calculate average decisions per switch
        avg_decisions = Decimal(self.total_decisions_made) / Decimal(self.total_switches)

        # Combined efficiency score
        efficiency = (avg_actions * Decimal("0.6") + avg_decisions * Decimal("0.4")) * 10

        return Decimal(str(min(float(efficiency), 100))).quantize(Decimal("0.01"))

    @computed_field
    @property
    def hostel_focus_distribution(self) -> str:
        """Determine hostel focus distribution pattern."""
        if self.unique_hostels_accessed == 0:
            return "No Activity"

        if self.total_switches == 0:
            return "No Activity"

        # Calculate concentration: how focused admin is on specific hostels
        concentration_ratio = self.most_accessed_count / self.total_switches

        if concentration_ratio > 0.7:
            return "Highly Focused (70%+ on one hostel)"
        elif concentration_ratio > 0.5:
            return "Moderately Focused (50-70% on one hostel)"
        else:
            return "Distributed (Balanced across hostels)"

    @computed_field
    @property
    def recommendations(self) -> List[str]:
        """Generate context usage recommendations based on patterns."""
        recommendations = []

        # High switch frequency recommendation
        if float(self.avg_switches_per_day) > 10:
            recommendations.append(
                "Consider consolidating tasks to reduce frequent context switching"
            )

        # Short session duration recommendation
        if float(self.avg_session_duration_minutes) < 10 and self.total_switches > 5:
            recommendations.append(
                "Average session duration is short; consider focusing on one hostel at a time"
            )

        # Low productivity recommendation
        if float(self.productivity_score) < 50 and self.total_switches > 10:
            recommendations.append(
                "Productivity could be improved by spending more time per hostel session"
            )

        # Balanced usage recommendation
        if self.unique_hostels_accessed > 5:
            concentration_ratio = (
                self.most_accessed_count / self.total_switches if self.total_switches > 0 else 0
            )
            if concentration_ratio < 0.3:
                recommendations.append(
                    "You're managing many hostels; consider delegating to improve efficiency"
                )

        # High efficiency praise
        if float(self.productivity_score) > 80:
            recommendations.append("Excellent productivity! Keep up the good work")

        return recommendations if recommendations else ["Usage patterns are healthy"]

    @model_validator(mode="after")
    def validate_history_consistency(self) -> "ContextHistory":
        """Validate history data consistency."""
        if self.history_end < self.history_start:
            raise ValueError("history_end must be after history_start")

        # Validate switch count matches switches list
        # (Might be due to pagination, so we don't error)
        if len(self.switches) != self.total_switches:
            pass  # Application code should handle logging if needed

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\hostel_selector.py ---
"""
Enhanced hostel selector UI schemas with comprehensive filtering and organization.

Provides optimized schemas for hostel selection dropdown/sidebar with quick stats,
favorites management, and recent access tracking for improved user experience.

Fully migrated to Pydantic v2.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator, ConfigDict

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "HostelSelectorResponse",
    "HostelSelectorItem",
    "RecentHostels",
    "RecentHostelItem",
    "FavoriteHostels",
    "FavoriteHostelItem",
    "UpdateFavoriteRequest",
]


class HostelSelectorItem(BaseSchema):
    """
    Enhanced individual hostel item in selector with comprehensive quick view.
    
    Provides essential hostel information with visual indicators,
    quick statistics, and status information for efficient selection.
    """
    
    model_config = ConfigDict()
    
    # Hostel identification
    hostel_id: UUID = Field(..., description="Hostel unique identifier")
    hostel_name: str = Field(..., description="Hostel display name")
    hostel_city: str = Field(..., description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type (boys/girls/co-ed)")
    hostel_address: Optional[str] = Field(None, description="Short address for display")
    
    # Visual indicators and flags
    is_active: bool = Field(True, description="Currently active hostel in context")
    is_primary: bool = Field(False, description="Primary hostel for this admin")
    is_favorite: bool = Field(False, description="Marked as favorite by admin")
    is_recently_accessed: bool = Field(False, description="Accessed in last 24 hours")
    
    # Quick statistics for decision making - Pydantic v2: Decimal with constraints
    occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=Decimal("0"), le=Decimal("100"), description="Current occupancy rate"
    )
    total_students: int = Field(0, ge=0, description="Total student count")
    available_beds: int = Field(0, ge=0, description="Available beds count")
    
    # Alert indicators
    pending_bookings: int = Field(0, ge=0, description="Pending booking requests")
    pending_complaints: int = Field(0, ge=0, description="Open complaints")
    urgent_tasks: int = Field(0, ge=0, description="Urgent tasks count")
    
    # Permission summary
    permission_level: str = Field(..., description="Admin permission level for this hostel")
    can_manage: bool = Field(True, description="Has management permissions")
    
    # Activity tracking
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    
    # Display customization
    display_order: int = Field(0, description="Custom display order")
    custom_label: Optional[str] = Field(None, description="Custom label/nickname for hostel")

    @computed_field
    @property
    def requires_attention(self) -> bool:
        """Determine if hostel requires immediate attention."""
        return (
            self.urgent_tasks > 0 or
            self.pending_complaints > 5 or
            self.occupancy_percentage < Decimal("50.00")
        )

    @computed_field
    @property
    def notification_badge_count(self) -> int:
        """Calculate notification badge count for visual indicator."""
        return self.pending_bookings + self.urgent_tasks

    @computed_field
    @property
    def status_indicator_color(self) -> str:
        """Determine status indicator color for UI."""
        if self.urgent_tasks > 0:
            return "red"  # Critical
        elif self.pending_complaints > 5 or self.occupancy_percentage < Decimal("50.00"):
            return "yellow"  # Warning
        else:
            return "green"  # Good

    @computed_field
    @property
    def display_label(self) -> str:
        """Get display label (custom or default)."""
        return self.custom_label if self.custom_label else self.hostel_name

    @computed_field
    @property
    def quick_summary(self) -> str:
        """Generate quick summary text for tooltip."""
        return (
            f"{int(self.occupancy_percentage)}% occupied  "
            f"{self.total_students} students  "
            f"{self.available_beds} beds available"
        )


class HostelSelectorResponse(BaseSchema):
    """
    Enhanced hostel selector dropdown/sidebar response with organized data.
    
    Provides complete hostel list with categorization, recent access,
    favorites, and intelligent sorting for optimal user experience.
    """
    
    model_config = ConfigDict()
    
    admin_id: UUID = Field(..., description="Admin user ID")
    total_hostels: int = Field(..., ge=0, description="Total hostels managed")
    active_hostels: int = Field(..., ge=0, description="Active hostel assignments")
    
    # Active context
    active_hostel_id: Optional[UUID] = Field(None, description="Currently active hostel ID")
    active_hostel_name: Optional[str] = Field(None, description="Currently active hostel name")
    
    # Organized hostel lists
    hostels: List[HostelSelectorItem] = Field(
        default_factory=list,
        description="All hostels with details"
    )
    
    # Quick access lists (IDs for reference)
    recent_hostel_ids: List[UUID] = Field(
        default_factory=list,
        max_length=10,
        description="Recently accessed hostel IDs (max 10)"
    )
    favorite_hostel_ids: List[UUID] = Field(
        default_factory=list,
        description="Favorite hostel IDs"
    )
    primary_hostel_id: Optional[UUID] = Field(None, description="Primary hostel ID")
    
    # Hostel requiring attention
    attention_required_ids: List[UUID] = Field(
        default_factory=list,
        description="Hostels requiring immediate attention"
    )
    
    # Summary statistics - Pydantic v2: Decimal with constraints
    total_pending_tasks: int = Field(0, ge=0, description="Total pending tasks across all hostels")
    total_urgent_alerts: int = Field(0, ge=0, description="Total urgent alerts")
    avg_occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=Decimal("0"), le=Decimal("100"), description="Average occupancy across hostels"
    )

    @computed_field
    @property
    def has_critical_alerts(self) -> bool:
        """Check if any hostel has critical alerts."""
        return len(self.attention_required_ids) > 0

    @computed_field
    @property
    def hostels_by_category(self) -> Dict[str, List[HostelSelectorItem]]:
        """Organize hostels by category for UI grouping."""
        return {
            "primary": [h for h in self.hostels if h.is_primary],
            "favorites": [h for h in self.hostels if h.is_favorite],
            "recent": [h for h in self.hostels if h.hostel_id in self.recent_hostel_ids[:5]],
            "attention_required": [h for h in self.hostels if h.requires_attention],
            "others": [
                h for h in self.hostels
                if not (h.is_primary or h.is_favorite or h.hostel_id in self.recent_hostel_ids[:5])
            ]
        }

    @computed_field
    @property
    def selector_summary(self) -> str:
        """Generate summary text for selector header."""
        if self.active_hostel_name:
            return f"Managing {self.total_hostels} hostels  Active: {self.active_hostel_name}"
        else:
            return f"Managing {self.total_hostels} hostels"


class RecentHostelItem(BaseSchema):
    """
    Enhanced recent hostel item with access patterns.
    
    Tracks recent hostel access with frequency and recency metrics
    for intelligent sorting and quick access recommendations.
    """
    
    model_config = ConfigDict()
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Access tracking
    last_accessed: datetime = Field(..., description="Last access timestamp")
    access_count: int = Field(..., ge=1, description="Total access count")
    access_count_last_7_days: int = Field(0, ge=0, description="Access count in last 7 days")
    access_count_last_30_days: int = Field(0, ge=0, description="Access count in last 30 days")
    
    # Session metrics - Pydantic v2: Decimal with ge constraint
    avg_session_duration_minutes: Decimal = Field(
        Decimal("0.00"), ge=Decimal("0"), description="Average session duration"
    )
    total_session_time_minutes: int = Field(0, ge=0, description="Total session time")
    
    # Quick stats for recent access
    last_occupancy: Decimal = Field(
        Decimal("0.00"), ge=Decimal("0"), le=Decimal("100")
    )
    pending_tasks_on_last_visit: int = Field(0, ge=0)

    @computed_field
    @property
    def hours_since_access(self) -> int:
        """Calculate hours since last access."""
        delta = datetime.utcnow() - self.last_accessed
        return int(delta.total_seconds() // 3600)

    @computed_field
    @property
    def access_frequency_score(self) -> Decimal:
        """Calculate access frequency score for ranking."""
        # Recent access gets higher score
        recency_score = max(0, 100 - self.hours_since_access)
        
        # Frequency score based on 7-day access
        frequency_score = min(self.access_count_last_7_days * 10, 100)
        
        # Combined score (60% frequency, 40% recency)
        total_score = (frequency_score * 0.6) + (recency_score * 0.4)
        
        return Decimal(str(total_score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_frequent(self) -> bool:
        """Determine if this is a frequently accessed hostel."""
        return self.access_count_last_7_days >= 5


class RecentHostels(BaseSchema):
    """
    Enhanced recent hostels list with intelligent sorting.
    
    Provides recently accessed hostels sorted by access patterns
    with analytics for usage optimization recommendations.
    """
    
    model_config = ConfigDict()
    
    admin_id: UUID = Field(..., description="Admin user ID")
    
    hostels: List[RecentHostelItem] = Field(
        default_factory=list,
        max_length=20,
        description="Recently accessed hostels (max 20)"
    )
    
    # Summary metrics
    total_recent_hostels: int = Field(0, ge=0, description="Total recent hostels count")
    most_frequent_hostel_id: Optional[UUID] = Field(None, description="Most frequently accessed hostel")
    
    # Time range for recent access
    tracking_period_days: int = Field(30, ge=1, description="Tracking period in days")

    @computed_field
    @property
    def access_pattern_summary(self) -> str:
        """Generate access pattern summary."""
        if not self.hostels:
            return "No recent access"
        
        frequent_count = sum(1 for h in self.hostels if h.is_frequent)
        
        if frequent_count > 0:
            return f"{frequent_count} frequently accessed  {len(self.hostels)} total recent"
        else:
            return f"{len(self.hostels)} hostels accessed recently"


class FavoriteHostelItem(BaseSchema):
    """
    Enhanced favorite hostel item with customization options.
    
    Supports hostel favorites with custom labels, notes,
    and priority ordering for personalized quick access.
    """
    
    model_config = ConfigDict()
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Favorite metadata
    added_to_favorites: datetime = Field(..., description="Timestamp when added to favorites")
    custom_label: Optional[str] = Field(
        None, max_length=100, description="Custom label/nickname for hostel"
    )
    notes: Optional[str] = Field(
        None, max_length=500, description="Personal notes about hostel"
    )
    display_order: int = Field(0, description="Custom display order priority")
    
    # Quick stats - Pydantic v2: Decimal with constraints
    current_occupancy: Decimal = Field(
        Decimal("0.00"), ge=Decimal("0"), le=Decimal("100")
    )
    pending_items: int = Field(0, ge=0, description="Total pending items count")
    
    # Access tracking for favorites
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count_since_favorited: int = Field(0, ge=0)

    @computed_field
    @property
    def days_in_favorites(self) -> int:
        """Calculate days since added to favorites."""
        delta = datetime.utcnow() - self.added_to_favorites
        return delta.days

    @computed_field
    @property
    def display_name(self) -> str:
        """Get display name (custom label or hostel name)."""
        return self.custom_label if self.custom_label else self.hostel_name

    @computed_field
    @property
    def is_recently_accessed(self) -> bool:
        """Check if accessed in last 24 hours."""
        if not self.last_accessed:
            return False
        hours_since = (datetime.utcnow() - self.last_accessed).total_seconds() / 3600
        return hours_since <= 24


class FavoriteHostels(BaseSchema):
    """
    Enhanced favorites list with organization and management.
    
    Provides organized favorites with custom ordering,
    labels, and quick access to frequently used hostels.
    """
    
    model_config = ConfigDict()
    
    admin_id: UUID = Field(..., description="Admin user ID")
    
    hostels: List[FavoriteHostelItem] = Field(
        default_factory=list,
        description="Favorite hostels sorted by display_order"
    )
    
    total_favorites: int = Field(0, ge=0, description="Total favorite hostels count")
    max_favorites_allowed: int = Field(20, ge=1, description="Maximum favorites allowed")

    @computed_field
    @property
    def can_add_more(self) -> bool:
        """Check if more favorites can be added."""
        return self.total_favorites < self.max_favorites_allowed

    @computed_field
    @property
    def favorites_by_city(self) -> Dict[str, List[FavoriteHostelItem]]:
        """Group favorites by city."""
        grouped: Dict[str, List[FavoriteHostelItem]] = {}
        for hostel in self.hostels:
            city = hostel.hostel_city
            if city not in grouped:
                grouped[city] = []
            grouped[city].append(hostel)
        return grouped


class UpdateFavoriteRequest(BaseCreateSchema):
    """
    Enhanced favorite update request with comprehensive customization.
    
    Supports adding/removing favorites with custom labels,
    notes, and display order preferences.
    """
    
    model_config = ConfigDict(validate_assignment=True)
    
    hostel_id: UUID = Field(..., description="Hostel ID to add/remove from favorites")
    is_favorite: bool = Field(..., description="True to add, False to remove")
    
    # Customization options (only used when is_favorite=True)
    custom_label: Optional[str] = Field(
        None,
        max_length=100,
        description="Custom label/nickname for hostel"
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Personal notes about this hostel"
    )
    display_order: Optional[int] = Field(
        None,
        ge=0,
        description="Custom display order (0 = highest priority)"
    )

    @field_validator("custom_label", "notes")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize text fields."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Normalize whitespace
            v = " ".join(v.split())
        return v

    @model_validator(mode="after")
    def validate_customization_logic(self) -> "UpdateFavoriteRequest":
        """Validate that customization is only provided when adding to favorites."""
        if not self.is_favorite:
            # Clear customization fields when removing from favorites
            if any([self.custom_label, self.notes, self.display_order is not None]):
                # Silently ignore customization when removing
                self.custom_label = None
                self.notes = None
                self.display_order = None
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\multi_hostel_dashboard.py ---
# --- File: app/schemas/admin/multi_hostel_dashboard.py ---
"""
Multihostel admin dashboard schemas.

Provides aggregated portfolio statistics, perhostel quick stats,
and crosshostel comparisons for the multihostel admin dashboard.

Key points:
- No assignment CRUD here (that lives in admin_hostel_assignment.py)
- Focused on readonly dashboard views and analytics
"""

from __future__ import annotations

from datetime import date as Date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import PermissionLevel

__all__ = [
    "MultiHostelDashboard",
    "AggregatedStats",
    "HostelQuickStats",
    "CrossHostelComparison",
    "TopPerformer",
    "BottomPerformer",
    "HostelMetricComparison",
    "HostelTaskSummary",
]


# ---------------------------------------------------------------------------
# Helpers / constants
# ---------------------------------------------------------------------------

def _normalize_hostel_type(value: str) -> str:
    """Normalize hostel type to canonical values and validate."""
    valid_types = {"boys", "girls", "co-ed", "coed", "mixed"}
    normalized = value.strip().lower()
    if normalized not in valid_types:
        raise ValueError(
            f"Invalid hostel type '{value}'. Must be one of: {', '.join(sorted(valid_types))}"
        )
    # Normalize co-ed variants
    return "co-ed" if normalized in {"coed", "mixed"} else normalized


ATTENTION_LOW_OCCUPANCY = Decimal("50.00")
ATTENTION_PENDING_TASKS = 20
ATTENTION_URGENT_ALERTS = 5


# ---------------------------------------------------------------------------
# Perhostel quick stats
# ---------------------------------------------------------------------------

class HostelQuickStats(BaseSchema):
    """
    Quick statistics for a single hostel in the multihostel dashboard.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type (boys/girls/co-ed)")

    # Assignment / access info for current admin
    is_primary: bool = Field(False, description="Primary hostel for this admin")
    permission_level: PermissionLevel = Field(
        ..., description="Admin permission level for this hostel"
    )
    has_management_access: bool = Field(
        True,
        description="Admin has management-level capabilities for this hostel",
    )

    # Capacity / occupancy
    total_students: int = Field(0, ge=0, description="Total students currently in hostel")
    capacity: int = Field(0, ge=0, description="Total bed capacity")
    occupancy_percentage: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        le=100,
        description="Current occupancy percentage",
    )
    available_beds: int = Field(0, ge=0, description="Available beds count")

    # Operational workload
    pending_tasks: int = Field(0, ge=0, description="Pending tasks")
    urgent_alerts: int = Field(0, ge=0, description="Urgent alerts")
    pending_bookings: int = Field(0, ge=0, description="Pending booking requests")
    open_complaints: int = Field(0, ge=0, description="Open complaints")

    # Financials
    revenue_this_month: Decimal = Field(
        Decimal("0.00"), ge=0, description="Revenue collected this month"
    )
    outstanding_payments: Decimal = Field(
        Decimal("0.00"), ge=0, description="Outstanding (due) amount"
    )

    # Satisfaction / quality signals
    avg_student_rating: Optional[Decimal] = Field(
        None, ge=0, le=5, description="Average student rating for this hostel"
    )
    admin_satisfaction_score: Optional[Decimal] = Field(
        None, ge=0, le=5, description="Internal satisfaction score for this hostel"
    )

    # Activity from this admin
    last_activity: Optional[datetime] = Field(
        None, description="Last time this admin interacted with this hostel"
    )
    access_count: int = Field(0, ge=0, description="Total accesses by this admin")

    @field_validator("hostel_type")
    @classmethod
    def validate_hostel_type(cls, v: str) -> str:
        return _normalize_hostel_type(v)

    @computed_field  # type: ignore[misc]
    @property
    def financial_risk(self) -> bool:
        """Whether outstanding payments exceed current month revenue."""
        return self.outstanding_payments > self.revenue_this_month

    @computed_field  # type: ignore[misc]
    @property
    def requires_attention(self) -> bool:
        """
        Whether this hostel should be highlighted as needing attention
        on the multihostel dashboard.
        """
        return (
            self.urgent_alerts > 0
            or self.pending_tasks > ATTENTION_PENDING_TASKS
            or self.open_complaints > 10
            or self.occupancy_percentage < ATTENTION_LOW_OCCUPANCY
            or self.financial_risk
        )

    @computed_field  # type: ignore[misc]
    @property
    def status_indicator(self) -> str:
        """
        Highlevel status indicator for UI (critical/warning/normal).
        """
        if self.urgent_alerts > ATTENTION_URGENT_ALERTS or self.open_complaints > 20:
            return "critical"
        if (
            self.urgent_alerts > 0
            or self.pending_tasks > ATTENTION_PENDING_TASKS
            or self.open_complaints > 10
            or self.occupancy_percentage < ATTENTION_LOW_OCCUPANCY
        ):
            return "warning"
        return "normal"

    @computed_field  # type: ignore[misc]
    @property
    def occupancy_status(self) -> str:
        """Humanreadable occupancy status."""
        if self.occupancy_percentage < Decimal("40.00"):
            return "Underutilized"
        elif self.occupancy_percentage < Decimal("90.00"):
            return "Healthy"
        else:
            return "Near Full"

    @computed_field  # type: ignore[misc]
    @property
    def hours_since_last_activity(self) -> Optional[int]:
        """Hours since this admin last interacted with this hostel."""
        if not self.last_activity:
            return None
        # Pydantic v2: Use timezone-aware datetime.now() or UTC consistently
        delta = datetime.utcnow() - self.last_activity
        return int(delta.total_seconds() // 3600)


# ---------------------------------------------------------------------------
# Aggregated / portfolio stats
# ---------------------------------------------------------------------------

class AggregatedStats(BaseSchema):
    """
    Aggregated statistics across all hostels managed by the admin.
    """

    admin_id: UUID = Field(..., description="Admin user ID")

    total_hostels: int = Field(..., ge=0, description="Total hostels assigned")
    active_hostels: int = Field(..., ge=0, description="Hostels with active assignments")

    total_students: int = Field(0, ge=0, description="Total students across hostels")
    active_students: int = Field(0, ge=0, description="Active/checkedin students")
    total_capacity: int = Field(0, ge=0, description="Total bed capacity")

    avg_occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Average occupancy across hostels"
    )

    total_pending_tasks: int = Field(0, ge=0, description="Total pending tasks")
    total_urgent_alerts: int = Field(0, ge=0, description="Total urgent alerts")
    total_open_complaints: int = Field(0, ge=0, description="Total open complaints")

    total_revenue_this_month: Decimal = Field(
        Decimal("0.00"), ge=0, description="Total revenue this month"
    )
    total_outstanding_payments: Decimal = Field(
        Decimal("0.00"), ge=0, description="Total outstanding payments"
    )

    avg_student_rating: Optional[Decimal] = Field(
        None, ge=0, le=5, description="Average student rating across hostels"
    )
    avg_admin_satisfaction_score: Optional[Decimal] = Field(
        None, ge=0, le=5, description="Average internal satisfaction score"
    )

    @computed_field  # type: ignore[misc]
    @property
    def hostel_utilization_rate(self) -> Decimal:
        """Percentage of hostels that are actively managed."""
        if self.total_hostels == 0:
            return Decimal("0.00")
        rate = Decimal(self.active_hostels) / Decimal(self.total_hostels) * 100
        return rate.quantize(Decimal("0.01"))

    @computed_field  # type: ignore[misc]
    @property
    def student_occupancy_rate(self) -> Decimal:
        """Overall bed occupancy rate across the portfolio."""
        if self.total_capacity == 0:
            return Decimal("0.00")
        rate = Decimal(self.active_students) / Decimal(self.total_capacity) * 100
        return rate.quantize(Decimal("0.01"))

    @computed_field  # type: ignore[misc]
    @property
    def has_critical_issues(self) -> bool:
        """Whether the portfolio has clearly critical issues."""
        return (
            self.total_urgent_alerts > 0
            or self.total_open_complaints > 20
            or self.total_pending_tasks > 100
        )

    @computed_field  # type: ignore[misc]
    @property
    def financial_health_indicator(self) -> str:
        """Basic financial health indicator."""
        if self.total_revenue_this_month == 0 and self.total_outstanding_payments == 0:
            return "neutral"
        if self.total_outstanding_payments > self.total_revenue_this_month:
            return "at_risk"
        if self.total_outstanding_payments > self.total_revenue_this_month * Decimal("0.5"):
            return "watch"
        return "healthy"

    @model_validator(mode="after")
    def validate_consistency(self) -> "AggregatedStats":
        """Basic consistency checks on aggregated counts."""
        if self.active_hostels > self.total_hostels:
            raise ValueError("active_hostels cannot exceed total_hostels")
        if self.active_students > self.total_students:
            raise ValueError("active_students cannot exceed total_students")
        if self.total_students > self.total_capacity and self.total_capacity > 0:
            # Allow, but this is suspicious; don't raise to avoid breaking clients.
            pass
        return self


# ---------------------------------------------------------------------------
# Task summary
# ---------------------------------------------------------------------------

class HostelTaskSummary(BaseSchema):
    """
    Portfoliowide task summary for the dashboard.
    """

    total_tasks: int = Field(0, ge=0, description="Total tasks in the selected period")
    pending_tasks: int = Field(0, ge=0, description="Currently pending tasks")
    overdue_tasks: int = Field(0, ge=0, description="Overdue tasks")
    urgent_tasks: int = Field(0, ge=0, description="Urgent tasks")
    completed_today: int = Field(0, ge=0, description="Tasks completed today")

    # Optional breakdown by hostel
    tasks_by_hostel: Dict[UUID, int] = Field(
        default_factory=dict, description="Total tasks per hostel (optional)"
    )

    @computed_field  # type: ignore[misc]
    @property
    def pending_ratio(self) -> Decimal:
        """Percentage of tasks that are pending."""
        if self.total_tasks == 0:
            return Decimal("0.00")
        ratio = Decimal(self.pending_tasks) / Decimal(self.total_tasks) * 100
        return ratio.quantize(Decimal("0.01"))

    @computed_field  # type: ignore[misc]
    @property
    def overdue_ratio(self) -> Decimal:
        """Percentage of tasks that are overdue."""
        if self.total_tasks == 0:
            return Decimal("0.00")
        ratio = Decimal(self.overdue_tasks) / Decimal(self.total_tasks) * 100
        return ratio.quantize(Decimal("0.01"))

    @computed_field  # type: ignore[misc]
    @property
    def health_status(self) -> str:
        """Highlevel health indicator based on task backlog."""
        if self.urgent_tasks == 0 and self.overdue_tasks == 0:
            return "good"
        if self.urgent_tasks > 20 or self.overdue_ratio > Decimal("25.00"):
            return "critical"
        if self.urgent_tasks > 0 or self.overdue_ratio > Decimal("10.00"):
            return "attention"
        return "good"

    @model_validator(mode="after")
    def validate_counts(self) -> "HostelTaskSummary":
        """Ensure basic numeric consistency."""
        if self.pending_tasks > self.total_tasks:
            raise ValueError("pending_tasks cannot exceed total_tasks")
        if self.overdue_tasks > self.total_tasks:
            raise ValueError("overdue_tasks cannot exceed total_tasks")
        return self


# ---------------------------------------------------------------------------
# Top / bottom performers
# ---------------------------------------------------------------------------

class TopPerformer(BaseSchema):
    """
    Top performing hostel in a given dimension.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")

    performance_score: Decimal = Field(
        ..., ge=0, le=100, description="Composite performance score (0100)"
    )
    rank: int = Field(..., ge=1, description="Rank among hostels")
    key_metric: str = Field(..., min_length=1, description="Primary metric driving this ranking")
    key_metric_value: Optional[Decimal] = Field(
        None, description="Value of the primary metric (e.g. occupancy %)"
    )

    @field_validator("hostel_type")
    @classmethod
    def validate_hostel_type(cls, v: str) -> str:
        return _normalize_hostel_type(v)

    @computed_field  # type: ignore[misc]
    @property
    def label(self) -> str:
        """Convenient display label."""
        return f"#{self.rank} {self.hostel_name}"


class BottomPerformer(BaseSchema):
    """
    Bottom performing hostel in a given dimension.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")

    performance_score: Decimal = Field(
        ..., ge=0, le=100, description="Composite performance score (0100)"
    )
    rank: int = Field(..., ge=1, description="Rank among hostels (1 = worst)")
    key_metric: str = Field(..., min_length=1, description="Primary metric driving this ranking")
    key_metric_value: Optional[Decimal] = Field(
        None, description="Value of the primary metric (e.g. complaints count)"
    )

    @field_validator("hostel_type")
    @classmethod
    def validate_hostel_type(cls, v: str) -> str:
        return _normalize_hostel_type(v)

    @computed_field  # type: ignore[misc]
    @property
    def label(self) -> str:
        """Convenient display label."""
        return f"#{self.rank} {self.hostel_name}"


# ---------------------------------------------------------------------------
# Metric comparison
# ---------------------------------------------------------------------------

class HostelMetricComparison(BaseSchema):
    """
    Comparison of a single metric across hostels (best/worst vs portfolio average).
    """

    metric_name: str = Field(..., min_length=1, description="Metric name (e.g. occupancy)")
    unit: str = Field(..., min_length=1, description="Display unit (%, count, currency, etc.)")

    portfolio_average: Decimal = Field(
        Decimal("0.00"), description="Portfoliowide average for this metric"
    )

    best_hostel_id: Optional[UUID] = Field(None, description="Best performing hostel ID")
    best_hostel_name: Optional[str] = Field(None, description="Best performing hostel name")
    best_value: Optional[Decimal] = Field(
        None, description="Best value for the metric (direction depends on metric)"
    )

    worst_hostel_id: Optional[UUID] = Field(None, description="Worst performing hostel ID")
    worst_hostel_name: Optional[str] = Field(None, description="Worst performing hostel name")
    worst_value: Optional[Decimal] = Field(
        None, description="Worst value for the metric (direction depends on metric)"
    )

    @computed_field  # type: ignore[misc]
    @property
    def spread(self) -> Decimal:
        """Absolute spread between best and worst values."""
        if self.best_value is None or self.worst_value is None:
            return Decimal("0.00")
        diff = abs(Decimal(self.best_value) - Decimal(self.worst_value))
        return diff.quantize(Decimal("0.01"))

    @computed_field  # type: ignore[misc]
    @property
    def variation_index(self) -> Decimal:
        """
        Relative variation vs portfolio average (percentage).
        Higher = more variation between hostels for this metric.
        """
        if self.portfolio_average == 0 or self.spread == 0:
            return Decimal("0.00")
        ratio = self.spread / abs(self.portfolio_average) * 100
        return ratio.quantize(Decimal("0.01"))


# ---------------------------------------------------------------------------
# Crosshostel comparison wrapper
# ---------------------------------------------------------------------------

class CrossHostelComparison(BaseSchema):
    """
    Crosshostel comparison section for the dashboard, containing
    metric comparisons and top/bottom performers.
    """

    metrics: List[HostelMetricComparison] = Field(
        default_factory=list, description="Permetric comparisons"
    )
    top_performers: List[TopPerformer] = Field(
        default_factory=list, description="Top performing hostels"
    )
    bottom_performers: List[BottomPerformer] = Field(
        default_factory=list, description="Bottom performing hostels"
    )

    @computed_field  # type: ignore[misc]
    @property
    def has_significant_variation(self) -> bool:
        """
        Whether any metric shows large variation across hostels.
        """
        return any(m.variation_index > Decimal("20.00") for m in self.metrics)

    @computed_field  # type: ignore[misc]
    @property
    def metrics_by_name(self) -> Dict[str, HostelMetricComparison]:
        """Index metrics by name for quicker lookup in clients."""
        return {m.metric_name: m for m in self.metrics}


# ---------------------------------------------------------------------------
# Root multihostel dashboard schema
# ---------------------------------------------------------------------------

class MultiHostelDashboard(BaseResponseSchema):
    """
    Root schema for the multihostel admin dashboard response.
    """

    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., min_length=1, description="Admin full name")

    generated_at: datetime = Field(
        default_factory=datetime.utcnow, description="Timestamp when dashboard was generated"
    )

    period_start: Date = Field(..., description="Start of reporting period")
    period_end: Date = Field(..., description="End of reporting period (inclusive)")

    # Portfoliolevel aggregates
    aggregated_stats: AggregatedStats = Field(
        ..., description="Aggregated statistics across all hostels"
    )

    # Perhostel quick stats
    hostels: List[HostelQuickStats] = Field(
        default_factory=list, description="Quick stats for each hostel"
    )

    # Tasks / workload
    task_summary: HostelTaskSummary = Field(
        ..., description="Portfoliowide task summary"
    )

    # Comparisons / rankings
    cross_hostel_comparison: Optional[CrossHostelComparison] = Field(
        None, description="Crosshostel comparisons and rankings"
    )

    # UI helpers
    active_hostel_id: Optional[UUID] = Field(
        None, description="Hostel currently focused in UI (optional)"
    )

    @computed_field  # type: ignore[misc]
    @property
    def period_days(self) -> int:
        """Length of the reporting period in days (at least 1)."""
        days = (self.period_end - self.period_start).days + 1
        return max(1, days)

    @computed_field  # type: ignore[misc]
    @property
    def hostels_requiring_attention(self) -> List[UUID]:
        """IDs of hostels that require attention."""
        return [h.hostel_id for h in self.hostels if h.requires_attention]

    @computed_field  # type: ignore[misc]
    @property
    def total_critical_hostels(self) -> int:
        """Number of hostels in warning/critical state."""
        return len(self.hostels_requiring_attention)

    @computed_field  # type: ignore[misc]
    @property
    def overall_attention_level(self) -> str:
        """
        Overall portfolio attention level based on how many hostels
        are in a concerning state.
        """
        n = self.total_critical_hostels
        if n == 0:
            return "low"
        if n <= 2:
            return "medium"
        if n <= 5:
            return "high"
        return "critical"

    @model_validator(mode="after")
    def validate_period(self) -> "MultiHostelDashboard":
        """Validate reporting period and basic consistency."""
        if self.period_end < self.period_start:
            raise ValueError("period_end must be on or after period_start")

        # Optional soft check: aggregated_stats.total_hostels vs hostels list
        if self.aggregated_stats.total_hostels and self.hostels:
            # Don't hardfail, but this is a useful invariant to watch.
            if self.aggregated_stats.total_hostels < len(self.hostels):
                # Could log a warning in application code.
                pass

        if self.aggregated_stats.admin_id != self.admin_id:
            # Ensure we didn't accidentally mix data for different admins
            raise ValueError("aggregated_stats.admin_id must match admin_id")

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\__init__.py ---
from __future__ import annotations

from app.schemas.admin.admin_hostel_assignment import (
    AdminHostelAssignment,
    AssignmentCreate,
    AssignmentList,
    AssignmentUpdate,
    BulkAssignment,
    HostelAdminItem,
    HostelAdminList,
    RevokeAssignment,
)
from app.schemas.admin.admin_override import (
    AdminOverrideRequest,
    OverrideLog,
    OverrideReason,
    OverrideSummary,
    SupervisorOverrideStats,
)
from app.schemas.admin.admin_permissions import (
    AdminPermissions,
    PermissionCheck,
    PermissionMatrix,
    RolePermissions,
)
from app.schemas.admin.hostel_context import (
    ActiveHostelResponse,
    ContextHistory,
    ContextSwitch,
    HostelContext,
    HostelSwitchRequest,
)
from app.schemas.admin.hostel_selector import (
    FavoriteHostelItem,
    FavoriteHostels,
    HostelSelectorItem,
    HostelSelectorResponse,
    RecentHostelItem,
    RecentHostels,
    UpdateFavoriteRequest,
)
from app.schemas.admin.multi_hostel_dashboard import (
    AggregatedStats,
    BottomPerformer,
    CrossHostelComparison,
    HostelMetricComparison,
    HostelQuickStats,
    HostelTaskSummary,
    MultiHostelDashboard,
    TopPerformer,
)

__all__ = [
    # Hostel Assignment Management
    "AdminHostelAssignment",
    "AssignmentCreate",
    "AssignmentUpdate",
    "BulkAssignment",
    "RevokeAssignment",
    "AssignmentList",
    "HostelAdminList",
    "HostelAdminItem",
    
    # Hostel Context Management
    "HostelContext",
    "HostelSwitchRequest",
    "ActiveHostelResponse",
    "ContextHistory",
    "ContextSwitch",
    
    # Hostel Selector UI
    "HostelSelectorResponse",
    "HostelSelectorItem",
    "RecentHostels",
    "RecentHostelItem",
    "FavoriteHostels",
    "FavoriteHostelItem",
    "UpdateFavoriteRequest",
    
    # Multi-Hostel Dashboard
    "MultiHostelDashboard",
    "AggregatedStats",
    "HostelQuickStats",
    "CrossHostelComparison",
    "TopPerformer",
    "BottomPerformer",
    "HostelMetricComparison",
    "HostelTaskSummary",
    
    # Admin Override System
    "AdminOverrideRequest",
    "OverrideLog",
    "OverrideReason",
    "OverrideSummary",
    "SupervisorOverrideStats",
    
    # Admin Permissions
    "AdminPermissions",
    "PermissionMatrix",
    "RolePermissions",
    "PermissionCheck",
]


# Package metadata
__author__ = "Hostel Management System Team"
__description__ = "Admin management schemas for multi-hostel operations"


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\__pycache__ =====
