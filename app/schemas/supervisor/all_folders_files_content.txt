### Combined Content from Folder: D:\Last Github Push\Last\Hostel-Main\app\schemas\supervisor ###



# ===== Folder: D:\Last Github Push\Last\Hostel-Main\app\schemas\supervisor =====

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\supervisor\supervisor_activity.py ---
# --- File: app/schemas/supervisor/supervisor_activity.py ---
"""
Supervisor activity and audit log schemas with enhanced tracking.

Provides comprehensive activity monitoring, audit trails, and
performance analytics with optimized filtering and export capabilities.
"""

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional

from pydantic import Field, field_validator, computed_field, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseFilterSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import AuditActionCategory
from app.schemas.common.filters import DateTimeRangeFilter

__all__ = [
    "SupervisorActivityLog",
    "ActivityDetail",
    "ActivitySummary",
    "ActivityFilterParams",
    "ActivityExportRequest",
    "TopActivity",
    "ActivityTimelinePoint",
    "ActivityMetrics",
]


class SupervisorActivityLog(BaseResponseSchema):
    """
    Supervisor activity log entry with enhanced metadata.
    
    Tracks all supervisor actions with context and performance data.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Action details
    action_type: str = Field(
        ...,
        description="Specific action performed",
        examples=[
            "complaint_resolved",
            "attendance_marked",
            "maintenance_created",
            "announcement_published",
        ],
    )
    action_category: AuditActionCategory = Field(
        ...,
        description="Action category for grouping",
    )
    action_description: str = Field(
        ...,
        description="Human-readable description",
    )
    
    # Entity affected
    entity_type: Optional[str] = Field(
        default=None,
        description="Type of entity affected",
        examples=["complaint", "student", "room", "maintenance_request"],
    )
    entity_id: Optional[str] = Field(
        default=None,
        description="ID of affected entity",
    )
    entity_name: Optional[str] = Field(
        default=None,
        description="Name/title of affected entity",
    )
    
    # Context and metadata
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional action details and context",
    )
    
    # Technical details
    ip_address: Optional[str] = Field(
        default=None,
        description="IP address of action origin",
    )
    user_agent: Optional[str] = Field(
        default=None,
        description="User agent string",
    )
    device_type: Optional[str] = Field(
        default=None,
        description="Device type (mobile/desktop/tablet)",
    )
    
    # Performance tracking
    response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Action response time in milliseconds",
    )
    success: bool = Field(
        default=True,
        description="Whether action completed successfully",
    )
    error_message: Optional[str] = Field(
        default=None,
        description="Error message if action failed",
    )

    @computed_field
    @property
    def action_display_name(self) -> str:
        """Get human-readable action name."""
        action_names = {
            "complaint_resolved": "Resolved Complaint",
            "complaint_assigned": "Assigned Complaint",
            "attendance_marked": "Marked Attendance",
            "leave_approved": "Approved Leave",
            "maintenance_created": "Created Maintenance Request",
            "maintenance_assigned": "Assigned Maintenance",
            "announcement_published": "Published Announcement",
            "student_contacted": "Contacted Student",
            "room_status_updated": "Updated Room Status",
            "menu_updated": "Updated Menu",
        }
        return action_names.get(self.action_type, self.action_type.replace("_", " ").title())


class ActivityDetail(BaseSchema):
    """
    Detailed activity information with change tracking.
    
    Comprehensive activity record with before/after states.
    """

    activity_id: str = Field(..., description="Activity ID")
    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    
    timestamp: datetime = Field(..., description="Activity timestamp")
    action_type: str = Field(..., description="Action type")
    action_category: AuditActionCategory = Field(..., description="Action category")
    action_description: str = Field(..., description="Action description")
    
    # Entity details
    entity_type: Optional[str] = Field(default=None, description="Entity type")
    entity_id: Optional[str] = Field(default=None, description="Entity ID")
    entity_name: Optional[str] = Field(default=None, description="Entity name")
    
    # Change tracking
    old_values: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Previous values before change",
    )
    new_values: Optional[Dict[str, Any]] = Field(
        default=None,
        description="New values after change",
    )
    
    # Context
    ip_address: Optional[str] = Field(default=None, description="IP address")
    user_agent: Optional[str] = Field(default=None, description="User agent")
    location: Optional[str] = Field(default=None, description="Geographic location")
    device_info: Optional[Dict[str, str]] = Field(
        default=None,
        description="Device information",
    )
    
    # Result
    success: bool = Field(default=True, description="Action success status")
    error_message: Optional[str] = Field(default=None, description="Error message")
    response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Response time in milliseconds",
    )
    
    # Impact assessment
    impact_level: Optional[str] = Field(
        default=None,
        pattern=r"^(low|medium|high|critical)$",
        description="Impact level of the action",
    )
    affected_users_count: Optional[int] = Field(
        default=None,
        ge=0,
        description="Number of users affected by action",
    )

    @computed_field
    @property
    def has_changes(self) -> bool:
        """Check if activity involved data changes."""
        return bool(self.old_values or self.new_values)

    @computed_field
    @property
    def change_summary(self) -> Optional[str]:
        """Generate summary of changes made."""
        if not self.has_changes:
            return None
        
        if not self.old_values or not self.new_values:
            return "Data modified"
        
        changes = []
        for key in self.new_values:
            if key in self.old_values and self.old_values[key] != self.new_values[key]:
                changes.append(f"{key}: {self.old_values[key]} â†’ {self.new_values[key]}")
        
        return "; ".join(changes) if changes else "No changes detected"


class TopActivity(BaseSchema):
    """
    Top activity item for summary reports.
    
    Represents frequently performed activities.
    """

    action_type: str = Field(..., description="Action type")
    action_category: str = Field(..., description="Action category")
    action_display_name: str = Field(..., description="Human-readable name")
    count: int = Field(..., ge=0, description="Number of times performed")
    last_performed: datetime = Field(..., description="Last time performed")
    average_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Average response time",
    )
    success_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Success rate percentage",
    )

    @computed_field
    @property
    def frequency_description(self) -> str:
        """Get frequency description."""
        if self.count >= 100:
            return "Very Frequent"
        elif self.count >= 50:
            return "Frequent"
        elif self.count >= 20:
            return "Regular"
        elif self.count >= 10:
            return "Occasional"
        else:
            return "Rare"


class ActivityTimelinePoint(BaseSchema):
    """
    Activity timeline data point for trend analysis.
    
    Represents activity volume over time periods.
    """

    timestamp: datetime = Field(..., description="Time period")
    action_count: int = Field(..., ge=0, description="Total actions in period")
    unique_action_types: int = Field(..., ge=0, description="Unique action types")
    success_rate: float = Field(..., ge=0, le=100, description="Success rate %")
    
    # Category breakdown
    categories: Dict[str, int] = Field(
        default_factory=dict,
        description="Action count by category",
    )
    
    # Performance metrics
    average_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Average response time",
    )

    @computed_field
    @property
    def activity_level(self) -> str:
        """Categorize activity level."""
        if self.action_count >= 50:
            return "High"
        elif self.action_count >= 20:
            return "Medium"
        elif self.action_count >= 5:
            return "Low"
        else:
            return "Minimal"


class ActivityMetrics(BaseSchema):
    """
    Comprehensive activity metrics for performance analysis.
    
    Aggregated metrics for supervisor activity assessment.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    period_start: datetime = Field(..., description="Metrics period start")
    period_end: datetime = Field(..., description="Metrics period end")
    
    # Volume metrics
    total_actions: int = Field(..., ge=0, description="Total actions performed")
    unique_action_types: int = Field(..., ge=0, description="Unique action types")
    active_days: int = Field(..., ge=0, description="Days with activity")
    
    # Performance metrics
    overall_success_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Overall success rate percentage",
    )
    average_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Average response time",
    )
    
    # Category distribution
    actions_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Action count by category",
    )
    
    # Peak activity analysis
    peak_hour: Optional[int] = Field(
        default=None,
        ge=0,
        le=23,
        description="Hour with most activity (0-23)",
    )
    peak_day_of_week: Optional[int] = Field(
        default=None,
        ge=0,
        le=6,
        description="Day of week with most activity (0=Monday)",
    )
    
    # Efficiency metrics
    actions_per_day: float = Field(
        ...,
        ge=0,
        description="Average actions per active day",
    )
    response_time_trend: Optional[str] = Field(
        default=None,
        pattern=r"^(improving|stable|declining)$",
        description="Response time trend",
    )

    @computed_field
    @property
    def activity_score(self) -> float:
        """Calculate overall activity score (0-100)."""
        # Weighted scoring based on volume, consistency, and performance
        volume_score = min(self.total_actions / 100 * 40, 40)  # Max 40 points
        consistency_score = min(self.active_days / 30 * 30, 30)  # Max 30 points
        performance_score = self.overall_success_rate * 0.3  # Max 30 points
        
        return round(volume_score + consistency_score + performance_score, 2)

    @computed_field
    @property
    def productivity_level(self) -> str:
        """Categorize productivity level."""
        score = self.activity_score
        if score >= 80:
            return "Excellent"
        elif score >= 60:
            return "Good"
        elif score >= 40:
            return "Average"
        elif score >= 20:
            return "Below Average"
        else:
            return "Poor"


class ActivitySummary(BaseSchema):
    """
    Activity summary for supervisor dashboard.
    
    High-level activity overview with key insights.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    period_start: datetime = Field(..., description="Summary period start")
    period_end: datetime = Field(..., description="Summary period end")
    
    total_actions: int = Field(..., ge=0, description="Total actions")
    
    # Category breakdown
    actions_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of actions by category",
    )
    
    # Type breakdown
    actions_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of actions by type",
    )
    
    # Top activities
    top_activities: List[TopActivity] = Field(
        default_factory=list,
        max_length=10,
        description="Most frequent activities",
    )
    
    # Activity timeline
    activity_timeline: List[ActivityTimelinePoint] = Field(
        default_factory=list,
        description="Activity over time",
    )
    
    # Performance insights
    peak_hours: List[int] = Field(
        default_factory=list,
        description="Hours with most activity (0-23)",
    )
    most_productive_day: Optional[str] = Field(
        default=None,
        description="Day of week with highest activity",
    )
    
    # Efficiency metrics
    average_daily_actions: float = Field(
        ...,
        ge=0,
        description="Average actions per day",
    )
    success_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Overall success rate",
    )

    @computed_field
    @property
    def most_common_activity(self) -> Optional[str]:
        """Get most frequently performed activity."""
        if not self.top_activities:
            return None
        return self.top_activities[0].action_display_name

    @computed_field
    @property
    def activity_consistency(self) -> str:
        """Assess activity consistency."""
        if not self.activity_timeline:
            return "Unknown"
        
        # Calculate coefficient of variation
        counts = [point.action_count for point in self.activity_timeline]
        if not counts:
            return "No Data"
        
        mean_count = sum(counts) / len(counts)
        if mean_count == 0:
            return "No Activity"
        
        variance = sum((x - mean_count) ** 2 for x in counts) / len(counts)
        cv = (variance ** 0.5) / mean_count
        
        if cv < 0.3:
            return "Very Consistent"
        elif cv < 0.6:
            return "Consistent"
        elif cv < 1.0:
            return "Moderately Variable"
        else:
            return "Highly Variable"


class ActivityFilterParams(BaseFilterSchema):
    """
    Enhanced filter parameters for activity logs.
    
    Comprehensive filtering with performance optimizations.
    """

    # Supervisor filters
    supervisor_id: Optional[str] = Field(
        default=None,
        description="Filter by specific supervisor",
    )
    supervisor_ids: Optional[List[str]] = Field(
        default=None,
        max_length=20,
        description="Filter by multiple supervisors (max 20)",
    )
    
    # Hostel filter
    hostel_id: Optional[str] = Field(
        default=None,
        description="Filter by hostel",
    )
    
    # Time range
    date_range: Optional[DateTimeRangeFilter] = Field(
        default=None,
        description="Filter by Date/time range",
    )
    
    # Action filters
    action_category: Optional[AuditActionCategory] = Field(
        default=None,
        description="Filter by action category",
    )
    action_categories: Optional[List[AuditActionCategory]] = Field(
        default=None,
        max_length=10,
        description="Filter by multiple categories",
    )
    action_type: Optional[str] = Field(
        default=None,
        description="Filter by specific action type",
    )
    action_types: Optional[List[str]] = Field(
        default=None,
        max_length=20,
        description="Filter by multiple action types",
    )
    
    # Entity filter
    entity_type: Optional[str] = Field(
        default=None,
        description="Filter by entity type",
    )
    entity_id: Optional[str] = Field(
        default=None,
        description="Filter by specific entity",
    )
    
    # Success filter
    success_only: Optional[bool] = Field(
        default=None,
        description="Show only successful actions",
    )
    failed_only: Optional[bool] = Field(
        default=None,
        description="Show only failed actions",
    )
    
    # Performance filters
    min_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum response time filter",
    )
    max_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Maximum response time filter",
    )
    
    # Device filters
    device_type: Optional[str] = Field(
        default=None,
        pattern=r"^(mobile|desktop|tablet)$",
        description="Filter by device type",
    )
    
    # Pagination and sorting
    page: int = Field(default=1, ge=1, description="Page number")
    page_size: int = Field(default=50, ge=1, le=100, description="Items per page")
    sort_by: str = Field(
        default="created_at",
        pattern=r"^(created_at|action_type|success|response_time_ms)$",
        description="Sort field",
    )
    sort_order: str = Field(
        default="desc",
        pattern=r"^(asc|desc)$",
        description="Sort order",
    )

    @field_validator("supervisor_ids")
    @classmethod
    def validate_supervisor_ids(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Validate supervisor IDs list."""
        if v is not None:
            # Remove duplicates while preserving order
            seen = set()
            unique_ids = []
            for supervisor_id in v:
                if supervisor_id not in seen:
                    seen.add(supervisor_id)
                    unique_ids.append(supervisor_id)
            return unique_ids
        return v

    @model_validator(mode="after")
    def validate_filter_consistency(self) -> "ActivityFilterParams":
        """Validate filter consistency."""
        # Can't have both success_only and failed_only
        if self.success_only and self.failed_only:
            raise ValueError("Cannot filter for both success_only and failed_only")
        
        # Validate response time range
        if (self.min_response_time_ms is not None and 
            self.max_response_time_ms is not None and
            self.min_response_time_ms > self.max_response_time_ms):
            raise ValueError("min_response_time_ms cannot be greater than max_response_time_ms")
        
        return self


class ActivityExportRequest(BaseCreateSchema):
    """
    Export activity logs with customizable format and fields.
    
    Supports various export formats with field selection.
    """

    filters: ActivityFilterParams = Field(
        ...,
        description="Filter criteria for export",
    )
    format: str = Field(
        default="csv",
        pattern=r"^(csv|excel|pdf|json)$",
        description="Export file format",
    )
    
    # Field selection
    include_metadata: bool = Field(
        default=False,
        description="Include full metadata in export",
    )
    include_technical_details: bool = Field(
        default=False,
        description="Include IP, user agent, etc.",
    )
    include_performance_metrics: bool = Field(
        default=True,
        description="Include response times and success rates",
    )
    include_change_tracking: bool = Field(
        default=False,
        description="Include old/new values for changes",
    )
    
    # Grouping options
    group_by_category: bool = Field(
        default=False,
        description="Group activities by category",
    )
    group_by_date: bool = Field(
        default=False,
        description="Group activities by Date",
    )
    
    # Summary options
    include_summary: bool = Field(
        default=True,
        description="Include summary statistics",
    )
    include_charts: bool = Field(
        default=False,
        description="Include charts (for PDF/Excel)",
    )

    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize format to lowercase."""
        return v.lower().strip()

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\supervisor\supervisor_assignment.py ---
# --- File: app/schemas/supervisor/supervisor_assignment.py ---
"""
Supervisor assignment schemas with enhanced validation.

Manages supervisor-hostel assignments with proper tracking,
permission management, and transfer handling.
"""

from __future__ import annotations

from datetime import datetime, timedelta, date as Date
from typing import Optional
from decimal import Decimal

from pydantic import Field, field_validator, model_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import PermissionLevel

__all__ = [
    "SupervisorAssignment",
    "AssignmentRequest",
    "AssignmentUpdate",
    "RevokeAssignmentRequest",
    "AssignmentTransfer",
    "AssignmentSummary",
]


class SupervisorAssignment(BaseResponseSchema):
    """
    Supervisor-hostel assignment response.
    
    Complete assignment information with metadata.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    supervisor_email: str = Field(..., description="Supervisor email")
    
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    assigned_by: str = Field(..., description="Admin who assigned")
    assigned_by_name: str = Field(..., description="Admin name")
    assigned_date: Date = Field(..., description="Assignment Date")
    
    is_active: bool = Field(..., description="Assignment is active")
    
    # Permission summary
    permission_level: str = Field(
        ...,
        description="Summary of permission level",
        examples=["Full Access", "Standard Access", "Limited Access"],
    )
    
    # Activity tracking
    last_active: Optional[datetime] = Field(
        default=None,
        description="Last activity timestamp",
    )
    total_days_assigned: int = Field(
        default=0,
        ge=0,
        description="Total days in current assignment",
    )

    @computed_field
    @property
    def assignment_duration_months(self) -> int:
        """Calculate assignment duration in months."""
        return self.total_days_assigned // 30


class AssignmentRequest(BaseCreateSchema):
    """
    Request to assign supervisor to hostel.
    
    Creates new supervisor-hostel assignment with employment details.
    """

    user_id: str = Field(
        ...,
        description="User ID to assign as supervisor",
    )
    hostel_id: str = Field(
        ...,
        description="Hostel ID",
    )
    
    # Employment details
    employee_id: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Employee/Staff ID",
    )
    join_date: Date = Field(
        ...,
        description="Joining Date",
    )
    employment_type: str = Field(
        default="full_time",
        pattern=r"^(full_time|part_time|contract)$",
        description="Employment type",
    )
    shift_timing: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Shift timing",
    )
    
    # Permissions (optional, will use defaults)
    permissions: Optional[dict] = Field(
        default=None,
        description="Custom permissions (uses template defaults if not provided)",
    )
    permission_template: Optional[str] = Field(
        default="junior_supervisor",
        description="Permission template to apply",
    )

    @field_validator("join_date")
    @classmethod
    def validate_join_date(cls, v: Date) -> Date:
        """Validate join Date is reasonable."""
        today = Date.today()
        
        # Allow up to 30 days in future for scheduled assignments
        if v > today + timedelta(days=30):
            raise ValueError("Join Date cannot be more than 30 days in the future")
        
        # Allow up to 1 year in past for historical data entry
        if v < today - timedelta(days=365):
            raise ValueError("Join Date cannot be more than 1 year in the past")
        
        return v

    @field_validator("employment_type")
    @classmethod
    def normalize_employment_type(cls, v: str) -> str:
        """Normalize employment type to lowercase."""
        return v.lower().strip()


class AssignmentUpdate(BaseUpdateSchema):
    """
    Update supervisor assignment details.
    
    Allows modification of employment details and assignment status.
    """

    employee_id: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Employee ID",
    )
    employment_type: Optional[str] = Field(
        default=None,
        pattern=r"^(full_time|part_time|contract)$",
        description="Employment type",
    )
    shift_timing: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Shift timing",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Assignment active status",
    )
    
    # Permission updates
    permissions: Optional[dict] = Field(
        default=None,
        description="Updated permissions",
    )

    @field_validator("employment_type")
    @classmethod
    def normalize_employment_type(cls, v: Optional[str]) -> Optional[str]:
        """Normalize employment type."""
        return v.lower().strip() if v else None


class RevokeAssignmentRequest(BaseCreateSchema):
    """
    Revoke supervisor assignment.
    
    Handles assignment revocation with handover support.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID",
    )
    revoke_date: Date = Field(
        ...,
        description="Effective revocation Date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for revocation",
    )
    
    # Handover
    handover_to_supervisor_id: Optional[str] = Field(
        default=None,
        description="Transfer responsibilities to another supervisor",
    )
    handover_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Handover instructions",
    )
    handover_period_days: int = Field(
        default=7,
        ge=0,
        le=30,
        description="Handover period in days",
    )

    @field_validator("revoke_date")
    @classmethod
    def validate_revoke_date(cls, v: Date) -> Date:
        """Validate revocation Date."""
        today = Date.today()
        
        # Can't revoke in past (except today)
        if v < today:
            raise ValueError("Revoke Date cannot be in the past")
        
        # Limit future revocation
        if v > today + timedelta(days=90):
            raise ValueError("Revoke Date cannot be more than 90 days in future")
        
        return v

    @model_validator(mode="after")
    def validate_handover_consistency(self) -> "RevokeAssignmentRequest":
        """Validate handover requirements."""
        if self.handover_to_supervisor_id:
            if not self.handover_notes:
                raise ValueError(
                    "handover_notes required when transferring to another supervisor"
                )
        
        return self


class AssignmentTransfer(BaseCreateSchema):
    """
    Transfer supervisor to different hostel.
    
    Manages supervisor reassignment between hostels with permission handling.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID",
    )
    from_hostel_id: str = Field(
        ...,
        description="Current hostel",
    )
    to_hostel_id: str = Field(
        ...,
        description="New hostel",
    )
    transfer_date: Date = Field(
        ...,
        description="Transfer effective Date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Transfer reason",
    )
    
    # Permission handling
    retain_permissions: bool = Field(
        default=True,
        description="Keep same permission set",
    )
    new_permissions: Optional[dict] = Field(
        default=None,
        description="New permissions if not retaining",
    )
    permission_template: Optional[str] = Field(
        default=None,
        description="Permission template to apply at new hostel",
    )

    @field_validator("transfer_date")
    @classmethod
    def validate_transfer_date(cls, v: Date) -> Date:
        """Validate transfer Date."""
        today = Date.today()
        
        if v < today:
            raise ValueError("Transfer Date cannot be in the past")
        
        if v > today + timedelta(days=90):
            raise ValueError("Transfer Date cannot be more than 90 days in future")
        
        return v

    @model_validator(mode="after")
    def validate_transfer_logic(self) -> "AssignmentTransfer":
        """Validate transfer business logic."""
        # Different hostels required
        if self.from_hostel_id == self.to_hostel_id:
            raise ValueError("from_hostel_id and to_hostel_id must be different")
        
        # Permission configuration
        if not self.retain_permissions:
            if not self.new_permissions and not self.permission_template:
                raise ValueError(
                    "Must provide new_permissions or permission_template "
                    "when not retaining permissions"
                )
        
        return self


class AssignmentSummary(BaseSchema):
    """
    Assignment summary for reporting.
    
    Aggregated assignment information for dashboards and reports.
    """

    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Assignment counts
    total_supervisors: int = Field(
        default=0,
        ge=0,
        description="Total assigned supervisors",
    )
    active_supervisors: int = Field(
        default=0,
        ge=0,
        description="Currently active supervisors",
    )
    on_leave_supervisors: int = Field(
        default=0,
        ge=0,
        description="Supervisors on leave",
    )
    
    # Activity metrics
    supervisors_online_now: int = Field(
        default=0,
        ge=0,
        description="Currently online",
    )
    supervisors_active_today: int = Field(
        default=0,
        ge=0,
        description="Active today",
    )
    
    # Performance summary
    average_performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average performance rating",
    )
    
    # Coverage
    shift_coverage: dict = Field(
        default_factory=dict,
        description="Coverage by shift",
    )

    @computed_field
    @property
    def active_percentage(self) -> Decimal:
        """Calculate percentage of active supervisors."""
        if self.total_supervisors == 0:
            return Decimal("100.00")
        
        rate = (self.active_supervisors / self.total_supervisors * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def needs_coverage(self) -> bool:
        """Check if hostel needs more supervisor coverage."""
        return self.active_supervisors < 1

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\supervisor\supervisor_base.py ---
# --- File: app/schemas/supervisor/supervisor_base.py ---
"""
Supervisor base schemas with enhanced validation and type safety.

Provides core supervisor management schemas including creation, updates,
status management, and hostel reassignment with comprehensive validation.
"""

from __future__ import annotations

from datetime import date as Date, timedelta
from decimal import Decimal
from typing import Dict, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import EmploymentType, SupervisorStatus

__all__ = [
    "SupervisorBase",
    "SupervisorCreate",
    "SupervisorUpdate",
    "SupervisorStatusUpdate",
    "SupervisorReassignment",
    "SupervisorTermination",
]


# Constants for validation
class SupervisorValidationConstants:
    """Centralized validation constants for supervisor operations."""
    
    MAX_FUTURE_JOIN_DAYS = 30
    MAX_PAST_JOIN_YEARS = 50
    MIN_HANDOVER_PERIOD_DAYS = 0
    MAX_HANDOVER_PERIOD_DAYS = 30
    MAX_FUTURE_EFFECTIVE_DAYS = 30
    MAX_PAST_EFFECTIVE_DAYS = 7
    MAX_FUTURE_REASSIGNMENT_DAYS = 90
    MAX_FUTURE_TERMINATION_DAYS = 90
    MAX_PAST_TERMINATION_DAYS = 30
    MIN_REASON_LENGTH = 10
    MAX_REASON_LENGTH = 500
    MAX_NOTES_LENGTH = 1000
    MAX_EMPLOYEE_ID_LENGTH = 100
    MAX_DESIGNATION_LENGTH = 100
    MAX_SHIFT_TIMING_LENGTH = 100
    MIN_SALARY = 0
    MAX_PROBATION_MONTHS = 3


class SupervisorBase(BaseSchema):
    """
    Base supervisor schema with core attributes.
    
    Contains common fields shared across supervisor operations including
    employment details and assignment information.
    """

    user_id: str = Field(
        ...,
        description="Associated user account ID",
    )
    assigned_hostel_id: str = Field(
        ...,
        description="Currently assigned hostel ID",
    )

    # Employment details
    employee_id: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_EMPLOYEE_ID_LENGTH,
        description="Employee/Staff ID number",
        examples=["EMP001", "SUP-2024-001"],
    )
    join_date: Date = Field(
        ...,
        description="Joining/start Date",
    )
    employment_type: EmploymentType = Field(
        default=EmploymentType.FULL_TIME,
        description="Employment type/contract",
    )
    shift_timing: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_SHIFT_TIMING_LENGTH,
        description="Shift timing or working hours",
        examples=["9 AM - 6 PM", "Morning Shift", "24x7 Rotating"],
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_DESIGNATION_LENGTH,
        description="Job designation/title",
        examples=["Hostel Supervisor", "Senior Supervisor", "Floor Supervisor"],
    )
    salary: Optional[Decimal] = Field(
        default=None,
        ge=SupervisorValidationConstants.MIN_SALARY,
        max_digits=10,
        decimal_places=2,
        description="Monthly salary (confidential)",
    )

    @field_validator("employee_id", "shift_timing", "designation")
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """
        Normalize text fields by trimming and cleaning whitespace.
        
        Args:
            v: Input string value
            
        Returns:
            Normalized string or None if empty
        """
        if v is None:
            return None
        
        v = v.strip()
        if not v:
            return None
        
        # Remove excessive whitespace while preserving single spaces
        normalized = " ".join(v.split())
        
        return normalized

    @field_validator("join_date")
    @classmethod
    def validate_join_date(cls, v: Date) -> Date:
        """
        Validate join Date is within reasonable bounds.
        
        Args:
            v: Join Date to validate
            
        Returns:
            Validated join Date
            
        Raises:
            ValueError: If Date is outside acceptable range
        """
        today = Date.today()
        
        # Future Date validation
        max_future = today + timedelta(days=SupervisorValidationConstants.MAX_FUTURE_JOIN_DAYS)
        if v > max_future:
            raise ValueError(
                f"Join Date cannot be more than {SupervisorValidationConstants.MAX_FUTURE_JOIN_DAYS} days in the future"
            )
        
        # Past Date validation
        max_past = today - timedelta(days=365 * SupervisorValidationConstants.MAX_PAST_JOIN_YEARS)
        if v < max_past:
            raise ValueError(
                f"Join Date cannot be more than {SupervisorValidationConstants.MAX_PAST_JOIN_YEARS} years in the past"
            )
        
        return v

    @model_validator(mode="after")
    def validate_employment_consistency(self) -> "SupervisorBase":
        """
        Validate employment data consistency.
        
        Returns:
            Self with validated data
        """
        # Contract employees should have employee_id
        if self.employment_type == EmploymentType.CONTRACT and not self.employee_id:
            # Warning only - don't enforce
            pass
        
        return self


class SupervisorCreate(SupervisorBase, BaseCreateSchema):
    """
    Schema for creating a new supervisor.
    
    Used when assigning a user as supervisor to a hostel.
    Includes assignment tracking and initial permission configuration.
    """

    user_id: str = Field(
        ...,
        description="User ID to assign as supervisor (required)",
    )
    assigned_hostel_id: str = Field(
        ...,
        description="Hostel ID to assign supervisor to (required)",
    )
    join_date: Date = Field(
        ...,
        description="Joining Date (required)",
    )
    assigned_by: str = Field(
        ...,
        description="Admin user ID who is assigning the supervisor",
    )

    # Initial permissions (optional, defaults will be applied)
    permissions: Optional[Dict[str, bool | int | Decimal]] = Field(
        default=None,
        description="Initial permission settings (uses defaults if not provided)",
    )
    
    # Assignment metadata
    assignment_notes: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Notes about the assignment",
    )

    @field_validator("permissions")
    @classmethod
    def validate_permissions_structure(
        cls, 
        v: Optional[Dict[str, bool | int | Decimal]]
    ) -> Optional[Dict[str, bool | int | Decimal]]:
        """
        Validate permissions dictionary structure.
        
        Args:
            v: Permissions dictionary
            
        Returns:
            Validated permissions
        """
        if v is None:
            return None
        
        # Ensure all values are of correct types
        for key, value in v.items():
            if not isinstance(value, (bool, int, float, Decimal)):
                raise ValueError(
                    f"Permission '{key}' has invalid value type. "
                    f"Expected bool, int, or Decimal, got {type(value).__name__}"
                )
        
        return v


class SupervisorUpdate(BaseUpdateSchema):
    """
    Schema for updating supervisor information.
    
    All fields are optional for partial updates.
    Includes permission updates and status changes.
    """

    # Employment details
    employee_id: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_EMPLOYEE_ID_LENGTH,
        description="Employee ID",
    )
    employment_type: Optional[EmploymentType] = Field(
        default=None,
        description="Employment type",
    )
    shift_timing: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_SHIFT_TIMING_LENGTH,
        description="Shift timing",
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_DESIGNATION_LENGTH,
        description="Designation",
    )
    salary: Optional[Decimal] = Field(
        default=None,
        ge=SupervisorValidationConstants.MIN_SALARY,
        max_digits=10,
        decimal_places=2,
        description="Monthly salary",
    )

    # Status
    status: Optional[SupervisorStatus] = Field(
        default=None,
        description="Supervisor status",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Active status",
    )

    # Permissions
    permissions: Optional[Dict[str, bool | int | Decimal]] = Field(
        default=None,
        description="Updated permission settings",
    )

    # Notes
    notes: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Additional notes",
    )

    @field_validator("employee_id", "shift_timing", "designation")
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is None:
            return None
        
        v = v.strip()
        if not v:
            return None
        
        return " ".join(v.split())

    @model_validator(mode="after")
    def validate_status_consistency(self) -> "SupervisorUpdate":
        """
        Validate status and is_active consistency.
        
        Returns:
            Self with validated data
        """
        # If setting to inactive status, ensure is_active is False
        if self.status in [SupervisorStatus.TERMINATED, SupervisorStatus.SUSPENDED]:
            if self.is_active is True:
                raise ValueError(
                    f"Cannot set is_active=True when status is {self.status.value}"
                )
        
        return self


class SupervisorStatusUpdate(BaseUpdateSchema):
    """
    Schema for updating supervisor status.
    
    Handles status transitions with proper documentation and validation.
    Supports termination, suspension, and leave management.
    """

    status: SupervisorStatus = Field(
        ...,
        description="New supervisor status",
    )
    is_active: bool = Field(
        ...,
        description="Active status (false for terminated/suspended)",
    )
    effective_date: Date = Field(
        ...,
        description="Status change effective Date",
    )
    reason: str = Field(
        ...,
        min_length=SupervisorValidationConstants.MIN_REASON_LENGTH,
        max_length=SupervisorValidationConstants.MAX_REASON_LENGTH,
        description="Reason for status change",
    )

    # Termination-specific fields
    termination_date: Optional[Date] = Field(
        default=None,
        description="Termination Date (required if status is TERMINATED)",
    )
    termination_reason: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_REASON_LENGTH,
        description="Detailed termination reason",
    )
    eligible_for_rehire: Optional[bool] = Field(
        default=None,
        description="Eligible for rehire in future",
    )

    # Suspension-specific fields
    suspension_start_date: Optional[Date] = Field(
        default=None,
        description="Suspension start Date (required if SUSPENDED)",
    )
    suspension_end_date: Optional[Date] = Field(
        default=None,
        description="Expected suspension end Date (required if SUSPENDED)",
    )
    suspension_reason: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_REASON_LENGTH,
        description="Detailed suspension reason",
    )

    # Leave-specific fields
    leave_start_date: Optional[Date] = Field(
        default=None,
        description="Leave start Date (required if ON_LEAVE)",
    )
    leave_end_date: Optional[Date] = Field(
        default=None,
        description="Expected return Date from leave (required if ON_LEAVE)",
    )
    leave_type: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Type of leave (sick, vacation, etc.)",
    )

    # Handover details
    handover_to: Optional[str] = Field(
        default=None,
        description="Supervisor ID for responsibility handover",
    )
    handover_notes: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Handover instructions",
    )

    @field_validator("effective_date")
    @classmethod
    def validate_effective_date(cls, v: Date) -> Date:
        """Validate effective Date is within acceptable range."""
        today = Date.today()
        
        min_date = today - timedelta(days=SupervisorValidationConstants.MAX_PAST_EFFECTIVE_DAYS)
        max_date = today + timedelta(days=SupervisorValidationConstants.MAX_FUTURE_EFFECTIVE_DAYS)
        
        if v < min_date:
            raise ValueError(
                f"Effective Date cannot be more than {SupervisorValidationConstants.MAX_PAST_EFFECTIVE_DAYS} days in the past"
            )
        
        if v > max_date:
            raise ValueError(
                f"Effective Date cannot be more than {SupervisorValidationConstants.MAX_FUTURE_EFFECTIVE_DAYS} days in the future"
            )
        
        return v

    @model_validator(mode="after")
    def validate_status_specific_requirements(self) -> "SupervisorStatusUpdate":
        """
        Validate status-specific required fields and constraints.
        
        Returns:
            Self with validated data
            
        Raises:
            ValueError: If required fields are missing for specific statuses
        """
        # Termination validation
        if self.status == SupervisorStatus.TERMINATED:
            if not self.termination_date:
                raise ValueError("termination_date is required for TERMINATED status")
            if not self.termination_reason:
                raise ValueError("termination_reason is required for TERMINATED status")
            if self.is_active:
                raise ValueError("is_active must be False for TERMINATED status")
        
        # Suspension validation
        if self.status == SupervisorStatus.SUSPENDED:
            if not self.suspension_start_date:
                raise ValueError("suspension_start_date is required for SUSPENDED status")
            if not self.suspension_end_date:
                raise ValueError("suspension_end_date is required for SUSPENDED status")
            if not self.suspension_reason:
                raise ValueError("suspension_reason is required for SUSPENDED status")
            if self.is_active:
                raise ValueError("is_active must be False for SUSPENDED status")
        
        # Leave validation
        if self.status == SupervisorStatus.ON_LEAVE:
            if not self.leave_start_date:
                raise ValueError("leave_start_date is required for ON_LEAVE status")
            if not self.leave_end_date:
                raise ValueError("leave_end_date is required for ON_LEAVE status")
        
        return self

    @model_validator(mode="after")
    def validate_date_ranges(self) -> "SupervisorStatusUpdate":
        """
        Validate Date range consistency for suspension and leave.
        
        Returns:
            Self with validated dates
            
        Raises:
            ValueError: If end dates are before start dates
        """
        # Suspension Date range
        if self.suspension_start_date and self.suspension_end_date:
            if self.suspension_end_date <= self.suspension_start_date:
                raise ValueError("suspension_end_date must be after suspension_start_date")
        
        # Leave Date range
        if self.leave_start_date and self.leave_end_date:
            if self.leave_end_date <= self.leave_start_date:
                raise ValueError("leave_end_date must be after leave_start_date")
        
        return self


class SupervisorReassignment(BaseCreateSchema):
    """
    Schema for reassigning supervisor to different hostel.
    
    Handles supervisor transfer between hostels with proper tracking,
    permission handling, and optional salary adjustments.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID to reassign",
    )
    from_hostel_id: str = Field(
        ...,
        description="Current hostel ID",
    )
    new_hostel_id: str = Field(
        ...,
        description="New hostel ID to assign",
    )
    effective_date: Date = Field(
        ...,
        description="Reassignment effective Date",
    )
    reason: str = Field(
        ...,
        min_length=SupervisorValidationConstants.MIN_REASON_LENGTH,
        max_length=SupervisorValidationConstants.MAX_REASON_LENGTH,
        description="Reason for reassignment",
        examples=[
            "Staff shortage at new hostel",
            "Performance-based transfer",
            "Personal request",
            "Organizational restructuring",
        ],
    )

    # Permission handling
    retain_permissions: bool = Field(
        default=True,
        description="Retain same permission set at new hostel",
    )
    new_permissions: Optional[Dict[str, bool | int | Decimal]] = Field(
        default=None,
        description="New permission set (required if not retaining)",
    )

    # Salary adjustment
    salary_adjustment: Optional[Decimal] = Field(
        default=None,
        max_digits=10,
        decimal_places=2,
        description="Salary adjustment amount (positive or negative)",
    )
    salary_adjustment_reason: Optional[str] = Field(
        default=None,
        max_length=200,
        description="Reason for salary adjustment",
    )

    # Handover configuration
    handover_period_days: int = Field(
        default=7,
        ge=SupervisorValidationConstants.MIN_HANDOVER_PERIOD_DAYS,
        le=SupervisorValidationConstants.MAX_HANDOVER_PERIOD_DAYS,
        description="Handover period in days",
    )
    handover_to: Optional[str] = Field(
        default=None,
        description="Supervisor ID for handover at current hostel",
    )

    @field_validator("effective_date")
    @classmethod
    def validate_effective_date(cls, v: Date) -> Date:
        """Validate effective Date is in acceptable future range."""
        today = Date.today()
        
        if v < today:
            raise ValueError("Effective Date cannot be in the past")
        
        max_date = today + timedelta(days=SupervisorValidationConstants.MAX_FUTURE_REASSIGNMENT_DAYS)
        if v > max_date:
            raise ValueError(
                f"Effective Date cannot be more than {SupervisorValidationConstants.MAX_FUTURE_REASSIGNMENT_DAYS} days in the future"
            )
        
        return v

    @model_validator(mode="after")
    def validate_reassignment_logic(self) -> "SupervisorReassignment":
        """
        Validate reassignment business logic.
        
        Returns:
            Self with validated data
            
        Raises:
            ValueError: If reassignment logic is invalid
        """
        # Different hostel validation
        if self.from_hostel_id == self.new_hostel_id:
            raise ValueError("New hostel must be different from current hostel")
        
        # Permission configuration validation
        if not self.retain_permissions and not self.new_permissions:
            raise ValueError(
                "new_permissions must be provided when retain_permissions is False"
            )
        
        # Salary adjustment validation
        if self.salary_adjustment is not None and self.salary_adjustment != 0:
            if not self.salary_adjustment_reason:
                raise ValueError(
                    "salary_adjustment_reason is required when adjusting salary"
                )
        
        return self


class SupervisorTermination(BaseCreateSchema):
    """
    Schema for comprehensive supervisor termination.
    
    Handles complete termination process including exit interview,
    clearance verification, asset return, and final settlement.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID to terminate",
    )
    termination_date: Date = Field(
        ...,
        description="Termination effective Date",
    )
    termination_type: str = Field(
        ...,
        pattern=r"^(voluntary|involuntary|retirement|end_of_contract)$",
        description="Type of termination",
        examples=["voluntary", "involuntary", "retirement", "end_of_contract"],
    )
    reason: str = Field(
        ...,
        min_length=20,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Detailed termination reason",
    )

    # Notice period
    notice_period_served: bool = Field(
        ...,
        description="Whether notice period was served",
    )
    notice_period_days: Optional[int] = Field(
        default=None,
        ge=0,
        le=90,
        description="Notice period served in days",
    )

    # Clearance checklist
    hostel_clearance_obtained: bool = Field(
        default=False,
        description="Hostel clearance completed",
    )
    finance_clearance_obtained: bool = Field(
        default=False,
        description="Finance clearance completed",
    )
    admin_clearance_obtained: bool = Field(
        default=False,
        description="Admin clearance completed",
    )

    # Asset management
    assets_returned: bool = Field(
        default=False,
        description="All hostel assets returned",
    )
    asset_list: Optional[str] = Field(
        default=None,
        max_length=500,
        description="List of assets returned",
    )

    # Exit interview
    exit_interview_conducted: bool = Field(
        default=False,
        description="Exit interview completed",
    )
    exit_interview_notes: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Exit interview notes",
    )

    # Rehire eligibility
    eligible_for_rehire: bool = Field(
        ...,
        description="Eligible for future rehire",
    )
    rehire_notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Notes on rehire eligibility",
    )

    # Final settlement
    final_settlement_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Final settlement amount",
    )
    settlement_date: Optional[Date] = Field(
        default=None,
        description="Settlement payment Date",
    )

    # Handover
    responsibilities_handover_to: Optional[str] = Field(
        default=None,
        description="Supervisor ID for handover",
    )
    handover_completed: bool = Field(
        default=False,
        description="Handover completion status",
    )
    handover_notes: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Handover notes",
    )

    @field_validator("termination_date")
    @classmethod
    def validate_termination_date(cls, v: Date) -> Date:
        """Validate termination Date is within acceptable range."""
        today = Date.today()
        
        min_date = today - timedelta(days=SupervisorValidationConstants.MAX_PAST_TERMINATION_DAYS)
        max_date = today + timedelta(days=SupervisorValidationConstants.MAX_FUTURE_TERMINATION_DAYS)
        
        if v < min_date:
            raise ValueError(
                f"Termination Date cannot be more than {SupervisorValidationConstants.MAX_PAST_TERMINATION_DAYS} days in the past"
            )
        
        if v > max_date:
            raise ValueError(
                f"Termination Date cannot be more than {SupervisorValidationConstants.MAX_FUTURE_TERMINATION_DAYS} days in the future"
            )
        
        return v

    @field_validator("termination_type")
    @classmethod
    def normalize_termination_type(cls, v: str) -> str:
        """Normalize termination type to lowercase."""
        return v.lower().strip()

    @model_validator(mode="after")
    def validate_termination_requirements(self) -> "SupervisorTermination":
        """
        Validate termination-specific business logic.
        
        Returns:
            Self with validated data
        """
        # Settlement validation
        if self.final_settlement_amount and self.final_settlement_amount > 0:
            if not self.settlement_date:
                raise ValueError(
                    "settlement_date is required when final_settlement_amount is provided"
                )
        
        # Notice period validation for voluntary termination
        if self.termination_type == "voluntary" and not self.notice_period_served:
            if self.notice_period_days is None or self.notice_period_days == 0:
                # Warning only - don't enforce strictly
                pass
        
        return self

    @model_validator(mode="after")
    def validate_clearance_completeness(self) -> "SupervisorTermination":
        """
        Validate clearance requirements for past terminations.
        
        Returns:
            Self with validation warnings (non-blocking)
        """
        # For past terminations, all clearances should ideally be complete
        if self.termination_date <= Date.today():
            incomplete_clearances = []
            
            if not self.hostel_clearance_obtained:
                incomplete_clearances.append("hostel")
            if not self.finance_clearance_obtained:
                incomplete_clearances.append("finance")
            if not self.admin_clearance_obtained:
                incomplete_clearances.append("admin")
            
            # Log warning but don't block (can be handled at service layer)
            if incomplete_clearances:
                # This would typically trigger a warning in logs
                pass
        
        return self

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\supervisor\supervisor_dashboard.py ---
# --- File: app/schemas/supervisor/supervisor_dashboard.py ---
"""
Supervisor dashboard schemas with real-time metrics and insights.

Provides comprehensive dashboard data with performance indicators,
task management, and actionable insights.
"""

from __future__ import annotations

from datetime import datetime, time, date as Date
from decimal import Decimal
from typing import Any, Dict, List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseSchema

__all__ = [
    "SupervisorDashboard",
    "DashboardMetrics",
    "TaskSummary",
    "RecentComplaintItem",
    "RecentMaintenanceItem",
    "PendingLeaveItem",
    "TodaySchedule",
    "DashboardAlert",
    "QuickActions",
    "PerformanceIndicators",
    "ScheduledMaintenanceItem",
    "ScheduledMeeting",
    "QuickAction",
]


class DashboardMetrics(BaseSchema):
    """
    Key performance metrics for supervisor dashboard.
    
    Real-time metrics with trend indicators and benchmarks.
    """

    # Student metrics
    total_students: int = Field(..., ge=0, description="Total students in hostel")
    active_students: int = Field(..., ge=0, description="Currently active students")
    students_on_leave: int = Field(..., ge=0, description="Students on approved leave")
    new_students_this_month: int = Field(..., ge=0, description="New admissions this month")
    
    # Occupancy metrics
    total_beds: int = Field(..., ge=0, description="Total bed capacity")
    occupied_beds: int = Field(..., ge=0, description="Currently occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current occupancy percentage",
    )
    occupancy_trend: str = Field(
        ...,
        pattern=r"^(increasing|stable|decreasing)$",
        description="Occupancy trend direction",
    )
    
    # Complaint metrics
    total_complaints: int = Field(..., ge=0, description="Total complaints (all time)")
    open_complaints: int = Field(..., ge=0, description="Currently open complaints")
    assigned_to_me: int = Field(..., ge=0, description="Complaints assigned to me")
    resolved_today: int = Field(..., ge=0, description="Complaints resolved today")
    resolved_this_week: int = Field(..., ge=0, description="Resolved this week")
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average resolution time in hours",
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="SLA compliance percentage",
    )
    
    # Maintenance metrics
    pending_maintenance: int = Field(..., ge=0, description="Pending maintenance requests")
    in_progress_maintenance: int = Field(..., ge=0, description="In-progress maintenance")
    completed_today: int = Field(..., ge=0, description="Completed today")
    overdue_maintenance: int = Field(..., ge=0, description="Overdue maintenance")
    maintenance_budget_used: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of maintenance budget used",
    )
    
    # Attendance metrics
    attendance_marked_today: bool = Field(..., description="Today's attendance marked")
    total_present_today: int = Field(..., ge=0, description="Students present today")
    total_absent_today: int = Field(..., ge=0, description="Students absent today")
    attendance_percentage_today: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Today's attendance percentage",
    )
    
    # Payment metrics (view-only)
    overdue_payments_count: int = Field(..., ge=0, description="Students with overdue payments")
    payment_collection_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Monthly payment collection rate",
    )
    
    # Communication metrics
    unread_admin_messages: int = Field(..., ge=0, description="Unread messages from admin")
    pending_announcements: int = Field(..., ge=0, description="Announcements pending approval")

    @computed_field
    @property
    def overall_health_score(self) -> Decimal:
        """Calculate overall hostel health score (0-100)."""
        # Weighted scoring based on key metrics
        occupancy_score = min(float(self.occupancy_percentage), 100) * 0.25
        complaint_score = max(0, 100 - (self.open_complaints * 5)) * 0.25
        maintenance_score = max(0, 100 - (self.pending_maintenance * 10)) * 0.25
        attendance_score = float(self.attendance_percentage_today) * 0.25
        
        total_score = occupancy_score + complaint_score + maintenance_score + attendance_score
        return Decimal(str(total_score)).quantize(Decimal("0.1"))

    @computed_field
    @property
    def needs_attention(self) -> List[str]:
        """Identify areas needing immediate attention."""
        issues = []
        
        if self.open_complaints > 5:
            issues.append("High number of open complaints")
        
        if self.overdue_maintenance > 0:
            issues.append("Overdue maintenance requests")
        
        if not self.attendance_marked_today:
            issues.append("Attendance not marked today")
        
        if self.occupancy_percentage < 70:
            issues.append("Low occupancy rate")
        
        if self.overdue_payments_count > 10:
            issues.append("Multiple overdue payments")
        
        return issues


class TaskSummary(BaseSchema):
    """
    Summary of pending tasks and priorities.
    
    Actionable task list with urgency indicators.
    """

    # High priority tasks
    urgent_complaints: int = Field(..., ge=0, description="Urgent complaints requiring attention")
    critical_maintenance: int = Field(..., ge=0, description="Critical maintenance requests")
    pending_leave_approvals: int = Field(..., ge=0, description="Leave requests awaiting approval")
    overdue_tasks: int = Field(..., ge=0, description="Overdue tasks")
    
    # Daily routine tasks
    attendance_pending: bool = Field(..., description="Daily attendance not yet marked")
    menu_published_today: bool = Field(..., description="Today's menu published")
    daily_inspection_done: bool = Field(..., description="Daily inspection completed")
    reports_pending: int = Field(..., ge=0, description="Reports pending submission")
    
    # Administrative tasks
    document_verifications_pending: int = Field(
        ...,
        ge=0,
        description="Student documents awaiting verification",
    )
    room_assignments_pending: int = Field(
        ...,
        ge=0,
        description="Room assignments to be processed",
    )
    
    # Overdue items
    overdue_complaint_resolutions: int = Field(
        ...,
        ge=0,
        description="Complaints past SLA deadline",
    )
    overdue_maintenance: int = Field(
        ...,
        ge=0,
        description="Maintenance past due Date",
    )
    
    # Total pending
    total_pending_tasks: int = Field(
        ...,
        ge=0,
        description="Total tasks requiring action",
    )

    @computed_field
    @property
    def priority_score(self) -> int:
        """Calculate task priority score (higher = more urgent)."""
        score = 0
        score += self.urgent_complaints * 10
        score += self.critical_maintenance * 8
        score += self.overdue_complaint_resolutions * 15
        score += self.overdue_maintenance * 12
        score += self.pending_leave_approvals * 3
        
        if self.attendance_pending:
            score += 20
        
        return score

    @computed_field
    @property
    def workload_level(self) -> str:
        """Assess current workload level."""
        if self.total_pending_tasks == 0:
            return "Light"
        elif self.total_pending_tasks <= 5:
            return "Moderate"
        elif self.total_pending_tasks <= 15:
            return "Heavy"
        else:
            return "Overwhelming"


class RecentComplaintItem(BaseSchema):
    """Recent complaint for dashboard display."""
    
    complaint_id: str = Field(..., description="Complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")
    title: str = Field(..., description="Complaint title")
    category: str = Field(..., description="Complaint category")
    priority: str = Field(..., description="Priority level")
    status: str = Field(..., description="Current status")
    
    # Student info
    student_name: str = Field(..., description="Student name")
    room_number: str = Field(..., description="Room number")
    
    # Timing
    created_at: datetime = Field(..., description="Complaint creation time")
    age_hours: int = Field(..., ge=0, description="Hours since creation")
    sla_deadline: Optional[datetime] = Field(
        default=None,
        description="SLA deadline for resolution",
    )

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if complaint is past SLA deadline."""
        if not self.sla_deadline:
            return False
        return datetime.now() > self.sla_deadline

    @computed_field
    @property
    def urgency_indicator(self) -> str:
        """Get urgency indicator for UI."""
        if self.is_overdue:
            return "overdue"
        elif self.priority in ["urgent", "high"]:
            return "urgent"
        elif self.age_hours > 24:
            return "attention"
        else:
            return "normal"


class RecentMaintenanceItem(BaseSchema):
    """Recent maintenance request for dashboard."""
    
    request_id: str = Field(..., description="Maintenance request ID")
    request_number: str = Field(..., description="Request reference number")
    title: str = Field(..., description="Maintenance title")
    category: str = Field(..., description="Maintenance category")
    priority: str = Field(..., description="Priority level")
    status: str = Field(..., description="Current status")
    
    # Location
    room_number: Optional[str] = Field(default=None, description="Room number")
    location_description: Optional[str] = Field(
        default=None,
        description="Location description",
    )
    
    # Cost and timing
    estimated_cost: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Estimated cost",
    )
    created_at: datetime = Field(..., description="Request creation time")
    scheduled_date: Optional[Date] = Field(
        default=None,
        description="Scheduled completion Date",
    )
    
    # Assignment
    assigned_to: Optional[str] = Field(
        default=None,
        description="Assigned staff/vendor",
    )

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if maintenance is overdue."""
        if not self.scheduled_date:
            return False
        return Date.today() > self.scheduled_date

    @computed_field
    @property
    def days_pending(self) -> int:
        """Calculate days since request creation."""
        return (datetime.now() - self.created_at).days


class PendingLeaveItem(BaseSchema):
    """Pending leave approval for dashboard."""
    
    leave_id: str = Field(..., description="Leave application ID")
    student_name: str = Field(..., description="Student name")
    room_number: str = Field(..., description="Room number")
    
    # Leave details
    leave_type: str = Field(..., description="Type of leave")
    from_date: Date = Field(..., description="Leave start Date")
    to_date: Date = Field(..., description="Leave end Date")
    total_days: int = Field(..., ge=1, description="Total leave days")
    reason: str = Field(..., description="Leave reason")
    
    # Application details
    applied_at: datetime = Field(..., description="Application timestamp")
    emergency_contact: Optional[str] = Field(
        default=None,
        description="Emergency contact during leave",
    )
    supporting_documents: bool = Field(
        default=False,
        description="Supporting documents provided",
    )

    @computed_field
    @property
    def is_urgent(self) -> bool:
        """Check if leave approval is urgent."""
        # Urgent if leave starts within 2 days
        return (self.from_date - Date.today()).days <= 2

    @computed_field
    @property
    def pending_days(self) -> int:
        """Days since application was submitted."""
        return (datetime.now() - self.applied_at).days


class ScheduledMaintenanceItem(BaseSchema):
    """Scheduled maintenance for today."""
    
    maintenance_id: str = Field(..., description="Maintenance ID")
    title: str = Field(..., description="Maintenance title")
    scheduled_time: time = Field(..., description="Scheduled time")
    estimated_duration_hours: Optional[int] = Field(
        default=None,
        ge=1,
        description="Estimated duration in hours",
    )
    room_number: Optional[str] = Field(default=None, description="Room number")
    assigned_staff: Optional[str] = Field(default=None, description="Assigned staff")
    priority: str = Field(..., description="Priority level")


class ScheduledMeeting(BaseSchema):
    """Scheduled meeting for today."""
    
    meeting_id: str = Field(..., description="Meeting ID")
    title: str = Field(..., description="Meeting title")
    start_time: time = Field(..., description="Meeting start time")
    end_time: time = Field(..., description="Meeting end time")
    attendees: List[str] = Field(default_factory=list, description="Attendee names")
    location: str = Field(..., description="Meeting location")
    meeting_type: str = Field(
        ...,
        pattern=r"^(staff|admin|student|vendor|other)$",
        description="Type of meeting",
    )


class TodaySchedule(BaseSchema):
    """Today's schedule and planned activities."""
    
    date: Date = Field(..., description="Schedule Date")
    
    # Routine tasks
    attendance_marking_time: time = Field(
        ...,
        description="Expected time for attendance marking",
    )
    inspection_rounds: List[str] = Field(
        default_factory=list,
        description="Scheduled inspection areas",
    )
    
    # Scheduled activities
    scheduled_maintenance: List[ScheduledMaintenanceItem] = Field(
        default_factory=list,
        description="Maintenance scheduled for today",
    )
    scheduled_meetings: List[ScheduledMeeting] = Field(
        default_factory=list,
        description="Meetings scheduled for today",
    )
    
    # Special events
    special_events: List[str] = Field(
        default_factory=list,
        description="Special events or occasions",
    )
    
    # Deadlines
    report_deadlines: List[str] = Field(
        default_factory=list,
        description="Reports due today",
    )

    @computed_field
    @property
    def total_scheduled_items(self) -> int:
        """Count total scheduled items for the day."""
        return (
            len(self.scheduled_maintenance) +
            len(self.scheduled_meetings) +
            len(self.special_events) +
            len(self.report_deadlines)
        )

    @computed_field
    @property
    def schedule_density(self) -> str:
        """Assess schedule density for the day."""
        if self.total_scheduled_items == 0:
            return "Light"
        elif self.total_scheduled_items <= 3:
            return "Moderate"
        elif self.total_scheduled_items <= 6:
            return "Busy"
        else:
            return "Very Busy"


class DashboardAlert(BaseSchema):
    """Dashboard alert/notification with action support."""
    
    alert_id: str = Field(..., description="Alert ID")
    alert_type: str = Field(
        ...,
        pattern=r"^(urgent|warning|info|success)$",
        description="Alert severity level",
    )
    title: str = Field(..., description="Alert title")
    message: str = Field(..., description="Alert message")
    
    # Action support
    action_required: bool = Field(..., description="Whether action is required")
    action_url: Optional[str] = Field(default=None, description="Action URL")
    action_label: Optional[str] = Field(default=None, description="Action button label")
    
    # Metadata
    created_at: datetime = Field(..., description="Alert creation time")
    expires_at: Optional[datetime] = Field(default=None, description="Alert expiration")
    is_dismissible: bool = Field(default=True, description="Can be dismissed by user")
    
    # Context
    related_entity_type: Optional[str] = Field(
        default=None,
        description="Related entity type",
    )
    related_entity_id: Optional[str] = Field(
        default=None,
        description="Related entity ID",
    )

    @computed_field
    @property
    def is_expired(self) -> bool:
        """Check if alert has expired."""
        if not self.expires_at:
            return False
        return datetime.now() > self.expires_at

    @computed_field
    @property
    def age_minutes(self) -> int:
        """Calculate alert age in minutes."""
        return int((datetime.now() - self.created_at).total_seconds() / 60)


class QuickAction(BaseSchema):
    """Individual quick action button."""
    
    action_id: str = Field(..., description="Action identifier")
    label: str = Field(..., description="Action label")
    icon: str = Field(..., description="Icon identifier")
    url: str = Field(..., description="Action URL")
    
    # Badge support
    badge_count: Optional[int] = Field(
        default=None,
        ge=0,
        description="Number indicator (e.g., pending items)",
    )
    badge_type: Optional[str] = Field(
        default=None,
        pattern=r"^(info|warning|danger|success)$",
        description="Badge color type",
    )
    
    # Permissions
    requires_permission: Optional[str] = Field(
        default=None,
        description="Required permission to show action",
    )
    
    # Grouping
    category: str = Field(
        default="general",
        description="Action category for grouping",
    )


class QuickActions(BaseSchema):
    """Quick action buttons for dashboard."""
    
    actions: List[QuickAction] = Field(
        ...,
        description="Available quick actions",
    )

    @computed_field
    @property
    def actions_by_category(self) -> Dict[str, List[QuickAction]]:
        """Group actions by category."""
        grouped: Dict[str, List[QuickAction]] = {}
        for action in self.actions:
            category = action.category
            if category not in grouped:
                grouped[category] = []
            grouped[category].append(action)
        return grouped


class PerformanceIndicators(BaseSchema):
    """Key performance indicators for supervisor."""
    
    # Efficiency metrics
    complaint_resolution_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Complaint resolution rate %",
    )
    average_response_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average response time to issues",
    )
    task_completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Task completion rate %",
    )
    
    # Quality metrics
    student_satisfaction_score: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Student satisfaction rating",
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="SLA compliance rate %",
    )
    
    # Activity metrics
    daily_activity_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Daily activity score",
    )
    consistency_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Performance consistency score",
    )
    
    # Trend indicators
    performance_trend: str = Field(
        ...,
        pattern=r"^(improving|stable|declining)$",
        description="Overall performance trend",
    )
    
    # Benchmarking
    rank_among_peers: Optional[int] = Field(
        default=None,
        ge=1,
        description="Rank among peer supervisors",
    )
    total_peers: Optional[int] = Field(
        default=None,
        ge=1,
        description="Total number of peer supervisors",
    )

    @computed_field
    @property
    def overall_performance_score(self) -> Decimal:
        """Calculate overall performance score."""
        # Weighted average of key metrics
        weights = {
            'complaint_resolution': 0.25,
            'task_completion': 0.25,
            'sla_compliance': 0.25,
            'activity': 0.25,
        }
        
        score = (
            float(self.complaint_resolution_rate) * weights['complaint_resolution'] +
            float(self.task_completion_rate) * weights['task_completion'] +
            float(self.sla_compliance_rate) * weights['sla_compliance'] +
            float(self.daily_activity_score) * weights['activity']
        )
        
        return Decimal(str(score)).quantize(Decimal("0.1"))

    @computed_field
    @property
    def performance_grade(self) -> str:
        """Get performance grade based on overall score."""
        score = float(self.overall_performance_score)
        
        if score >= 90:
            return "A+"
        elif score >= 80:
            return "A"
        elif score >= 70:
            return "B+"
        elif score >= 60:
            return "B"
        elif score >= 50:
            return "C"
        else:
            return "D"


class SupervisorDashboard(BaseSchema):
    """
    Complete supervisor dashboard with real-time data.
    
    Comprehensive dashboard providing all necessary information
    for effective hostel management.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Core metrics
    metrics: DashboardMetrics = Field(..., description="Key performance metrics")
    
    # Task management
    tasks: TaskSummary = Field(..., description="Pending tasks summary")
    
    # Recent activity
    recent_complaints: List[RecentComplaintItem] = Field(
        default_factory=list,
        max_length=5,
        description="Recent complaints (max 5)",
    )
    recent_maintenance: List[RecentMaintenanceItem] = Field(
        default_factory=list,
        max_length=5,
        description="Recent maintenance requests (max 5)",
    )
    pending_leaves: List[PendingLeaveItem] = Field(
        default_factory=list,
        max_length=10,
        description="Pending leave approvals (max 10)",
    )
    
    # Schedule
    today_schedule: TodaySchedule = Field(..., description="Today's schedule")
    
    # Alerts and notifications
    alerts: List[DashboardAlert] = Field(
        default_factory=list,
        description="Active alerts and notifications",
    )
    
    # Quick actions
    quick_actions: QuickActions = Field(..., description="Available quick actions")
    
    # Performance indicators
    performance: PerformanceIndicators = Field(
        ...,
        description="Performance indicators",
    )
    
    # Activity tracking
    last_login: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )
    actions_today: int = Field(
        default=0,
        ge=0,
        description="Actions performed today",
    )
    online_duration_minutes: int = Field(
        default=0,
        ge=0,
        description="Online duration today (minutes)",
    )
    
    # Dashboard metadata
    dashboard_updated_at: datetime = Field(
        ...,
        description="Dashboard data timestamp",
    )
    refresh_interval_seconds: int = Field(
        default=300,
        ge=60,
        description="Recommended refresh interval",
    )

    @computed_field
    @property
    def critical_alerts_count(self) -> int:
        """Count critical alerts requiring immediate attention."""
        return sum(1 for alert in self.alerts if alert.alert_type == "urgent")

    @computed_field
    @property
    def workload_summary(self) -> str:
        """Get workload summary description."""
        total_pending = self.tasks.total_pending_tasks
        urgent_items = (
            self.tasks.urgent_complaints +
            self.tasks.critical_maintenance +
            self.tasks.overdue_tasks
        )
        
        if urgent_items > 5:
            return "Critical workload - immediate attention required"
        elif total_pending > 15:
            return "Heavy workload - prioritize urgent tasks"
        elif total_pending > 5:
            return "Moderate workload - manageable"
        else:
            return "Light workload - good job!"

    @computed_field
    @property
    def dashboard_health_status(self) -> str:
        """Overall dashboard health status."""
        health_score = float(self.metrics.overall_health_score)
        critical_alerts = self.critical_alerts_count
        urgent_tasks = (
            self.tasks.urgent_complaints +
            self.tasks.critical_maintenance +
            self.tasks.overdue_tasks
        )
        
        if critical_alerts > 0 or urgent_tasks > 5:
            return "Critical"
        elif health_score < 60 or urgent_tasks > 2:
            return "Warning"
        elif health_score < 80:
            return "Good"
        else:
            return "Excellent"

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\supervisor\supervisor_performance.py ---
# --- File: app/schemas/supervisor/supervisor_performance.py ---
"""
Supervisor performance tracking schemas with comprehensive analytics.

Provides detailed performance measurement, goal tracking, and
comparative analysis with peer benchmarking.
"""

from __future__ import annotations

from datetime import date as Date, datetime, timedelta
from decimal import Decimal
from typing import Any, Dict, List, Optional

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "PerformanceMetrics",
    "PerformanceReport",
    "ComplaintPerformance",
    "AttendancePerformance",
    "MaintenancePerformance",
    "PerformanceTrendPoint",
    "PeerComparison",
    "MetricComparison",
    "PeriodComparison",
    "PerformanceReview",
    "PerformanceReviewResponse",
    "PerformanceGoal",
    "PerformanceGoalProgress",
    "PerformanceInsights",
]


class PerformanceMetrics(BaseSchema):
    """
    Comprehensive supervisor performance metrics.
    
    Aggregated performance data across all key areas with
    trend analysis and benchmarking.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_id: str = Field(..., description="Hostel ID")
    period_start: Date = Field(..., description="Metrics period start")
    period_end: Date = Field(..., description="Metrics period end")
    
    # ============ Complaint Handling Metrics ============
    complaints_handled: int = Field(..., ge=0, description="Total complaints handled")
    complaints_resolved: int = Field(..., ge=0, description="Complaints resolved")
    complaint_resolution_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Complaint resolution rate percentage",
    )
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average time to resolve complaints",
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="SLA compliance rate percentage",
    )
    first_response_time_minutes: Decimal = Field(
        ...,
        ge=0,
        description="Average first response time",
    )
    
    # ============ Attendance Management Metrics ============
    attendance_records_created: int = Field(
        ...,
        ge=0,
        description="Attendance records created",
    )
    attendance_accuracy: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Attendance accuracy percentage",
    )
    leaves_approved: int = Field(..., ge=0, description="Leave applications approved")
    leaves_rejected: int = Field(..., ge=0, description="Leave applications rejected")
    attendance_punctuality_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="On-time attendance marking rate",
    )
    
    # ============ Maintenance Management Metrics ============
    maintenance_requests_created: int = Field(
        ...,
        ge=0,
        description="Maintenance requests created",
    )
    maintenance_completed: int = Field(
        ...,
        ge=0,
        description="Maintenance requests completed",
    )
    maintenance_completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Maintenance completion rate",
    )
    average_maintenance_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average maintenance completion time",
    )
    maintenance_cost_efficiency: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Cost efficiency percentage",
    )
    
    # ============ Communication Metrics ============
    announcements_created: int = Field(
        ...,
        ge=0,
        description="Announcements created",
    )
    announcement_reach: int = Field(
        ...,
        ge=0,
        description="Total students reached by announcements",
    )
    student_interactions: int = Field(
        ...,
        ge=0,
        description="Direct student interactions",
    )
    
    # ============ Responsiveness Metrics ============
    average_first_response_time_minutes: Decimal = Field(
        ...,
        ge=0,
        description="Average first response time to issues",
    )
    availability_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Availability during working hours",
    )
    response_consistency_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Consistency in response times",
    )
    
    # ============ Student Satisfaction ============
    student_feedback_score: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average student feedback rating",
    )
    student_feedback_count: int = Field(
        ...,
        ge=0,
        description="Number of student feedback responses",
    )
    complaint_escalation_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of complaints escalated",
    )
    
    # ============ Overall Performance ============
    overall_performance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Calculated overall performance score",
    )
    performance_grade: str = Field(
        ...,
        pattern=r"^(A\+|A|B\+|B|C|D)$",
        description="Performance grade",
    )

    @computed_field
    @property
    def efficiency_score(self) -> Decimal:
        """Calculate efficiency score based on time metrics."""
        # Weighted score based on response times and completion rates
        response_score = max(0, 100 - float(self.average_first_response_time_minutes))
        completion_score = float(self.complaint_resolution_rate + self.maintenance_completion_rate) / 2
        
        efficiency = (response_score * 0.4 + completion_score * 0.6)
        return Decimal(str(efficiency)).quantize(Decimal("0.1"))

    @computed_field
    @property
    def quality_score(self) -> Decimal:
        """Calculate quality score based on accuracy and satisfaction."""
        quality_metrics = [
            float(self.attendance_accuracy),
            float(self.sla_compliance_rate),
            float(self.maintenance_cost_efficiency),
        ]
        
        if self.student_feedback_score:
            quality_metrics.append(float(self.student_feedback_score) * 20)  # Convert 5-point to 100-point
        
        average_quality = sum(quality_metrics) / len(quality_metrics)
        return Decimal(str(average_quality)).quantize(Decimal("0.1"))


class ComplaintPerformance(BaseSchema):
    """Detailed complaint handling performance analysis."""
    
    total_complaints: int = Field(..., ge=0, description="Total complaints handled")
    resolved_complaints: int = Field(..., ge=0, description="Successfully resolved")
    pending_complaints: int = Field(..., ge=0, description="Currently pending")
    escalated_complaints: int = Field(..., ge=0, description="Escalated to admin")
    
    # Category breakdown
    complaints_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaints by category",
    )
    
    # Priority breakdown
    complaints_by_priority: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaints by priority level",
    )
    
    # Resolution time analysis
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average resolution time",
    )
    fastest_resolution_hours: Decimal = Field(
        ...,
        ge=0,
        description="Fastest resolution time",
    )
    slowest_resolution_hours: Decimal = Field(
        ...,
        ge=0,
        description="Slowest resolution time",
    )
    median_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Median resolution time",
    )
    
    # SLA performance
    within_sla: int = Field(..., ge=0, description="Complaints resolved within SLA")
    breached_sla: int = Field(..., ge=0, description="SLA breaches")
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="SLA compliance percentage",
    )
    
    # Student satisfaction
    average_complaint_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average student rating for resolved complaints",
    )
    satisfaction_responses: int = Field(
        ...,
        ge=0,
        description="Number of satisfaction responses received",
    )

    @computed_field
    @property
    def resolution_efficiency(self) -> str:
        """Categorize resolution efficiency."""
        avg_hours = float(self.average_resolution_time_hours)
        
        if avg_hours <= 4:
            return "Excellent"
        elif avg_hours <= 12:
            return "Good"
        elif avg_hours <= 24:
            return "Average"
        elif avg_hours <= 48:
            return "Below Average"
        else:
            return "Poor"


class AttendancePerformance(BaseSchema):
    """Attendance management performance details."""
    
    total_attendance_records: int = Field(
        ...,
        ge=0,
        description="Total attendance records created",
    )
    days_attendance_marked: int = Field(
        ...,
        ge=0,
        description="Days attendance was marked",
    )
    days_attendance_missed: int = Field(
        ...,
        ge=0,
        description="Days attendance was not marked",
    )
    
    # Timeliness metrics
    on_time_marking_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of on-time attendance marking",
    )
    average_marking_delay_minutes: Decimal = Field(
        ...,
        ge=0,
        description="Average delay in attendance marking",
    )
    
    # Accuracy metrics
    corrections_made: int = Field(
        ...,
        ge=0,
        description="Number of attendance corrections made",
    )
    accuracy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Attendance accuracy rate",
    )
    
    # Leave management
    leaves_processed: int = Field(
        ...,
        ge=0,
        description="Total leave applications processed",
    )
    leaves_approved: int = Field(
        ...,
        ge=0,
        description="Leave applications approved",
    )
    leaves_rejected: int = Field(
        ...,
        ge=0,
        description="Leave applications rejected",
    )
    average_leave_approval_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average time to process leave applications",
    )

    @computed_field
    @property
    def attendance_consistency(self) -> str:
        """Assess attendance marking consistency."""
        total_days = self.days_attendance_marked + self.days_attendance_missed
        if total_days == 0:
            return "No Data"
        
        consistency_rate = (self.days_attendance_marked / total_days) * 100
        
        if consistency_rate >= 95:
            return "Excellent"
        elif consistency_rate >= 85:
            return "Good"
        elif consistency_rate >= 70:
            return "Average"
        else:
            return "Poor"

    @computed_field
    @property
    def leave_approval_rate(self) -> Decimal:
        """Calculate leave approval rate."""
        if self.leaves_processed == 0:
            return Decimal("0.00")
        
        rate = (self.leaves_approved / self.leaves_processed) * 100
        return Decimal(str(rate)).quantize(Decimal("0.01"))


class MaintenancePerformance(BaseSchema):
    """Maintenance management performance details."""
    
    requests_created: int = Field(
        ...,
        ge=0,
        description="Maintenance requests created",
    )
    requests_completed: int = Field(
        ...,
        ge=0,
        description="Maintenance requests completed",
    )
    requests_pending: int = Field(
        ...,
        ge=0,
        description="Currently pending requests",
    )
    requests_overdue: int = Field(
        ...,
        ge=0,
        description="Overdue maintenance requests",
    )
    
    # Category breakdown
    requests_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Requests by maintenance category",
    )
    
    # Completion time analysis
    average_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average completion time",
    )
    fastest_completion_hours: Decimal = Field(
        ...,
        ge=0,
        description="Fastest completion time",
    )
    slowest_completion_hours: Decimal = Field(
        ...,
        ge=0,
        description="Slowest completion time",
    )
    
    # Cost management
    total_maintenance_cost: Decimal = Field(
        ...,
        ge=0,
        description="Total maintenance costs",
    )
    average_cost_per_request: Decimal = Field(
        ...,
        ge=0,
        description="Average cost per request",
    )
    budget_allocated: Decimal = Field(
        ...,
        ge=0,
        description="Allocated maintenance budget",
    )
    within_budget_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of requests within budget",
    )
    
    # Preventive maintenance
    preventive_tasks_completed: int = Field(
        ...,
        ge=0,
        description="Preventive maintenance tasks completed",
    )
    preventive_tasks_scheduled: int = Field(
        ...,
        ge=0,
        description="Preventive maintenance tasks scheduled",
    )
    preventive_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Preventive maintenance compliance rate",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate maintenance completion rate."""
        total_requests = self.requests_created
        if total_requests == 0:
            return Decimal("100.00")
        
        rate = (self.requests_completed / total_requests) * 100
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def budget_utilization(self) -> Decimal:
        """Calculate budget utilization percentage."""
        if self.budget_allocated == 0:
            return Decimal("0.00")
        
        utilization = (self.total_maintenance_cost / self.budget_allocated) * 100
        return Decimal(str(utilization)).quantize(Decimal("0.01"))
# Continuing supervisor_performance.py...

class PerformanceTrendPoint(BaseSchema):
    """Performance trend data point for analysis."""
    
    period: str = Field(
        ...,
        description="Time period identifier",
        examples=["2024-01", "Week 15", "Q1 2024"],
    )
    overall_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall performance score for period",
    )
    complaint_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Complaint handling score",
    )
    attendance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Attendance management score",
    )
    maintenance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Maintenance management score",
    )
    student_satisfaction_score: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Student satisfaction score",
    )

    @computed_field
    @property
    def trend_indicator(self) -> str:
        """Get trend indicator for the period."""
        # This would typically be calculated by comparing with previous period
        # For now, return based on overall score
        score = float(self.overall_score)
        if score >= 85:
            return "excellent"
        elif score >= 70:
            return "good"
        elif score >= 55:
            return "average"
        else:
            return "needs_improvement"


class MetricComparison(BaseSchema):
    """Individual metric comparison with peers."""
    
    metric_name: str = Field(..., description="Name of the metric")
    supervisor_value: Decimal = Field(..., description="Supervisor's value")
    peer_average: Decimal = Field(..., description="Peer average value")
    peer_median: Decimal = Field(..., description="Peer median value")
    best_peer_value: Decimal = Field(..., description="Best peer value")
    difference_from_average: Decimal = Field(
        ...,
        description="Difference from peer average",
    )
    difference_percentage: Decimal = Field(
        ...,
        description="Percentage difference from average",
    )
    better_than_average: bool = Field(
        ...,
        description="Whether supervisor performs better than average",
    )

    @computed_field
    @property
    def performance_vs_peers(self) -> str:
        """Describe performance relative to peers."""
        if self.better_than_average:
            if float(self.difference_percentage) >= 20:
                return "Significantly Above Average"
            elif float(self.difference_percentage) >= 10:
                return "Above Average"
            else:
                return "Slightly Above Average"
        else:
            if float(abs(self.difference_percentage)) >= 20:
                return "Significantly Below Average"
            elif float(abs(self.difference_percentage)) >= 10:
                return "Below Average"
            else:
                return "Slightly Below Average"


class PeerComparison(BaseSchema):
    """Comparison with peer supervisors."""
    
    total_supervisors: int = Field(
        ...,
        ge=1,
        description="Total number of supervisors in comparison",
    )
    rank: int = Field(
        ...,
        ge=1,
        description="Supervisor's rank among peers (1 = best)",
    )
    percentile: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Performance percentile",
    )
    
    # Metric comparisons
    metrics_vs_average: Dict[str, MetricComparison] = Field(
        default_factory=dict,
        description="Individual metric comparisons",
    )
    
    # Top performers
    top_performer_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Score of top performer",
    )
    score_gap_to_top: Decimal = Field(
        ...,
        ge=0,
        description="Gap to top performer",
    )

    @computed_field
    @property
    def performance_tier(self) -> str:
        """Categorize performance tier among peers."""
        if self.percentile >= 90:
            return "Top Performer"
        elif self.percentile >= 75:
            return "High Performer"
        elif self.percentile >= 50:
            return "Average Performer"
        elif self.percentile >= 25:
            return "Below Average"
        else:
            return "Needs Improvement"


class PeriodComparison(BaseSchema):
    """Comparison with previous period."""
    
    previous_period: DateRangeFilter = Field(
        ...,
        description="Previous comparison period",
    )
    current_period: DateRangeFilter = Field(
        ...,
        description="Current period",
    )
    
    # Overall change
    overall_score_change: Decimal = Field(
        ...,
        description="Percentage change in overall score",
    )
    
    # Metric changes
    metric_changes: Dict[str, Decimal] = Field(
        ...,
        description="Percentage change for each metric",
    )
    
    # Improvement/decline indicators
    improved_metrics: List[str] = Field(
        default_factory=list,
        description="Metrics that improved",
    )
    declined_metrics: List[str] = Field(
        default_factory=list,
        description="Metrics that declined",
    )
    stable_metrics: List[str] = Field(
        default_factory=list,
        description="Metrics that remained stable",
    )

    @computed_field
    @property
    def overall_trend(self) -> str:
        """Determine overall performance trend."""
        if self.overall_score_change >= 5:
            return "Improving"
        elif self.overall_score_change <= -5:
            return "Declining"
        else:
            return "Stable"

    @computed_field
    @property
    def improvement_summary(self) -> str:
        """Generate improvement summary."""
        improved_count = len(self.improved_metrics)
        declined_count = len(self.declined_metrics)
        
        if improved_count > declined_count:
            return f"Improved in {improved_count} areas, declined in {declined_count}"
        elif declined_count > improved_count:
            return f"Declined in {declined_count} areas, improved in {improved_count}"
        else:
            return f"Mixed performance: {improved_count} improved, {declined_count} declined"


class PerformanceReport(BaseSchema):
    """Comprehensive performance report."""
    
    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_name: str = Field(..., description="Hostel name")
    report_period: DateRangeFilter = Field(..., description="Report period")
    generated_at: datetime = Field(..., description="Report generation timestamp")
    
    # Summary metrics
    summary: PerformanceMetrics = Field(..., description="Summary performance metrics")
    
    # Detailed breakdown
    complaint_performance: ComplaintPerformance = Field(
        ...,
        description="Complaint handling performance",
    )
    attendance_performance: AttendancePerformance = Field(
        ...,
        description="Attendance management performance",
    )
    maintenance_performance: MaintenancePerformance = Field(
        ...,
        description="Maintenance management performance",
    )
    
    # Trends and comparisons
    performance_trends: List[PerformanceTrendPoint] = Field(
        default_factory=list,
        description="Performance trends over time",
    )
    comparison_with_peers: Optional[PeerComparison] = Field(
        default=None,
        description="Comparison with peer supervisors",
    )
    comparison_with_previous_period: Optional[PeriodComparison] = Field(
        default=None,
        description="Comparison with previous period",
    )
    
    # Insights and recommendations
    strengths: List[str] = Field(
        default_factory=list,
        description="Identified strengths",
    )
    areas_for_improvement: List[str] = Field(
        default_factory=list,
        description="Areas needing improvement",
    )
    recommendations: List[str] = Field(
        default_factory=list,
        description="Specific recommendations",
    )
    
    # Goals and targets
    current_goals: List[PerformanceGoalProgress] = Field(
        default_factory=list,
        description="Current performance goals progress",
    )

    @computed_field
    @property
    def report_summary(self) -> str:
        """Generate executive summary of the report."""
        score = float(self.summary.overall_performance_score)
        grade = self.summary.performance_grade
        
        summary = f"Overall Performance: {score:.1f}/100 (Grade: {grade}). "
        
        if self.comparison_with_previous_period:
            trend = self.comparison_with_previous_period.overall_trend
            summary += f"Trend: {trend}. "
        
        if self.comparison_with_peers:
            tier = self.comparison_with_peers.performance_tier
            summary += f"Peer Ranking: {tier}."
        
        return summary


class PerformanceReview(BaseCreateSchema):
    """Performance review by admin."""
    
    supervisor_id: str = Field(..., description="Supervisor being reviewed")
    review_period: DateRangeFilter = Field(..., description="Review period")
    
    # Ratings (1-5 scale)
    complaint_handling_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Complaint handling rating",
    )
    attendance_management_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Attendance management rating",
    )
    maintenance_management_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Maintenance management rating",
    )
    communication_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Communication skills rating",
    )
    professionalism_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Professionalism rating",
    )
    reliability_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Reliability rating",
    )
    initiative_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Initiative and proactiveness rating",
    )
    
    # Overall rating
    overall_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Overall performance rating",
    )
    
    # Textual feedback
    strengths: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Supervisor strengths",
    )
    areas_for_improvement: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Areas to improve",
    )
    goals_for_next_period: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Goals for next review period",
    )
    
    # Additional feedback
    admin_comments: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Additional admin comments",
    )
    
    # Action items
    action_items: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Specific action items (max 10)",
    )
    
    # Development recommendations
    training_recommendations: List[str] = Field(
        default_factory=list,
        description="Recommended training or development",
    )

    @field_validator("action_items", "training_recommendations")
    @classmethod
    def validate_non_empty_items(cls, v: List[str]) -> List[str]:
        """Remove empty items from lists."""
        return [item.strip() for item in v if item.strip()]

    @computed_field
    @property
    def average_rating(self) -> Decimal:
        """Calculate average of all individual ratings."""
        ratings = [
            self.complaint_handling_rating,
            self.attendance_management_rating,
            self.maintenance_management_rating,
            self.communication_rating,
            self.professionalism_rating,
            self.reliability_rating,
            self.initiative_rating,
        ]
        
        average = sum(float(r) for r in ratings) / len(ratings)
        return Decimal(str(average)).quantize(Decimal("0.1"))


class PerformanceReviewResponse(BaseSchema):
    """Performance review response with acknowledgment."""
    
    review_id: str = Field(..., description="Review ID")
    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    reviewed_by: str = Field(..., description="Reviewer ID")
    reviewed_by_name: str = Field(..., description="Reviewer name")
    review_date: Date = Field(..., description="Review Date")
    
    review_period: DateRangeFilter = Field(..., description="Review period")
    
    # Ratings
    ratings: Dict[str, Decimal] = Field(
        ...,
        description="All ratings by category",
    )
    overall_rating: Decimal = Field(..., description="Overall rating")
    
    # Feedback
    strengths: str = Field(..., description="Identified strengths")
    areas_for_improvement: str = Field(..., description="Areas for improvement")
    goals_for_next_period: str = Field(..., description="Next period goals")
    admin_comments: Optional[str] = Field(default=None, description="Admin comments")
    
    # Actions and development
    action_items: List[str] = Field(default_factory=list, description="Action items")
    training_recommendations: List[str] = Field(
        default_factory=list,
        description="Training recommendations",
    )
    
    # Supervisor acknowledgment
    acknowledged: bool = Field(default=False, description="Supervisor acknowledged review")
    acknowledged_at: Optional[datetime] = Field(
        default=None,
        description="Acknowledgment timestamp",
    )
    supervisor_comments: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Supervisor's response comments",
    )

    @computed_field
    @property
    def performance_level(self) -> str:
        """Categorize performance level based on overall rating."""
        rating = float(self.overall_rating)
        
        if rating >= 4.5:
            return "Outstanding"
        elif rating >= 4.0:
            return "Exceeds Expectations"
        elif rating >= 3.0:
            return "Meets Expectations"
        elif rating >= 2.0:
            return "Below Expectations"
        else:
            return "Unsatisfactory"


class PerformanceGoal(BaseCreateSchema):
    """Set performance goal for supervisor."""
    
    supervisor_id: str = Field(..., description="Supervisor ID")
    goal_name: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Goal name",
    )
    goal_description: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Detailed goal description",
    )
    
    # Measurable target
    metric_name: str = Field(
        ...,
        description="Metric to measure",
        examples=[
            "complaint_resolution_rate",
            "sla_compliance_rate",
            "attendance_punctuality_rate",
        ],
    )
    target_value: Decimal = Field(
        ...,
        description="Target value to achieve",
    )
    current_value: Optional[Decimal] = Field(
        default=None,
        description="Current baseline value",
    )
    
    # Timeline
    start_date: Date = Field(..., description="Goal start Date")
    end_date: Date = Field(..., description="Goal target completion Date")
    
    # Priority and category
    priority: str = Field(
        default="medium",
        pattern=r"^(low|medium|high|critical)$",
        description="Goal priority level",
    )
    category: str = Field(
        ...,
        pattern=r"^(complaint|attendance|maintenance|communication|efficiency|quality)$",
        description="Goal category",
    )
    
    # Tracking
    measurement_frequency: str = Field(
        default="weekly",
        pattern=r"^(daily|weekly|monthly)$",
        description="How often to measure progress",
    )

    @field_validator("end_date")
    @classmethod
    def validate_end_date(cls, v: Date, info) -> Date:
        """Validate end Date is after start Date."""
        # In Pydantic v2, we use info.data instead of values
        start_date = info.data.get("start_date")
        if start_date and v <= start_date:
            raise ValueError("End Date must be after start Date")
        return v

    @computed_field
    @property
    def duration_days(self) -> int:
        """Calculate goal duration in days."""
        return (self.end_date - self.start_date).days


class PerformanceGoalProgress(BaseSchema):
    """Track progress on performance goal."""
    
    goal_id: str = Field(..., description="Goal ID")
    goal_name: str = Field(..., description="Goal name")
    metric_name: str = Field(..., description="Metric being measured")
    
    # Values
    target_value: Decimal = Field(..., description="Target value")
    current_value: Decimal = Field(..., description="Current achieved value")
    baseline_value: Optional[Decimal] = Field(
        default=None,
        description="Starting baseline value",
    )
    
    # Progress calculation
    progress_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Progress percentage towards goal",
    )
    
    # Timeline
    start_date: Date = Field(..., description="Goal start Date")
    end_date: Date = Field(..., description="Goal end Date")
    days_remaining: int = Field(..., ge=0, description="Days remaining to achieve goal")
    
    # Status
    status: str = Field(
        ...,
        pattern=r"^(on_track|at_risk|behind|completed|failed|paused)$",
        description="Goal progress status",
    )
    
    # Tracking
    last_updated: datetime = Field(..., description="Last progress update")
    measurement_history: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Historical measurements",
    )

    @computed_field
    @property
    def days_elapsed(self) -> int:
        """Calculate days elapsed since goal start."""
        return (Date.today() - self.start_date).days

    @computed_field
    @property
    def time_progress_percentage(self) -> Decimal:
        """Calculate time progress percentage."""
        total_days = (self.end_date - self.start_date).days
        if total_days == 0:
            return Decimal("100.00")
        
        elapsed_days = self.days_elapsed
        time_progress = min(100, (elapsed_days / total_days) * 100)
        return Decimal(str(time_progress)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_on_schedule(self) -> bool:
        """Check if goal progress is on schedule."""
        time_progress = float(self.time_progress_percentage)
        actual_progress = float(self.progress_percentage)
        
        # Allow 10% tolerance
        return actual_progress >= (time_progress - 10)

    @computed_field
    @property
    def projected_completion_date(self) -> Optional[Date]:
        """Project completion Date based on current progress rate."""
        if self.progress_percentage == 0:
            return None
        
        days_elapsed = self.days_elapsed
        if days_elapsed == 0:
            return None
        
        progress_rate = float(self.progress_percentage) / days_elapsed
        if progress_rate == 0:
            return None
        
        remaining_progress = 100 - float(self.progress_percentage)
        days_to_complete = remaining_progress / progress_rate
        
        projected_date = Date.today() + timedelta(days=int(days_to_complete))
        return projected_date


class PerformanceInsights(BaseSchema):
    """AI-generated performance insights and recommendations."""
    
    supervisor_id: str = Field(..., description="Supervisor ID")
    analysis_period: DateRangeFilter = Field(..., description="Analysis period")
    generated_at: datetime = Field(..., description="Insights generation timestamp")
    
    # Key insights
    top_strengths: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 identified strengths",
    )
    improvement_opportunities: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 improvement opportunities",
    )
    
    # Trend analysis
    performance_trends: Dict[str, str] = Field(
        default_factory=dict,
        description="Trend analysis for each metric",
    )
    
    # Predictive insights
    risk_factors: List[str] = Field(
        default_factory=list,
        description="Identified risk factors",
    )
    success_indicators: List[str] = Field(
        default_factory=list,
        description="Positive success indicators",
    )
    
    # Recommendations
    immediate_actions: List[str] = Field(
        default_factory=list,
        max_length=3,
        description="Immediate actions recommended",
    )
    long_term_development: List[str] = Field(
        default_factory=list,
        max_length=3,
        description="Long-term development recommendations",
    )
    
    # Benchmarking insights
    peer_comparison_insights: List[str] = Field(
        default_factory=list,
        description="Insights from peer comparison",
    )
    
    # Confidence scores
    insight_confidence: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Confidence level in insights (0-100)",
    )

    @computed_field
    @property
    def overall_assessment(self) -> str:
        """Generate overall performance assessment."""
        strengths_count = len(self.top_strengths)
        improvements_count = len(self.improvement_opportunities)
        risks_count = len(self.risk_factors)
        
        if strengths_count > improvements_count and risks_count == 0:
            return "Strong performer with consistent results"
        elif improvements_count > strengths_count:
            return "Developing performer with growth potential"
        elif risks_count > 0:
            return "Requires attention and support"
        else:
            return "Balanced performer with mixed results"

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\supervisor\supervisor_permissions.py ---
# --- File: app/schemas/supervisor/supervisor_permissions.py ---
"""
Supervisor permission schemas with comprehensive access control.

Provides granular permission management with templates, bulk operations,
and audit tracking. Optimized for performance and maintainability.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Any, Dict, List, Literal, Optional, Set

from pydantic import Field, field_validator, model_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema

__all__ = [
    "SupervisorPermissions",
    "PermissionUpdate",
    "PermissionCheckRequest",
    "PermissionCheckResponse",
    "BulkPermissionUpdate",
    "PermissionTemplate",
    "ApplyPermissionTemplate",
    "PermissionAuditLog",
    "PermissionConstants",
]


class PermissionConstants:
    """Centralized constants for permission management."""
    
    # Permission categories
    COMPLAINT_PERMISSIONS = {
        "can_manage_complaints",
        "can_assign_complaints",
        "can_resolve_complaints",
        "can_close_complaints",
    }
    
    ATTENDANCE_PERMISSIONS = {
        "can_record_attendance",
        "can_approve_leaves",
        "can_edit_past_attendance",
    }
    
    MAINTENANCE_PERMISSIONS = {
        "can_manage_maintenance",
        "can_assign_maintenance",
        "can_approve_maintenance_costs",
        "can_schedule_preventive_maintenance",
    }
    
    COMMUNICATION_PERMISSIONS = {
        "can_create_announcements",
        "can_send_push_notifications",
        "can_send_sms",
        "can_send_email",
    }
    
    # Threshold defaults
    DEFAULT_MAINTENANCE_THRESHOLD = Decimal("5000.00")
    DEFAULT_LEAVE_APPROVAL_DAYS = 3
    DEFAULT_PAST_ATTENDANCE_EDIT_DAYS = 7
    
    # Permission templates
    JUNIOR_SUPERVISOR_TEMPLATE = "junior_supervisor"
    SENIOR_SUPERVISOR_TEMPLATE = "senior_supervisor"
    HEAD_SUPERVISOR_TEMPLATE = "head_supervisor"
    LIMITED_ACCESS_TEMPLATE = "limited_access"
    
    # Validation constraints
    MIN_LEAVE_APPROVAL_DAYS = 1
    MAX_LEAVE_APPROVAL_DAYS = 10
    MIN_PAST_EDIT_DAYS = 1
    MAX_PAST_EDIT_DAYS = 30
    MIN_MAINTENANCE_THRESHOLD = Decimal("0.00")
    MAX_MAINTENANCE_THRESHOLD = Decimal("100000.00")


class SupervisorPermissions(BaseSchema):
    """
    Comprehensive supervisor permission configuration.
    
    Provides granular control over supervisor capabilities with
    dependency validation and threshold-based permissions.
    """

    # ============ Complaint Management ============
    can_manage_complaints: bool = Field(
        default=True,
        description="Can view and manage complaints",
    )
    can_assign_complaints: bool = Field(
        default=True,
        description="Can assign complaints to staff/vendors",
    )
    can_resolve_complaints: bool = Field(
        default=True,
        description="Can mark complaints as resolved",
    )
    can_close_complaints: bool = Field(
        default=False,
        description="Can permanently close complaints (admin-level)",
    )
    complaint_priority_limit: Optional[Literal["low", "medium", "high", "urgent"]] = Field(
        default=None,
        description="Maximum priority level can handle independently",
    )

    # ============ Attendance Management ============
    can_record_attendance: bool = Field(
        default=True,
        description="Can record daily student attendance",
    )
    can_approve_leaves: bool = Field(
        default=True,
        description="Can approve leave applications",
    )
    max_leave_days_approval: int = Field(
        default=PermissionConstants.DEFAULT_LEAVE_APPROVAL_DAYS,
        ge=PermissionConstants.MIN_LEAVE_APPROVAL_DAYS,
        le=PermissionConstants.MAX_LEAVE_APPROVAL_DAYS,
        description="Maximum days of leave can approve independently",
    )
    can_edit_past_attendance: bool = Field(
        default=False,
        description="Can edit past attendance records",
    )
    past_attendance_edit_days: int = Field(
        default=PermissionConstants.DEFAULT_PAST_ATTENDANCE_EDIT_DAYS,
        ge=PermissionConstants.MIN_PAST_EDIT_DAYS,
        le=PermissionConstants.MAX_PAST_EDIT_DAYS,
        description="Days back can edit attendance (if permitted)",
    )

    # ============ Maintenance Management ============
    can_manage_maintenance: bool = Field(
        default=True,
        description="Can create and manage maintenance requests",
    )
    can_assign_maintenance: bool = Field(
        default=True,
        description="Can assign maintenance tasks to staff",
    )
    can_approve_maintenance_costs: bool = Field(
        default=False,
        description="Can approve maintenance costs",
    )
    maintenance_approval_threshold: Decimal = Field(
        default=PermissionConstants.DEFAULT_MAINTENANCE_THRESHOLD,
        ge=PermissionConstants.MIN_MAINTENANCE_THRESHOLD,
        le=PermissionConstants.MAX_MAINTENANCE_THRESHOLD,
        max_digits=10,
        decimal_places=2,
        description="Maximum repair cost can approve independently (INR)",
    )
    can_schedule_preventive_maintenance: bool = Field(
        default=True,
        description="Can schedule preventive maintenance",
    )

    # ============ Mess/Menu Management ============
    can_update_mess_menu: bool = Field(
        default=True,
        description="Can update daily mess menu",
    )
    menu_requires_approval: bool = Field(
        default=False,
        description="Menu changes require admin approval",
    )
    can_publish_special_menus: bool = Field(
        default=False,
        description="Can publish special occasion menus",
    )
    can_manage_meal_preferences: bool = Field(
        default=True,
        description="Can manage student meal preferences",
    )

    # ============ Communication ============
    can_create_announcements: bool = Field(
        default=True,
        description="Can create announcements",
    )
    urgent_announcement_requires_approval: bool = Field(
        default=True,
        description="Urgent announcements require admin approval",
    )
    can_send_push_notifications: bool = Field(
        default=False,
        description="Can send push notifications to students",
    )
    can_send_sms: bool = Field(
        default=False,
        description="Can send SMS to students",
    )
    can_send_email: bool = Field(
        default=True,
        description="Can send emails to students",
    )

    # ============ Student Management ============
    can_view_student_profiles: bool = Field(
        default=True,
        description="Can view student profiles and details",
    )
    can_update_student_contacts: bool = Field(
        default=True,
        description="Can update student contact information",
    )
    can_view_student_payments: bool = Field(
        default=True,
        description="Can view student payment status (read-only)",
    )
    can_view_student_documents: bool = Field(
        default=True,
        description="Can view student documents",
    )
    can_verify_student_documents: bool = Field(
        default=False,
        description="Can verify student documents",
    )

    # ============ Financial Access ============
    can_view_financial_reports: bool = Field(
        default=False,
        description="Can view detailed financial reports",
    )
    can_view_revenue_data: bool = Field(
        default=False,
        description="Can view revenue and collection data",
    )
    can_view_expense_data: bool = Field(
        default=False,
        description="Can view expense data",
    )
    can_generate_payment_reminders: bool = Field(
        default=True,
        description="Can generate payment reminders",
    )

    # ============ Room and Bed Management ============
    can_view_room_availability: bool = Field(
        default=True,
        description="Can view room and bed availability",
    )
    can_suggest_room_transfers: bool = Field(
        default=True,
        description="Can suggest room transfers (requires admin approval)",
    )
    can_assign_beds: bool = Field(
        default=False,
        description="Can assign beds to students",
    )
    can_update_room_status: bool = Field(
        default=True,
        description="Can update room maintenance status",
    )

    # ============ Booking Management ============
    can_view_bookings: bool = Field(
        default=True,
        description="Can view booking requests",
    )
    can_contact_visitors: bool = Field(
        default=True,
        description="Can contact visitors for inquiries",
    )
    can_approve_bookings: bool = Field(
        default=False,
        description="Can approve booking requests",
    )

    # ============ Reporting ============
    can_generate_reports: bool = Field(
        default=True,
        description="Can generate operational reports",
    )
    can_export_data: bool = Field(
        default=False,
        description="Can export data (CSV, Excel)",
    )

    # ============ Security and Access ============
    can_view_cctv: bool = Field(
        default=False,
        description="Can access CCTV footage",
    )
    can_manage_visitor_log: bool = Field(
        default=True,
        description="Can manage visitor entry/exit log",
    )

    @model_validator(mode="after")
    def validate_permission_dependencies(self) -> "SupervisorPermissions":
        """
        Validate permission dependencies and ensure consistency.
        
        Returns:
            Self with validated and corrected permissions
        """
        # Complaint management hierarchy
        if not self.can_manage_complaints:
            self.can_assign_complaints = False
            self.can_resolve_complaints = False
            self.can_close_complaints = False
        
        # Maintenance management hierarchy
        if not self.can_manage_maintenance:
            self.can_assign_maintenance = False
            self.can_approve_maintenance_costs = False
            self.can_schedule_preventive_maintenance = False
        
        # Menu management hierarchy
        if not self.can_update_mess_menu:
            self.can_publish_special_menus = False
        
        return self

    @model_validator(mode="after")
    def validate_threshold_consistency(self) -> "SupervisorPermissions":
        """
        Validate threshold-based permissions.
        
        Returns:
            Self with validated thresholds
        """
        # If can't approve costs, threshold is irrelevant
        if not self.can_approve_maintenance_costs:
            self.maintenance_approval_threshold = Decimal("0.00")
        
        # If can't approve leaves, max days is irrelevant
        if not self.can_approve_leaves:
            self.max_leave_days_approval = 0
        
        # If can't edit past attendance, days limit is irrelevant
        if not self.can_edit_past_attendance:
            self.past_attendance_edit_days = 0
        
        return self

    def get_permission_summary(self) -> Dict[str, int]:
        """
        Get summary of permissions by category.
        
        Returns:
            Dictionary with permission counts per category
        """
        summary = {
            "complaint_permissions": 0,
            "attendance_permissions": 0,
            "maintenance_permissions": 0,
            "communication_permissions": 0,
            "student_permissions": 0,
            "financial_permissions": 0,
            "room_permissions": 0,
            "booking_permissions": 0,
            "reporting_permissions": 0,
            "security_permissions": 0,
        }
        
        # Count enabled permissions per category
        if self.can_manage_complaints:
            summary["complaint_permissions"] += 1
        if self.can_assign_complaints:
            summary["complaint_permissions"] += 1
        if self.can_resolve_complaints:
            summary["complaint_permissions"] += 1
        if self.can_close_complaints:
            summary["complaint_permissions"] += 1
        
        if self.can_record_attendance:
            summary["attendance_permissions"] += 1
        if self.can_approve_leaves:
            summary["attendance_permissions"] += 1
        if self.can_edit_past_attendance:
            summary["attendance_permissions"] += 1
        
        if self.can_manage_maintenance:
            summary["maintenance_permissions"] += 1
        if self.can_assign_maintenance:
            summary["maintenance_permissions"] += 1
        if self.can_approve_maintenance_costs:
            summary["maintenance_permissions"] += 1
        if self.can_schedule_preventive_maintenance:
            summary["maintenance_permissions"] += 1
        
        if self.can_create_announcements:
            summary["communication_permissions"] += 1
        if self.can_send_push_notifications:
            summary["communication_permissions"] += 1
        if self.can_send_sms:
            summary["communication_permissions"] += 1
        if self.can_send_email:
            summary["communication_permissions"] += 1
        
        if self.can_view_student_profiles:
            summary["student_permissions"] += 1
        if self.can_update_student_contacts:
            summary["student_permissions"] += 1
        if self.can_view_student_payments:
            summary["student_permissions"] += 1
        if self.can_view_student_documents:
            summary["student_permissions"] += 1
        if self.can_verify_student_documents:
            summary["student_permissions"] += 1
        
        if self.can_view_financial_reports:
            summary["financial_permissions"] += 1
        if self.can_view_revenue_data:
            summary["financial_permissions"] += 1
        if self.can_view_expense_data:
            summary["financial_permissions"] += 1
        if self.can_generate_payment_reminders:
            summary["financial_permissions"] += 1
        
        if self.can_view_room_availability:
            summary["room_permissions"] += 1
        if self.can_suggest_room_transfers:
            summary["room_permissions"] += 1
        if self.can_assign_beds:
            summary["room_permissions"] += 1
        if self.can_update_room_status:
            summary["room_permissions"] += 1
        
        if self.can_view_bookings:
            summary["booking_permissions"] += 1
        if self.can_contact_visitors:
            summary["booking_permissions"] += 1
        if self.can_approve_bookings:
            summary["booking_permissions"] += 1
        
        if self.can_generate_reports:
            summary["reporting_permissions"] += 1
        if self.can_export_data:
            summary["reporting_permissions"] += 1
        
        if self.can_view_cctv:
            summary["security_permissions"] += 1
        if self.can_manage_visitor_log:
            summary["security_permissions"] += 1
        
        return summary
# Continuing supervisor_permissions.py...

class PermissionUpdate(BaseUpdateSchema):
    """
    Update supervisor permissions with validation.
    
    Allows partial permission updates with audit trail support.
    """

    permissions: Dict[str, bool | int | Decimal] = Field(
        ...,
        description="Permission key-value pairs to update",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for permission change",
    )

    @field_validator("permissions")
    @classmethod
    def validate_permissions(cls, v: Dict[str, bool | int | Decimal]) -> Dict[str, bool | int | Decimal]:
        """
        Validate permission keys and value types.
        
        Args:
            v: Permissions dictionary
            
        Returns:
            Validated permissions
            
        Raises:
            ValueError: If invalid keys or value types
        """
        valid_keys = set(SupervisorPermissions.model_fields.keys())
        provided_keys = set(v.keys())
        
        # Check for invalid keys
        invalid_keys = provided_keys - valid_keys
        if invalid_keys:
            raise ValueError(
                f"Invalid permission keys: {', '.join(sorted(invalid_keys))}"
            )
        
        # Validate value types based on field annotations
        for key, value in v.items():
            field_info = SupervisorPermissions.model_fields.get(key)
            if not field_info:
                continue
            
            # Get expected type
            expected_type = field_info.annotation
            
            # Handle Optional types
            if hasattr(expected_type, "__origin__"):
                # Extract actual type from Optional
                args = getattr(expected_type, "__args__", ())
                if args:
                    expected_type = args[0]
            
            # Validate type
            if expected_type == bool:
                if not isinstance(value, bool):
                    raise ValueError(f"{key} must be a boolean value")
            elif expected_type == int:
                if not isinstance(value, int) or isinstance(value, bool):
                    raise ValueError(f"{key} must be an integer value")
            elif expected_type == Decimal:
                if not isinstance(value, (Decimal, int, float)):
                    raise ValueError(f"{key} must be a numeric value")
                # Convert to Decimal if needed
                if not isinstance(value, Decimal):
                    v[key] = Decimal(str(value))
        
        return v


class PermissionCheckRequest(BaseCreateSchema):
    """
    Request to check specific permission.
    
    Validates supervisor permission with optional context for
    threshold-based permissions.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID to check",
    )
    permission_key: str = Field(
        ...,
        description="Permission to check",
        examples=[
            "can_resolve_complaints",
            "can_approve_leaves",
            "can_approve_maintenance_costs",
        ],
    )
    context: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Additional context for permission check",
        examples=[
            {"amount": 7500},
            {"leave_days": 5},
            {"priority": "urgent"},
        ],
    )

    @field_validator("permission_key")
    @classmethod
    def validate_permission_key(cls, v: str) -> str:
        """
        Validate permission key exists.
        
        Args:
            v: Permission key to validate
            
        Returns:
            Validated permission key
            
        Raises:
            ValueError: If permission key doesn't exist
        """
        valid_keys = set(SupervisorPermissions.model_fields.keys())
        if v not in valid_keys:
            raise ValueError(
                f"Invalid permission key: {v}. "
                f"Valid keys: {', '.join(sorted(valid_keys))}"
            )
        return v


class PermissionCheckResponse(BaseSchema):
    """
    Response for permission check.
    
    Provides detailed information about permission status and
    any threshold restrictions.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    permission_key: str = Field(..., description="Permission checked")
    has_permission: bool = Field(
        ...,
        description="Whether supervisor has permission",
    )
    requires_approval: bool = Field(
        default=False,
        description="Whether action requires admin approval",
    )
    threshold_exceeded: bool = Field(
        default=False,
        description="Whether threshold limit is exceeded",
    )
    message: Optional[str] = Field(
        default=None,
        description="Explanation message",
    )

    # Threshold details
    threshold_value: Optional[Decimal] = Field(
        default=None,
        description="Configured threshold value",
    )
    actual_value: Optional[Decimal] = Field(
        default=None,
        description="Actual value being checked",
    )
    allowed_value: Optional[Decimal] = Field(
        default=None,
        description="Maximum allowed value",
    )

    def get_detailed_message(self) -> str:
        """
        Get detailed human-readable message.
        
        Returns:
            Detailed explanation of permission status
        """
        if self.has_permission and not self.threshold_exceeded:
            return f"Permission granted for {self.permission_key}"
        
        if self.threshold_exceeded:
            return (
                f"Threshold exceeded: {self.actual_value} exceeds "
                f"allowed limit of {self.threshold_value}. Admin approval required."
            )
        
        if self.requires_approval:
            return f"Action requires admin approval for {self.permission_key}"
        
        return f"Permission denied for {self.permission_key}"


class BulkPermissionUpdate(BaseUpdateSchema):
    """
    Update permissions for multiple supervisors.
    
    Efficient batch permission updates with validation and audit support.
    """

    supervisor_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Supervisor IDs to update (max 50)",
    )
    permissions: Dict[str, bool | int | Decimal] = Field(
        ...,
        description="Permissions to update for all supervisors",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for bulk permission change",
    )
    effective_date: Optional[datetime] = Field(
        default=None,
        description="Effective date for permission change",
    )

    @field_validator("supervisor_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[str]) -> List[str]:
        """Ensure supervisor IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Supervisor IDs must be unique")
        return v

    @field_validator("permissions")
    @classmethod
    def validate_permissions(cls, v: Dict[str, bool | int | Decimal]) -> Dict[str, bool | int | Decimal]:
        """Validate permissions using PermissionUpdate validator."""
        # Reuse the validation logic from PermissionUpdate
        return PermissionUpdate.model_fields["permissions"].validators[0](v)


class PermissionTemplate(BaseSchema):
    """
    Permission template for quick assignment.
    
    Predefined permission sets for different supervisor levels.
    Supports system templates and custom templates.
    """

    template_id: str = Field(
        ...,
        description="Template unique identifier",
    )
    template_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Template name",
    )
    description: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Template description",
    )
    permissions: SupervisorPermissions = Field(
        ...,
        description="Permission configuration",
    )
    is_system_template: bool = Field(
        default=False,
        description="System-defined template (cannot be modified)",
    )
    is_active: bool = Field(
        default=True,
        description="Template is active and can be used",
    )
    created_at: Optional[datetime] = Field(
        default=None,
        description="Template creation timestamp",
    )
    created_by: Optional[str] = Field(
        default=None,
        description="Admin who created template",
    )
    updated_at: Optional[datetime] = Field(
        default=None,
        description="Last update timestamp",
    )

    @classmethod
    def get_system_templates(cls) -> Dict[str, "PermissionTemplate"]:
        """
        Get predefined system templates.
        
        Returns:
            Dictionary of template name to template object
        """
        templates = {}
        
        # Junior Supervisor Template - Basic permissions
        templates[PermissionConstants.JUNIOR_SUPERVISOR_TEMPLATE] = cls(
            template_id="sys_junior_supervisor",
            template_name="Junior Supervisor",
            description="Basic permissions for junior supervisors",
            permissions=SupervisorPermissions(
                can_manage_complaints=True,
                can_assign_complaints=False,
                can_resolve_complaints=True,
                can_close_complaints=False,
                can_record_attendance=True,
                can_approve_leaves=True,
                max_leave_days_approval=2,
                can_edit_past_attendance=False,
                can_manage_maintenance=True,
                can_assign_maintenance=False,
                can_approve_maintenance_costs=False,
                can_update_mess_menu=True,
                can_publish_special_menus=False,
                can_create_announcements=True,
                urgent_announcement_requires_approval=True,
                can_send_email=True,
                can_send_sms=False,
                can_send_push_notifications=False,
                can_view_student_profiles=True,
                can_view_student_payments=True,
                can_view_financial_reports=False,
                can_generate_reports=True,
                can_export_data=False,
            ),
            is_system_template=True,
        )
        
        # Senior Supervisor Template - Extended permissions
        templates[PermissionConstants.SENIOR_SUPERVISOR_TEMPLATE] = cls(
            template_id="sys_senior_supervisor",
            template_name="Senior Supervisor",
            description="Extended permissions for senior supervisors",
            permissions=SupervisorPermissions(
                can_manage_complaints=True,
                can_assign_complaints=True,
                can_resolve_complaints=True,
                can_close_complaints=False,
                can_record_attendance=True,
                can_approve_leaves=True,
                max_leave_days_approval=5,
                can_edit_past_attendance=True,
                past_attendance_edit_days=7,
                can_manage_maintenance=True,
                can_assign_maintenance=True,
                can_approve_maintenance_costs=True,
                maintenance_approval_threshold=Decimal("10000.00"),
                can_schedule_preventive_maintenance=True,
                can_update_mess_menu=True,
                can_publish_special_menus=True,
                can_create_announcements=True,
                urgent_announcement_requires_approval=False,
                can_send_email=True,
                can_send_sms=True,
                can_send_push_notifications=False,
                can_view_student_profiles=True,
                can_view_student_payments=True,
                can_view_financial_reports=True,
                can_view_revenue_data=True,
                can_generate_reports=True,
                can_export_data=True,
                can_suggest_room_transfers=True,
                can_assign_beds=False,
            ),
            is_system_template=True,
        )
        
        # Head Supervisor Template - Full permissions
        templates[PermissionConstants.HEAD_SUPERVISOR_TEMPLATE] = cls(
            template_id="sys_head_supervisor",
            template_name="Head Supervisor",
            description="Full permissions for head supervisors",
            permissions=SupervisorPermissions(
                can_manage_complaints=True,
                can_assign_complaints=True,
                can_resolve_complaints=True,
                can_close_complaints=True,
                can_record_attendance=True,
                can_approve_leaves=True,
                max_leave_days_approval=10,
                can_edit_past_attendance=True,
                past_attendance_edit_days=30,
                can_manage_maintenance=True,
                can_assign_maintenance=True,
                can_approve_maintenance_costs=True,
                maintenance_approval_threshold=Decimal("50000.00"),
                can_schedule_preventive_maintenance=True,
                can_update_mess_menu=True,
                can_publish_special_menus=True,
                can_create_announcements=True,
                urgent_announcement_requires_approval=False,
                can_send_email=True,
                can_send_sms=True,
                can_send_push_notifications=True,
                can_view_student_profiles=True,
                can_update_student_contacts=True,
                can_view_student_payments=True,
                can_view_student_documents=True,
                can_verify_student_documents=True,
                can_view_financial_reports=True,
                can_view_revenue_data=True,
                can_view_expense_data=True,
                can_generate_reports=True,
                can_export_data=True,
                can_view_room_availability=True,
                can_suggest_room_transfers=True,
                can_assign_beds=True,
                can_update_room_status=True,
                can_approve_bookings=True,
                can_view_cctv=True,
            ),
            is_system_template=True,
        )
        
        # Limited Access Template - Minimal permissions
        templates[PermissionConstants.LIMITED_ACCESS_TEMPLATE] = cls(
            template_id="sys_limited_access",
            template_name="Limited Access",
            description="Minimal permissions for restricted access",
            permissions=SupervisorPermissions(
                can_manage_complaints=True,
                can_assign_complaints=False,
                can_resolve_complaints=False,
                can_close_complaints=False,
                can_record_attendance=True,
                can_approve_leaves=False,
                can_edit_past_attendance=False,
                can_manage_maintenance=True,
                can_assign_maintenance=False,
                can_approve_maintenance_costs=False,
                can_update_mess_menu=False,
                can_create_announcements=False,
                can_send_email=False,
                can_send_sms=False,
                can_send_push_notifications=False,
                can_view_student_profiles=True,
                can_view_student_payments=False,
                can_view_financial_reports=False,
                can_generate_reports=False,
                can_export_data=False,
            ),
            is_system_template=True,
        )
        
        return templates


class ApplyPermissionTemplate(BaseCreateSchema):
    """
    Apply permission template to supervisor(s).
    
    Supports both override and merge modes with validation.
    """

    supervisor_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Supervisor IDs to apply template to (max 50)",
    )
    template_name: str = Field(
        ...,
        description="Template name to apply",
    )
    override_existing: bool = Field(
        default=True,
        description="Override existing permissions completely",
    )
    merge_permissions: bool = Field(
        default=False,
        description="Merge with existing permissions (upgrade only)",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for applying template",
    )

    @field_validator("supervisor_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[str]) -> List[str]:
        """Ensure supervisor IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Supervisor IDs must be unique")
        return v

    @model_validator(mode="after")
    def validate_mode_selection(self) -> "ApplyPermissionTemplate":
        """
        Ensure only one application mode is selected.
        
        Returns:
            Self with validated mode
            
        Raises:
            ValueError: If both modes are selected
        """
        if self.override_existing and self.merge_permissions:
            raise ValueError(
                "Cannot both override and merge permissions. "
                "Choose either override_existing=True OR merge_permissions=True"
            )
        
        if not self.override_existing and not self.merge_permissions:
            # Default to override
            self.override_existing = True
        
        return self


class PermissionAuditLog(BaseSchema):
    """
    Permission change audit log.
    
    Comprehensive tracking of permission modifications for compliance
    and security auditing.
    """

    audit_id: str = Field(..., description="Audit log ID")
    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")

    # Change metadata
    changed_by: str = Field(..., description="Admin who made changes")
    changed_by_name: str = Field(..., description="Admin name")
    changed_at: datetime = Field(..., description="Change timestamp")

    # Change details
    permission_changes: Dict[str, Dict[str, Any]] = Field(
        ...,
        description="Permission changes in format {permission: {old: value, new: value}}",
    )
    change_type: Literal["grant", "revoke", "update", "template_applied"] = Field(
        ...,
        description="Type of change",
    )
    reason: Optional[str] = Field(
        default=None,
        description="Reason for change",
    )

    # Context
    ip_address: Optional[str] = Field(
        default=None,
        description="IP address of change initiator",
    )
    user_agent: Optional[str] = Field(
        default=None,
        description="User agent string",
    )
    template_applied: Optional[str] = Field(
        default=None,
        description="Template name if template was applied",
    )

    # Approval tracking (if applicable)
    requires_approval: bool = Field(
        default=False,
        description="Whether change requires approval",
    )
    approved_by: Optional[str] = Field(
        default=None,
        description="Admin who approved change",
    )
    approved_at: Optional[datetime] = Field(
        default=None,
        description="Approval timestamp",
    )

    @computed_field
    @property
    def changes_count(self) -> int:
        """Count of permission changes made."""
        return len(self.permission_changes)

    @computed_field
    @property
    def change_summary(self) -> str:
        """Human-readable summary of changes."""
        if self.template_applied:
            return f"Applied template '{self.template_applied}' ({self.changes_count} permissions changed)"
        
        return f"{self.change_type.title()}: {self.changes_count} permission(s) modified"

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\supervisor\supervisor_profile.py ---
# --- File: app/schemas/supervisor/supervisor_profile.py ---
"""
Supervisor profile schemas with employment and personal information.

Provides comprehensive profile management with employment history,
performance summaries, and personal preferences.
"""

from __future__ import annotations

from datetime import date as Date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import EmploymentType, SupervisorStatus

__all__ = [
    "SupervisorProfile",
    "SupervisorEmployment",
    "PerformanceSummary",
    "SupervisorProfileUpdate",
    "EmploymentHistory",
    "SupervisorPreferences",
]


class SupervisorEmployment(BaseSchema):
    """Detailed supervisor employment information."""
    
    employee_id: Optional[str] = Field(
        default=None,
        description="Employee/Staff ID",
    )
    join_date: Date = Field(..., description="Joining Date")
    employment_type: EmploymentType = Field(..., description="Employment type")
    shift_timing: Optional[str] = Field(
        default=None,
        description="Shift timing or working hours",
    )
    designation: Optional[str] = Field(
        default=None,
        description="Job designation/title",
    )
    
    # Current status
    status: SupervisorStatus = Field(..., description="Current employment status")
    is_active: bool = Field(..., description="Active employment status")
    
    # Contract details
    contract_start_date: Optional[Date] = Field(
        default=None,
        description="Contract start Date (for contract employees)",
    )
    contract_end_date: Optional[Date] = Field(
        default=None,
        description="Contract end Date (for contract employees)",
    )
    
    # Termination details (if applicable)
    termination_date: Optional[Date] = Field(
        default=None,
        description="Termination Date",
    )
    termination_reason: Optional[str] = Field(
        default=None,
        description="Termination reason",
    )
    eligible_for_rehire: Optional[bool] = Field(
        default=None,
        description="Eligible for rehire",
    )
    
    # Assignment details
    assigned_by: str = Field(..., description="Admin who assigned")
    assigned_by_name: str = Field(..., description="Admin name")
    assigned_date: Date = Field(..., description="Assignment Date")
    
    # Compensation (admin view only)
    salary: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Monthly salary",
    )
    last_salary_revision: Optional[Date] = Field(
        default=None,
        description="Last salary revision Date",
    )

    @computed_field
    @property
    def tenure_days(self) -> int:
        """Calculate total tenure in days."""
        end_date = self.termination_date or Date.today()
        return (end_date - self.join_date).days

    @computed_field
    @property
    def tenure_display(self) -> str:
        """Get human-readable tenure."""
        days = self.tenure_days
        
        if days < 30:
            return f"{days} days"
        
        months = days // 30
        if months < 12:
            return f"{months} months"
        
        years = months // 12
        remaining_months = months % 12
        
        if remaining_months == 0:
            return f"{years} {'year' if years == 1 else 'years'}"
        
        return f"{years}y {remaining_months}m"

    @computed_field
    @property
    def is_contract_employee(self) -> bool:
        """Check if employee is on contract."""
        return self.employment_type == EmploymentType.CONTRACT

    @computed_field
    @property
    def contract_status(self) -> Optional[str]:
        """Get contract status for contract employees."""
        if not self.is_contract_employee or not self.contract_end_date:
            return None
        
        today = Date.today()
        days_remaining = (self.contract_end_date - today).days
        
        if days_remaining < 0:
            return "Expired"
        elif days_remaining == 0:
            return "Expires Today"
        elif days_remaining <= 30:
            return f"Expires in {days_remaining} days"
        else:
            return "Active"


class PerformanceSummary(BaseSchema):
    """Performance summary for supervisor profile."""
    
    # Complaint handling
    total_complaints_resolved: int = Field(
        default=0,
        ge=0,
        description="Total complaints resolved",
    )
    average_resolution_time_hours: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average resolution time in hours",
    )
    sla_compliance_rate: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        le=100,
        description="SLA compliance rate percentage",
    )
    
    # Attendance management
    total_attendance_records: int = Field(
        default=0,
        ge=0,
        description="Total attendance records created",
    )
    attendance_punctuality_rate: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        le=100,
        description="On-time attendance marking rate",
    )
    
    # Maintenance management
    total_maintenance_requests: int = Field(
        default=0,
        ge=0,
        description="Total maintenance requests handled",
    )
    maintenance_completion_rate: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        le=100,
        description="Maintenance completion rate",
    )
    
    # Current month performance
    current_month_complaints: int = Field(
        default=0,
        ge=0,
        description="Complaints handled this month",
    )
    current_month_attendance_records: int = Field(
        default=0,
        ge=0,
        description="Attendance records this month",
    )
    current_month_maintenance: int = Field(
        default=0,
        ge=0,
        description="Maintenance requests this month",
    )
    
    # Overall ratings
    performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Latest performance rating (1-5 scale)",
    )
    last_performance_review: Optional[Date] = Field(
        default=None,
        description="Last performance review Date",
    )
    
    # Student feedback
    student_satisfaction_score: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average student satisfaction rating",
    )
    student_feedback_count: int = Field(
        default=0,
        ge=0,
        description="Number of student feedback responses",
    )

    @computed_field
    @property
    def overall_efficiency_score(self) -> Decimal:
        """Calculate overall efficiency score."""
        scores = [
            float(self.sla_compliance_rate),
            float(self.attendance_punctuality_rate),
            float(self.maintenance_completion_rate),
        ]
        
        average_score = sum(scores) / len(scores)
        return Decimal(str(average_score)).quantize(Decimal("0.1"))

    @computed_field
    @property
    def performance_level(self) -> str:
        """Categorize performance level."""
        if not self.performance_rating:
            return "Not Rated"
        
        rating = float(self.performance_rating)
        if rating >= 4.5:
            return "Outstanding"
        elif rating >= 4.0:
            return "Excellent"
        elif rating >= 3.5:
            return "Good"
        elif rating >= 3.0:
            return "Satisfactory"
        elif rating >= 2.0:
            return "Needs Improvement"
        else:
            return "Unsatisfactory"


class EmploymentHistory(BaseSchema):
    """Employment history entry."""
    
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    start_date: Date = Field(..., description="Assignment start Date")
    end_date: Optional[Date] = Field(
        default=None,
        description="Assignment end Date (null if current)",
    )
    designation: Optional[str] = Field(
        default=None,
        description="Designation during this period",
    )
    employment_type: EmploymentType = Field(
        ...,
        description="Employment type during this period",
    )
    reason_for_change: Optional[str] = Field(
        default=None,
        description="Reason for assignment change/end",
    )
    performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Performance rating for this period",
    )

    @computed_field
    @property
    def duration_days(self) -> int:
        """Calculate duration of this assignment."""
        end = self.end_date or Date.today()
        return (end - self.start_date).days

    @computed_field
    @property
    def is_current(self) -> bool:
        """Check if this is the current assignment."""
        return self.end_date is None


class SupervisorPreferences(BaseSchema):
    """Supervisor personal preferences and settings."""
    
    # Notification preferences
    email_notifications: bool = Field(
        default=True,
        description="Enable email notifications",
    )
    sms_notifications: bool = Field(
        default=True,
        description="Enable SMS notifications",
    )
    push_notifications: bool = Field(
        default=True,
        description="Enable push notifications",
    )
    
    # Notification types
    complaint_notifications: bool = Field(
        default=True,
        description="Receive complaint notifications",
    )
    maintenance_notifications: bool = Field(
        default=True,
        description="Receive maintenance notifications",
    )
    attendance_reminders: bool = Field(
        default=True,
        description="Receive attendance marking reminders",
    )
    admin_announcements: bool = Field(
        default=True,
        description="Receive admin announcements",
    )
    
    # Dashboard preferences
    dashboard_refresh_interval: int = Field(
        default=300,
        ge=60,
        le=3600,
        description="Dashboard auto-refresh interval in seconds",
    )
    default_view: str = Field(
        default="dashboard",
        pattern=r"^(dashboard|complaints|attendance|maintenance|reports)$",
        description="Default view on login",
    )
    
    # Language and locale
    preferred_language: str = Field(
        default="en",
        pattern=r"^(en|hi|ta|te|bn|mr|gu)$",
        description="Preferred language",
    )
    timezone: str = Field(
        default="Asia/Kolkata",
        description="Preferred timezone",
    )
    
    # Working hours
    work_start_time: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Work start time (HH:MM)",
    )
    work_end_time: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Work end time (HH:MM)",
    )


class SupervisorProfile(BaseSchema):
    """Complete supervisor profile with all information."""
    
    id: str = Field(..., description="Supervisor ID")
    user_id: str = Field(..., description="User ID")
    
    # Personal information
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email address")
    phone: str = Field(..., description="Phone number")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )
    
    # Current assignment
    hostel_id: str = Field(..., description="Current hostel ID")
    hostel_name: str = Field(..., description="Current hostel name")
    
    # Employment details
    employment: SupervisorEmployment = Field(
        ...,
        description="Current employment information",
    )
    
    # Employment history
    employment_history: List[EmploymentHistory] = Field(
        default_factory=list,
        description="Employment history",
    )
    
    # Permissions
    permissions: dict = Field(
        default_factory=dict,
        description="Current permission settings",
    )
    
    # Performance
    performance_summary: PerformanceSummary = Field(
        ...,
        description="Performance summary",
    )
    
    # Preferences
    preferences: SupervisorPreferences = Field(
        ...,
        description="Personal preferences",
    )
    
    # Activity tracking
    last_login: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )
    total_logins: int = Field(
        default=0,
        ge=0,
        description="Total login count",
    )
    last_activity: Optional[datetime] = Field(
        default=None,
        description="Last activity timestamp",
    )

    @computed_field
    @property
    def total_experience_days(self) -> int:
        """Calculate total experience across all assignments."""
        total_days = 0
        for history in self.employment_history:
            total_days += history.duration_days
        
        # Add current assignment
        total_days += self.employment.tenure_days
        return total_days

    @computed_field
    @property
    def experience_display(self) -> str:
        """Get human-readable total experience."""
        days = self.total_experience_days
        
        if days < 30:
            return f"{days} days"
        
        months = days // 30
        if months < 12:
            return f"{months} months"
        
        years = months // 12
        remaining_months = months % 12
        
        if remaining_months == 0:
            return f"{years} {'year' if years == 1 else 'years'}"
        
        return f"{years}y {remaining_months}m"

    @computed_field
    @property
    def hostels_worked(self) -> int:
        """Count number of different hostels worked at."""
        hostel_ids = {self.hostel_id}
        for history in self.employment_history:
            hostel_ids.add(history.hostel_id)
        return len(hostel_ids)


class SupervisorProfileUpdate(BaseUpdateSchema):
    """Update supervisor profile (supervisor can update own profile)."""
    
    # Contact updates (may require admin approval)
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number",
    )
    
    # Preferences updates
    preferences: Optional[SupervisorPreferences] = Field(
        default=None,
        description="Updated preferences",
    )
    
    # Emergency contact
    emergency_contact_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Emergency contact relation",
    )
    
    # Personal notes
    notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Personal notes",
    )

    @field_validator("phone", "emergency_contact_phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone numbers."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return v

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\supervisor\supervisor_response.py ---
# --- File: app/schemas/supervisor/supervisor_response.py ---
"""
Supervisor response schemas for API responses.

Provides optimized response formats with computed properties
and efficient data serialization.
"""

from __future__ import annotations

from datetime import date as Date, datetime
from decimal import Decimal
from typing import Dict, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import EmploymentType, SupervisorStatus

__all__ = [
    "SupervisorResponse",
    "SupervisorDetail",
    "SupervisorListItem",
    "SupervisorSummary",
    "SupervisorEmploymentInfo",
    "SupervisorStatistics",
]


class SupervisorResponse(BaseResponseSchema):
    """
    Standard supervisor response schema.
    
    Optimized for general API responses with essential information.
    """

    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Supervisor full name")
    email: str = Field(..., description="Email address")
    phone: str = Field(..., description="Phone number")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )

    # Assignment
    assigned_hostel_id: str = Field(..., description="Assigned hostel ID")
    hostel_name: str = Field(..., description="Hostel name")

    # Employment
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    join_date: Date = Field(..., description="Joining Date")
    employment_type: EmploymentType = Field(..., description="Employment type")
    designation: Optional[str] = Field(default=None, description="Designation")

    # Status
    status: SupervisorStatus = Field(..., description="Current status")
    is_active: bool = Field(..., description="Active status")

    # Assignment metadata
    assigned_by: str = Field(..., description="Admin who assigned")
    assigned_date: Date = Field(..., description="Assignment Date")

    @computed_field
    @property
    def tenure_days(self) -> int:
        """Calculate tenure in days since joining."""
        return (Date.today() - self.join_date).days

    @computed_field
    @property
    def tenure_months(self) -> int:
        """Calculate approximate tenure in months."""
        return self.tenure_days // 30

    @computed_field
    @property
    def is_probation(self) -> bool:
        """Check if supervisor is in probation period (first 3 months)."""
        return self.tenure_months < 3


class SupervisorDetail(BaseResponseSchema):
    """
    Detailed supervisor information.
    
    Comprehensive profile with all attributes and computed metrics.
    """

    # User information
    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    gender: Optional[str] = Field(default=None, description="Gender")
    date_of_birth: Optional[Date] = Field(default=None, description="Date of birth")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )

    # Hostel assignment
    assigned_hostel_id: str = Field(..., description="Assigned hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    assigned_by: str = Field(..., description="Admin user ID who assigned")
    assigned_by_name: str = Field(..., description="Admin name")
    assigned_date: Date = Field(..., description="Assignment Date")

    # Employment details
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    join_date: Date = Field(..., description="Joining Date")
    employment_type: EmploymentType = Field(..., description="Employment type")
    shift_timing: Optional[str] = Field(default=None, description="Shift timing")
    designation: Optional[str] = Field(default=None, description="Designation")
    salary: Optional[Decimal] = Field(
        default=None,
        description="Monthly salary (admin view only)",
    )

    # Status
    status: SupervisorStatus = Field(..., description="Current status")
    is_active: bool = Field(..., description="Active status")

    # Termination information
    termination_date: Optional[Date] = Field(
        default=None,
        description="Termination Date",
    )
    termination_reason: Optional[str] = Field(
        default=None,
        description="Termination reason",
    )
    eligible_for_rehire: Optional[bool] = Field(
        default=None,
        description="Rehire eligibility",
    )

    # Suspension information
    suspension_start_date: Optional[Date] = Field(
        default=None,
        description="Suspension start Date",
    )
    suspension_end_date: Optional[Date] = Field(
        default=None,
        description="Suspension end Date",
    )
    suspension_reason: Optional[str] = Field(
        default=None,
        description="Suspension reason",
    )

    # Permissions (optimized structure)
    permissions: Dict[str, bool | int | Decimal] = Field(
        default_factory=dict,
        description="Permission settings",
    )

    # Performance metrics (aggregated)
    total_complaints_resolved: int = Field(
        default=0,
        ge=0,
        description="Total complaints resolved",
    )
    average_resolution_time_hours: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average complaint resolution time",
    )
    total_attendance_records: int = Field(
        default=0,
        ge=0,
        description="Total attendance records created",
    )
    total_maintenance_requests: int = Field(
        default=0,
        ge=0,
        description="Total maintenance requests",
    )
    last_performance_review: Optional[Date] = Field(
        default=None,
        description="Last performance review Date",
    )
    performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Latest performance rating",
    )

    # Activity tracking
    last_login: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )
    total_logins: int = Field(
        default=0,
        ge=0,
        description="Total login count",
    )
    last_activity: Optional[datetime] = Field(
        default=None,
        description="Last activity timestamp",
    )

    # Administrative notes
    notes: Optional[str] = Field(
        default=None,
        description="Administrative notes",
    )

    @computed_field
    @property
    def age(self) -> Optional[int]:
        """Calculate age from Date of birth."""
        if not self.date_of_birth:
            return None
        
        today = Date.today()
        age = (
            today.year
            - self.date_of_birth.year
            - ((today.month, today.day) < (self.date_of_birth.month, self.date_of_birth.day))
        )
        return age

    @computed_field
    @property
    def tenure_months(self) -> int:
        """Calculate tenure in complete months."""
        return (Date.today() - self.join_date).days // 30

    @computed_field
    @property
    def tenure_years(self) -> int:
        """Calculate tenure in complete years."""
        return self.tenure_months // 12

    @computed_field
    @property
    def is_probation(self) -> bool:
        """Check if supervisor is in probation period."""
        return self.tenure_months < 3

    @computed_field
    @property
    def can_work(self) -> bool:
        """Check if supervisor is currently allowed to work."""
        return self.is_active and self.status == SupervisorStatus.ACTIVE

    @computed_field
    @property
    def suspension_days_remaining(self) -> Optional[int]:
        """Calculate remaining suspension days if currently suspended."""
        if self.status != SupervisorStatus.SUSPENDED or not self.suspension_end_date:
            return None
        
        remaining = (self.suspension_end_date - Date.today()).days
        return max(0, remaining)
# Continuing supervisor_response.py...

class SupervisorListItem(BaseSchema):
    """
    Supervisor list item for efficient list rendering.
    
    Minimal information optimized for table/grid views.
    """

    id: str = Field(..., description="Supervisor ID")
    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )

    # Assignment
    hostel_name: str = Field(..., description="Assigned hostel")
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    designation: Optional[str] = Field(default=None, description="Designation")

    # Employment
    employment_type: EmploymentType = Field(..., description="Employment type")
    join_date: Date = Field(..., description="Joining Date")

    # Status
    status: SupervisorStatus = Field(..., description="Status")
    is_active: bool = Field(..., description="Active status")

    # Performance (current month)
    performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Performance rating",
    )
    complaints_resolved_this_month: int = Field(
        default=0,
        ge=0,
        description="Complaints resolved this month",
    )

    # Activity
    last_login: Optional[datetime] = Field(
        default=None,
        description="Last login",
    )

    @computed_field
    @property
    def tenure_months(self) -> int:
        """Calculate tenure in months."""
        return (Date.today() - self.join_date).days // 30

    @computed_field
    @property
    def display_status(self) -> str:
        """Get human-readable status."""
        status_map = {
            SupervisorStatus.ACTIVE: "Active",
            SupervisorStatus.ON_LEAVE: "On Leave",
            SupervisorStatus.SUSPENDED: "Suspended",
            SupervisorStatus.TERMINATED: "Terminated",
        }
        return status_map.get(self.status, self.status.value)


class SupervisorSummary(BaseSchema):
    """
    Supervisor summary for dashboards.
    
    Optimized for quick overview with key metrics.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    designation: Optional[str] = Field(default=None, description="Designation")

    # Status
    status: SupervisorStatus = Field(..., description="Status")
    is_active: bool = Field(..., description="Active status")
    shift_timing: Optional[str] = Field(default=None, description="Shift timing")

    # Current month metrics
    complaints_handled_this_month: int = Field(
        default=0,
        ge=0,
        description="Complaints handled",
    )
    complaints_resolved_this_month: int = Field(
        default=0,
        ge=0,
        description="Complaints resolved",
    )
    attendance_records_this_month: int = Field(
        default=0,
        ge=0,
        description="Attendance records",
    )
    maintenance_requests_this_month: int = Field(
        default=0,
        ge=0,
        description="Maintenance requests",
    )

    # Activity
    last_active: Optional[datetime] = Field(
        default=None,
        description="Last activity",
    )
    is_online: bool = Field(
        default=False,
        description="Currently online",
    )

    @computed_field
    @property
    def complaint_resolution_rate(self) -> Decimal:
        """Calculate complaint resolution rate percentage."""
        if self.complaints_handled_this_month == 0:
            return Decimal("100.00")
        
        rate = (
            self.complaints_resolved_this_month
            / self.complaints_handled_this_month
            * 100
        )
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def activity_status(self) -> str:
        """Get human-readable activity status."""
        if self.is_online:
            return "Online"
        
        if not self.last_active:
            return "Never"
        
        hours_ago = (datetime.now() - self.last_active).total_seconds() / 3600
        
        if hours_ago < 1:
            return "Active recently"
        elif hours_ago < 24:
            return f"Active {int(hours_ago)}h ago"
        else:
            days_ago = int(hours_ago / 24)
            return f"Active {days_ago}d ago"


class SupervisorEmploymentInfo(BaseSchema):
    """
    Detailed employment information.
    
    Comprehensive contract and compensation details.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")

    # Employment details
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    join_date: Date = Field(..., description="Joining Date")
    employment_type: EmploymentType = Field(..., description="Employment type")
    designation: Optional[str] = Field(default=None, description="Designation")
    shift_timing: Optional[str] = Field(default=None, description="Shift timing")

    # Contract
    contract_start_date: Optional[Date] = Field(
        default=None,
        description="Contract start Date",
    )
    contract_end_date: Optional[Date] = Field(
        default=None,
        description="Contract end Date",
    )
    is_contract_active: bool = Field(
        default=True,
        description="Contract active status",
    )

    # Compensation
    salary: Optional[Decimal] = Field(
        default=None,
        description="Monthly salary",
    )
    last_salary_revision: Optional[Date] = Field(
        default=None,
        description="Last salary revision Date",
    )

    # Status
    status: SupervisorStatus = Field(..., description="Current status")
    is_active: bool = Field(..., description="Active status")

    # Assignment
    assigned_hostel: str = Field(..., description="Assigned hostel")
    assigned_by: str = Field(..., description="Admin who assigned")
    assigned_date: Date = Field(..., description="Assignment Date")

    # Termination
    termination_date: Optional[Date] = Field(
        default=None,
        description="Termination Date",
    )
    termination_reason: Optional[str] = Field(
        default=None,
        description="Termination reason",
    )
    eligible_for_rehire: Optional[bool] = Field(
        default=None,
        description="Rehire eligibility",
    )

    @computed_field
    @property
    def tenure_days(self) -> int:
        """Calculate total tenure in days."""
        end_date = self.termination_date or Date.today()
        return (end_date - self.join_date).days

    @computed_field
    @property
    def tenure_display(self) -> str:
        """Get human-readable tenure."""
        days = self.tenure_days
        
        if days < 30:
            return f"{days} days"
        
        months = days // 30
        if months < 12:
            return f"{months} months"
        
        years = months // 12
        remaining_months = months % 12
        
        if remaining_months == 0:
            return f"{years} {'year' if years == 1 else 'years'}"
        
        return f"{years}y {remaining_months}m"

    @computed_field
    @property
    def is_contract_expiring_soon(self) -> bool:
        """Check if contract expires within 30 days."""
        if not self.contract_end_date or not self.is_contract_active:
            return False
        
        days_until_expiry = (self.contract_end_date - Date.today()).days
        return 0 < days_until_expiry <= 30

    @computed_field
    @property
    def contract_status(self) -> str:
        """Get contract status description."""
        if not self.contract_end_date:
            return "Permanent"
        
        if not self.is_contract_active:
            return "Expired"
        
        days_remaining = (self.contract_end_date - Date.today()).days
        
        if days_remaining < 0:
            return "Expired"
        elif days_remaining == 0:
            return "Expires today"
        elif days_remaining <= 7:
            return f"Expires in {days_remaining} days (urgent)"
        elif days_remaining <= 30:
            return f"Expires in {days_remaining} days"
        else:
            return f"Active (expires {self.contract_end_date.strftime('%b %Y')})"


class SupervisorStatistics(BaseSchema):
    """
    Comprehensive statistics and performance metrics.
    
    Aggregated data for reporting and analysis.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    calculation_period: str = Field(
        ...,
        description="Period for statistics",
        examples=["Last 30 days", "This month", "2024-01"],
    )

    # Complaint metrics
    total_complaints_assigned: int = Field(
        default=0,
        ge=0,
        description="Total complaints assigned",
    )
    complaints_resolved: int = Field(
        default=0,
        ge=0,
        description="Complaints resolved",
    )
    complaints_pending: int = Field(
        default=0,
        ge=0,
        description="Complaints pending",
    )
    average_resolution_time_hours: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average resolution time",
    )
    sla_compliance_rate: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        le=100,
        description="SLA compliance percentage",
    )

    # Attendance metrics
    attendance_records_created: int = Field(
        default=0,
        ge=0,
        description="Attendance records created",
    )
    attendance_marked_on_time: int = Field(
        default=0,
        ge=0,
        description="Attendance marked on time",
    )
    leaves_processed: int = Field(
        default=0,
        ge=0,
        description="Leave requests processed",
    )

    # Maintenance metrics
    maintenance_requests_created: int = Field(
        default=0,
        ge=0,
        description="Maintenance requests created",
    )
    maintenance_completed: int = Field(
        default=0,
        ge=0,
        description="Maintenance completed",
    )
    average_maintenance_completion_hours: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average completion time",
    )

    # Communication metrics
    announcements_created: int = Field(
        default=0,
        ge=0,
        description="Announcements created",
    )
    announcement_reach: int = Field(
        default=0,
        ge=0,
        description="Total students reached",
    )

    # Activity metrics
    total_logins: int = Field(
        default=0,
        ge=0,
        description="Total logins",
    )
    active_days: int = Field(
        default=0,
        ge=0,
        description="Days with activity",
    )
    average_response_time_minutes: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average response time",
    )

    # Overall performance
    overall_performance_score: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Calculated performance score",
    )

    @computed_field
    @property
    def complaint_resolution_rate(self) -> Decimal:
        """Calculate complaint resolution rate percentage."""
        if self.total_complaints_assigned == 0:
            return Decimal("100.00")
        
        rate = (self.complaints_resolved / self.total_complaints_assigned * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def maintenance_completion_rate(self) -> Decimal:
        """Calculate maintenance completion rate percentage."""
        if self.maintenance_requests_created == 0:
            return Decimal("100.00")
        
        rate = (self.maintenance_completed / self.maintenance_requests_created * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def attendance_punctuality_rate(self) -> Decimal:
        """Calculate attendance marking punctuality rate."""
        if self.attendance_records_created == 0:
            return Decimal("100.00")
        
        rate = (self.attendance_marked_on_time / self.attendance_records_created * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def activity_rate(self) -> Decimal:
        """Calculate activity rate (active days / total days in period)."""
        # Assuming 30 days for "This month" or "Last 30 days"
        # In real implementation, this would be calculated from period
        total_days = 30
        
        if self.active_days == 0:
            return Decimal("0.00")
        
        rate = (self.active_days / total_days * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def performance_grade(self) -> str:
        """Get performance grade based on overall score."""
        score = float(self.overall_performance_score)
        
        if score >= 90:
            return "A+ (Excellent)"
        elif score >= 80:
            return "A (Very Good)"
        elif score >= 70:
            return "B+ (Good)"
        elif score >= 60:
            return "B (Satisfactory)"
        elif score >= 50:
            return "C (Needs Improvement)"
        else:
            return "D (Poor)"

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\supervisor\__init__.py ---
# --- File: app/schemas/supervisor/__init__.py ---
# app/schemas/supervisor/__init__.py
"""
Supervisor schemas package
"""
from app.schemas.supervisor.supervisor_base import (
    SupervisorBase,
    SupervisorCreate,
    SupervisorUpdate
)
from app.schemas.supervisor.supervisor_response import (
    SupervisorResponse,
    SupervisorDetail,
    SupervisorListItem
)
from app.schemas.supervisor.supervisor_profile import (
    SupervisorProfile,
    SupervisorEmployment,
    SupervisorProfileUpdate
)
from app.schemas.supervisor.supervisor_permissions import (
    SupervisorPermissions,
    PermissionUpdate,
    PermissionCheckRequest,
    PermissionCheckResponse
)
from app.schemas.supervisor.supervisor_assignment import (
    SupervisorAssignment,
    AssignmentRequest,
    AssignmentUpdate,
    RevokeAssignmentRequest
)
from app.schemas.supervisor.supervisor_activity import (
    SupervisorActivityLog,
    ActivitySummary,
    ActivityDetail,
    ActivityFilterParams
)
from app.schemas.supervisor.supervisor_dashboard import (
    SupervisorDashboard,
    DashboardMetrics,
    TaskSummary,
    RecentComplaintItem,
    RecentMaintenanceItem,
    PendingLeaveItem,
    TodaySchedule,
    ScheduledMaintenanceItem,
    ScheduledMeeting,
    DashboardAlert,
    QuickActions,
    PerformanceIndicators
)
from app.schemas.supervisor.supervisor_performance import (
    PerformanceMetrics,
    PerformanceReport,
    PerformanceReview,
    ComplaintPerformance,
    AttendancePerformance,
    MaintenancePerformance
)

__all__ = [
    # Base
    "SupervisorBase",
    "SupervisorCreate",
    "SupervisorUpdate",
    
    # Response
    "SupervisorResponse",
    "SupervisorDetail",
    "SupervisorListItem",
    
    # Profile
    "SupervisorProfile",
    "SupervisorEmployment",
    "SupervisorProfileUpdate",
    
    # Permissions
    "SupervisorPermissions",
    "PermissionUpdate",
    "PermissionCheckRequest",
    "PermissionCheckResponse",
    
    # Assignment
    "SupervisorAssignment",
    "AssignmentRequest",
    "AssignmentUpdate",
    "RevokeAssignmentRequest",
    
    # Activity
    "SupervisorActivityLog",
    "ActivitySummary",
    "ActivityDetail",
    "ActivityFilterParams",
    
    # Dashboard
    "SupervisorDashboard",
    "DashboardMetrics",
    "TaskSummary",
    "RecentComplaintItem",
    "RecentMaintenanceItem",
    "PendingLeaveItem",
    "TodaySchedule",
    "ScheduledMaintenanceItem",
    "ScheduledMeeting",
    "DashboardAlert",
    "QuickActions",
    "PerformanceIndicators",
    
    # Performance
    "PerformanceMetrics",
    "PerformanceReport",
    "PerformanceReview",
    "ComplaintPerformance",
    "AttendancePerformance",
    "MaintenancePerformance",
]


# ===== Folder: D:\Last Github Push\Last\Hostel-Main\app\schemas\supervisor\__pycache__ =====