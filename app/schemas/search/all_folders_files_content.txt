### Combined Content from Folder: D:\Last Github Push\Last\Hostel-Main\app\schemas\search ###



# ===== Folder: D:\Last Github Push\Last\Hostel-Main\app\schemas\search =====

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\search\search_analytics.py ---
# --- File: app/schemas/search/search_analytics.py ---
"""
Search analytics and insights schemas.

Provides comprehensive analytics on search behavior, popular queries,
and zero-result searches for optimization.
"""

from __future__ import annotations

from datetime import date as Date, datetime
from typing import Any, Dict, List, Optional

from pydantic import Field, field_validator, model_validator, computed_field, ConfigDict

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "SearchTermStats",
    "SearchMetrics",
    "PopularSearchTerm",
    "TrendingSearch",
    "ZeroResultTerm",
    "SearchAnalyticsRequest",
    "SearchAnalytics",
]


class SearchTermStats(BaseSchema):
    """
    Detailed statistics for a single search term.

    Tracks usage patterns and result quality for search optimization.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    term: str = Field(
        ...,
        description="Search term or query",
    )
    search_count: int = Field(
        ...,
        ge=0,
        description="Number of times this term was searched",
    )
    unique_users: int = Field(
        default=0,
        ge=0,
        description="Number of unique users who searched this term",
    )

    # Result quality metrics
    avg_results: float = Field(
        ...,
        ge=0,
        description="Average number of results returned",
    )
    zero_result_count: int = Field(
        ...,
        ge=0,
        description="Number of searches with zero results",
    )
    zero_result_rate: float = Field(
        default=0.0,
        ge=0,
        le=100,
        description="Percentage of searches with zero results",
    )

    # Engagement metrics
    avg_click_position: Optional[float] = Field(
        default=None,
        ge=0,
        description="Average position of clicked results (1-based)",
    )
    click_through_rate: float = Field(
        default=0.0,
        ge=0,
        le=100,
        description="Percentage of searches that resulted in clicks",
    )

    # Temporal data
    first_searched_at: datetime = Field(
        ...,
        description="When this term was first searched",
    )
    last_searched_at: datetime = Field(
        ...,
        description="Most recent search timestamp",
    )

    # Trend indicators
    trend_direction: Optional[str] = Field(
        default=None,
        pattern=r"^(rising|falling|stable)$",
        description="Search trend direction",
    )
    growth_rate: Optional[float] = Field(
        default=None,
        description="Percentage change in search volume (vs previous period)",
    )


class SearchMetrics(BaseSchema):
    """
    Aggregated search performance metrics.

    Provides overview of search system health and performance.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    # Volume metrics
    total_searches: int = Field(
        ...,
        ge=0,
        description="Total number of searches in period",
    )
    unique_searches: int = Field(
        ...,
        ge=0,
        description="Number of unique search queries",
    )
    unique_users: int = Field(
        default=0,
        ge=0,
        description="Number of unique users who performed searches",
    )

    # Quality metrics
    avg_results_per_search: float = Field(
        ...,
        ge=0,
        description="Average number of results per search",
    )
    zero_result_searches: int = Field(
        ...,
        ge=0,
        description="Number of searches with zero results",
    )
    zero_result_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of searches with zero results",
    )

    # Performance metrics
    avg_response_time_ms: float = Field(
        ...,
        ge=0,
        description="Average search response time in milliseconds",
    )
    p95_response_time_ms: float = Field(
        ...,
        ge=0,
        description="95th percentile response time",
    )
    p99_response_time_ms: float = Field(
        ...,
        ge=0,
        description="99th percentile response time",
    )

    # Engagement metrics
    avg_click_through_rate: float = Field(
        default=0.0,
        ge=0,
        le=100,
        description="Average click-through rate across all searches",
    )
    searches_with_clicks: int = Field(
        default=0,
        ge=0,
        description="Number of searches that resulted in at least one click",
    )


class PopularSearchTerm(BaseSchema):
    """
    Popular search term with ranking.

    Used for displaying trending/popular searches to users.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    rank: int = Field(
        ...,
        ge=1,
        description="Popularity ranking (1 = most popular)",
    )
    term: str = Field(
        ...,
        description="Search term",
    )
    search_count: int = Field(
        ...,
        ge=0,
        description="Number of searches",
    )
    result_count: int = Field(
        ...,
        ge=0,
        description="Average number of results",
    )
    change_from_previous: Optional[int] = Field(
        default=None,
        description="Change in rank from previous period (+/- positions)",
    )


class TrendingSearch(BaseSchema):
    """
    Trending search term (rapidly growing in popularity).

    Identifies emerging search patterns.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    term: str = Field(
        ...,
        description="Trending search term",
    )
    current_count: int = Field(
        ...,
        ge=0,
        description="Number of searches in current period",
    )
    previous_count: int = Field(
        ...,
        ge=0,
        description="Number of searches in previous period",
    )
    growth_rate: float = Field(
        ...,
        description="Percentage growth rate",
    )
    velocity: float = Field(
        ...,
        ge=0,
        description="Trending velocity score (higher = faster growth)",
    )


class ZeroResultTerm(BaseSchema):
    """
    Search term that consistently returns zero results.

    Critical for search optimization and content gap analysis.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    term: str = Field(
        ...,
        description="Search term with zero results",
    )
    search_count: int = Field(
        ...,
        ge=1,
        description="Number of times searched (with zero results)",
    )
    unique_users: int = Field(
        ...,
        ge=0,
        description="Number of unique users affected",
    )
    first_seen: datetime = Field(
        ...,
        description="First occurrence of this zero-result search",
    )
    last_seen: datetime = Field(
        ...,
        description="Most recent occurrence",
    )
    suggested_alternatives: Optional[List[str]] = Field(
        default=None,
        description="Suggested alternative search terms",
    )


class SearchAnalyticsRequest(BaseSchema):
    """
    Request parameters for search analytics.

    Allows filtering analytics by Date range and other criteria.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    # Date range
    date_range: DateRangeFilter = Field(
        ...,
        description="Date range for analytics",
    )

    # Filters
    min_search_count: int = Field(
        default=1,
        ge=1,
        description="Minimum number of searches to include term",
    )
    include_zero_results: bool = Field(
        default=True,
        description="Include zero-result searches in analysis",
    )

    # Limits
    top_terms_limit: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Number of top terms to return",
    )
    trending_limit: int = Field(
        default=10,
        ge=1,
        le=50,
        description="Number of trending terms to return",
    )
    zero_result_limit: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Number of zero-result terms to return",
    )

    @model_validator(mode="after")
    def validate_date_range(self) -> "SearchAnalyticsRequest":
        """Validate Date range is reasonable."""
        if self.date_range.start_date and self.date_range.end_date:
            delta = self.date_range.end_date - self.date_range.start_date
            if delta.days > 365:
                raise ValueError("Date range cannot exceed 365 days")
        return self


class SearchAnalytics(BaseSchema):
    """
    Comprehensive search analytics response.

    Provides detailed insights into search behavior and performance.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    # Period information
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period",
    )
    generated_at: datetime = Field(
        default_factory=lambda: datetime.utcnow(),
        description="When this analytics report was generated",
    )

    # Overall metrics
    metrics: SearchMetrics = Field(
        ...,
        description="Aggregated search metrics",
    )

    # Top searches
    top_searches: List[PopularSearchTerm] = Field(
        default_factory=list,
        description="Most popular search terms",
    )

    # Trending searches
    trending_searches: List[TrendingSearch] = Field(
        default_factory=list,
        description="Rapidly growing search terms",
    )

    # Zero-result searches
    zero_result_searches: List[ZeroResultTerm] = Field(
        default_factory=list,
        description="Searches that returned no results",
    )

    # Detailed term statistics (optional, for deep dive)
    term_statistics: Optional[List[SearchTermStats]] = Field(
        default=None,
        description="Detailed statistics for individual search terms",
    )

    # Breakdown by category
    category_breakdown: Optional[Dict[str, int]] = Field(
        default=None,
        description="Search volume by category (hostel_type, location, etc.)",
    )

    # Geographic breakdown
    geographic_breakdown: Optional[Dict[str, int]] = Field(
        default=None,
        description="Search volume by location (city/state)",
    )

    @computed_field
    @property
    def has_quality_issues(self) -> bool:
        """
        Check if there are search quality issues.

        Returns True if zero-result rate is high or response times are slow.
        """
        return (
            self.metrics.zero_result_rate > 20
            or self.metrics.p95_response_time_ms > 1000
        )

    @computed_field
    @property
    def engagement_score(self) -> float:
        """
        Calculate overall engagement score (0-100).

        Based on click-through rate and result quality.
        """
        # Weight CTR (70%) and inverse zero-result rate (30%)
        ctr_score = self.metrics.avg_click_through_rate * 0.7
        quality_score = (100 - self.metrics.zero_result_rate) * 0.3
        return min(ctr_score + quality_score, 100)

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\search\search_autocomplete.py ---
# --- File: app/schemas/search/search_autocomplete.py ---
"""
Autocomplete and suggestion schemas for search.

Provides real-time search suggestions as users type.
"""

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import Field, field_validator, ConfigDict

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "SuggestionType",
    "AutocompleteRequest",
    "Suggestion",
    "AutocompleteResponse",
]


class SuggestionType(str, Enum):
    """
    Type of autocomplete suggestion.

    Helps categorize and display suggestions appropriately.
    """

    HOSTEL = "hostel"
    CITY = "city"
    AREA = "area"
    LANDMARK = "landmark"
    AMENITY = "amenity"
    POPULAR_SEARCH = "popular_search"


class AutocompleteRequest(BaseCreateSchema):
    """
    Autocomplete request for search suggestions.

    Optimized for real-time typeahead functionality.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    prefix: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Search prefix (user's partial input)",
        examples=["mumb", "boys host", "pg near"],
    )
    suggestion_type: Optional[SuggestionType] = Field(
        default=None,
        description="Filter suggestions by type (optional)",
    )
    limit: int = Field(
        default=10,
        ge=1,
        le=20,
        description="Maximum number of suggestions to return",
    )

    # Context for personalization
    user_latitude: Optional[float] = Field(
        default=None,
        ge=-90,
        le=90,
        description="User latitude for location-based suggestions",
    )
    user_longitude: Optional[float] = Field(
        default=None,
        ge=-180,
        le=180,
        description="User longitude for location-based suggestions",
    )

    # Filtering
    include_types: Optional[List[SuggestionType]] = Field(
        default=None,
        description="Include only these suggestion types",
        examples=[["hostel", "city"]],
    )
    exclude_types: Optional[List[SuggestionType]] = Field(
        default=None,
        description="Exclude these suggestion types",
    )

    @field_validator("prefix")
    @classmethod
    def normalize_prefix(cls, v: str) -> str:
        """
        Normalize search prefix.

        - Trim whitespace
        - Convert to lowercase for matching
        """
        normalized = v.strip().lower()
        if not normalized:
            raise ValueError("Search prefix cannot be empty or only whitespace")
        return normalized

    @field_validator("include_types", "exclude_types")
    @classmethod
    def validate_type_lists(
        cls,
        v: Optional[List[SuggestionType]],
    ) -> Optional[List[SuggestionType]]:
        """Remove duplicates from type lists."""
        if v is not None:
            return list(dict.fromkeys(v))  # Preserve order while removing dupes
        return v


class Suggestion(BaseSchema):
    """
    Single autocomplete suggestion.

    Provides rich metadata for displaying suggestions.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    # Core fields
    value: str = Field(
        ...,
        description="Suggestion value (what to insert into search)",
        examples=["Mumbai", "Boys Hostel in Andheri"],
    )
    label: str = Field(
        ...,
        description="Display label (formatted for UI)",
        examples=["Mumbai, Maharashtra", "Boys Hostel in Andheri (15 results)"],
    )
    type: SuggestionType = Field(
        ...,
        description="Suggestion type",
    )

    # Metadata
    score: float = Field(
        default=0.0,
        ge=0,
        description="Relevance/popularity score",
    )
    result_count: Optional[int] = Field(
        default=None,
        ge=0,
        description="Estimated number of results for this suggestion",
    )

    # Rich data (optional)
    icon: Optional[str] = Field(
        default=None,
        description="Icon identifier for UI display",
        examples=["location", "building", "search"],
    )
    thumbnail_url: Optional[str] = Field(
        default=None,
        description="Thumbnail image URL (for hostel suggestions)",
    )

    # Additional context
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional type-specific metadata",
        examples=[
            {"city": "Mumbai", "state": "Maharashtra"},
            {"hostel_id": "uuid", "min_price": 10000},
        ],
    )

    # Highlighting
    highlighted_label: Optional[str] = Field(
        default=None,
        description="Label with matched portions highlighted (HTML)",
        examples=["<strong>Mumb</strong>ai, Maharashtra"],
    )


class AutocompleteResponse(BaseSchema):
    """
    Autocomplete response with suggestions.

    Groups suggestions by type for better UX.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    suggestions: List[Suggestion] = Field(
        default_factory=list,
        description="Ordered list of suggestions",
    )

    # Grouped suggestions (optional, for categorized display)
    grouped_suggestions: Optional[Dict[str, List[Suggestion]]] = Field(
        default=None,
        description="Suggestions grouped by type",
        examples=[
            {
                "hostel": [{"value": "XYZ Hostel", "label": "XYZ Hostel"}],
                "city": [{"value": "Mumbai", "label": "Mumbai, Maharashtra"}],
            }
        ],
    )

    # Metadata
    prefix: str = Field(
        ...,
        description="Original search prefix",
    )
    total_suggestions: int = Field(
        ...,
        ge=0,
        description="Total number of suggestions returned",
    )
    execution_time_ms: int = Field(
        ...,
        ge=0,
        description="Suggestion generation time in milliseconds",
    )

    # Popular searches (shown when no prefix match)
    popular_searches: Optional[List[str]] = Field(
        default=None,
        description="Popular search terms (shown for empty/short prefix)",
        examples=[["Boys Hostel Mumbai", "PG in Bangalore", "Hostel near me"]],
    )

    @classmethod
    def create_grouped(
        cls,
        suggestions: List[Suggestion],
        prefix: str,
        execution_time_ms: int = 0,
    ) -> "AutocompleteResponse":
        """
        Create response with automatic grouping by type.

        Args:
            suggestions: List of suggestions
            prefix: Original search prefix
            execution_time_ms: Execution time

        Returns:
            AutocompleteResponse with grouped suggestions
        """
        # Group suggestions by type
        grouped: Dict[str, List[Suggestion]] = {}
        for suggestion in suggestions:
            type_key = suggestion.type.value
            if type_key not in grouped:
                grouped[type_key] = []
            grouped[type_key].append(suggestion)

        return cls(
            suggestions=suggestions,
            grouped_suggestions=grouped if grouped else None,
            prefix=prefix,
            total_suggestions=len(suggestions),
            execution_time_ms=execution_time_ms,
        )

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\search\search_filters.py ---
# --- File: app/schemas/search/search_filters.py ---
"""
Reusable search filter schemas.

Provides modular, composable filter schemas for advanced search functionality.
"""

from __future__ import annotations

from datetime import date as Date
from decimal import Decimal
from typing import List, Optional, Annotated

from pydantic import Field, field_validator, model_validator, computed_field, ConfigDict

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import HostelType, RoomType

__all__ = [
    "PriceFilter",
    "RatingFilter",
    "AmenityFilter",
    "LocationFilter",
    "AvailabilityFilter",
    "SearchFilterSet",
]


class PriceFilter(BaseFilterSchema):
    """
    Price range filter with validation.

    Ensures min_price <= max_price and both are non-negative.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    min_price: Optional[Annotated[Decimal, Field(ge=0)]] = Field(
        default=None,
        description="Minimum price in INR",
        examples=[5000, 10000],
    )
    max_price: Optional[Annotated[Decimal, Field(ge=0)]] = Field(
        default=None,
        description="Maximum price in INR",
        examples=[20000, 30000],
    )

    @model_validator(mode="after")
    def validate_price_range(self) -> "PriceFilter":
        """Ensure min_price is not greater than max_price."""
        if (
            self.min_price is not None
            and self.max_price is not None
            and self.min_price > self.max_price
        ):
            raise ValueError(
                f"min_price ({self.min_price}) cannot be greater than "
                f"max_price ({self.max_price})"
            )
        return self

    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if price filter is active."""
        return self.min_price is not None or self.max_price is not None


class RatingFilter(BaseFilterSchema):
    """
    Rating range filter with validation.

    Ensures ratings are within valid range (0-5).
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    min_rating: Optional[Annotated[Decimal, Field(ge=0, le=5)]] = Field(
        default=None,
        description="Minimum average rating (0-5 scale)",
        examples=[3.5, 4.0, 4.5],
    )
    max_rating: Optional[Annotated[Decimal, Field(ge=0, le=5)]] = Field(
        default=None,
        description="Maximum average rating (0-5 scale)",
        examples=[5.0],
    )

    @model_validator(mode="after")
    def validate_rating_range(self) -> "RatingFilter":
        """Ensure min_rating is not greater than max_rating."""
        if (
            self.min_rating is not None
            and self.max_rating is not None
            and self.min_rating > self.max_rating
        ):
            raise ValueError(
                f"min_rating ({self.min_rating}) cannot be greater than "
                f"max_rating ({self.max_rating})"
            )
        return self

    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if rating filter is active."""
        return self.min_rating is not None or self.max_rating is not None


class AmenityFilter(BaseFilterSchema):
    """
    Amenity filter with AND/OR logic support.

    - `required_amenities`: ALL must be present (AND logic)
    - `optional_amenities`: ANY can be present (OR logic)
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    required_amenities: Optional[List[str]] = Field(
        default=None,
        description="All of these amenities must be present (AND logic)",
        examples=[["wifi", "ac", "parking"]],
    )
    optional_amenities: Optional[List[str]] = Field(
        default=None,
        description="Any of these amenities can be present (OR logic)",
        examples=[["gym", "swimming_pool", "laundry"]],
    )
    excluded_amenities: Optional[List[str]] = Field(
        default=None,
        description="None of these amenities should be present",
        examples=[["smoking_allowed"]],
    )

    @field_validator("required_amenities", "optional_amenities", "excluded_amenities")
    @classmethod
    def normalize_amenities(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """
        Normalize amenity list.

        - Convert to lowercase
        - Remove duplicates
        - Strip whitespace
        - Preserve order
        """
        if v is not None:
            seen = set()
            normalized = []
            for amenity in v:
                amenity_clean = amenity.lower().strip()
                if amenity_clean and amenity_clean not in seen:
                    seen.add(amenity_clean)
                    normalized.append(amenity_clean)
            return normalized if normalized else None
        return v

    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if amenity filter is active."""
        return (
            self.required_amenities is not None
            or self.optional_amenities is not None
            or self.excluded_amenities is not None
        )


class LocationFilter(BaseFilterSchema):
    """
    Location-based filter with multiple filter types.

    Supports:
    - Text-based location (city, state, pincode)
    - Proximity-based (lat/lon + radius)
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    # Text-based location
    city: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="City name",
        examples=["Mumbai", "Bangalore"],
    )
    state: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="State name",
        examples=["Maharashtra", "Karnataka"],
    )
    pincode: Optional[str] = Field(
        default=None,
        pattern=r"^\d{6}$",
        description="6-digit pincode",
        examples=["400001", "560001"],
    )

    # Proximity-based location
    latitude: Optional[Annotated[Decimal, Field(ge=-90, le=90)]] = Field(
        default=None,
        description="Latitude for proximity search",
    )
    longitude: Optional[Annotated[Decimal, Field(ge=-180, le=180)]] = Field(
        default=None,
        description="Longitude for proximity search",
    )
    radius_km: Optional[Annotated[Decimal, Field(ge=0.1, le=100)]] = Field(
        default=None,
        description="Search radius in kilometers",
        examples=[5, 10, 25],
    )

    @field_validator("city", "state")
    @classmethod
    def normalize_location(cls, v: Optional[str]) -> Optional[str]:
        """Normalize location strings to title case."""
        if v is not None:
            return v.strip().title()
        return v

    @model_validator(mode="after")
    def validate_proximity_requirements(self) -> "LocationFilter":
        """Ensure radius requires both latitude and longitude."""
        if self.radius_km is not None:
            if self.latitude is None or self.longitude is None:
                raise ValueError(
                    "Both latitude and longitude are required when using radius_km"
                )
        return self

    @computed_field
    @property
    def is_text_location(self) -> bool:
        """Check if text-based location filter is active."""
        return any([self.city, self.state, self.pincode])

    @computed_field
    @property
    def is_proximity_location(self) -> bool:
        """Check if proximity-based location filter is active."""
        return self.latitude is not None and self.longitude is not None

    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if any location filter is active."""
        return self.is_text_location or self.is_proximity_location


class AvailabilityFilter(BaseFilterSchema):
    """
    Availability and booking filters.

    Filters based on bed availability and booking requirements.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    available_only: bool = Field(
        default=False,
        description="Show only hostels with available beds",
    )
    min_available_beds: Optional[int] = Field(
        default=None,
        ge=1,
        description="Minimum number of available beds required",
        examples=[1, 2, 5],
    )

    # Date-based availability
    check_in_date: Optional[Date] = Field(
        default=None,
        description="Desired check-in Date",
    )
    check_out_date: Optional[Date] = Field(
        default=None,
        description="Desired check-out Date",
    )

    # Booking preferences
    instant_booking_only: bool = Field(
        default=False,
        description="Show only hostels with instant booking enabled",
    )
    verified_only: bool = Field(
        default=False,
        description="Show only verified hostels",
    )

    @model_validator(mode="after")
    def validate_date_range(self) -> "AvailabilityFilter":
        """Validate check-in and check-out Date logic."""
        if self.check_in_date and self.check_out_date:
            if self.check_in_date >= self.check_out_date:
                raise ValueError(
                    "check_in_date must be before check_out_date"
                )

            # Validate dates are not in the past
            today = Date.today()
            if self.check_in_date < today:
                raise ValueError("check_in_date cannot be in the past")

        return self

    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if any availability filter is active."""
        return (
            self.available_only
            or self.min_available_beds is not None
            or self.check_in_date is not None
            or self.instant_booking_only
            or self.verified_only
        )


class SearchFilterSet(BaseFilterSchema):
    """
    Composite filter set combining all filter types.

    Provides a convenient way to apply multiple filters together.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    # Core filters
    price: Optional[PriceFilter] = Field(
        default=None,
        description="Price range filter",
    )
    rating: Optional[RatingFilter] = Field(
        default=None,
        description="Rating range filter",
    )
    amenities: Optional[AmenityFilter] = Field(
        default=None,
        description="Amenity filters",
    )
    location: Optional[LocationFilter] = Field(
        default=None,
        description="Location filters",
    )
    availability: Optional[AvailabilityFilter] = Field(
        default=None,
        description="Availability filters",
    )

    # Type filters
    hostel_types: Optional[List[HostelType]] = Field(
        default=None,
        description="Filter by hostel types",
        examples=[["boys", "girls"]],
    )
    room_types: Optional[List[RoomType]] = Field(
        default=None,
        description="Filter by room types",
        examples=[["single", "double"]],
    )

    @computed_field
    @property
    def active_filters(self) -> List[str]:
        """Get list of active filter names."""
        active = []
        if self.price and self.price.is_active:
            active.append("price")
        if self.rating and self.rating.is_active:
            active.append("rating")
        if self.amenities and self.amenities.is_active:
            active.append("amenities")
        if self.location and self.location.is_active:
            active.append("location")
        if self.availability and self.availability.is_active:
            active.append("availability")
        if self.hostel_types:
            active.append("hostel_types")
        if self.room_types:
            active.append("room_types")
        return active

    @computed_field
    @property
    def filter_count(self) -> int:
        """Get count of active filters."""
        return len(self.active_filters)

    @computed_field
    @property
    def has_filters(self) -> bool:
        """Check if any filter is active."""
        return self.filter_count > 0

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\search\search_request.py ---
# --- File: app/schemas/search/search_request.py ---
"""
Search request schemas with comprehensive validation and type safety.

Provides schemas for:
- Basic keyword search
- Advanced search with multiple filters
- Nearby/proximity search
- Saved searches
- Search history
"""

from __future__ import annotations

from datetime import date as Date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional, Annotated
from uuid import UUID

from pydantic import Field, field_validator, model_validator, computed_field, ConfigDict

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseFilterSchema,
    BaseResponseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import Gender, HostelType, RoomType

__all__ = [
    "BasicSearchRequest",
    "AdvancedSearchRequest",
    "NearbySearchRequest",
    "SavedSearchCreate",
    "SavedSearchUpdate",
    "SavedSearchResponse",
    "SearchHistoryResponse",
]


class BasicSearchRequest(BaseFilterSchema):
    """
    Simple keyword-based search request.

    Optimized for quick searches with minimal parameters.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    query: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Search query string",
        examples=["hostels in Mumbai", "PG near me"],
    )
    limit: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Maximum number of results to return",
    )

    @field_validator("query")
    @classmethod
    def validate_and_normalize_query(cls, v: str) -> str:
        """
        Normalize search query.

        - Strips whitespace
        - Removes excessive spaces
        - Validates non-empty after normalization
        """
        # Strip and normalize whitespace
        normalized = " ".join(v.split())

        if not normalized:
            raise ValueError("Search query cannot be empty or only whitespace")

        return normalized


class AdvancedSearchRequest(BaseFilterSchema):
    """
    Advanced search request with comprehensive filtering options.

    Supports:
    - Text search
    - Geographic filtering
    - Price range
    - Amenity filtering
    - Rating filters
    - Availability filters
    - Sorting and pagination
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    # Search query
    query: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Optional search keywords",
        examples=["boys hostel", "PG with meals"],
    )

    # Location filters
    city: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="City name",
        examples=["Mumbai", "Bangalore"],
    )
    state: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="State name",
        examples=["Maharashtra", "Karnataka"],
    )
    pincode: Optional[str] = Field(
        default=None,
        pattern=r"^\d{6}$",
        description="6-digit Indian pincode",
        examples=["400001", "560001"],
    )

    # Geographic coordinates for proximity search
    latitude: Optional[Annotated[Decimal, Field(ge=-90, le=90)]] = Field(
        default=None,
        description="Latitude for proximity search",
        examples=[19.0760],
    )
    longitude: Optional[Annotated[Decimal, Field(ge=-180, le=180)]] = Field(
        default=None,
        description="Longitude for proximity search",
        examples=[72.8777],
    )
    radius_km: Optional[Annotated[Decimal, Field(ge=0.1, le=100)]] = Field(
        default=None,
        description="Search radius in kilometers",
        examples=[5, 10, 25],
    )

    # Hostel and room type filters
    hostel_type: Optional[HostelType] = Field(
        default=None,
        description="Filter by hostel type (boys/girls/co-ed)",
    )
    room_types: Optional[List[RoomType]] = Field(
        default=None,
        description="Filter by room types (can select multiple)",
        examples=[["single", "double"]],
    )

    # Gender preference (for co-ed hostels)
    gender_preference: Optional[Gender] = Field(
        default=None,
        description="Gender preference for room allocation",
    )

    # Price range filter
    min_price: Optional[Annotated[Decimal, Field(ge=0)]] = Field(
        default=None,
        description="Minimum monthly price in INR",
        examples=[5000, 10000],
    )
    max_price: Optional[Annotated[Decimal, Field(ge=0)]] = Field(
        default=None,
        description="Maximum monthly price in INR",
        examples=[20000, 30000],
    )

    # Amenities filter
    amenities: Optional[List[str]] = Field(
        default=None,
        description="Required amenities (AND logic - hostel must have all)",
        examples=[["wifi", "ac", "parking"]],
    )
    any_amenities: Optional[List[str]] = Field(
        default=None,
        description="Optional amenities (OR logic - hostel can have any)",
        examples=[["gym", "laundry", "swimming_pool"]],
    )

    # Rating filter
    min_rating: Optional[Annotated[Decimal, Field(ge=0, le=5)]] = Field(
        default=None,
        description="Minimum average rating (0-5)",
        examples=[3.5, 4.0],
    )

    # Availability filters
    verified_only: bool = Field(
        default=False,
        description="Show only verified hostels",
    )
    available_only: bool = Field(
        default=False,
        description="Show only hostels with available beds",
    )
    instant_booking: bool = Field(
        default=False,
        description="Show only hostels with instant booking enabled",
    )

    # Date-based availability
    check_in_date: Optional[Date] = Field(
        default=None,
        description="Desired check-in Date for availability check",
    )
    check_out_date: Optional[Date] = Field(
        default=None,
        description="Desired check-out Date for availability check",
    )

    # Sorting options
    sort_by: str = Field(
        default="relevance",
        pattern=r"^(relevance|price_asc|price_desc|rating_desc|distance_asc|newest|popular)$",
        description="Sort criterion",
    )

    # Pagination
    page: int = Field(
        default=1,
        ge=1,
        description="Page number (1-indexed)",
    )
    page_size: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Results per page",
    )

    # Advanced options
    include_nearby_cities: bool = Field(
        default=False,
        description="Include results from nearby cities",
    )
    boost_featured: bool = Field(
        default=True,
        description="Boost featured/promoted hostels in results",
    )

    @field_validator("query")
    @classmethod
    def normalize_query(cls, v: Optional[str]) -> Optional[str]:
        """Normalize search query."""
        if v is not None:
            normalized = " ".join(v.split())
            return normalized if normalized else None
        return v

    @field_validator("city", "state")
    @classmethod
    def normalize_location(cls, v: Optional[str]) -> Optional[str]:
        """Normalize location strings."""
        if v is not None:
            return v.strip().title()
        return v

    @field_validator("amenities", "any_amenities")
    @classmethod
    def normalize_amenities(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Normalize amenity list (lowercase, deduplicate)."""
        if v is not None:
            # Convert to lowercase and remove duplicates while preserving order
            seen = set()
            normalized = []
            for amenity in v:
                amenity_lower = amenity.lower().strip()
                if amenity_lower and amenity_lower not in seen:
                    seen.add(amenity_lower)
                    normalized.append(amenity_lower)
            return normalized if normalized else None
        return v

    @model_validator(mode="after")
    def validate_location_consistency(self) -> "AdvancedSearchRequest":
        """
        Validate location-related fields consistency.

        - Ensure radius is provided only with coordinates
        - Validate price range
        - Validate Date range
        """
        # Validate radius requires coordinates
        if self.radius_km is not None:
            if self.latitude is None or self.longitude is None:
                raise ValueError(
                    "Both latitude and longitude are required when using radius_km"
                )

        # Validate price range
        if (
            self.min_price is not None
            and self.max_price is not None
            and self.min_price > self.max_price
        ):
            raise ValueError("min_price cannot be greater than max_price")

        # Validate Date range
        if self.check_in_date and self.check_out_date:
            if self.check_in_date >= self.check_out_date:
                raise ValueError("check_in_date must be before check_out_date")

            # Validate dates are not in the past
            today = Date.today()
            if self.check_in_date < today:
                raise ValueError("check_in_date cannot be in the past")

        return self

    @computed_field
    @property
    def has_location_filter(self) -> bool:
        """Check if any location filter is applied."""
        return any(
            [
                self.city,
                self.state,
                self.pincode,
                self.latitude and self.longitude,
            ]
        )

    @computed_field
    @property
    def has_price_filter(self) -> bool:
        """Check if price filter is applied."""
        return self.min_price is not None or self.max_price is not None

    @computed_field
    @property
    def offset(self) -> int:
        """Calculate offset for database queries."""
        return (self.page - 1) * self.page_size


class NearbySearchRequest(BaseFilterSchema):
    """
    Proximity-based search request.

    Optimized for "near me" searches and location-based discovery.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    latitude: Annotated[Decimal, Field(ge=-90, le=90)] = Field(
        ...,
        description="Current latitude",
    )
    longitude: Annotated[Decimal, Field(ge=-180, le=180)] = Field(
        ...,
        description="Current longitude",
    )
    radius_km: Annotated[Decimal, Field(ge=0.1, le=50)] = Field(
        default=5.0,
        description="Search radius in kilometers",
    )

    # Optional filters
    hostel_type: Optional[HostelType] = Field(
        default=None,
        description="Filter by hostel type",
    )
    min_price: Optional[Annotated[Decimal, Field(ge=0)]] = Field(
        default=None,
        description="Minimum price filter",
    )
    max_price: Optional[Annotated[Decimal, Field(ge=0)]] = Field(
        default=None,
        description="Maximum price filter",
    )
    available_only: bool = Field(
        default=True,
        description="Show only hostels with available beds",
    )

    limit: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Maximum number of results",
    )

    @model_validator(mode="after")
    def validate_price_range(self) -> "NearbySearchRequest":
        """Validate price range."""
        if (
            self.min_price is not None
            and self.max_price is not None
            and self.min_price > self.max_price
        ):
            raise ValueError("min_price cannot be greater than max_price")
        return self


class SavedSearchCreate(BaseCreateSchema):
    """
    Create saved search for user.

    Allows users to save frequently used search criteria.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="User-friendly name for the saved search",
        examples=["My Daily Commute Search", "Budget Hostels in Mumbai"],
    )
    search_criteria: Dict[str, Any] = Field(
        ...,
        description="Serialized search parameters (AdvancedSearchRequest as dict)",
    )
    is_alert_enabled: bool = Field(
        default=False,
        description="Enable notifications when new matching hostels are added",
    )
    alert_frequency: Optional[str] = Field(
        default=None,
        pattern=r"^(daily|weekly|instant)$",
        description="Alert notification frequency",
    )

    @field_validator("name")
    @classmethod
    def normalize_name(cls, v: str) -> str:
        """Normalize search name."""
        normalized = " ".join(v.split())
        if not normalized:
            raise ValueError("Search name cannot be empty")
        return normalized

    @model_validator(mode="after")
    def validate_alert_settings(self) -> "SavedSearchCreate":
        """Validate alert configuration."""
        if self.is_alert_enabled and not self.alert_frequency:
            raise ValueError(
                "alert_frequency is required when is_alert_enabled is True"
            )
        if not self.is_alert_enabled and self.alert_frequency:
            self.alert_frequency = None  # Clear frequency if alerts disabled
        return self


class SavedSearchUpdate(BaseUpdateSchema):
    """Update saved search configuration."""

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    name: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=100,
        description="Updated name",
    )
    search_criteria: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Updated search parameters",
    )
    is_alert_enabled: Optional[bool] = Field(
        default=None,
        description="Enable/disable alerts",
    )
    alert_frequency: Optional[str] = Field(
        default=None,
        pattern=r"^(daily|weekly|instant)$",
        description="Alert frequency",
    )

    @field_validator("name")
    @classmethod
    def normalize_name(cls, v: Optional[str]) -> Optional[str]:
        """Normalize search name."""
        if v is not None:
            normalized = " ".join(v.split())
            return normalized if normalized else None
        return v


class SavedSearchResponse(BaseResponseSchema):
    """Saved search response schema."""

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    user_id: UUID = Field(..., description="User ID who owns this search")
    name: str = Field(..., description="Search name")
    search_criteria: Dict[str, Any] = Field(..., description="Search parameters")
    is_alert_enabled: bool = Field(..., description="Alert status")
    alert_frequency: Optional[str] = Field(default=None, description="Alert frequency")
    last_executed_at: Optional[datetime] = Field(
        default=None,
        description="Last time this search was executed",
    )
    result_count: int = Field(
        default=0,
        ge=0,
        description="Number of results from last execution",
    )


class SearchHistoryResponse(BaseResponseSchema):
    """Search history entry response."""

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID (null for anonymous searches)",
    )
    query: str = Field(..., description="Search query")
    search_criteria: Dict[str, Any] = Field(
        ...,
        description="Complete search parameters",
    )
    result_count: int = Field(
        ...,
        ge=0,
        description="Number of results returned",
    )
    execution_time_ms: int = Field(
        ...,
        ge=0,
        description="Query execution time in milliseconds",
    )
    clicked_result_ids: List[UUID] = Field(
        default_factory=list,
        description="IDs of hostels clicked from this search",
    )

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\search\search_response.py ---
# --- File: app/schemas/search/search_response.py ---
"""
Search response schemas with comprehensive result metadata.

Provides schemas for:
- Search result items
- Faceted search responses
- Search metadata and diagnostics
- Search suggestions

Pydantic v2 Migration Notes:
- Uses Annotated pattern for Decimal fields with max_digits/decimal_places constraints
- Optional[Decimal] fields use Annotated to ensure constraints apply correctly
- @computed_field with @property decorator for computed properties
- All field validators use v2 syntax (none present in this schema)
"""

from __future__ import annotations

from decimal import Decimal
from typing import Annotated, Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseSchema

__all__ = [
    "SearchResultItem",
    "SearchMetadata",
    "FacetBucket",
    "FacetedSearchResponse",
    "SearchSuggestion",
]


class SearchResultItem(BaseSchema):
    """
    Individual search result item.

    Wraps hostel data with search-specific metadata like relevance score.
    """

    # Hostel identifier
    hostel_id: UUID = Field(
        ...,
        description="Unique hostel identifier",
    )

    # Basic hostel information (denormalized for performance)
    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL-friendly slug")
    hostel_type: str = Field(..., description="Hostel type")

    # Location
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    address_line1: str = Field(..., description="Primary address")

    # Pricing - Using Decimal with precision constraints for currency values
    min_price: Annotated[
        Decimal,
        Field(
            ge=0,
            max_digits=10,
            decimal_places=2,
            description="Minimum monthly price across all rooms",
        ),
    ]
    max_price: Annotated[
        Decimal,
        Field(
            ge=0,
            max_digits=10,
            decimal_places=2,
            description="Maximum monthly price across all rooms",
        ),
    ]

    # Ratings and reviews
    # Pydantic v2: For Optional[Decimal] with constraints, use Annotated pattern
    average_rating: Optional[
        Annotated[
            Decimal,
            Field(
                ge=0,
                le=5,
                max_digits=3,
                decimal_places=2,
                description="Average rating (0-5)",
            ),
        ]
    ] = None
    total_reviews: int = Field(
        default=0,
        ge=0,
        description="Total number of reviews",
    )

    # Availability
    available_beds: int = Field(
        default=0,
        ge=0,
        description="Number of currently available beds",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total bed capacity",
    )

    # Media
    thumbnail_url: Optional[str] = Field(
        default=None,
        description="Primary image URL",
    )
    image_urls: List[str] = Field(
        default_factory=list,
        description="Additional image URLs",
    )

    # Amenities (top/featured only for performance)
    featured_amenities: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Top featured amenities",
    )

    # Verification and quality indicators
    is_verified: bool = Field(
        default=False,
        description="Hostel verification status",
    )
    is_featured: bool = Field(
        default=False,
        description="Featured/promoted status",
    )

    # Search-specific metadata
    relevance_score: Annotated[
        Decimal,
        Field(
            ge=0,
            max_digits=10,
            decimal_places=4,
            description="Relevance score from search engine (higher = more relevant)",
        ),
    ]
    distance_km: Optional[
        Annotated[
            Decimal,
            Field(
                ge=0,
                max_digits=10,
                decimal_places=2,
                description="Distance from search location (if proximity search)",
            ),
        ]
    ] = None

    # Highlighting (search term matches)
    highlights: Dict[str, List[str]] = Field(
        default_factory=dict,
        description="Highlighted snippets showing search term matches",
        examples=[{"name": ["Best <em>Hostel</em> in Mumbai"]}],
    )

    @computed_field  # type: ignore[misc]
    @property
    def occupancy_rate(self) -> Decimal:
        """Calculate current occupancy rate as percentage."""
        if self.total_beds == 0:
            return Decimal("0")
        occupied = self.total_beds - self.available_beds
        return Decimal(occupied / self.total_beds * 100).quantize(Decimal("0.01"))

    @computed_field  # type: ignore[misc]
    @property
    def has_availability(self) -> bool:
        """Check if hostel has any available beds."""
        return self.available_beds > 0


class SearchMetadata(BaseSchema):
    """
    Search execution metadata and diagnostics.

    Provides insights into search performance and result quality.
    """

    # Result counts
    total_results: int = Field(
        ...,
        ge=0,
        description="Total number of matching results",
    )
    returned_results: int = Field(
        ...,
        ge=0,
        description="Number of results in current page",
    )

    # Pagination
    page: int = Field(
        ...,
        ge=1,
        description="Current page number",
    )
    page_size: int = Field(
        ...,
        ge=1,
        description="Results per page",
    )
    total_pages: int = Field(
        ...,
        ge=0,
        description="Total number of pages",
    )

    # Performance metrics
    query_time_ms: int = Field(
        ...,
        ge=0,
        description="Search execution time in milliseconds",
    )
    fetch_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Data fetch time in milliseconds",
    )

    # Query information
    applied_filters: Dict[str, Any] = Field(
        default_factory=dict,
        description="Filters that were applied to this search",
    )
    sort_criteria: str = Field(
        ...,
        description="Sort order applied",
    )

    # Result quality indicators
    # Pydantic v2: Optional[Decimal] with constraints uses Annotated pattern
    max_score: Optional[
        Annotated[
            Decimal,
            Field(
                ge=0,
                max_digits=10,
                decimal_places=4,
                description="Highest relevance score in results",
            ),
        ]
    ] = None
    min_score: Optional[
        Annotated[
            Decimal,
            Field(
                ge=0,
                max_digits=10,
                decimal_places=4,
                description="Lowest relevance score in results",
            ),
        ]
    ] = None

    # Debug information (optional, for development)
    debug_info: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Debug information (available in development mode)",
    )

    @computed_field  # type: ignore[misc]
    @property
    def has_next_page(self) -> bool:
        """Check if there are more pages available."""
        return self.page < self.total_pages

    @computed_field  # type: ignore[misc]
    @property
    def has_previous_page(self) -> bool:
        """Check if there are previous pages."""
        return self.page > 1


class FacetBucket(BaseSchema):
    """
    Single facet value with count.

    Used in faceted search to show available filter options.
    """

    value: str = Field(
        ...,
        description="Facet value (e.g., 'Mumbai' for city facet)",
    )
    label: str = Field(
        ...,
        description="Human-readable label",
    )
    count: int = Field(
        ...,
        ge=0,
        description="Number of results with this facet value",
    )
    is_selected: bool = Field(
        default=False,
        description="Whether this facet is currently selected/active",
    )

    # Additional metadata
    metadata: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Additional facet-specific metadata",
    )


class FacetedSearchResponse(BaseSchema):
    """
    Complete faceted search response.

    Includes results, facets, and comprehensive metadata.
    """

    # Search results
    results: List[SearchResultItem] = Field(
        default_factory=list,
        description="Search result items",
    )

    # Metadata
    metadata: SearchMetadata = Field(
        ...,
        description="Search execution metadata",
    )

    # Facets for filtering
    facets: Dict[str, List[FacetBucket]] = Field(
        default_factory=dict,
        description="Available facets organized by facet name",
        examples=[
            {
                "city": [
                    {"value": "mumbai", "label": "Mumbai", "count": 45},
                    {"value": "bangalore", "label": "Bangalore", "count": 32},
                ],
                "hostel_type": [
                    {"value": "boys", "label": "Boys", "count": 50},
                    {"value": "girls", "label": "Girls", "count": 27},
                ],
            }
        ],
    )

    # Search suggestions (for query refinement)
    suggestions: List[SearchSuggestion] = Field(
        default_factory=list,
        description="Suggested query refinements",
    )

    @computed_field  # type: ignore[misc]
    @property
    def is_empty(self) -> bool:
        """Check if search returned no results."""
        return len(self.results) == 0

    @computed_field  # type: ignore[misc]
    @property
    def facet_names(self) -> List[str]:
        """Get list of available facet names."""
        return list(self.facets.keys())


class SearchSuggestion(BaseSchema):
    """
    Search query suggestion for refinement.

    Helps users refine their search when results are poor.
    """

    suggestion_type: str = Field(
        ...,
        pattern=r"^(spell_correction|alternative_query|related_search|popular_search)$",
        description="Type of suggestion",
    )
    text: str = Field(
        ...,
        description="Suggested search text",
    )
    reason: Optional[str] = Field(
        default=None,
        description="Why this suggestion is offered",
        examples=[
            "Did you mean...",
            "Popular search",
            "Related to your search",
        ],
    )
    expected_results: Optional[int] = Field(
        default=None,
        ge=0,
        description="Estimated number of results for this suggestion",
    )

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\search\search_sort.py ---
# --- File: app/schemas/search/search_sort.py ---
"""
Search sorting schemas with type-safe sort options.

Provides strongly-typed sorting criteria for search results.

Pydantic v2 Migration Notes:
- field_validator syntax already compatible with v2
- @computed_field with @property for computed properties
- Enum-based fields work identically in v2
"""

from __future__ import annotations

from enum import Enum
from typing import Optional

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseSchema

__all__ = [
    "SearchSortField",
    "SearchSortOrder",
    "SortCriteria",
]


class SearchSortField(str, Enum):
    """
    Available sort fields for search results.

    Provides type-safe sort field options.
    """

    RELEVANCE = "relevance"
    PRICE_LOW_TO_HIGH = "price_asc"
    PRICE_HIGH_TO_LOW = "price_desc"
    RATING_HIGH_TO_LOW = "rating_desc"
    DISTANCE_NEAR_TO_FAR = "distance_asc"
    NEWEST_FIRST = "newest"
    POPULAR = "popular"
    AVAILABILITY = "availability"


class SearchSortOrder(str, Enum):
    """Sort order direction."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class SortCriteria(BaseSchema):
    """
    Sort criteria for search results.

    Provides flexible sorting with primary and optional secondary sort.
    """

    sort_by: SearchSortField = Field(
        default=SearchSortField.RELEVANCE,
        description="Primary sort field",
    )
    sort_order: SearchSortOrder = Field(
        default=SearchSortOrder.DESCENDING,
        description="Sort direction (for applicable fields)",
    )

    # Secondary sort (for tie-breaking)
    secondary_sort_by: Optional[SearchSortField] = Field(
        default=None,
        description="Secondary sort field for tie-breaking",
    )
    secondary_sort_order: Optional[SearchSortOrder] = Field(
        default=None,
        description="Secondary sort direction",
    )

    @field_validator("sort_by")
    @classmethod
    def validate_sort_field(cls, v: SearchSortField) -> SearchSortField:
        """Validate sort field is appropriate."""
        # Some sort fields have implicit direction
        implicit_direction_fields = {
            SearchSortField.PRICE_LOW_TO_HIGH,
            SearchSortField.PRICE_HIGH_TO_LOW,
            SearchSortField.RATING_HIGH_TO_LOW,
            SearchSortField.DISTANCE_NEAR_TO_FAR,
        }

        # These fields encode direction in the field name
        # The sort_order parameter will be ignored for them
        # No validation needed - just documenting the behavior
        return v

    @computed_field  # type: ignore[misc]
    @property
    def effective_sort_order(self) -> SearchSortOrder:
        """
        Get effective sort order based on sort field.

        Some fields have implicit direction (e.g., price_asc always means ascending).
        """
        # Fields with implicit direction
        if self.sort_by == SearchSortField.PRICE_LOW_TO_HIGH:
            return SearchSortOrder.ASCENDING
        elif self.sort_by == SearchSortField.PRICE_HIGH_TO_LOW:
            return SearchSortOrder.DESCENDING
        elif self.sort_by == SearchSortField.RATING_HIGH_TO_LOW:
            return SearchSortOrder.DESCENDING
        elif self.sort_by == SearchSortField.DISTANCE_NEAR_TO_FAR:
            return SearchSortOrder.ASCENDING

        # For other fields, use specified sort_order
        return self.sort_order

    def to_db_sort(self) -> tuple[str, str]:
        """
        Convert to database sort parameters.

        Returns:
            Tuple of (field_name, direction) for database queries
        """
        field_mapping = {
            SearchSortField.RELEVANCE: "relevance_score",
            SearchSortField.PRICE_LOW_TO_HIGH: "min_price",
            SearchSortField.PRICE_HIGH_TO_LOW: "max_price",
            SearchSortField.RATING_HIGH_TO_LOW: "average_rating",
            SearchSortField.DISTANCE_NEAR_TO_FAR: "distance",
            SearchSortField.NEWEST_FIRST: "created_at",
            SearchSortField.POPULAR: "popularity_score",
            SearchSortField.AVAILABILITY: "available_beds",
        }

        field = field_mapping.get(self.sort_by, "relevance_score")
        direction = self.effective_sort_order.value

        return field, direction

# --- File: D:\Last Github Push\Last\Hostel-Main\app\schemas\search\__init__.py ---
# --- File: app/schemas/search/__init__.py ---
"""
Search schemas package.

Provides comprehensive search functionality including:
- Basic and advanced hostel search
- Autocomplete and suggestions
- Search analytics and insights
- Faceted search with filtering
- Search history tracking

Example:
    from app.schemas.search import (
        AdvancedSearchRequest,
        FacetedSearchResponse,
        SearchAnalytics,
    )
"""

from __future__ import annotations

from app.schemas.search.search_analytics import (
    PopularSearchTerm,
    SearchAnalytics,
    SearchAnalyticsRequest,
    SearchMetrics,
    SearchTermStats,
    TrendingSearch,
    ZeroResultTerm,
)
from app.schemas.search.search_autocomplete import (
    AutocompleteRequest,
    AutocompleteResponse,
    Suggestion,
    SuggestionType,
)
from app.schemas.search.search_filters import (
    AmenityFilter,
    AvailabilityFilter,
    LocationFilter,
    PriceFilter,
    RatingFilter,
    SearchFilterSet,
)
from app.schemas.search.search_request import (
    AdvancedSearchRequest,
    BasicSearchRequest,
    NearbySearchRequest,
    SavedSearchCreate,
    SavedSearchResponse,
    SavedSearchUpdate,
    SearchHistoryResponse,
)
from app.schemas.search.search_response import (
    FacetBucket,
    FacetedSearchResponse,
    SearchMetadata,
    SearchResultItem,
    SearchSuggestion,
)
from app.schemas.search.search_sort import (
    SearchSortField,
    SearchSortOrder,
    SortCriteria,
)

__all__ = [
    # Request schemas
    "BasicSearchRequest",
    "AdvancedSearchRequest",
    "NearbySearchRequest",
    "SavedSearchCreate",
    "SavedSearchUpdate",
    # Response schemas
    "SearchResultItem",
    "FacetedSearchResponse",
    "SearchMetadata",
    "SearchSuggestion",
    "FacetBucket",
    "SavedSearchResponse",
    "SearchHistoryResponse",
    # Autocomplete
    "AutocompleteRequest",
    "AutocompleteResponse",
    "Suggestion",
    "SuggestionType",
    # Filters
    "PriceFilter",
    "RatingFilter",
    "AmenityFilter",
    "LocationFilter",
    "AvailabilityFilter",
    "SearchFilterSet",
    # Sort
    "SortCriteria",
    "SearchSortField",
    "SearchSortOrder",
    # Analytics
    "SearchAnalytics",
    "SearchAnalyticsRequest",
    "SearchTermStats",
    "SearchMetrics",
    "PopularSearchTerm",
    "TrendingSearch",
    "ZeroResultTerm",
]


# ===== Folder: D:\Last Github Push\Last\Hostel-Main\app\schemas\search\__pycache__ =====
