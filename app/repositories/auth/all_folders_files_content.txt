### Combined Content from Folder: C:\Hostel-Main\app\repositories\auth ###



# ===== Folder: C:\Hostel-Main\app\repositories\auth =====

# --- File: C:\Hostel-Main\app\repositories\auth\auth_aggregate_repository.py ---
"""
Authentication Aggregate Repository
Provides unified access to all authentication-related repositories and operations.
"""

from typing import Optional, Dict, Any, List, Tuple
from uuid import UUID
from datetime import datetime, timedelta
from sqlalchemy.orm import Session

from app.repositories.auth.user_session_repository import (
    UserSessionRepository,
    SessionTokenRepository,
    RefreshTokenRepository,
    LoginAttemptRepository,
)
from app.repositories.auth.otp_token_repository import (
    OTPTokenRepository,
    OTPTemplateRepository,
    OTPDeliveryRepository,
    OTPThrottlingRepository,
)
from app.repositories.auth.password_reset_repository import (
    PasswordResetRepository,
    PasswordHistoryRepository,
    PasswordPolicyRepository,
    PasswordAttemptRepository,
)
from app.repositories.auth.social_auth_token_repository import (
    SocialAuthProviderRepository,
    SocialAuthTokenRepository,
    SocialAuthProfileRepository,
    SocialAuthLinkRepository,
)
from app.repositories.auth.token_blacklist_repository import (
    BlacklistedTokenRepository,
    TokenRevocationRepository,
    SecurityEventRepository,
)
from app.schemas.common.enums import OTPType


class AuthAggregateRepository:
    """
    Aggregate repository providing unified access to all authentication operations.
    
    This repository serves as a facade for all authentication-related repositories,
    providing a single entry point for complex authentication workflows.
    """

    def __init__(self, db: Session):
        self.db = db
        
        # Session Management
        self.user_sessions = UserSessionRepository(db)
        self.session_tokens = SessionTokenRepository(db)
        self.refresh_tokens = RefreshTokenRepository(db)
        self.login_attempts = LoginAttemptRepository(db)
        
        # OTP Management
        self.otp_tokens = OTPTokenRepository(db)
        self.otp_templates = OTPTemplateRepository(db)
        self.otp_deliveries = OTPDeliveryRepository(db)
        self.otp_throttling = OTPThrottlingRepository(db)
        
        # Password Management
        self.password_resets = PasswordResetRepository(db)
        self.password_history = PasswordHistoryRepository(db)
        self.password_policies = PasswordPolicyRepository(db)
        self.password_attempts = PasswordAttemptRepository(db)
        
        # Social Authentication
        self.social_providers = SocialAuthProviderRepository(db)
        self.social_tokens = SocialAuthTokenRepository(db)
        self.social_profiles = SocialAuthProfileRepository(db)
        self.social_links = SocialAuthLinkRepository(db)
        
        # Token Blacklist & Security
        self.blacklisted_tokens = BlacklistedTokenRepository(db)
        self.token_revocations = TokenRevocationRepository(db)
        self.security_events = SecurityEventRepository(db)

    # ==================== Complete Authentication Workflows ====================

    def authenticate_user(
        self,
        user_id: UUID,
        device_info: Dict[str, Any],
        ip_address: str,
        is_remember_me: bool = False
    ) -> Dict[str, Any]:
        """
        Complete user authentication workflow.
        
        Creates session, generates tokens, and records login attempt.
        
        Args:
            user_id: User identifier
            device_info: Device information
            ip_address: IP address
            is_remember_me: Extended session flag
            
        Returns:
            Dictionary with session and token information
        """
        import uuid
        import hashlib
        
        # Generate session ID
        session_id = str(uuid.uuid4())
        
        # Create session
        session = self.user_sessions.create_session(
            user_id=user_id,
            session_id=session_id,
            device_info=device_info,
            ip_address=ip_address,
            is_remember_me=is_remember_me,
            expires_in_hours=720 if is_remember_me else 24  # 30 days or 24 hours
        )
        
        # Generate access token JTI
        access_jti = str(uuid.uuid4())
        access_token_hash = hashlib.sha256(access_jti.encode()).hexdigest()
        
        # Create access token
        access_token = self.session_tokens.create_token(
            session_id=session.id,
            jti=access_jti,
            token_hash=access_token_hash,
            expires_in_minutes=15
        )
        
        # Generate refresh token
        refresh_jti = str(uuid.uuid4())
        refresh_token_hash = hashlib.sha256(refresh_jti.encode()).hexdigest()
        family_id = str(uuid.uuid4())
        
        refresh_token = self.refresh_tokens.create_token(
            session_id=session.id,
            jti=refresh_jti,
            token_hash=refresh_token_hash,
            family_id=family_id,
            expires_in_days=30 if is_remember_me else 7
        )
        
        # Record successful login attempt
        self.login_attempts.record_attempt(
            user_id=user_id,
            email=None,  # Should be passed from caller
            phone=None,
            is_successful=True,
            failure_reason=None,
            ip_address=ip_address,
            user_agent=device_info.get("user_agent"),
            device_fingerprint=device_info.get("device_fingerprint")
        )
        
        return {
            "session_id": session_id,
            "access_token_jti": access_jti,
            "refresh_token_jti": refresh_jti,
            "family_id": family_id,
            "session": session,
            "access_token": access_token,
            "refresh_token": refresh_token
        }

    def logout_user(
        self,
        session_id: str,
        revocation_reason: str = "User logout"
    ) -> bool:
        """
        Complete user logout workflow.
        
        Terminates session, revokes tokens, and records revocation.
        
        Args:
            session_id: Session identifier
            revocation_reason: Reason for logout
            
        Returns:
            Success status
        """
        session = self.user_sessions.find_by_session_id(session_id)
        
        if not session:
            return False
        
        # Get all tokens for session
        session_tokens = self.db.query(self.session_tokens.model).filter_by(
            session_id=session.id
        ).all()
        
        refresh_tokens = self.db.query(self.refresh_tokens.model).filter_by(
            session_id=session.id
        ).all()
        
        # Blacklist all tokens
        for token in session_tokens:
            if not self.blacklisted_tokens.is_blacklisted(token.jti):
                self.blacklisted_tokens.blacklist_token(
                    jti=token.jti,
                    token_type="access",
                    token_hash=token.token_hash,
                    user_id=session.user_id,
                    expires_at=token.expires_at,
                    revocation_reason=revocation_reason
                )
        
        for token in refresh_tokens:
            if not self.blacklisted_tokens.is_blacklisted(token.jti):
                self.blacklisted_tokens.blacklist_token(
                    jti=token.jti,
                    token_type="refresh",
                    token_hash=token.token_hash,
                    user_id=session.user_id,
                    expires_at=token.expires_at,
                    revocation_reason=revocation_reason
                )
        
        # Record revocation
        self.token_revocations.record_revocation(
            user_id=session.user_id,
            revocation_type="session",
            revocation_reason=revocation_reason,
            tokens_revoked_count=len(session_tokens) + len(refresh_tokens),
            initiated_by_user_id=session.user_id
        )
        
        # Terminate session
        return self.user_sessions.terminate_session(session_id, revoke_tokens=False)

    def logout_all_sessions(
        self,
        user_id: UUID,
        except_session_id: Optional[str] = None
    ) -> int:
        """
        Logout user from all sessions.
        
        Args:
            user_id: User identifier
            except_session_id: Keep this session active
            
        Returns:
            Number of sessions terminated
        """
        sessions = self.user_sessions.find_active_sessions(
            user_id,
            exclude_session_id=except_session_id
        )
        
        total_tokens = 0
        
        for session in sessions:
            # Get token count for this session
            session_token_count = self.db.query(
                self.session_tokens.model
            ).filter_by(session_id=session.id).count()
            
            refresh_token_count = self.db.query(
                self.refresh_tokens.model
            ).filter_by(session_id=session.id).count()
            
            total_tokens += session_token_count + refresh_token_count
            
            # Logout session
            self.logout_user(session.session_id, "Logout all sessions")
        
        # Record global revocation
        if total_tokens > 0:
            self.token_revocations.record_revocation(
                user_id=user_id,
                revocation_type="all_tokens",
                revocation_reason="User requested logout from all sessions",
                tokens_revoked_count=total_tokens,
                initiated_by_user_id=user_id
            )
        
        return len(sessions)

    def refresh_authentication(
        self,
        refresh_token_jti: str
    ) -> Optional[Dict[str, Any]]:
        """
        Refresh authentication tokens.
        
        Args:
            refresh_token_jti: Refresh token JTI
            
        Returns:
            New tokens or None if refresh failed
        """
        import uuid
        import hashlib
        
        # Check for token reuse
        if self.refresh_tokens.detect_token_reuse(refresh_token_jti):
            # Security breach detected
            self.security_events.record_event(
                event_type="token_reuse_detected",
                severity="high",
                description="Refresh token reuse detected - possible security breach",
                event_data={"refresh_token_jti": refresh_token_jti}
            )
            return None
        
        # Use refresh token
        refresh_token = self.refresh_tokens.use_token(refresh_token_jti)
        
        if not refresh_token:
            return None
        
        # Generate new access token
        access_jti = str(uuid.uuid4())
        access_token_hash = hashlib.sha256(access_jti.encode()).hexdigest()
        
        access_token = self.session_tokens.create_token(
            session_id=refresh_token.session_id,
            jti=access_jti,
            token_hash=access_token_hash,
            expires_in_minutes=15
        )
        
        # Generate new refresh token (rotation)
        new_refresh_jti = str(uuid.uuid4())
        new_refresh_token_hash = hashlib.sha256(new_refresh_jti.encode()).hexdigest()
        
        new_refresh_token = self.refresh_tokens.create_token(
            session_id=refresh_token.session_id,
            jti=new_refresh_jti,
            token_hash=new_refresh_token_hash,
            family_id=refresh_token.family_id,
            parent_token_id=refresh_token.id,
            expires_in_days=7
        )
        
        # Update session activity
        session = self.user_sessions.find_by_id(refresh_token.session_id)
        if session:
            self.user_sessions.update_session_activity(session.session_id)
        
        return {
            "access_token_jti": access_jti,
            "refresh_token_jti": new_refresh_jti,
            "family_id": refresh_token.family_id,
            "access_token": access_token,
            "refresh_token": new_refresh_token
        }

    # ==================== OTP Workflows ====================

    def send_otp(
        self,
        user_id: Optional[UUID],
        identifier: str,
        identifier_type: str,
        otp_type: OTPType,
        ip_address: str,
        max_requests: int = 5,
        window_minutes: int = 60
    ) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        Complete OTP generation and sending workflow.
        
        Args:
            user_id: User identifier (optional)
            identifier: Email or phone
            identifier_type: 'email' or 'phone'
            otp_type: Type of OTP
            ip_address: IP address
            max_requests: Maximum requests per window
            window_minutes: Time window in minutes
            
        Returns:
            Tuple of (success, otp_code, error_message)
        """
        import random
        import hashlib
        
        # Check rate limiting
        is_allowed, error_msg = self.otp_throttling.check_rate_limit(
            identifier=identifier,
            identifier_type=identifier_type,
            ip_address=ip_address,
            otp_type=otp_type,
            max_requests=max_requests,
            window_minutes=window_minutes
        )
        
        if not is_allowed:
            return False, None, error_msg
        
        # Invalidate previous OTPs
        self.otp_tokens.invalidate_previous_otps(
            identifier=identifier,
            identifier_type=identifier_type,
            otp_type=otp_type
        )
        
        # Generate OTP code
        otp_code = str(random.randint(100000, 999999))
        otp_hash = hashlib.sha256(otp_code.encode()).hexdigest()
        
        # Create OTP token
        email = identifier if identifier_type == "email" else None
        phone = identifier if identifier_type == "phone" else None
        
        otp_token = self.otp_tokens.create_otp(
            user_id=user_id,
            email=email,
            phone=phone,
            otp_code=otp_hash,
            otp_type=otp_type,
            delivery_channel=identifier_type,
            ip_address=ip_address
        )
        
        # Create delivery record
        delivery = self.otp_deliveries.create_delivery(
            otp_token_id=otp_token.id,
            channel=identifier_type,
            recipient=identifier
        )
        
        # In production, you would send the OTP via email/SMS here
        # For now, we'll just mark it as sent
        self.otp_deliveries.mark_as_sent(delivery.id)
        
        return True, otp_code, None

    def verify_otp(
        self,
        identifier: str,
        identifier_type: str,
        otp_code: str,
        otp_type: OTPType
    ) -> Tuple[bool, Optional[str]]:
        """
        Verify OTP code.
        
        Args:
            identifier: Email or phone
            identifier_type: 'email' or 'phone'
            otp_code: OTP code to verify
            otp_type: Type of OTP
            
        Returns:
            Tuple of (success, error_message)
        """
        import hashlib
        
        # Hash the provided OTP
        otp_hash = hashlib.sha256(otp_code.encode()).hexdigest()
        
        return self.otp_tokens.verify_otp(
            identifier=identifier,
            identifier_type=identifier_type,
            otp_code=otp_hash,
            otp_type=otp_type
        )

    # ==================== Password Reset Workflows ====================

    def initiate_password_reset(
        self,
        user_id: UUID,
        ip_address: str,
        user_agent: str
    ) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        Initiate password reset workflow.
        
        Args:
            user_id: User identifier
            ip_address: IP address
            user_agent: User agent
            
        Returns:
            Tuple of (success, reset_token, error_message)
        """
        import secrets
        import hashlib
        
        # Generate reset token
        reset_token = secrets.token_urlsafe(32)
        token_hash = hashlib.sha256(reset_token.encode()).hexdigest()
        
        # Create reset record
        reset = self.password_resets.create_reset_token(
            user_id=user_id,
            token=reset_token,
            token_hash=token_hash,
            expires_in_hours=1,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        # Record security event
        self.security_events.record_event(
            event_type="password_reset_requested",
            severity="medium",
            description="Password reset requested",
            user_id=user_id,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        return True, reset_token, None

    def complete_password_reset(
        self,
        reset_token: str,
        new_password_hash: str,
        ip_address: str,
        user_agent: str,
        tenant_id: Optional[UUID] = None
    ) -> Tuple[bool, Optional[str]]:
        """
        Complete password reset workflow.
        
        Args:
            reset_token: Reset token
            new_password_hash: New password hash
            ip_address: IP address
            user_agent: User agent
            tenant_id: Tenant ID for policy lookup
            
        Returns:
            Tuple of (success, error_message)
        """
        # Verify reset token
        success, reset, error = self.password_resets.verify_and_use_token(
            token=reset_token,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        if not success or not reset:
            return False, error
        
        # Check password reuse
        policy = self.password_policies.get_active_policy(tenant_id)
        check_count = policy.prevent_reuse_count if policy else 5
        
        is_reused = self.password_history.check_password_reuse(
            user_id=reset.user_id,
            new_password_hash=new_password_hash,
            check_last_n=check_count
        )
        
        if is_reused:
            return False, "Password has been used recently. Please choose a different password."
        
        # Add to password history
        self.password_history.add_to_history(
            user_id=reset.user_id,
            password_hash=new_password_hash,
            change_reason="Password reset",
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        # Terminate all user sessions
        self.logout_all_sessions(reset.user_id)
        
        # Record security event
        self.security_events.record_event(
            event_type="password_reset_completed",
            severity="medium",
            description="Password successfully reset",
            user_id=reset.user_id,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        return True, None

    # ==================== Social Authentication Workflows ====================

    def link_social_account(
        self,
        user_id: UUID,
        provider_name: str,
        provider_user_id: str,
        access_token: str,
        refresh_token: Optional[str],
        profile_data: Dict[str, Any],
        expires_in: Optional[int] = None
    ) -> Tuple[bool, Optional[str]]:
        """
        Link social account to user.
        
        Args:
            user_id: User identifier
            provider_name: OAuth provider name
            provider_user_id: User ID from provider
            access_token: OAuth access token
            refresh_token: OAuth refresh token
            profile_data: Profile data from provider
            expires_in: Token expiration in seconds
            
        Returns:
            Tuple of (success, error_message)
        """
        # Get provider
        provider = self.social_providers.find_by_name(provider_name)
        
        if not provider or not provider.is_enabled:
            return False, f"Provider {provider_name} not available"
        
        # Check if account already linked
        existing_link = self.social_links.find_by_user_and_provider(
            user_id=user_id,
            provider_id=provider.id
        )
        
        if existing_link and existing_link.is_linked:
            return False, "Social account already linked"
        
        # Create or update social profile
        self.social_profiles.create_or_update_profile(
            user_id=user_id,
            provider_id=provider.id,
            provider_user_id=provider_user_id,
            profile_data=profile_data
        )
        
        # Create or update token
        self.social_tokens.create_token(
            user_id=user_id,
            provider_id=provider.id,
            access_token=access_token,
            refresh_token=refresh_token,
            expires_in=expires_in
        )
        
        # Create or relink account
        if existing_link:
            self.social_links.relink_account(existing_link.id)
        else:
            self.social_links.create_link(
                user_id=user_id,
                provider_id=provider.id,
                link_method="manual_link"
            )
        
        # Record security event
        self.security_events.record_event(
            event_type="social_account_linked",
            severity="low",
            description=f"Social account linked: {provider_name}",
            user_id=user_id
        )
        
        return True, None

    # ==================== Comprehensive Statistics ====================

    def get_authentication_overview(
        self,
        user_id: UUID,
        days: int = 30
    ) -> Dict[str, Any]:
        """
        Get comprehensive authentication overview for user.
        
        Args:
            user_id: User identifier
            days: Number of days to analyze
            
        Returns:
            Dictionary with complete authentication statistics
        """
        return {
            "sessions": self.user_sessions.get_session_statistics(user_id),
            "login_attempts": self.login_attempts.get_attempt_statistics(user_id, days),
            "password_attempts": self.password_attempts.get_attempt_statistics(user_id, days),
            "security_events": self.security_events.get_event_statistics(user_id, days),
            "social_links": {
                "active_links": self.social_links.count_active_links(user_id),
                "links": [
                    {
                        "provider": link.provider.provider_name,
                        "is_primary": link.is_primary,
                        "linked_at": link.linked_at
                    }
                    for link in self.social_links.find_user_links(user_id)
                ]
            },
            "devices": self.user_sessions.get_user_devices(user_id)
        }

    def get_security_dashboard(
        self,
        days: int = 7
    ) -> Dict[str, Any]:
        """
        Get security dashboard with threat intelligence.
        
        Args:
            days: Number of days to analyze
            
        Returns:
            Dictionary with security metrics and threats
        """
        return {
            "security_events": self.security_events.get_event_statistics(days=days),
            "threat_intelligence": self.security_events.get_threat_intelligence(days),
            "high_risk_events": len(self.security_events.find_high_risk_events(hours=days*24)),
            "critical_events": len(self.security_events.find_critical_events(hours=days*24)),
            "blacklist_stats": self.blacklisted_tokens.get_blacklist_statistics(days=days),
            "revocation_stats": self.token_revocations.get_revocation_statistics(days=days)
        }

    # ==================== Cleanup Operations ====================

    def cleanup_expired_data(self, days_old: int = 30) -> Dict[str, int]:
        """
        Clean up expired authentication data.
        
        Args:
            days_old: Remove data older than this many days
            
        Returns:
            Dictionary with cleanup counts
        """
        return {
            "sessions_cleaned": self.user_sessions.cleanup_expired_sessions(days_old),
            "session_tokens_cleaned": self.session_tokens.cleanup_expired_tokens(days_old),
            "refresh_tokens_cleaned": self.refresh_tokens.cleanup_expired_tokens(days_old),
            "login_attempts_cleaned": self.login_attempts.cleanup_old_attempts(days_old),
            "otp_tokens_cleaned": self.otp_tokens.cleanup_expired_otps(days_old),
            "otp_throttling_cleaned": self.otp_throttling.cleanup_old_records(days_old),
            "password_resets_cleaned": self.password_resets.cleanup_expired_tokens(days_old),
            "password_attempts_cleaned": self.password_attempts.cleanup_old_attempts(days_old),
            "blacklisted_tokens_cleaned": self.blacklisted_tokens.cleanup_expired_tokens(days_old),
            "security_events_cleaned": self.security_events.cleanup_old_events(days_old, keep_critical=True)
        }

# --- File: C:\Hostel-Main\app\repositories\auth\otp_token_repository.py ---
"""
OTP Token Repository
Manages OTP generation, validation, delivery, and throttling.
"""

from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from sqlalchemy import and_, or_, func, desc
from sqlalchemy.orm import Session

from app.models.auth import (
    OTPToken,
    OTPTemplate,
    OTPDelivery,
    OTPThrottling,
)
from app.repositories.base.base_repository import BaseRepository
from app.schemas.common.enums import OTPType


class OTPTokenRepository(BaseRepository[OTPToken]):
    """
    Repository for OTP token management with multi-channel delivery.
    """

    def __init__(self, db: Session):
        super().__init__(OTPToken, db)

    def create_otp(
        self,
        user_id: Optional[UUID],
        email: Optional[str],
        phone: Optional[str],
        otp_code: str,
        otp_type: OTPType,
        delivery_channel: str,
        expires_in_minutes: int = 10,
        max_attempts: int = 3,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> OTPToken:
        """
        Create new OTP token.
        
        Args:
            user_id: User identifier (optional for non-authenticated requests)
            email: Email for OTP delivery
            phone: Phone for OTP delivery
            otp_code: OTP code (should be hashed)
            otp_type: Purpose of OTP
            delivery_channel: Delivery channel (email, sms, both)
            expires_in_minutes: OTP validity period
            max_attempts: Maximum verification attempts
            ip_address: Request IP address
            user_agent: Request user agent
            metadata: Additional metadata
            
        Returns:
            Created OTPToken instance
        """
        expires_at = datetime.utcnow() + timedelta(minutes=expires_in_minutes)
        
        otp = OTPToken(
            user_id=user_id,
            email=email,
            phone=phone,
            otp_code=otp_code,
            otp_type=otp_type,
            delivery_channel=delivery_channel,
            max_attempts=max_attempts,
            expires_at=expires_at,
            generated_at=datetime.utcnow(),
            ip_address=ip_address,
            user_agent=user_agent,
            metadata=metadata,
        )
        
        self.db.add(otp)
        self.db.commit()
        self.db.refresh(otp)
        return otp

    def find_valid_otp(
        self,
        identifier: str,
        identifier_type: str,
        otp_type: OTPType
    ) -> Optional[OTPToken]:
        """
        Find valid OTP for verification.
        
        Args:
            identifier: Email or phone number
            identifier_type: 'email' or 'phone'
            otp_type: Type of OTP
            
        Returns:
            Valid OTPToken or None
        """
        filter_field = OTPToken.email if identifier_type == "email" else OTPToken.phone
        
        otp = self.db.query(OTPToken).filter(
            and_(
                filter_field == identifier,
                OTPToken.otp_type == otp_type,
                OTPToken.is_used == False,
                OTPToken.is_expired == False,
                OTPToken.expires_at > datetime.utcnow()
            )
        ).order_by(desc(OTPToken.created_at)).first()
        
        # Check expiration
        if otp:
            otp.check_expiration()
            self.db.commit()
            
            if not otp.is_valid():
                return None
        
        return otp

    def verify_otp(
        self,
        identifier: str,
        identifier_type: str,
        otp_code: str,
        otp_type: OTPType
    ) -> Tuple[bool, Optional[str]]:
        """
        Verify OTP code.
        
        Args:
            identifier: Email or phone number
            identifier_type: 'email' or 'phone'
            otp_code: OTP code to verify
            otp_type: Type of OTP
            
        Returns:
            Tuple of (success, error_message)
        """
        otp = self.find_valid_otp(identifier, identifier_type, otp_type)
        
        if not otp:
            return False, "Invalid or expired OTP"
        
        if not otp.is_valid():
            return False, "OTP has expired or exceeded maximum attempts"
        
        # Verify OTP code (assuming otp_code in DB is hashed)
        # You should implement proper hash verification here
        if otp.otp_code != otp_code:
            otp.increment_attempt()
            self.db.commit()
            
            remaining_attempts = otp.max_attempts - otp.attempt_count
            if remaining_attempts > 0:
                return False, f"Invalid OTP. {remaining_attempts} attempts remaining"
            else:
                return False, "Maximum verification attempts exceeded"
        
        # Mark as used
        otp.mark_as_used()
        self.db.commit()
        
        return True, None

    def invalidate_previous_otps(
        self,
        identifier: str,
        identifier_type: str,
        otp_type: OTPType
    ) -> int:
        """
        Invalidate all previous OTPs for an identifier.
        
        Args:
            identifier: Email or phone number
            identifier_type: 'email' or 'phone'
            otp_type: Type of OTP
            
        Returns:
            Number of OTPs invalidated
        """
        filter_field = OTPToken.email if identifier_type == "email" else OTPToken.phone
        
        count = self.db.query(OTPToken).filter(
            and_(
                filter_field == identifier,
                OTPToken.otp_type == otp_type,
                OTPToken.is_used == False,
                OTPToken.is_expired == False
            )
        ).update({
            "is_expired": True
        })
        
        self.db.commit()
        return count

    def get_otp_statistics(
        self,
        identifier: str,
        identifier_type: str,
        days: int = 30
    ) -> Dict[str, Any]:
        """
        Get OTP usage statistics.
        
        Args:
            identifier: Email or phone number
            identifier_type: 'email' or 'phone'
            days: Number of days to analyze
            
        Returns:
            Dictionary with OTP statistics
        """
        filter_field = OTPToken.email if identifier_type == "email" else OTPToken.phone
        cutoff_time = datetime.utcnow() - timedelta(days=days)
        
        total_otps = self.db.query(func.count(OTPToken.id)).filter(
            and_(
                filter_field == identifier,
                OTPToken.created_at >= cutoff_time
            )
        ).scalar()
        
        successful_verifications = self.db.query(func.count(OTPToken.id)).filter(
            and_(
                filter_field == identifier,
                OTPToken.is_used == True,
                OTPToken.created_at >= cutoff_time
            )
        ).scalar()
        
        expired_otps = self.db.query(func.count(OTPToken.id)).filter(
            and_(
                filter_field == identifier,
                OTPToken.is_expired == True,
                OTPToken.created_at >= cutoff_time
            )
        ).scalar()
        
        return {
            "total_otps": total_otps,
            "successful_verifications": successful_verifications,
            "expired_otps": expired_otps,
            "success_rate": (successful_verifications / total_otps * 100) if total_otps > 0 else 0
        }

    def cleanup_expired_otps(self, days_old: int = 7) -> int:
        """Clean up old expired OTPs."""
        cutoff_date = datetime.utcnow() - timedelta(days=days_old)
        
        count = self.db.query(OTPToken).filter(
            OTPToken.expires_at < cutoff_date
        ).delete(synchronize_session=False)
        
        self.db.commit()
        return count


class OTPTemplateRepository(BaseRepository[OTPTemplate]):
    """
    Repository for OTP message template management.
    """

    def __init__(self, db: Session):
        super().__init__(OTPTemplate, db)

    def find_template(
        self,
        otp_type: OTPType,
        channel: str,
        language: str = "en"
    ) -> Optional[OTPTemplate]:
        """
        Find template for OTP type and channel.
        
        Args:
            otp_type: Type of OTP
            channel: Delivery channel (email, sms)
            language: Language code
            
        Returns:
            OTPTemplate or None
        """
        return self.db.query(OTPTemplate).filter(
            and_(
                OTPTemplate.otp_type == otp_type,
                OTPTemplate.channel == channel,
                OTPTemplate.language == language,
                OTPTemplate.is_active == True
            )
        ).first()

    def create_template(
        self,
        otp_type: OTPType,
        channel: str,
        subject: Optional[str],
        body: str,
        html_body: Optional[str] = None,
        language: str = "en",
        variables: Optional[Dict[str, str]] = None,
        description: Optional[str] = None
    ) -> OTPTemplate:
        """Create new OTP template."""
        template = OTPTemplate(
            otp_type=otp_type,
            channel=channel,
            subject=subject,
            body=body,
            html_body=html_body,
            language=language,
            variables=variables,
            description=description,
        )
        
        self.db.add(template)
        self.db.commit()
        self.db.refresh(template)
        return template

    def get_all_templates(
        self,
        otp_type: Optional[OTPType] = None,
        channel: Optional[str] = None,
        active_only: bool = True
    ) -> List[OTPTemplate]:
        """Get all templates with optional filtering."""
        query = self.db.query(OTPTemplate)
        
        if otp_type:
            query = query.filter(OTPTemplate.otp_type == otp_type)
        
        if channel:
            query = query.filter(OTPTemplate.channel == channel)
        
        if active_only:
            query = query.filter(OTPTemplate.is_active == True)
        
        return query.all()


class OTPDeliveryRepository(BaseRepository[OTPDelivery]):
    """
    Repository for OTP delivery tracking.
    """

    def __init__(self, db: Session):
        super().__init__(OTPDelivery, db)

    def create_delivery(
        self,
        otp_token_id: UUID,
        channel: str,
        recipient: str,
        provider: Optional[str] = None
    ) -> OTPDelivery:
        """
        Create OTP delivery record.
        
        Args:
            otp_token_id: OTP token ID
            channel: Delivery channel
            recipient: Recipient address
            provider: Service provider
            
        Returns:
            Created OTPDelivery instance
        """
        delivery = OTPDelivery(
            otp_token_id=otp_token_id,
            channel=channel,
            recipient=recipient,
            status="pending",
            provider=provider,
        )
        
        self.db.add(delivery)
        self.db.commit()
        self.db.refresh(delivery)
        return delivery

    def mark_as_sent(
        self,
        delivery_id: UUID,
        provider_message_id: Optional[str] = None
    ) -> bool:
        """Mark delivery as sent."""
        delivery = self.find_by_id(delivery_id)
        if delivery:
            delivery.mark_as_sent(provider_message_id)
            self.db.commit()
            return True
        return False

    def mark_as_delivered(self, delivery_id: UUID) -> bool:
        """Mark delivery as delivered."""
        delivery = self.find_by_id(delivery_id)
        if delivery:
            delivery.mark_as_delivered()
            self.db.commit()
            return True
        return False

    def mark_as_failed(
        self,
        delivery_id: UUID,
        error_code: str,
        error_message: str
    ) -> bool:
        """Mark delivery as failed."""
        delivery = self.find_by_id(delivery_id)
        if delivery:
            delivery.mark_as_failed(error_code, error_message)
            self.db.commit()
            return True
        return False

    def get_delivery_statistics(
        self,
        channel: Optional[str] = None,
        days: int = 30
    ) -> Dict[str, Any]:
        """
        Get delivery statistics.
        
        Args:
            channel: Filter by channel
            days: Number of days to analyze
            
        Returns:
            Dictionary with delivery statistics
        """
        cutoff_time = datetime.utcnow() - timedelta(days=days)
        
        query = self.db.query(OTPDelivery).filter(
            OTPDelivery.created_at >= cutoff_time
        )
        
        if channel:
            query = query.filter(OTPDelivery.channel == channel)
        
        total_deliveries = query.count()
        
        status_breakdown = self.db.query(
            OTPDelivery.status,
            func.count(OTPDelivery.id)
        ).filter(
            OTPDelivery.created_at >= cutoff_time
        )
        
        if channel:
            status_breakdown = status_breakdown.filter(OTPDelivery.channel == channel)
        
        status_breakdown = status_breakdown.group_by(OTPDelivery.status).all()
        
        return {
            "total_deliveries": total_deliveries,
            "status_breakdown": {
                status: count for status, count in status_breakdown
            },
            "success_rate": self._calculate_success_rate(status_breakdown, total_deliveries)
        }

    def _calculate_success_rate(
        self,
        status_breakdown: List[Tuple[str, int]],
        total: int
    ) -> float:
        """Calculate delivery success rate."""
        if total == 0:
            return 0.0
        
        successful = sum(
            count for status, count in status_breakdown 
            if status in ["sent", "delivered"]
        )
        
        return (successful / total) * 100


class OTPThrottlingRepository(BaseRepository[OTPThrottling]):
    """
    Repository for OTP rate limiting and abuse prevention.
    """

    def __init__(self, db: Session):
        super().__init__(OTPThrottling, db)

    def check_rate_limit(
        self,
        identifier: str,
        identifier_type: str,
        ip_address: str,
        otp_type: OTPType,
        max_requests: int = 5,
        window_minutes: int = 60
    ) -> Tuple[bool, Optional[str]]:
        """
        Check if rate limit is exceeded.
        
        Args:
            identifier: Email or phone number
            identifier_type: 'email' or 'phone'
            ip_address: IP address
            otp_type: Type of OTP
            max_requests: Maximum requests per window
            window_minutes: Time window in minutes
            
        Returns:
            Tuple of (is_allowed, error_message)
        """
        now = datetime.utcnow()
        window_start = now - timedelta(minutes=window_minutes)
        
        # Check existing throttling record
        record = self.db.query(OTPThrottling).filter(
            and_(
                OTPThrottling.identifier == identifier,
                OTPThrottling.identifier_type == identifier_type,
                OTPThrottling.otp_type == otp_type,
                OTPThrottling.created_at >= window_start
            )
        ).first()
        
        if record:
            # Check if blocked
            if record.is_blocked and record.blocked_until and now < record.blocked_until:
                time_remaining = (record.blocked_until - now).seconds // 60
                return False, f"Too many requests. Please try again after {time_remaining} minutes"
            
            # Check rate limit
            if record.request_count >= max_requests:
                # Block the identifier
                record.is_blocked = True
                record.blocked_until = now + timedelta(hours=1)
                record.block_reason = "Rate limit exceeded"
                self.db.commit()
                return False, "Too many OTP requests. Please try again later."
            
            # Increment count
            record.request_count += 1
            self.db.commit()
        else:
            # Create new throttling record
            window_end = now + timedelta(minutes=window_minutes)
            new_record = OTPThrottling(
                identifier=identifier,
                identifier_type=identifier_type,
                ip_address=ip_address,
                otp_type=otp_type,
                request_count=1,
                window_start=now,
                window_end=window_end,
            )
            self.db.add(new_record)
            self.db.commit()
        
        return True, None

    def reset_throttling(
        self,
        identifier: str,
        identifier_type: str
    ) -> bool:
        """Reset throttling for an identifier."""
        record = self.db.query(OTPThrottling).filter(
            and_(
                OTPThrottling.identifier == identifier,
                OTPThrottling.identifier_type == identifier_type
            )
        ).first()
        
        if record:
            record.is_blocked = False
            record.blocked_until = None
            record.request_count = 0
            self.db.commit()
            return True
        return False

    def cleanup_old_records(self, days_old: int = 7) -> int:
        """Clean up old throttling records."""
        cutoff_date = datetime.utcnow() - timedelta(days=days_old)
        
        count = self.db.query(OTPThrottling).filter(
            OTPThrottling.created_at < cutoff_date
        ).delete(synchronize_session=False)
        
        self.db.commit()
        return count

# --- File: C:\Hostel-Main\app\repositories\auth\password_reset_repository.py ---
"""
Password Reset Repository
Manages password reset tokens, password history, policies, and attempts.
"""

from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from sqlalchemy import and_, or_, func, desc
from sqlalchemy.orm import Session

from app.models.auth import (
    PasswordReset,
    PasswordHistory,
    PasswordPolicy,
    PasswordAttempt,
)
from app.repositories.base.base_repository import BaseRepository


class PasswordResetRepository(BaseRepository[PasswordReset]):
    """
    Repository for password reset token management.
    """

    def __init__(self, db: Session):
        super().__init__(PasswordReset, db)

    def create_reset_token(
        self,
        user_id: UUID,
        token: str,
        token_hash: str,
        expires_in_hours: int = 1,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> PasswordReset:
        """
        Create password reset token.
        
        Args:
            user_id: User identifier
            token: Reset token (plain text, will be hashed)
            token_hash: SHA256 hash of token
            expires_in_hours: Token validity period
            ip_address: Request IP address
            user_agent: Request user agent
            metadata: Additional metadata
            
        Returns:
            Created PasswordReset instance
        """
        # Invalidate any existing tokens for this user
        self.invalidate_user_tokens(user_id)
        
        expires_at = datetime.utcnow() + timedelta(hours=expires_in_hours)
        
        reset = PasswordReset(
            user_id=user_id,
            token=token,
            token_hash=token_hash,
            expires_at=expires_at,
            ip_address=ip_address,
            user_agent=user_agent,
            metadata=metadata,
        )
        
        self.db.add(reset)
        self.db.commit()
        self.db.refresh(reset)
        return reset

    def find_by_token(self, token: str) -> Optional[PasswordReset]:
        """
        Find password reset by token.
        
        Args:
            token: Reset token
            
        Returns:
            PasswordReset or None
        """
        return self.db.query(PasswordReset).filter(
            PasswordReset.token == token
        ).first()

    def find_valid_token(
        self,
        user_id: UUID,
        token_hash: str
    ) -> Optional[PasswordReset]:
        """
        Find valid reset token for user.
        
        Args:
            user_id: User identifier
            token_hash: Token hash to verify
            
        Returns:
            Valid PasswordReset or None
        """
        reset = self.db.query(PasswordReset).filter(
            and_(
                PasswordReset.user_id == user_id,
                PasswordReset.token_hash == token_hash,
                PasswordReset.is_used == False,
                PasswordReset.is_expired == False,
                PasswordReset.expires_at > datetime.utcnow()
            )
        ).first()
        
        # Check expiration
        if reset:
            reset.check_expiration()
            self.db.commit()
            
            if not reset.is_valid():
                return None
        
        return reset

    def verify_and_use_token(
        self,
        token: str,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None
    ) -> Tuple[bool, Optional[PasswordReset], Optional[str]]:
        """
        Verify and mark reset token as used.
        
        Args:
            token: Reset token to verify
            ip_address: IP address of reset request
            user_agent: User agent of reset request
            
        Returns:
            Tuple of (success, reset_object, error_message)
        """
        reset = self.find_by_token(token)
        
        if not reset:
            return False, None, "Invalid reset token"
        
        if not reset.is_valid():
            return False, None, "Reset token has expired or already been used"
        
        # Mark as used
        reset.mark_as_used(ip_address, user_agent)
        self.db.commit()
        
        return True, reset, None

    def invalidate_user_tokens(self, user_id: UUID) -> int:
        """
        Invalidate all active reset tokens for a user.
        
        Args:
            user_id: User identifier
            
        Returns:
            Number of tokens invalidated
        """
        count = self.db.query(PasswordReset).filter(
            and_(
                PasswordReset.user_id == user_id,
                PasswordReset.is_used == False,
                PasswordReset.is_expired == False
            )
        ).update({
            "is_expired": True
        })
        
        self.db.commit()
        return count

    def get_reset_statistics(
        self,
        user_id: UUID,
        days: int = 30
    ) -> Dict[str, Any]:
        """
        Get password reset statistics for a user.
        
        Args:
            user_id: User identifier
            days: Number of days to analyze
            
        Returns:
            Dictionary with reset statistics
        """
        cutoff_time = datetime.utcnow() - timedelta(days=days)
        
        total_requests = self.db.query(func.count(PasswordReset.id)).filter(
            and_(
                PasswordReset.user_id == user_id,
                PasswordReset.created_at >= cutoff_time
            )
        ).scalar()
        
        successful_resets = self.db.query(func.count(PasswordReset.id)).filter(
            and_(
                PasswordReset.user_id == user_id,
                PasswordReset.is_used == True,
                PasswordReset.created_at >= cutoff_time
            )
        ).scalar()
        
        expired_tokens = self.db.query(func.count(PasswordReset.id)).filter(
            and_(
                PasswordReset.user_id == user_id,
                PasswordReset.is_expired == True,
                PasswordReset.is_used == False,
                PasswordReset.created_at >= cutoff_time
            )
        ).scalar()
        
        return {
            "total_requests": total_requests,
            "successful_resets": successful_resets,
            "expired_tokens": expired_tokens,
            "completion_rate": (successful_resets / total_requests * 100) if total_requests > 0 else 0
        }

    def cleanup_expired_tokens(self, days_old: int = 7) -> int:
        """Clean up old expired tokens."""
        cutoff_date = datetime.utcnow() - timedelta(days=days_old)
        
        count = self.db.query(PasswordReset).filter(
            PasswordReset.expires_at < cutoff_date
        ).delete(synchronize_session=False)
        
        self.db.commit()
        return count


class PasswordHistoryRepository(BaseRepository[PasswordHistory]):
    """
    Repository for password history management.
    """

    def __init__(self, db: Session):
        super().__init__(PasswordHistory, db)

    def add_to_history(
        self,
        user_id: UUID,
        password_hash: str,
        changed_by_user_id: Optional[UUID] = None,
        change_reason: Optional[str] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> PasswordHistory:
        """
        Add password to history.
        
        Args:
            user_id: User identifier
            password_hash: Hashed password
            changed_by_user_id: Who changed the password (for admin overrides)
            change_reason: Reason for change
            ip_address: IP address
            user_agent: User agent
            metadata: Additional metadata
            
        Returns:
            Created PasswordHistory instance
        """
        history = PasswordHistory(
            user_id=user_id,
            password_hash=password_hash,
            changed_by_user_id=changed_by_user_id,
            change_reason=change_reason,
            ip_address=ip_address,
            user_agent=user_agent,
            metadata=metadata,
        )
        
        self.db.add(history)
        self.db.commit()
        self.db.refresh(history)
        return history

    def get_user_history(
        self,
        user_id: UUID,
        limit: int = 10
    ) -> List[PasswordHistory]:
        """
        Get password change history for user.
        
        Args:
            user_id: User identifier
            limit: Maximum number of records to return
            
        Returns:
            List of PasswordHistory records
        """
        return self.db.query(PasswordHistory).filter(
            PasswordHistory.user_id == user_id
        ).order_by(desc(PasswordHistory.created_at)).limit(limit).all()

    def check_password_reuse(
        self,
        user_id: UUID,
        new_password_hash: str,
        check_last_n: int = 5
    ) -> bool:
        """
        Check if password has been used recently.
        
        Args:
            user_id: User identifier
            new_password_hash: New password hash to check
            check_last_n: Number of previous passwords to check
            
        Returns:
            True if password was used before
        """
        recent_passwords = self.db.query(PasswordHistory.password_hash).filter(
            PasswordHistory.user_id == user_id
        ).order_by(desc(PasswordHistory.created_at)).limit(check_last_n).all()
        
        # Compare hashes
        for (password_hash,) in recent_passwords:
            if password_hash == new_password_hash:
                return True
        
        return False

    def get_password_age(self, user_id: UUID) -> Optional[int]:
        """
        Get age of current password in days.
        
        Args:
            user_id: User identifier
            
        Returns:
            Number of days since last password change, or None
        """
        last_change = self.db.query(PasswordHistory).filter(
            PasswordHistory.user_id == user_id
        ).order_by(desc(PasswordHistory.created_at)).first()
        
        if last_change:
            age = datetime.utcnow() - last_change.created_at
            return age.days
        
        return None

    def cleanup_old_history(self, user_id: UUID, keep_last_n: int = 10) -> int:
        """
        Clean up old password history, keeping only the most recent entries.
        
        Args:
            user_id: User identifier
            keep_last_n: Number of recent passwords to keep
            
        Returns:
            Number of records deleted
        """
        # Get IDs of passwords to keep
        keep_ids = self.db.query(PasswordHistory.id).filter(
            PasswordHistory.user_id == user_id
        ).order_by(desc(PasswordHistory.created_at)).limit(keep_last_n).all()
        
        keep_ids = [id_tuple[0] for id_tuple in keep_ids]
        
        # Delete old records
        count = self.db.query(PasswordHistory).filter(
            and_(
                PasswordHistory.user_id == user_id,
                ~PasswordHistory.id.in_(keep_ids)
            )
        ).delete(synchronize_session=False)
        
        self.db.commit()
        return count


class PasswordPolicyRepository(BaseRepository[PasswordPolicy]):
    """
    Repository for password policy management.
    """

    def __init__(self, db: Session):
        super().__init__(PasswordPolicy, db)

    def create_policy(
        self,
        name: str,
        description: Optional[str] = None,
        tenant_id: Optional[UUID] = None,
        min_length: int = 8,
        max_length: int = 128,
        require_uppercase: bool = True,
        require_lowercase: bool = True,
        require_digit: bool = True,
        require_special_char: bool = True,
        special_chars: str = "!@#$%^&*()_+-=[]{}|;:,.<>?",
        prevent_reuse_count: int = 5,
        max_age_days: Optional[int] = None,
        expire_warning_days: int = 7,
        lockout_threshold: int = 5,
        lockout_duration_minutes: int = 30,
        metadata: Optional[Dict[str, Any]] = None
    ) -> PasswordPolicy:
        """
        Create password policy.
        
        Args:
            name: Policy name
            description: Policy description
            tenant_id: Tenant ID (None for system-wide)
            min_length: Minimum password length
            max_length: Maximum password length
            require_uppercase: Require uppercase letters
            require_lowercase: Require lowercase letters
            require_digit: Require digits
            require_special_char: Require special characters
            special_chars: Allowed special characters
            prevent_reuse_count: Number of previous passwords to prevent reuse
            max_age_days: Maximum password age
            expire_warning_days: Days before expiration to warn
            lockout_threshold: Failed attempts before lockout
            lockout_duration_minutes: Lockout duration
            metadata: Additional metadata
            
        Returns:
            Created PasswordPolicy instance
        """
        policy = PasswordPolicy(
            name=name,
            description=description,
            tenant_id=tenant_id,
            min_length=min_length,
            max_length=max_length,
            require_uppercase=require_uppercase,
            require_lowercase=require_lowercase,
            require_digit=require_digit,
            require_special_char=require_special_char,
            special_chars=special_chars,
            prevent_reuse_count=prevent_reuse_count,
            max_age_days=max_age_days,
            expire_warning_days=expire_warning_days,
            lockout_threshold=lockout_threshold,
            lockout_duration_minutes=lockout_duration_minutes,
            metadata=metadata,
        )
        
        self.db.add(policy)
        self.db.commit()
        self.db.refresh(policy)
        return policy

    def get_active_policy(
        self,
        tenant_id: Optional[UUID] = None
    ) -> Optional[PasswordPolicy]:
        """
        Get active password policy for tenant or system-wide.
        
        Args:
            tenant_id: Tenant ID (None for system-wide)
            
        Returns:
            Active PasswordPolicy or None
        """
        # First try to get tenant-specific policy
        if tenant_id:
            policy = self.db.query(PasswordPolicy).filter(
                and_(
                    PasswordPolicy.tenant_id == tenant_id,
                    PasswordPolicy.is_active == True
                )
            ).first()
            
            if policy:
                return policy
        
        # Fall back to system-wide policy
        return self.db.query(PasswordPolicy).filter(
            and_(
                PasswordPolicy.tenant_id.is_(None),
                PasswordPolicy.is_active == True
            )
        ).first()

    def validate_password(
        self,
        password: str,
        tenant_id: Optional[UUID] = None
    ) -> Tuple[bool, List[str]]:
        """
        Validate password against policy.
        
        Args:
            password: Password to validate
            tenant_id: Tenant ID
            
        Returns:
            Tuple of (is_valid, list_of_errors)
        """
        policy = self.get_active_policy(tenant_id)
        
        if not policy:
            # No policy, use basic validation
            if len(password) < 8:
                return False, ["Password must be at least 8 characters long"]
            return True, []
        
        errors = []
        
        # Check length
        if len(password) < policy.min_length:
            errors.append(f"Password must be at least {policy.min_length} characters long")
        
        if len(password) > policy.max_length:
            errors.append(f"Password must not exceed {policy.max_length} characters")
        
        # Check character requirements
        if policy.require_uppercase and not any(c.isupper() for c in password):
            errors.append("Password must contain at least one uppercase letter")
        
        if policy.require_lowercase and not any(c.islower() for c in password):
            errors.append("Password must contain at least one lowercase letter")
        
        if policy.require_digit and not any(c.isdigit() for c in password):
            errors.append("Password must contain at least one digit")
        
        if policy.require_special_char:
            if not any(c in policy.special_chars for c in password):
                errors.append(f"Password must contain at least one special character: {policy.special_chars}")
        
        return len(errors) == 0, errors

    def get_all_policies(
        self,
        tenant_id: Optional[UUID] = None,
        active_only: bool = True
    ) -> List[PasswordPolicy]:
        """Get all password policies."""
        query = self.db.query(PasswordPolicy)
        
        if tenant_id is not None:
            query = query.filter(PasswordPolicy.tenant_id == tenant_id)
        
        if active_only:
            query = query.filter(PasswordPolicy.is_active == True)
        
        return query.all()


class PasswordAttemptRepository(BaseRepository[PasswordAttempt]):
    """
    Repository for password attempt tracking.
    """

    def __init__(self, db: Session):
        super().__init__(PasswordAttempt, db)

    def record_attempt(
        self,
        user_id: UUID,
        attempt_type: str,
        is_successful: bool,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> PasswordAttempt:
        """
        Record password attempt.
        
        Args:
            user_id: User identifier
            attempt_type: Type of attempt (login, password_change, etc.)
            is_successful: Whether attempt was successful
            ip_address: IP address
            user_agent: User agent
            metadata: Additional metadata
            
        Returns:
            Created PasswordAttempt instance
        """
        attempt = PasswordAttempt(
            user_id=user_id,
            attempt_type=attempt_type,
            is_successful=is_successful,
            ip_address=ip_address,
            user_agent=user_agent,
            metadata=metadata,
        )
        
        self.db.add(attempt)
        self.db.commit()
        self.db.refresh(attempt)
        return attempt

    def count_recent_failures(
        self,
        user_id: UUID,
        attempt_type: str = "login",
        minutes: int = 30
    ) -> int:
        """
        Count recent failed password attempts.
        
        Args:
            user_id: User identifier
            attempt_type: Type of attempt to count
            minutes: Time window in minutes
            
        Returns:
            Count of failed attempts
        """
        cutoff_time = datetime.utcnow() - timedelta(minutes=minutes)
        
        return self.db.query(func.count(PasswordAttempt.id)).filter(
            and_(
                PasswordAttempt.user_id == user_id,
                PasswordAttempt.attempt_type == attempt_type,
                PasswordAttempt.is_successful == False,
                PasswordAttempt.created_at >= cutoff_time,
            )
        ).scalar() or 0

    def should_lockout(
        self,
        user_id: UUID,
        tenant_id: Optional[UUID] = None
    ) -> Tuple[bool, Optional[datetime]]:
        """
        Check if account should be locked based on failed attempts.
        
        Args:
            user_id: User identifier
            tenant_id: Tenant ID for policy lookup
            
        Returns:
            Tuple of (should_lock, lockout_until)
        """
        # Get password policy
        policy_repo = PasswordPolicyRepository(self.db)
        policy = policy_repo.get_active_policy(tenant_id)
        
        if not policy:
            # Default policy
            threshold = 5
            duration_minutes = 30
        else:
            threshold = policy.lockout_threshold
            duration_minutes = policy.lockout_duration_minutes
        
        # Count recent failures
        failure_count = self.count_recent_failures(
            user_id,
            minutes=duration_minutes
        )
        
        if failure_count >= threshold:
            lockout_until = datetime.utcnow() + timedelta(minutes=duration_minutes)
            return True, lockout_until
        
        return False, None

    def reset_attempts(self, user_id: UUID) -> int:
        """
        Reset failed attempts for user (after successful login).
        
        Args:
            user_id: User identifier
            
        Returns:
            Number of attempts cleared
        """
        # We don't actually delete, just record successful attempt
        # The time-based window will naturally exclude old attempts
        return 0

    def get_attempt_statistics(
        self,
        user_id: UUID,
        days: int = 30
    ) -> Dict[str, Any]:
        """
        Get password attempt statistics.
        
        Args:
            user_id: User identifier
            days: Number of days to analyze
            
        Returns:
            Dictionary with attempt statistics
        """
        cutoff_time = datetime.utcnow() - timedelta(days=days)
        
        total_attempts = self.db.query(func.count(PasswordAttempt.id)).filter(
            and_(
                PasswordAttempt.user_id == user_id,
                PasswordAttempt.created_at >= cutoff_time
            )
        ).scalar()
        
        successful_attempts = self.db.query(func.count(PasswordAttempt.id)).filter(
            and_(
                PasswordAttempt.user_id == user_id,
                PasswordAttempt.is_successful == True,
                PasswordAttempt.created_at >= cutoff_time
            )
        ).scalar()
        
        failed_attempts = total_attempts - successful_attempts
        
        # Get attempt type breakdown
        type_breakdown = self.db.query(
            PasswordAttempt.attempt_type,
            func.count(PasswordAttempt.id)
        ).filter(
            and_(
                PasswordAttempt.user_id == user_id,
                PasswordAttempt.created_at >= cutoff_time
            )
        ).group_by(PasswordAttempt.attempt_type).all()
        
        return {
            "total_attempts": total_attempts,
            "successful_attempts": successful_attempts,
            "failed_attempts": failed_attempts,
            "success_rate": (successful_attempts / total_attempts * 100) if total_attempts > 0 else 0,
            "type_breakdown": {
                attempt_type: count for attempt_type, count in type_breakdown
            }
        }

    def cleanup_old_attempts(self, days_old: int = 90) -> int:
        """Clean up old password attempts."""
        cutoff_date = datetime.utcnow() - timedelta(days=days_old)
        
        count = self.db.query(PasswordAttempt).filter(
            PasswordAttempt.created_at < cutoff_date
        ).delete(synchronize_session=False)
        
        self.db.commit()
        return count

# --- File: C:\Hostel-Main\app\repositories\auth\social_auth_token_repository.py ---
"""
Social Authentication Repository
Manages OAuth providers, tokens, profiles, and account linking.
"""

from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import and_, or_, func, desc
from sqlalchemy.orm import Session

from app.models.auth import (
    SocialAuthProvider,
    SocialAuthToken,
    SocialAuthProfile,
    SocialAuthLink,
)
from app.repositories.base.base_repository import BaseRepository


class SocialAuthProviderRepository(BaseRepository[SocialAuthProvider]):
    """
    Repository for OAuth provider configuration management.
    """

    def __init__(self, db: Session):
        super().__init__(SocialAuthProvider, db)

    def create_provider(
        self,
        provider_name: str,
        display_name: str,
        client_id: str,
        client_secret: str,
        authorization_url: str,
        token_url: str,
        user_info_url: str,
        default_scopes: Optional[List[str]] = None,
        icon_url: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> SocialAuthProvider:
        """
        Create OAuth provider configuration.
        
        Args:
            provider_name: Provider identifier (google, facebook, etc.)
            display_name: Display name for UI
            client_id: OAuth client ID
            client_secret: OAuth client secret (should be encrypted)
            authorization_url: Authorization endpoint
            token_url: Token endpoint
            user_info_url: User info endpoint
            default_scopes: Default OAuth scopes
            icon_url: Provider icon URL
            metadata: Additional configuration
            
        Returns:
            Created SocialAuthProvider instance
        """
        provider = SocialAuthProvider(
            provider_name=provider_name,
            display_name=display_name,
            client_id=client_id,
            client_secret=client_secret,
            authorization_url=authorization_url,
            token_url=token_url,
            user_info_url=user_info_url,
            default_scopes=default_scopes,
            icon_url=icon_url,
            metadata=metadata,
        )
        
        self.db.add(provider)
        self.db.commit()
        self.db.refresh(provider)
        return provider

    def find_by_name(self, provider_name: str) -> Optional[SocialAuthProvider]:
        """Find provider by name."""
        return self.db.query(SocialAuthProvider).filter(
            SocialAuthProvider.provider_name == provider_name
        ).first()

    def get_enabled_providers(self) -> List[SocialAuthProvider]:
        """Get all enabled OAuth providers."""
        return self.db.query(SocialAuthProvider).filter(
            SocialAuthProvider.is_enabled == True
        ).all()

    def enable_provider(self, provider_id: UUID) -> bool:
        """Enable OAuth provider."""
        provider = self.find_by_id(provider_id)
        if provider:
            provider.is_enabled = True
            self.db.commit()
            return True
        return False

    def disable_provider(self, provider_id: UUID) -> bool:
        """Disable OAuth provider."""
        provider = self.find_by_id(provider_id)
        if provider:
            provider.is_enabled = False
            self.db.commit()
            return True
        return False


class SocialAuthTokenRepository(BaseRepository[SocialAuthToken]):
    """
    Repository for OAuth token management.
    """

    def __init__(self, db: Session):
        super().__init__(SocialAuthToken, db)

    def create_token(
        self,
        user_id: UUID,
        provider_id: UUID,
        access_token: str,
        refresh_token: Optional[str] = None,
        token_type: str = "Bearer",
        expires_in: Optional[int] = None,
        scopes: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> SocialAuthToken:
        """
        Create or update OAuth token.
        
        Args:
            user_id: User identifier
            provider_id: OAuth provider ID
            access_token: Access token (should be encrypted)
            refresh_token: Refresh token (should be encrypted)
            token_type: Token type
            expires_in: Token expiration in seconds
            scopes: Granted OAuth scopes
            metadata: Additional metadata
            
        Returns:
            Created/Updated SocialAuthToken instance
        """
        # Check if token already exists
        existing_token = self.find_by_user_and_provider(user_id, provider_id)
        
        if existing_token:
            # Update existing token
            existing_token.update_tokens(access_token, refresh_token, expires_in)
            if scopes:
                existing_token.scopes = scopes
            if metadata:
                existing_token.metadata = metadata
            self.db.commit()
            return existing_token
        
        # Create new token
        expires_at = None
        if expires_in:
            expires_at = datetime.utcnow() + timedelta(seconds=expires_in)
        
        token = SocialAuthToken(
            user_id=user_id,
            provider_id=provider_id,
            access_token=access_token,
            refresh_token=refresh_token,
            token_type=token_type,
            expires_at=expires_at,
            scopes=scopes,
            metadata=metadata,
        )
        
        self.db.add(token)
        self.db.commit()
        self.db.refresh(token)
        return token

    def find_by_user_and_provider(
        self,
        user_id: UUID,
        provider_id: UUID
    ) -> Optional[SocialAuthToken]:
        """Find token for user and provider."""
        return self.db.query(SocialAuthToken).filter(
            and_(
                SocialAuthToken.user_id == user_id,
                SocialAuthToken.provider_id == provider_id
            )
        ).first()

    def find_user_tokens(self, user_id: UUID) -> List[SocialAuthToken]:
        """Get all social auth tokens for user."""
        return self.db.query(SocialAuthToken).filter(
            SocialAuthToken.user_id == user_id
        ).all()

    def refresh_token(
        self,
        token_id: UUID,
        new_access_token: str,
        new_refresh_token: Optional[str] = None,
        expires_in: Optional[int] = None
    ) -> bool:
        """Refresh OAuth token."""
        token = self.find_by_id(token_id)
        if token:
            token.update_tokens(new_access_token, new_refresh_token, expires_in)
            self.db.commit()
            return True
        return False

    def revoke_token(self, token_id: UUID) -> bool:
        """Revoke OAuth token."""
        token = self.find_by_id(token_id)
        if token:
            self.db.delete(token)
            self.db.commit()
            return True
        return False

    def get_expired_tokens(self) -> List[SocialAuthToken]:
        """Get all expired tokens that need refresh."""
        return self.db.query(SocialAuthToken).filter(
            and_(
                SocialAuthToken.expires_at.isnot(None),
                SocialAuthToken.expires_at < datetime.utcnow(),
                SocialAuthToken.refresh_token.isnot(None)
            )
        ).all()


class SocialAuthProfileRepository(BaseRepository[SocialAuthProfile]):
    """
    Repository for social profile data management.
    """

    def __init__(self, db: Session):
        super().__init__(SocialAuthProfile, db)

    def create_or_update_profile(
        self,
        user_id: UUID,
        provider_id: UUID,
        provider_user_id: str,
        profile_data: Dict[str, Any]
    ) -> SocialAuthProfile:
        """
        Create or update social profile.
        
        Args:
            user_id: User identifier
            provider_id: OAuth provider ID
            provider_user_id: User ID from provider
            profile_data: Profile data from provider
            
        Returns:
            Created/Updated SocialAuthProfile instance
        """
        # Check if profile exists
        existing_profile = self.find_by_user_and_provider(user_id, provider_id)
        
        if existing_profile:
            # Update existing profile
            existing_profile.sync_profile(profile_data)
            self.db.commit()
            return existing_profile
        
        # Create new profile
        profile = SocialAuthProfile(
            user_id=user_id,
            provider_id=provider_id,
            provider_user_id=provider_user_id,
            email=profile_data.get("email"),
            full_name=profile_data.get("name"),
            first_name=profile_data.get("given_name"),
            last_name=profile_data.get("family_name"),
            profile_picture_url=profile_data.get("picture"),
            gender=profile_data.get("gender"),
            locale=profile_data.get("locale"),
            email_verified=profile_data.get("email_verified", False),
            raw_profile_data=profile_data,
        )
        
        self.db.add(profile)
        self.db.commit()
        self.db.refresh(profile)
        return profile

    def find_by_user_and_provider(
        self,
        user_id: UUID,
        provider_id: UUID
    ) -> Optional[SocialAuthProfile]:
        """Find profile for user and provider."""
        return self.db.query(SocialAuthProfile).filter(
            and_(
                SocialAuthProfile.user_id == user_id,
                SocialAuthProfile.provider_id == provider_id
            )
        ).first()

    def find_by_provider_user_id(
        self,
        provider_id: UUID,
        provider_user_id: str
    ) -> Optional[SocialAuthProfile]:
        """Find profile by provider user ID."""
        return self.db.query(SocialAuthProfile).filter(
            and_(
                SocialAuthProfile.provider_id == provider_id,
                SocialAuthProfile.provider_user_id == provider_user_id
            )
        ).first()

    def find_user_profiles(self, user_id: UUID) -> List[SocialAuthProfile]:
        """Get all social profiles for user."""
        return self.db.query(SocialAuthProfile).filter(
            SocialAuthProfile.user_id == user_id
        ).all()

    def sync_profile(
        self,
        profile_id: UUID,
        profile_data: Dict[str, Any]
    ) -> bool:
        """Sync profile data from provider."""
        profile = self.find_by_id(profile_id)
        if profile:
            profile.sync_profile(profile_data)
            self.db.commit()
            return True
        return False

    def get_profiles_needing_sync(
        self,
        hours_old: int = 24
    ) -> List[SocialAuthProfile]:
        """Get profiles that need syncing."""
        cutoff_time = datetime.utcnow() - timedelta(hours=hours_old)
        
        return self.db.query(SocialAuthProfile).filter(
            SocialAuthProfile.last_synced_at < cutoff_time
        ).all()


class SocialAuthLinkRepository(BaseRepository[SocialAuthLink]):
    """
    Repository for social account linking management.
    """

    def __init__(self, db: Session):
        super().__init__(SocialAuthLink, db)

    def create_link(
        self,
        user_id: UUID,
        provider_id: UUID,
        link_method: str = "manual_link",
        is_primary: bool = False,
        metadata: Optional[Dict[str, Any]] = None
    ) -> SocialAuthLink:
        """
        Create social account link.
        
        Args:
            user_id: User identifier
            provider_id: OAuth provider ID
            link_method: How account was linked
            is_primary: Whether this is primary auth method
            metadata: Additional metadata
            
        Returns:
            Created SocialAuthLink instance
        """
        link = SocialAuthLink(
            user_id=user_id,
            provider_id=provider_id,
            link_method=link_method,
            is_primary=is_primary,
            metadata=metadata,
        )
        
        self.db.add(link)
        self.db.commit()
        self.db.refresh(link)
        return link

    def find_by_user_and_provider(
        self,
        user_id: UUID,
        provider_id: UUID
    ) -> Optional[SocialAuthLink]:
        """Find link for user and provider."""
        return self.db.query(SocialAuthLink).filter(
            and_(
                SocialAuthLink.user_id == user_id,
                SocialAuthLink.provider_id == provider_id
            )
        ).first()

    def find_user_links(
        self,
        user_id: UUID,
        active_only: bool = True
    ) -> List[SocialAuthLink]:
        """Get all social account links for user."""
        query = self.db.query(SocialAuthLink).filter(
            SocialAuthLink.user_id == user_id
        )
        
        if active_only:
            query = query.filter(SocialAuthLink.is_linked == True)
        
        return query.all()

    def unlink_account(
        self,
        link_id: UUID,
        reason: Optional[str] = None
    ) -> bool:
        """Unlink social account."""
        link = self.find_by_id(link_id)
        if link and link.is_linked:
            link.unlink(reason)
            self.db.commit()
            return True
        return False

    def relink_account(self, link_id: UUID) -> bool:
        """Relink previously unlinked account."""
        link = self.find_by_id(link_id)
        if link and not link.is_linked:
            link.relink()
            self.db.commit()
            return True
        return False

    def set_primary_link(
        self,
        user_id: UUID,
        provider_id: UUID
    ) -> bool:
        """Set a social account as primary authentication method."""
        # First, remove primary status from all links
        self.db.query(SocialAuthLink).filter(
            SocialAuthLink.user_id == user_id
        ).update({"is_primary": False})
        
        # Set new primary
        link = self.find_by_user_and_provider(user_id, provider_id)
        if link and link.is_linked:
            link.is_primary = True
            self.db.commit()
            return True
        
        return False

    def get_primary_link(self, user_id: UUID) -> Optional[SocialAuthLink]:
        """Get primary social auth link for user."""
        return self.db.query(SocialAuthLink).filter(
            and_(
                SocialAuthLink.user_id == user_id,
                SocialAuthLink.is_linked == True,
                SocialAuthLink.is_primary == True
            )
        ).first()

    def count_active_links(self, user_id: UUID) -> int:
        """Count active social account links."""
        return self.db.query(func.count(SocialAuthLink.id)).filter(
            and_(
                SocialAuthLink.user_id == user_id,
                SocialAuthLink.is_linked == True
            )
        ).scalar() or 0

    def get_link_statistics(
        self,
        days: int = 30
    ) -> Dict[str, Any]:
        """Get social auth link statistics."""
        cutoff_time = datetime.utcnow() - timedelta(days=days)
        
        total_links = self.db.query(func.count(SocialAuthLink.id)).filter(
            SocialAuthLink.created_at >= cutoff_time
        ).scalar()
        
        active_links = self.db.query(func.count(SocialAuthLink.id)).filter(
            and_(
                SocialAuthLink.is_linked == True,
                SocialAuthLink.created_at >= cutoff_time
            )
        ).scalar()
        
        unlinked = total_links - active_links
        
        # Get provider breakdown
        provider_breakdown = self.db.query(
            SocialAuthLink.provider_id,
            func.count(SocialAuthLink.id)
        ).filter(
            and_(
                SocialAuthLink.is_linked == True,
                SocialAuthLink.created_at >= cutoff_time
            )
        ).group_by(SocialAuthLink.provider_id).all()
        
        return {
            "total_links": total_links,
            "active_links": active_links,
            "unlinked": unlinked,
            "retention_rate": (active_links / total_links * 100) if total_links > 0 else 0,
            "provider_breakdown": {
                str(provider_id): count for provider_id, count in provider_breakdown
            }
        }

# --- File: C:\Hostel-Main\app\repositories\auth\token_blacklist_repository.py ---
"""
Token Blacklist Repository
Manages token revocation, blacklisting, and security events.
"""

from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from sqlalchemy import and_, or_, func, desc
from sqlalchemy.orm import Session

from app.models.auth import (
    BlacklistedToken,
    TokenRevocation,
    SecurityEvent,
)
from app.repositories.base.base_repository import BaseRepository


class BlacklistedTokenRepository(BaseRepository[BlacklistedToken]):
    """
    Repository for token blacklist management.
    """

    def __init__(self, db: Session):
        super().__init__(BlacklistedToken, db)

    def blacklist_token(
        self,
        jti: str,
        token_type: str,
        token_hash: str,
        user_id: Optional[UUID],
        expires_at: datetime,
        revocation_reason: str,
        revoked_by_user_id: Optional[UUID] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> BlacklistedToken:
        """
        Add token to blacklist.
        
        Args:
            jti: JWT ID
            token_type: Token type (access, refresh)
            token_hash: SHA256 hash of token
            user_id: User identifier
            expires_at: Token expiration timestamp
            revocation_reason: Reason for revocation
            revoked_by_user_id: Who revoked the token
            ip_address: IP address of revocation request
            user_agent: User agent of revocation request
            metadata: Additional metadata
            
        Returns:
            Created BlacklistedToken instance
        """
        blacklisted = BlacklistedToken(
            jti=jti,
            token_type=token_type,
            token_hash=token_hash,
            user_id=user_id,
            expires_at=expires_at,
            revocation_reason=revocation_reason,
            revoked_by_user_id=revoked_by_user_id,
            ip_address=ip_address,
            user_agent=user_agent,
            metadata=metadata,
        )
        
        self.db.add(blacklisted)
        self.db.commit()
        self.db.refresh(blacklisted)
        return blacklisted

    def is_blacklisted(self, jti: str) -> bool:
        """
        Check if token is blacklisted.
        
        Args:
            jti: JWT ID to check
            
        Returns:
            True if token is blacklisted
        """
        exists = self.db.query(
            self.db.query(BlacklistedToken).filter(
                BlacklistedToken.jti == jti
            ).exists()
        ).scalar()
        
        return exists

    def find_by_jti(self, jti: str) -> Optional[BlacklistedToken]:
        """Find blacklisted token by JTI."""
        return self.db.query(BlacklistedToken).filter(
            BlacklistedToken.jti == jti
        ).first()

    def find_user_blacklisted_tokens(
        self,
        user_id: UUID,
        token_type: Optional[str] = None
    ) -> List[BlacklistedToken]:
        """Get all blacklisted tokens for user."""
        query = self.db.query(BlacklistedToken).filter(
            BlacklistedToken.user_id == user_id
        )
        
        if token_type:
            query = query.filter(BlacklistedToken.token_type == token_type)
        
        return query.order_by(desc(BlacklistedToken.revoked_at)).all()

    def bulk_blacklist_tokens(
        self,
        jtis: List[str],
        token_type: str,
        user_id: UUID,
        revocation_reason: str,
        expires_at: datetime,
        revoked_by_user_id: Optional[UUID] = None
    ) -> int:
        """
        Blacklist multiple tokens at once.
        
        Args:
            jtis: List of JWT IDs to blacklist
            token_type: Token type
            user_id: User identifier
            revocation_reason: Reason for revocation
            expires_at: Token expiration
            revoked_by_user_id: Who revoked the tokens
            
        Returns:
            Number of tokens blacklisted
        """
        blacklisted_tokens = [
            BlacklistedToken(
                jti=jti,
                token_type=token_type,
                token_hash="",  # Hash not needed for bulk operations
                user_id=user_id,
                expires_at=expires_at,
                revocation_reason=revocation_reason,
                revoked_by_user_id=revoked_by_user_id,
            )
            for jti in jtis
        ]
        
        self.db.bulk_save_objects(blacklisted_tokens)
        self.db.commit()
        
        return len(blacklisted_tokens)

    def cleanup_expired_tokens(self, days_old: int = 7) -> int:
        """
        Clean up expired blacklisted tokens.
        
        Args:
            days_old: Remove tokens expired more than this many days ago
            
        Returns:
            Number of tokens removed
        """
        cutoff_date = datetime.utcnow() - timedelta(days=days_old)
        
        count = self.db.query(BlacklistedToken).filter(
            BlacklistedToken.expires_at < cutoff_date
        ).delete(synchronize_session=False)
        
        self.db.commit()
        return count

    def get_blacklist_statistics(
        self,
        user_id: Optional[UUID] = None,
        days: int = 30
    ) -> Dict[str, Any]:
        """
        Get blacklist statistics.
        
        Args:
            user_id: Filter by user (optional)
            days: Number of days to analyze
            
        Returns:
            Dictionary with blacklist statistics
        """
        cutoff_time = datetime.utcnow() - timedelta(days=days)
        
        query = self.db.query(BlacklistedToken).filter(
            BlacklistedToken.revoked_at >= cutoff_time
        )
        
        if user_id:
            query = query.filter(BlacklistedToken.user_id == user_id)
        
        total_blacklisted = query.count()
        
        # Token type breakdown
        type_breakdown = self.db.query(
            BlacklistedToken.token_type,
            func.count(BlacklistedToken.id)
        ).filter(
            BlacklistedToken.revoked_at >= cutoff_time
        )
        
        if user_id:
            type_breakdown = type_breakdown.filter(BlacklistedToken.user_id == user_id)
        
        type_breakdown = type_breakdown.group_by(BlacklistedToken.token_type).all()
        
        # Reason breakdown
        reason_breakdown = self.db.query(
            BlacklistedToken.revocation_reason,
            func.count(BlacklistedToken.id)
        ).filter(
            BlacklistedToken.revoked_at >= cutoff_time
        )
        
        if user_id:
            reason_breakdown = reason_breakdown.filter(BlacklistedToken.user_id == user_id)
        
        reason_breakdown = reason_breakdown.group_by(
            BlacklistedToken.revocation_reason
        ).all()
        
        return {
            "total_blacklisted": total_blacklisted,
            "type_breakdown": {
                token_type: count for token_type, count in type_breakdown
            },
            "reason_breakdown": {
                reason: count for reason, count in reason_breakdown
            }
        }


class TokenRevocationRepository(BaseRepository[TokenRevocation]):
    """
    Repository for token revocation audit trail.
    """

    def __init__(self, db: Session):
        super().__init__(TokenRevocation, db)

    def record_revocation(
        self,
        user_id: UUID,
        revocation_type: str,
        revocation_reason: str,
        tokens_revoked_count: int,
        initiated_by_user_id: Optional[UUID] = None,
        is_forced: bool = False,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        affected_token_ids: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> TokenRevocation:
        """
        Record token revocation event.
        
        Args:
            user_id: User whose tokens were revoked
            revocation_type: Type (single, session, all_tokens)
            revocation_reason: Reason for revocation
            tokens_revoked_count: Number of tokens revoked
            initiated_by_user_id: Who initiated revocation
            is_forced: Whether forced by admin
            ip_address: IP address
            user_agent: User agent
            affected_token_ids: List of affected JTIs
            metadata: Additional metadata
            
        Returns:
            Created TokenRevocation instance
        """
        revocation = TokenRevocation(
            user_id=user_id,
            revocation_type=revocation_type,
            revocation_reason=revocation_reason,
            tokens_revoked_count=tokens_revoked_count,
            initiated_by_user_id=initiated_by_user_id,
            is_forced=is_forced,
            ip_address=ip_address,
            user_agent=user_agent,
            affected_token_ids=affected_token_ids,
            metadata=metadata,
        )
        
        self.db.add(revocation)
        self.db.commit()
        self.db.refresh(revocation)
        return revocation

    def find_user_revocations(
        self,
        user_id: UUID,
        revocation_type: Optional[str] = None,
        limit: int = 50
    ) -> List[TokenRevocation]:
        """Get revocation history for user."""
        query = self.db.query(TokenRevocation).filter(
            TokenRevocation.user_id == user_id
        )
        
        if revocation_type:
            query = query.filter(TokenRevocation.revocation_type == revocation_type)
        
        return query.order_by(desc(TokenRevocation.created_at)).limit(limit).all()

    def find_forced_revocations(
        self,
        days: int = 30
    ) -> List[TokenRevocation]:
        """Get all forced revocations (admin actions)."""
        cutoff_time = datetime.utcnow() - timedelta(days=days)
        
        return self.db.query(TokenRevocation).filter(
            and_(
                TokenRevocation.is_forced == True,
                TokenRevocation.created_at >= cutoff_time
            )
        ).order_by(desc(TokenRevocation.created_at)).all()

    def get_revocation_statistics(
        self,
        user_id: Optional[UUID] = None,
        days: int = 30
    ) -> Dict[str, Any]:
        """
        Get revocation statistics.
        
        Args:
            user_id: Filter by user (optional)
            days: Number of days to analyze
            
        Returns:
            Dictionary with revocation statistics
        """
        cutoff_time = datetime.utcnow() - timedelta(days=days)
        
        query = self.db.query(TokenRevocation).filter(
            TokenRevocation.created_at >= cutoff_time
        )
        
        if user_id:
            query = query.filter(TokenRevocation.user_id == user_id)
        
        total_revocations = query.count()
        
        forced_revocations = self.db.query(
            func.count(TokenRevocation.id)
        ).filter(
            and_(
                TokenRevocation.is_forced == True,
                TokenRevocation.created_at >= cutoff_time
            )
        )
        
        if user_id:
            forced_revocations = forced_revocations.filter(
                TokenRevocation.user_id == user_id
            )
        
        forced_revocations = forced_revocations.scalar() or 0
        
        # Type breakdown
        type_breakdown = self.db.query(
            TokenRevocation.revocation_type,
            func.count(TokenRevocation.id)
        ).filter(
            TokenRevocation.created_at >= cutoff_time
        )
        
        if user_id:
            type_breakdown = type_breakdown.filter(TokenRevocation.user_id == user_id)
        
        type_breakdown = type_breakdown.group_by(
            TokenRevocation.revocation_type
        ).all()
        
        # Total tokens revoked
        total_tokens_revoked = self.db.query(
            func.sum(TokenRevocation.tokens_revoked_count)
        ).filter(
            TokenRevocation.created_at >= cutoff_time
        )
        
        if user_id:
            total_tokens_revoked = total_tokens_revoked.filter(
                TokenRevocation.user_id == user_id
            )
        
        total_tokens_revoked = total_tokens_revoked.scalar() or 0
        
        return {
            "total_revocations": total_revocations,
            "forced_revocations": forced_revocations,
            "total_tokens_revoked": total_tokens_revoked,
            "type_breakdown": {
                rev_type: count for rev_type, count in type_breakdown
            },
            "average_tokens_per_revocation": (
                total_tokens_revoked / total_revocations
            ) if total_revocations > 0 else 0
        }


class SecurityEventRepository(BaseRepository[SecurityEvent]):
    """
    Repository for security event tracking and monitoring.
    """

    def __init__(self, db: Session):
        super().__init__(SecurityEvent, db)

    def record_event(
        self,
        event_type: str,
        severity: str,
        description: str,
        user_id: Optional[UUID] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        device_fingerprint: Optional[str] = None,
        country: Optional[str] = None,
        city: Optional[str] = None,
        event_data: Optional[Dict[str, Any]] = None,
        risk_score: Optional[int] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> SecurityEvent:
        """
        Record security event.
        
        Args:
            event_type: Type of security event
            severity: Event severity (low, medium, high, critical)
            description: Event description
            user_id: Associated user (if applicable)
            ip_address: IP address
            user_agent: User agent
            device_fingerprint: Device fingerprint
            country: Country from geolocation
            city: City from geolocation
            event_data: Event-specific data
            risk_score: Calculated risk score (0-100)
            metadata: Additional metadata
            
        Returns:
            Created SecurityEvent instance
        """
        event = SecurityEvent(
            user_id=user_id,
            event_type=event_type,
            severity=severity,
            description=description,
            ip_address=ip_address,
            user_agent=user_agent,
            device_fingerprint=device_fingerprint,
            country=country,
            city=city,
            event_data=event_data,
            risk_score=risk_score,
            metadata=metadata,
        )
        
        self.db.add(event)
        self.db.commit()
        self.db.refresh(event)
        return event

    def find_user_events(
        self,
        user_id: UUID,
        event_type: Optional[str] = None,
        severity: Optional[str] = None,
        limit: int = 100
    ) -> List[SecurityEvent]:
        """Get security events for user."""
        query = self.db.query(SecurityEvent).filter(
            SecurityEvent.user_id == user_id
        )
        
        if event_type:
            query = query.filter(SecurityEvent.event_type == event_type)
        
        if severity:
            query = query.filter(SecurityEvent.severity == severity)
        
        return query.order_by(desc(SecurityEvent.created_at)).limit(limit).all()

    def find_high_risk_events(
        self,
        min_risk_score: int = 70,
        hours: int = 24,
        unresolved_only: bool = True
    ) -> List[SecurityEvent]:
        """Find high-risk security events."""
        cutoff_time = datetime.utcnow() - timedelta(hours=hours)
        
        query = self.db.query(SecurityEvent).filter(
            and_(
                SecurityEvent.risk_score >= min_risk_score,
                SecurityEvent.created_at >= cutoff_time
            )
        )
        
        if unresolved_only:
            query = query.filter(SecurityEvent.is_resolved == False)
        
        return query.order_by(desc(SecurityEvent.risk_score)).all()

    def find_critical_events(
        self,
        hours: int = 24,
        unresolved_only: bool = True
    ) -> List[SecurityEvent]:
        """Find critical security events."""
        cutoff_time = datetime.utcnow() - timedelta(hours=hours)
        
        query = self.db.query(SecurityEvent).filter(
            and_(
                SecurityEvent.severity == "critical",
                SecurityEvent.created_at >= cutoff_time
            )
        )
        
        if unresolved_only:
            query = query.filter(SecurityEvent.is_resolved == False)
        
        return query.order_by(desc(SecurityEvent.created_at)).all()

    def find_events_by_ip(
        self,
        ip_address: str,
        hours: int = 24
    ) -> List[SecurityEvent]:
        """Find all events from an IP address."""
        cutoff_time = datetime.utcnow() - timedelta(hours=hours)
        
        return self.db.query(SecurityEvent).filter(
            and_(
                SecurityEvent.ip_address == ip_address,
                SecurityEvent.created_at >= cutoff_time
            )
        ).order_by(desc(SecurityEvent.created_at)).all()

    def resolve_event(
        self,
        event_id: UUID,
        resolved_by_user_id: UUID,
        resolution_note: Optional[str] = None
    ) -> bool:
        """Mark security event as resolved."""
        event = self.find_by_id(event_id)
        if event and not event.is_resolved:
            event.resolve(resolved_by_user_id, resolution_note)
            self.db.commit()
            return True
        return False

    def bulk_resolve_events(
        self,
        event_ids: List[UUID],
        resolved_by_user_id: UUID,
        resolution_note: Optional[str] = None
    ) -> int:
        """Resolve multiple security events."""
        count = self.db.query(SecurityEvent).filter(
            and_(
                SecurityEvent.id.in_(event_ids),
                SecurityEvent.is_resolved == False
            )
        ).update({
            "is_resolved": True,
            "resolved_at": datetime.utcnow(),
            "resolved_by_user_id": resolved_by_user_id,
            "resolution_note": resolution_note
        }, synchronize_session=False)
        
        self.db.commit()
        return count

    def get_event_statistics(
        self,
        user_id: Optional[UUID] = None,
        days: int = 30
    ) -> Dict[str, Any]:
        """
        Get security event statistics.
        
        Args:
            user_id: Filter by user (optional)
            days: Number of days to analyze
            
        Returns:
            Dictionary with event statistics
        """
        cutoff_time = datetime.utcnow() - timedelta(days=days)
        
        query = self.db.query(SecurityEvent).filter(
            SecurityEvent.created_at >= cutoff_time
        )
        
        if user_id:
            query = query.filter(SecurityEvent.user_id == user_id)
        
        total_events = query.count()
        
        # Severity breakdown
        severity_breakdown = self.db.query(
            SecurityEvent.severity,
            func.count(SecurityEvent.id)
        ).filter(
            SecurityEvent.created_at >= cutoff_time
        )
        
        if user_id:
            severity_breakdown = severity_breakdown.filter(
                SecurityEvent.user_id == user_id
            )
        
        severity_breakdown = severity_breakdown.group_by(
            SecurityEvent.severity
        ).all()
        
        # Event type breakdown
        type_breakdown = self.db.query(
            SecurityEvent.event_type,
            func.count(SecurityEvent.id)
        ).filter(
            SecurityEvent.created_at >= cutoff_time
        )
        
        if user_id:
            type_breakdown = type_breakdown.filter(SecurityEvent.user_id == user_id)
        
        type_breakdown = type_breakdown.group_by(SecurityEvent.event_type).all()
        
        # Unresolved events
        unresolved_count = self.db.query(
            func.count(SecurityEvent.id)
        ).filter(
            and_(
                SecurityEvent.is_resolved == False,
                SecurityEvent.created_at >= cutoff_time
            )
        )
        
        if user_id:
            unresolved_count = unresolved_count.filter(SecurityEvent.user_id == user_id)
        
        unresolved_count = unresolved_count.scalar() or 0
        
        # Average risk score
        avg_risk_score = self.db.query(
            func.avg(SecurityEvent.risk_score)
        ).filter(
            and_(
                SecurityEvent.risk_score.isnot(None),
                SecurityEvent.created_at >= cutoff_time
            )
        )
        
        if user_id:
            avg_risk_score = avg_risk_score.filter(SecurityEvent.user_id == user_id)
        
        avg_risk_score = avg_risk_score.scalar() or 0
        
        return {
            "total_events": total_events,
            "unresolved_events": unresolved_count,
            "resolution_rate": (
                (total_events - unresolved_count) / total_events * 100
            ) if total_events > 0 else 0,
            "average_risk_score": round(avg_risk_score, 2),
            "severity_breakdown": {
                severity: count for severity, count in severity_breakdown
            },
            "type_breakdown": {
                event_type: count for event_type, count in type_breakdown
            }
        }

    def get_threat_intelligence(
        self,
        days: int = 7
    ) -> Dict[str, Any]:
        """
        Get threat intelligence summary.
        
        Args:
            days: Number of days to analyze
            
        Returns:
            Dictionary with threat intelligence
        """
        cutoff_time = datetime.utcnow() - timedelta(days=days)
        
        # Top threatening IPs
        top_ips = self.db.query(
            SecurityEvent.ip_address,
            func.count(SecurityEvent.id).label("event_count"),
            func.avg(SecurityEvent.risk_score).label("avg_risk")
        ).filter(
            and_(
                SecurityEvent.ip_address.isnot(None),
                SecurityEvent.created_at >= cutoff_time
            )
        ).group_by(
            SecurityEvent.ip_address
        ).order_by(
            desc("event_count")
        ).limit(10).all()
        
        # Top threat types
        top_threats = self.db.query(
            SecurityEvent.event_type,
            func.count(SecurityEvent.id).label("count"),
            func.avg(SecurityEvent.risk_score).label("avg_risk")
        ).filter(
            SecurityEvent.created_at >= cutoff_time
        ).group_by(
            SecurityEvent.event_type
        ).order_by(
            desc("count")
        ).limit(10).all()
        
        # Geographic distribution
        geo_distribution = self.db.query(
            SecurityEvent.country,
            func.count(SecurityEvent.id).label("count")
        ).filter(
            and_(
                SecurityEvent.country.isnot(None),
                SecurityEvent.created_at >= cutoff_time
            )
        ).group_by(
            SecurityEvent.country
        ).order_by(
            desc("count")
        ).all()
        
        return {
            "top_threatening_ips": [
                {
                    "ip_address": ip,
                    "event_count": count,
                    "average_risk_score": round(avg_risk, 2)
                }
                for ip, count, avg_risk in top_ips
            ],
            "top_threat_types": [
                {
                    "event_type": event_type,
                    "count": count,
                    "average_risk_score": round(avg_risk, 2)
                }
                for event_type, count, avg_risk in top_threats
            ],
            "geographic_distribution": [
                {
                    "country": country,
                    "event_count": count
                }
                for country, count in geo_distribution
            ]
        }

    def cleanup_old_events(
        self,
        days_old: int = 90,
        keep_critical: bool = True
    ) -> int:
        """
        Clean up old security events.
        
        Args:
            days_old: Remove events older than this many days
            keep_critical: Keep critical events regardless of age
            
        Returns:
            Number of events deleted
        """
        cutoff_date = datetime.utcnow() - timedelta(days=days_old)
        
        query = self.db.query(SecurityEvent).filter(
            SecurityEvent.created_at < cutoff_date
        )
        
        if keep_critical:
            query = query.filter(SecurityEvent.severity != "critical")
        
        count = query.delete(synchronize_session=False)
        self.db.commit()
        return count

# --- File: C:\Hostel-Main\app\repositories\auth\user_session_repository.py ---
"""
User Session Repository
Manages user sessions, tokens, and login attempts with advanced security features.
"""

from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import and_, or_, func, desc
from sqlalchemy.orm import Session, joinedload

from app.models.auth import (
    UserSession,
    SessionToken,
    RefreshToken,
    LoginAttempt,
)
from app.repositories.base.base_repository import BaseRepository
from app.schemas.common.enums import DeviceType


class UserSessionRepository(BaseRepository[UserSession]):
    """
    Repository for user session management with security monitoring.
    """

    def __init__(self, db: Session):
        super().__init__(UserSession, db)

    # ==================== Session Management ====================

    def create_session(
        self,
        user_id: UUID,
        session_id: str,
        device_info: Dict[str, Any],
        ip_address: str,
        is_remember_me: bool = False,
        expires_in_hours: int = 24,
    ) -> UserSession:
        """
        Create new user session with device tracking.
        
        Args:
            user_id: User identifier
            session_id: Unique session identifier
            device_info: Device information dictionary
            ip_address: IP address
            is_remember_me: Extended session flag
            expires_in_hours: Session expiration hours
            
        Returns:
            Created UserSession instance
        """
        expires_at = datetime.utcnow() + timedelta(hours=expires_in_hours)
        
        session = UserSession(
            user_id=user_id,
            session_id=session_id,
            device_name=device_info.get("device_name"),
            device_type=device_info.get("device_type"),
            device_fingerprint=device_info.get("device_fingerprint"),
            user_agent=device_info.get("user_agent"),
            browser=device_info.get("browser"),
            operating_system=device_info.get("operating_system"),
            ip_address=ip_address,
            country=device_info.get("country"),
            city=device_info.get("city"),
            timezone=device_info.get("timezone"),
            is_remember_me=is_remember_me,
            expires_at=expires_at,
            login_at=datetime.utcnow(),
            last_activity_at=datetime.utcnow(),
        )
        
        self.db.add(session)
        self.db.commit()
        self.db.refresh(session)
        return session

    def find_by_session_id(
        self,
        session_id: str,
        active_only: bool = True
    ) -> Optional[UserSession]:
        """
        Find session by session ID.
        
        Args:
            session_id: Session identifier
            active_only: Only return active sessions
            
        Returns:
            UserSession or None
        """
        query = self.db.query(UserSession).filter(
            UserSession.session_id == session_id
        )
        
        if active_only:
            query = query.filter(UserSession.is_active == True)
        
        return query.first()

    def find_active_sessions(
        self,
        user_id: UUID,
        exclude_session_id: Optional[str] = None
    ) -> List[UserSession]:
        """
        Get all active sessions for a user.
        
        Args:
            user_id: User identifier
            exclude_session_id: Session ID to exclude (current session)
            
        Returns:
            List of active sessions
        """
        query = self.db.query(UserSession).filter(
            and_(
                UserSession.user_id == user_id,
                UserSession.is_active == True,
                UserSession.expires_at > datetime.utcnow()
            )
        )
        
        if exclude_session_id:
            query = query.filter(UserSession.session_id != exclude_session_id)
        
        return query.order_by(desc(UserSession.last_activity_at)).all()

    def update_session_activity(self, session_id: str) -> bool:
        """
        Update last activity timestamp for session.
        
        Args:
            session_id: Session identifier
            
        Returns:
            Success status
        """
        session = self.find_by_session_id(session_id)
        if session and session.is_active:
            session.update_activity()
            self.db.commit()
            return True
        return False

    def terminate_session(
        self,
        session_id: str,
        revoke_tokens: bool = True
    ) -> bool:
        """
        Terminate a session and optionally revoke associated tokens.
        
        Args:
            session_id: Session identifier
            revoke_tokens: Whether to revoke associated tokens
            
        Returns:
            Success status
        """
        session = self.find_by_session_id(session_id, active_only=False)
        if not session:
            return False
        
        session.terminate()
        
        if revoke_tokens:
            # Revoke all session tokens
            self.db.query(SessionToken).filter(
                SessionToken.session_id == session.id
            ).update({
                "is_revoked": True,
                "revoked_at": datetime.utcnow(),
                "revocation_reason": "Session terminated"
            })
            
            # Revoke all refresh tokens
            self.db.query(RefreshToken).filter(
                RefreshToken.session_id == session.id
            ).update({
                "is_revoked": True,
                "revoked_at": datetime.utcnow(),
                "revocation_reason": "Session terminated"
            })
        
        self.db.commit()
        return True

    def terminate_all_user_sessions(
        self,
        user_id: UUID,
        except_session_id: Optional[str] = None
    ) -> int:
        """
        Terminate all sessions for a user.
        
        Args:
            user_id: User identifier
            except_session_id: Session to keep active (current session)
            
        Returns:
            Number of sessions terminated
        """
        sessions = self.find_active_sessions(user_id, exclude_session_id=except_session_id)
        
        for session in sessions:
            self.terminate_session(session.session_id, revoke_tokens=True)
        
        return len(sessions)

    def cleanup_expired_sessions(self, days_old: int = 30) -> int:
        """
        Clean up old expired sessions.
        
        Args:
            days_old: Remove sessions older than this many days
            
        Returns:
            Number of sessions deleted
        """
        cutoff_date = datetime.utcnow() - timedelta(days=days_old)
        
        count = self.db.query(UserSession).filter(
            and_(
                UserSession.is_active == False,
                UserSession.logout_at < cutoff_date
            )
        ).delete(synchronize_session=False)
        
        self.db.commit()
        return count

    # ==================== Security Monitoring ====================

    def find_suspicious_sessions(
        self,
        user_id: UUID,
        risk_threshold: int = 50
    ) -> List[UserSession]:
        """
        Find sessions with high risk scores.
        
        Args:
            user_id: User identifier
            risk_threshold: Minimum risk score to flag
            
        Returns:
            List of suspicious sessions
        """
        return self.db.query(UserSession).filter(
            and_(
                UserSession.user_id == user_id,
                UserSession.is_active == True,
                UserSession.risk_score >= risk_threshold
            )
        ).all()

    def detect_concurrent_locations(self, user_id: UUID) -> bool:
        """
        Detect if user has active sessions from different locations.
        
        Args:
            user_id: User identifier
            
        Returns:
            True if concurrent locations detected
        """
        active_sessions = self.find_active_sessions(user_id)
        
        if len(active_sessions) < 2:
            return False
        
        # Get unique countries from active sessions
        countries = set(
            session.country for session in active_sessions 
            if session.country
        )
        
        return len(countries) > 1

    def get_session_statistics(self, user_id: UUID) -> Dict[str, Any]:
        """
        Get session statistics for a user.
        
        Args:
            user_id: User identifier
            
        Returns:
            Dictionary with session statistics
        """
        total_sessions = self.db.query(func.count(UserSession.id)).filter(
            UserSession.user_id == user_id
        ).scalar()
        
        active_sessions = self.db.query(func.count(UserSession.id)).filter(
            and_(
                UserSession.user_id == user_id,
                UserSession.is_active == True
            )
        ).scalar()
        
        # Get device type breakdown
        device_breakdown = self.db.query(
            UserSession.device_type,
            func.count(UserSession.id)
        ).filter(
            UserSession.user_id == user_id
        ).group_by(UserSession.device_type).all()
        
        return {
            "total_sessions": total_sessions,
            "active_sessions": active_sessions,
            "device_breakdown": {
                device_type: count for device_type, count in device_breakdown
            },
            "has_suspicious_activity": len(self.find_suspicious_sessions(user_id)) > 0,
            "concurrent_locations": self.detect_concurrent_locations(user_id)
        }

    # ==================== Device Management ====================

    def find_sessions_by_device(
        self,
        user_id: UUID,
        device_fingerprint: str
    ) -> List[UserSession]:
        """
        Find all sessions for a specific device.
        
        Args:
            user_id: User identifier
            device_fingerprint: Device fingerprint hash
            
        Returns:
            List of sessions from this device
        """
        return self.db.query(UserSession).filter(
            and_(
                UserSession.user_id == user_id,
                UserSession.device_fingerprint == device_fingerprint
            )
        ).order_by(desc(UserSession.created_at)).all()

    def is_trusted_device(
        self,
        user_id: UUID,
        device_fingerprint: str,
        trust_threshold_days: int = 30
    ) -> bool:
        """
        Check if device is trusted based on usage history.
        
        Args:
            user_id: User identifier
            device_fingerprint: Device fingerprint hash
            trust_threshold_days: Days of history required
            
        Returns:
            True if device is trusted
        """
        oldest_session = self.db.query(UserSession).filter(
            and_(
                UserSession.user_id == user_id,
                UserSession.device_fingerprint == device_fingerprint
            )
        ).order_by(UserSession.created_at).first()
        
        if not oldest_session:
            return False
        
        days_used = (datetime.utcnow() - oldest_session.created_at).days
        return days_used >= trust_threshold_days

    def get_user_devices(self, user_id: UUID) -> List[Dict[str, Any]]:
        """
        Get list of unique devices used by user.
        
        Args:
            user_id: User identifier
            
        Returns:
            List of device information dictionaries
        """
        devices = self.db.query(
            UserSession.device_fingerprint,
            UserSession.device_name,
            UserSession.device_type,
            func.max(UserSession.last_activity_at).label("last_used"),
            func.count(UserSession.id).label("session_count")
        ).filter(
            UserSession.user_id == user_id
        ).group_by(
            UserSession.device_fingerprint,
            UserSession.device_name,
            UserSession.device_type
        ).all()
        
        return [
            {
                "device_fingerprint": device.device_fingerprint,
                "device_name": device.device_name,
                "device_type": device.device_type,
                "last_used": device.last_used,
                "session_count": device.session_count,
                "is_trusted": self.is_trusted_device(user_id, device.device_fingerprint)
            }
            for device in devices
        ]


class SessionTokenRepository(BaseRepository[SessionToken]):
    """
    Repository for JWT access token management.
    """

    def __init__(self, db: Session):
        super().__init__(SessionToken, db)

    def create_token(
        self,
        session_id: UUID,
        jti: str,
        token_hash: str,
        expires_in_minutes: int = 15,
        scopes: Optional[List[str]] = None
    ) -> SessionToken:
        """
        Create new session token.
        
        Args:
            session_id: Session identifier
            jti: JWT ID
            token_hash: Token hash
            expires_in_minutes: Expiration time in minutes
            scopes: Token scopes
            
        Returns:
            Created SessionToken instance
        """
        expires_at = datetime.utcnow() + timedelta(minutes=expires_in_minutes)
        
        token = SessionToken(
            session_id=session_id,
            jti=jti,
            token_hash=token_hash,
            expires_at=expires_at,
            scopes=scopes,
        )
        
        self.db.add(token)
        self.db.commit()
        self.db.refresh(token)
        return token

    def find_by_jti(self, jti: str) -> Optional[SessionToken]:
        """Find token by JWT ID."""
        return self.db.query(SessionToken).filter(
            SessionToken.jti == jti
        ).first()

    def is_token_valid(self, jti: str) -> bool:
        """Check if token is valid (not revoked and not expired)."""
        token = self.find_by_jti(jti)
        return token is not None and token.is_valid()

    def revoke_token(self, jti: str, reason: Optional[str] = None) -> bool:
        """Revoke a token."""
        token = self.find_by_jti(jti)
        if token:
            token.revoke(reason)
            self.db.commit()
            return True
        return False

    def revoke_session_tokens(self, session_id: UUID) -> int:
        """Revoke all tokens for a session."""
        count = self.db.query(SessionToken).filter(
            SessionToken.session_id == session_id
        ).update({
            "is_revoked": True,
            "revoked_at": datetime.utcnow(),
            "revocation_reason": "Session terminated"
        })
        self.db.commit()
        return count

    def cleanup_expired_tokens(self, days_old: int = 7) -> int:
        """Clean up old expired tokens."""
        cutoff_date = datetime.utcnow() - timedelta(days=days_old)
        
        count = self.db.query(SessionToken).filter(
            SessionToken.expires_at < cutoff_date
        ).delete(synchronize_session=False)
        
        self.db.commit()
        return count


class RefreshTokenRepository(BaseRepository[RefreshToken]):
    """
    Repository for JWT refresh token management with rotation.
    """

    def __init__(self, db: Session):
        super().__init__(RefreshToken, db)

    def create_token(
        self,
        session_id: UUID,
        jti: str,
        token_hash: str,
        family_id: str,
        expires_in_days: int = 30,
        parent_token_id: Optional[UUID] = None
    ) -> RefreshToken:
        """
        Create new refresh token with family tracking.
        
        Args:
            session_id: Session identifier
            jti: JWT ID
            token_hash: Token hash
            family_id: Token family ID for rotation tracking
            expires_in_days: Expiration time in days
            parent_token_id: Parent token in rotation chain
            
        Returns:
            Created RefreshToken instance
        """
        expires_at = datetime.utcnow() + timedelta(days=expires_in_days)
        
        rotation_count = 0
        if parent_token_id:
            parent = self.find_by_id(parent_token_id)
            if parent:
                rotation_count = parent.rotation_count + 1
        
        token = RefreshToken(
            session_id=session_id,
            jti=jti,
            token_hash=token_hash,
            family_id=family_id,
            parent_token_id=parent_token_id,
            rotation_count=rotation_count,
            expires_at=expires_at,
        )
        
        self.db.add(token)
        self.db.commit()
        self.db.refresh(token)
        return token

    def find_by_jti(self, jti: str) -> Optional[RefreshToken]:
        """Find token by JWT ID."""
        return self.db.query(RefreshToken).filter(
            RefreshToken.jti == jti
        ).first()

    def find_by_family_id(self, family_id: str) -> List[RefreshToken]:
        """Find all tokens in a family."""
        return self.db.query(RefreshToken).filter(
            RefreshToken.family_id == family_id
        ).order_by(RefreshToken.rotation_count).all()

    def is_token_valid(self, jti: str) -> bool:
        """Check if refresh token is valid."""
        token = self.find_by_jti(jti)
        return token is not None and token.is_valid()

    def use_token(self, jti: str) -> Optional[RefreshToken]:
        """Mark token as used and return it."""
        token = self.find_by_jti(jti)
        if token and token.is_valid():
            token.mark_as_used()
            self.db.commit()
            return token
        return None

    def revoke_token_family(
        self,
        family_id: str,
        reason: str = "Token reuse detected"
    ) -> int:
        """
        Revoke entire token family (security breach).
        
        Args:
            family_id: Token family ID
            reason: Revocation reason
            
        Returns:
            Number of tokens revoked
        """
        tokens = self.find_by_family_id(family_id)
        
        for token in tokens:
            token.revoke_family(reason)
        
        self.db.commit()
        return len(tokens)

    def detect_token_reuse(self, jti: str) -> bool:
        """
        Detect if a refresh token has been reused.
        
        Args:
            jti: JWT ID to check
            
        Returns:
            True if token reuse detected
        """
        token = self.find_by_jti(jti)
        
        if not token:
            return False
        
        # If token is already used but someone tries to use it again
        if token.is_used:
            # This is a security breach - revoke entire family
            self.revoke_token_family(
                token.family_id,
                "Token reuse detected - possible security breach"
            )
            return True
        
        return False

    def cleanup_expired_tokens(self, days_old: int = 7) -> int:
        """Clean up old expired refresh tokens."""
        cutoff_date = datetime.utcnow() - timedelta(days=days_old)
        
        count = self.db.query(RefreshToken).filter(
            RefreshToken.expires_at < cutoff_date
        ).delete(synchronize_session=False)
        
        self.db.commit()
        return count


class LoginAttemptRepository(BaseRepository[LoginAttempt]):
    """
    Repository for login attempt tracking and security monitoring.
    """

    def __init__(self, db: Session):
        super().__init__(LoginAttempt, db)

    def record_attempt(
        self,
        user_id: Optional[UUID],
        email: Optional[str],
        phone: Optional[str],
        is_successful: bool,
        failure_reason: Optional[str],
        ip_address: str,
        user_agent: str,
        device_fingerprint: Optional[str] = None,
        security_flags: Optional[Dict[str, Any]] = None
    ) -> LoginAttempt:
        """
        Record a login attempt.
        
        Args:
            user_id: User identifier (if known)
            email: Email used in attempt
            phone: Phone used in attempt
            is_successful: Whether attempt succeeded
            failure_reason: Reason for failure
            ip_address: IP address
            user_agent: User agent string
            device_fingerprint: Device fingerprint
            security_flags: Security analysis flags
            
        Returns:
            Created LoginAttempt instance
        """
        attempt = LoginAttempt(
            user_id=user_id,
            email=email,
            phone=phone,
            is_successful=is_successful,
            failure_reason=failure_reason,
            ip_address=ip_address,
            user_agent=user_agent,
            device_fingerprint=device_fingerprint,
            security_flags=security_flags,
        )
        
        self.db.add(attempt)
        self.db.commit()
        self.db.refresh(attempt)
        return attempt

    def count_recent_failures(
        self,
        identifier: str,
        identifier_type: str = "email",
        minutes: int = 15
    ) -> int:
        """
        Count recent failed login attempts.
        
        Args:
            identifier: Email or phone to check
            identifier_type: Type of identifier ('email' or 'phone')
            minutes: Time window in minutes
            
        Returns:
            Count of failed attempts
        """
        cutoff_time = datetime.utcnow() - timedelta(minutes=minutes)
        
        filter_field = LoginAttempt.email if identifier_type == "email" else LoginAttempt.phone
        
        return self.db.query(func.count(LoginAttempt.id)).filter(
            and_(
                filter_field == identifier,
                LoginAttempt.is_successful == False,
                LoginAttempt.created_at >= cutoff_time,
            )
        ).scalar() or 0

    def find_suspicious_attempts(
        self,
        hours: int = 24,
        min_risk_score: int = 70
    ) -> List[LoginAttempt]:
        """
        Find suspicious login attempts.
        
        Args:
            hours: Time window in hours
            min_risk_score: Minimum risk score to flag
            
        Returns:
            List of suspicious attempts
        """
        cutoff_time = datetime.utcnow() - timedelta(hours=hours)
        
        return self.db.query(LoginAttempt).filter(
            and_(
                LoginAttempt.created_at >= cutoff_time,
                LoginAttempt.risk_score >= min_risk_score
            )
        ).order_by(desc(LoginAttempt.risk_score)).all()

    def get_attempt_statistics(
        self,
        user_id: UUID,
        days: int = 30
    ) -> Dict[str, Any]:
        """
        Get login attempt statistics for a user.
        
        Args:
            user_id: User identifier
            days: Number of days to analyze
            
        Returns:
            Dictionary with attempt statistics
        """
        cutoff_time = datetime.utcnow() - timedelta(days=days)
        
        total_attempts = self.db.query(func.count(LoginAttempt.id)).filter(
            and_(
                LoginAttempt.user_id == user_id,
                LoginAttempt.created_at >= cutoff_time
            )
        ).scalar()
        
        successful_attempts = self.db.query(func.count(LoginAttempt.id)).filter(
            and_(
                LoginAttempt.user_id == user_id,
                LoginAttempt.is_successful == True,
                LoginAttempt.created_at >= cutoff_time
            )
        ).scalar()
        
        failed_attempts = total_attempts - successful_attempts
        
        # Get unique IPs
        unique_ips = self.db.query(
            func.count(func.distinct(LoginAttempt.ip_address))
        ).filter(
            and_(
                LoginAttempt.user_id == user_id,
                LoginAttempt.created_at >= cutoff_time
            )
        ).scalar()
        
        return {
            "total_attempts": total_attempts,
            "successful_attempts": successful_attempts,
            "failed_attempts": failed_attempts,
            "success_rate": (successful_attempts / total_attempts * 100) if total_attempts > 0 else 0,
            "unique_ips": unique_ips,
            "has_suspicious_activity": len(self.find_suspicious_attempts()) > 0
        }

    def cleanup_old_attempts(self, days_old: int = 90) -> int:
        """Clean up old login attempts."""
        cutoff_date = datetime.utcnow() - timedelta(days=days_old)
        
        count = self.db.query(LoginAttempt).filter(
            LoginAttempt.created_at < cutoff_date
        ).delete(synchronize_session=False)
        
        self.db.commit()
        return count

# --- File: C:\Hostel-Main\app\repositories\auth\__init__.py ---
"""
Authentication Repositories Package

Exports all authentication-related repositories for convenient imports.

Example:
    from app.repositories.auth import AuthAggregateRepository
    
    auth_repo = AuthAggregateRepository(db)
    result = auth_repo.authenticate_user(...)
"""

from app.repositories.auth.user_session_repository import (
    UserSessionRepository,
    SessionTokenRepository,
    RefreshTokenRepository,
    LoginAttemptRepository,
)
from app.repositories.auth.otp_token_repository import (
    OTPTokenRepository,
    OTPTemplateRepository,
    OTPDeliveryRepository,
    OTPThrottlingRepository,
)
from app.repositories.auth.password_reset_repository import (
    PasswordResetRepository,
    PasswordHistoryRepository,
    PasswordPolicyRepository,
    PasswordAttemptRepository,
)
from app.repositories.auth.social_auth_token_repository import (
    SocialAuthProviderRepository,
    SocialAuthTokenRepository,
    SocialAuthProfileRepository,
    SocialAuthLinkRepository,
)
from app.repositories.auth.token_blacklist_repository import (
    BlacklistedTokenRepository,
    TokenRevocationRepository,
    SecurityEventRepository,
)
from app.repositories.auth.auth_aggregate_repository import (
    AuthAggregateRepository,
)

__all__ = [
    # Session Management
    "UserSessionRepository",
    "SessionTokenRepository",
    "RefreshTokenRepository",
    "LoginAttemptRepository",
    # OTP Management
    "OTPTokenRepository",
    "OTPTemplateRepository",
    "OTPDeliveryRepository",
    "OTPThrottlingRepository",
    # Password Management
    "PasswordResetRepository",
    "PasswordHistoryRepository",
    "PasswordPolicyRepository",
    "PasswordAttemptRepository",
    # Social Authentication
    "SocialAuthProviderRepository",
    "SocialAuthTokenRepository",
    "SocialAuthProfileRepository",
    "SocialAuthLinkRepository",
    # Token Blacklist & Security
    "BlacklistedTokenRepository",
    "TokenRevocationRepository",
    "SecurityEventRepository",
    # Aggregate Repository
    "AuthAggregateRepository",
]
