### Combined Content from Folder: C:\Hostel-Main\app\repositories\admin ###



# ===== Folder: C:\Hostel-Main\app\repositories\admin =====

# --- File: C:\Hostel-Main\app\repositories\admin\admin_hostel_assignment_repository.py ---
"""
Admin Hostel Assignment Repository

Manages multi-hostel assignments with workload balancing,
transfer workflows, coverage analysis, and performance tracking.
"""

from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from datetime import datetime, date, timedelta
from decimal import Decimal
from sqlalchemy import select, and_, or_, func, desc, asc, case
from sqlalchemy.orm import Session, selectinload, joinedload
from sqlalchemy.exc import IntegrityError

from app.models.admin.admin_hostel_assignment import (
    AdminHostelAssignment,
    AssignmentPermission,
    AssignmentHistory,
    PrimaryHostelDesignation
)
from app.models.admin.admin_user import AdminUser
from app.models.hostel.hostel import Hostel
from app.repositories.base.base_repository import BaseRepository
from app.core.exceptions import (
    EntityNotFoundError,
    ValidationError,
    ConflictError,
    BusinessRuleViolationError
)


class AdminHostelAssignmentRepository(BaseRepository[AdminHostelAssignment]):
    """
    Multi-hostel assignment management with:
    - Workload balancing and optimization
    - Transfer workflows with handover tracking
    - Coverage gap analysis
    - Assignment history and audit trail
    - Performance metrics per assignment
    """

    def __init__(self, db: Session):
        super().__init__(AdminHostelAssignment, db)

    # ==================== ASSIGNMENT CREATION ====================

    async def assign_admin_to_hostels(
        self,
        admin_id: UUID,
        hostel_ids: List[UUID],
        assigned_by_id: UUID,
        permissions: Optional[Dict] = None,
        effective_from: Optional[date] = None,
        effective_until: Optional[date] = None,
        notes: Optional[str] = None,
        set_first_as_primary: bool = True
    ) -> List[AdminHostelAssignment]:
        """
        Assign admin to multiple hostels with comprehensive validation.
        
        Args:
            admin_id: Admin to assign
            hostel_ids: List of hostel IDs
            assigned_by_id: Who is making the assignment
            permissions: Optional permission overrides
            effective_from: Start date of assignment
            effective_until: End date of assignment
            notes: Assignment notes
            set_first_as_primary: Set first hostel as primary
            
        Returns:
            List of created assignments
            
        Raises:
            ValidationError: Invalid data
            BusinessRuleViolationError: Violates business rules
            ConflictError: Assignment conflicts
        """
        # Validate admin exists and is active
        admin = await self.db.get(AdminUser, admin_id)
        if not admin:
            raise EntityNotFoundError(f"Admin {admin_id} not found")
        
        if not admin.is_active:
            raise ValidationError(f"Admin {admin_id} is not active")

        # Check hostel limit
        if admin.max_hostel_limit:
            current_count = await self._get_active_assignment_count(admin_id)
            if current_count + len(hostel_ids) > admin.max_hostel_limit:
                raise BusinessRuleViolationError(
                    f"Admin can manage maximum {admin.max_hostel_limit} hostels. "
                    f"Current: {current_count}, Requested: {len(hostel_ids)}"
                )

        # Check for existing assignments
        conflicts = await self._check_assignment_conflicts(admin_id, hostel_ids)
        if conflicts:
            raise ConflictError(
                f"Active assignments already exist for hostels: "
                f"{', '.join(str(h) for h in conflicts)}"
            )

        # Validate all hostels exist
        await self._validate_hostels_exist(hostel_ids)

        # Create assignments
        assignments = []
        for idx, hostel_id in enumerate(hostel_ids):
            is_primary = (idx == 0 and set_first_as_primary and not admin.primary_hostel_id)
            
            assignment = AdminHostelAssignment(
                admin_id=admin_id,
                hostel_id=hostel_id,
                assigned_by_id=assigned_by_id,
                assigned_date=date.today(),
                effective_from=effective_from or date.today(),
                effective_until=effective_until,
                permission_level='FULL_ACCESS',
                permissions=permissions or {},
                is_active=True,
                is_primary=is_primary,
                assignment_notes=notes
            )

            self.db.add(assignment)
            assignments.append(assignment)

        try:
            await self.db.flush()

            # Set primary hostel if needed
            if set_first_as_primary and not admin.primary_hostel_id:
                admin.primary_hostel_id = hostel_ids[0]
                await self._create_primary_designation(
                    admin_id, hostel_ids[0], assigned_by_id
                )

            # Create assignment history for each
            for assignment in assignments:
                await self._create_assignment_history(
                    assignment_id=assignment.id,
                    admin_id=admin_id,
                    hostel_id=assignment.hostel_id,
                    action='created',
                    performed_by_id=assigned_by_id,
                    new_values=self._assignment_to_dict(assignment)
                )

            return assignments

        except IntegrityError as e:
            await self.db.rollback()
            raise ValidationError(f"Failed to create assignments: {str(e)}")

    async def assign_single_hostel(
        self,
        admin_id: UUID,
        hostel_id: UUID,
        assigned_by_id: UUID,
        **kwargs
    ) -> AdminHostelAssignment:
        """Assign admin to a single hostel."""
        assignments = await self.assign_admin_to_hostels(
            admin_id=admin_id,
            hostel_ids=[hostel_id],
            assigned_by_id=assigned_by_id,
            **kwargs
        )
        return assignments[0]

    # ==================== ASSIGNMENT RETRIEVAL ====================

    async def get_admin_assignments(
        self,
        admin_id: UUID,
        include_inactive: bool = False,
        include_expired: bool = False
    ) -> List[AdminHostelAssignment]:
        """Get all assignments for an admin."""
        stmt = (
            select(AdminHostelAssignment)
            .where(AdminHostelAssignment.admin_id == admin_id)
            .where(AdminHostelAssignment.is_deleted == False)
            .options(
                selectinload(AdminHostelAssignment.hostel),
                selectinload(AdminHostelAssignment.assigned_by)
            )
        )

        if not include_inactive:
            stmt = stmt.where(AdminHostelAssignment.is_active == True)

        if not include_expired:
            today = date.today()
            stmt = stmt.where(
                or_(
                    AdminHostelAssignment.effective_until.is_(None),
                    AdminHostelAssignment.effective_until >= today
                )
            )

        stmt = stmt.order_by(
            desc(AdminHostelAssignment.is_primary),
            AdminHostelAssignment.assigned_date
        )

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    async def get_hostel_assignments(
        self,
        hostel_id: UUID,
        include_inactive: bool = False
    ) -> List[AdminHostelAssignment]:
        """Get all admin assignments for a hostel."""
        stmt = (
            select(AdminHostelAssignment)
            .where(AdminHostelAssignment.hostel_id == hostel_id)
            .where(AdminHostelAssignment.is_deleted == False)
            .options(
                selectinload(AdminHostelAssignment.admin).selectinload(AdminUser.user)
            )
        )

        if not include_inactive:
            stmt = stmt.where(AdminHostelAssignment.is_active == True)

        stmt = stmt.order_by(
            desc(AdminHostelAssignment.is_primary),
            AdminHostelAssignment.assigned_date
        )

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    async def find_assignment(
        self,
        admin_id: UUID,
        hostel_id: UUID
    ) -> Optional[AdminHostelAssignment]:
        """Find specific assignment."""
        stmt = (
            select(AdminHostelAssignment)
            .where(AdminHostelAssignment.admin_id == admin_id)
            .where(AdminHostelAssignment.hostel_id == hostel_id)
            .where(AdminHostelAssignment.is_deleted == False)
            .options(
                selectinload(AdminHostelAssignment.hostel),
                selectinload(AdminHostelAssignment.assignment_permissions)
            )
        )

        result = await self.db.execute(stmt)
        return result.unique().scalar_one_or_none()

    async def get_primary_assignment(self, admin_id: UUID) -> Optional[AdminHostelAssignment]:
        """Get admin's primary hostel assignment."""
        stmt = (
            select(AdminHostelAssignment)
            .where(AdminHostelAssignment.admin_id == admin_id)
            .where(AdminHostelAssignment.is_primary == True)
            .where(AdminHostelAssignment.is_active == True)
            .where(AdminHostelAssignment.is_deleted == False)
            .options(selectinload(AdminHostelAssignment.hostel))
        )

        result = await self.db.execute(stmt)
        return result.unique().scalar_one_or_none()

    # ==================== ASSIGNMENT UPDATES ====================

    async def update_assignment(
        self,
        assignment_id: UUID,
        updates: Dict[str, Any],
        updated_by_id: UUID,
        reason: Optional[str] = None
    ) -> AdminHostelAssignment:
        """Update assignment with audit trail."""
        assignment = await self.find_by_id(assignment_id)
        if not assignment:
            raise EntityNotFoundError(f"Assignment {assignment_id} not found")

        # Store old values for audit
        old_values = self._assignment_to_dict(assignment)

        # Apply updates
        for key, value in updates.items():
            if hasattr(assignment, key):
                setattr(assignment, key, value)

        await self.db.flush()

        # Create audit record
        await self._create_assignment_history(
            assignment_id=assignment_id,
            admin_id=assignment.admin_id,
            hostel_id=assignment.hostel_id,
            action='updated',
            performed_by_id=updated_by_id,
            old_values=old_values,
            new_values=self._assignment_to_dict(assignment),
            reason=reason
        )

        return assignment

    async def revoke_assignment(
        self,
        assignment_id: UUID,
        revoked_by_id: UUID,
        reason: str,
        revoke_date: Optional[date] = None
    ) -> AdminHostelAssignment:
        """Revoke an assignment."""
        assignment = await self.find_by_id(assignment_id)
        if not assignment:
            raise EntityNotFoundError(f"Assignment {assignment_id} not found")

        assignment.is_active = False
        assignment.revoked_date = revoke_date or date.today()
        assignment.revoked_by_id = revoked_by_id
        assignment.revoke_reason = reason

        # If this was primary, unset it
        if assignment.is_primary:
            assignment.is_primary = False
            admin = await self.db.get(AdminUser, assignment.admin_id)
            if admin and admin.primary_hostel_id == assignment.hostel_id:
                admin.primary_hostel_id = None

        await self.db.flush()

        # Create audit record
        await self._create_assignment_history(
            assignment_id=assignment_id,
            admin_id=assignment.admin_id,
            hostel_id=assignment.hostel_id,
            action='revoked',
            performed_by_id=revoked_by_id,
            reason=reason
        )

        return assignment

    async def reactivate_assignment(
        self,
        assignment_id: UUID,
        reactivated_by_id: UUID,
        reason: Optional[str] = None
    ) -> AdminHostelAssignment:
        """Reactivate a revoked assignment."""
        assignment = await self.find_by_id(assignment_id)
        if not assignment:
            raise EntityNotFoundError(f"Assignment {assignment_id} not found")

        if assignment.is_active:
            raise ValidationError("Assignment is already active")

        assignment.is_active = True
        assignment.revoked_date = None
        assignment.revoked_by_id = None
        assignment.revoke_reason = None

        await self.db.flush()

        # Create audit record
        await self._create_assignment_history(
            assignment_id=assignment_id,
            admin_id=assignment.admin_id,
            hostel_id=assignment.hostel_id,
            action='reactivated',
            performed_by_id=reactivated_by_id,
            reason=reason
        )

        return assignment

    # ==================== PRIMARY HOSTEL MANAGEMENT ====================

    async def set_primary_hostel(
        self,
        admin_id: UUID,
        hostel_id: UUID,
        set_by_id: UUID,
        reason: Optional[str] = None
    ) -> AdminHostelAssignment:
        """Set primary hostel for admin."""
        # Verify assignment exists and is active
        assignment = await self.find_assignment(admin_id, hostel_id)
        if not assignment or not assignment.is_active:
            raise ValidationError(
                f"No active assignment found for admin {admin_id} and hostel {hostel_id}"
            )

        # Unset current primary
        current_primary = await self.get_primary_assignment(admin_id)
        if current_primary and current_primary.id != assignment.id:
            current_primary.is_primary = False
            # End primary designation
            await self._end_primary_designation(admin_id, current_primary.hostel_id)

        # Set new primary
        assignment.is_primary = True

        # Update admin's primary hostel
        admin = await self.db.get(AdminUser, admin_id)
        admin.primary_hostel_id = hostel_id

        # Create primary designation record
        await self._create_primary_designation(admin_id, hostel_id, set_by_id, reason)

        await self.db.flush()

        # Create audit record
        await self._create_assignment_history(
            assignment_id=assignment.id,
            admin_id=admin_id,
            hostel_id=hostel_id,
            action='set_as_primary',
            performed_by_id=set_by_id,
            reason=reason
        )

        return assignment

    async def _create_primary_designation(
        self,
        admin_id: UUID,
        hostel_id: UUID,
        designated_by_id: UUID,
        reason: Optional[str] = None
    ) -> PrimaryHostelDesignation:
        """Create primary hostel designation record."""
        # End any current designation
        await self._end_primary_designation(admin_id)

        designation = PrimaryHostelDesignation(
            admin_id=admin_id,
            hostel_id=hostel_id,
            designated_from=date.today(),
            designated_by_id=designated_by_id,
            reason=reason,
            is_current=True
        )

        self.db.add(designation)
        await self.db.flush()
        return designation

    async def _end_primary_designation(
        self,
        admin_id: UUID,
        hostel_id: Optional[UUID] = None
    ) -> None:
        """End current primary designation."""
        stmt = (
            select(PrimaryHostelDesignation)
            .where(PrimaryHostelDesignation.admin_id == admin_id)
            .where(PrimaryHostelDesignation.is_current == True)
        )

        if hostel_id:
            stmt = stmt.where(PrimaryHostelDesignation.hostel_id == hostel_id)

        result = await self.db.execute(stmt)
        current_designations = result.scalars().all()

        for designation in current_designations:
            designation.is_current = False
            designation.designated_until = date.today()

    # ==================== TRANSFER WORKFLOWS ====================

    async def transfer_responsibilities(
        self,
        from_admin_id: UUID,
        to_admin_id: UUID,
        hostel_ids: Optional[List[UUID]] = None,
        transferred_by_id: UUID,
        transfer_notes: Optional[str] = None,
        require_handover: bool = True
    ) -> Dict[str, Any]:
        """
        Transfer hostel responsibilities between admins.
        
        Args:
            from_admin_id: Source admin
            to_admin_id: Target admin
            hostel_ids: Specific hostels (None = all)
            transferred_by_id: Who initiated transfer
            transfer_notes: Transfer notes
            require_handover: Require handover completion
            
        Returns:
            Transfer summary with new and revoked assignments
        """
        # Get source assignments
        source_assignments = await self.get_admin_assignments(from_admin_id)
        
        if hostel_ids:
            source_assignments = [
                a for a in source_assignments if a.hostel_id in hostel_ids
            ]

        if not source_assignments:
            raise ValidationError(
                f"No active assignments found for admin {from_admin_id}"
            )

        # Validate target admin
        to_admin = await self.db.get(AdminUser, to_admin_id)
        if not to_admin or not to_admin.is_active:
            raise ValidationError(f"Target admin {to_admin_id} is not active")

        transferred_hostels = []
        new_assignments = []

        for source_assignment in source_assignments:
            # Revoke source assignment
            await self.revoke_assignment(
                assignment_id=source_assignment.id,
                revoked_by_id=transferred_by_id,
                reason=f"Transferred to admin {to_admin_id}"
            )

            # Create new assignment
            new_assignment = AdminHostelAssignment(
                admin_id=to_admin_id,
                hostel_id=source_assignment.hostel_id,
                assigned_by_id=transferred_by_id,
                assigned_date=date.today(),
                permission_level=source_assignment.permission_level,
                permissions=source_assignment.permissions,
                transferred_from_id=from_admin_id,
                transfer_notes=transfer_notes,
                handover_completed=not require_handover,
                is_active=True
            )

            self.db.add(new_assignment)
            new_assignments.append(new_assignment)
            transferred_hostels.append(source_assignment.hostel_id)

        await self.db.flush()

        # Create history records
        for assignment in new_assignments:
            await self._create_assignment_history(
                assignment_id=assignment.id,
                admin_id=to_admin_id,
                hostel_id=assignment.hostel_id,
                action='transferred_in',
                performed_by_id=transferred_by_id,
                reason=f"Transferred from admin {from_admin_id}"
            )

        return {
            'from_admin_id': from_admin_id,
            'to_admin_id': to_admin_id,
            'transferred_hostels': transferred_hostels,
            'transfer_count': len(new_assignments),
            'new_assignments': new_assignments,
            'handover_required': require_handover
        }

    async def complete_handover(
        self,
        assignment_id: UUID,
        completed_by_id: UUID,
        notes: Optional[str] = None
    ) -> AdminHostelAssignment:
        """Mark handover as completed for transferred assignment."""
        assignment = await self.find_by_id(assignment_id)
        if not assignment:
            raise EntityNotFoundError(f"Assignment {assignment_id} not found")

        if not assignment.transferred_from_id:
            raise ValidationError("Assignment is not a transfer")

        if assignment.handover_completed:
            raise ValidationError("Handover already completed")

        assignment.handover_completed = True
        assignment.handover_completed_at = datetime.utcnow()
        if notes:
            assignment.transfer_notes = (
                f"{assignment.transfer_notes}\n\nHandover notes: {notes}"
                if assignment.transfer_notes else f"Handover notes: {notes}"
            )

        await self.db.flush()

        await self._create_assignment_history(
            assignment_id=assignment_id,
            admin_id=assignment.admin_id,
            hostel_id=assignment.hostel_id,
            action='handover_completed',
            performed_by_id=completed_by_id,
            reason=notes
        )

        return assignment

    # ==================== WORKLOAD MANAGEMENT ====================

    async def balance_workload(
        self,
        target_assignments_per_admin: int = 3,
        max_variance: int = 1
    ) -> Dict[str, Any]:
        """
        Analyze and suggest workload balancing.
        
        Returns recommendations for reassignments to balance load.
        """
        # Get all active admins with assignment counts
        stmt = (
            select(
                AdminUser.id,
                AdminUser.max_hostel_limit,
                func.count(AdminHostelAssignment.id).label('assignment_count')
            )
            .outerjoin(
                AdminHostelAssignment,
                and_(
                    AdminUser.id == AdminHostelAssignment.admin_id,
                    AdminHostelAssignment.is_active == True,
                    AdminHostelAssignment.is_deleted == False
                )
            )
            .where(AdminUser.is_active == True)
            .where(AdminUser.is_deleted == False)
            .group_by(AdminUser.id, AdminUser.max_hostel_limit)
        )

        result = await self.db.execute(stmt)
        admin_workloads = result.all()

        overloaded = []
        underutilized = []
        balanced = []

        for admin_id, max_limit, count in admin_workloads:
            if count > target_assignments_per_admin + max_variance:
                overloaded.append({
                    'admin_id': admin_id,
                    'current_count': count,
                    'excess': count - target_assignments_per_admin
                })
            elif count < target_assignments_per_admin - max_variance:
                underutilized.append({
                    'admin_id': admin_id,
                    'current_count': count,
                    'capacity': target_assignments_per_admin - count,
                    'max_limit': max_limit
                })
            else:
                balanced.append({
                    'admin_id': admin_id,
                    'current_count': count
                })

        # Generate recommendations
        recommendations = []
        for overloaded_admin in overloaded:
            for underutil_admin in underutilized:
                if (not underutil_admin['max_limit'] or 
                    underutil_admin['current_count'] < underutil_admin['max_limit']):
                    
                    transfer_count = min(
                        overloaded_admin['excess'],
                        underutil_admin['capacity']
                    )
                    
                    if transfer_count > 0:
                        recommendations.append({
                            'from_admin_id': overloaded_admin['admin_id'],
                            'to_admin_id': underutil_admin['admin_id'],
                            'suggested_transfer_count': transfer_count
                        })

        return {
            'target_per_admin': target_assignments_per_admin,
            'overloaded_admins': overloaded,
            'underutilized_admins': underutilized,
            'balanced_admins': balanced,
            'recommendations': recommendations,
            'balance_score': len(balanced) / len(admin_workloads) if admin_workloads else 0
        }

    async def find_overloaded_admins(
        self,
        threshold: int = 5
    ) -> List[Dict[str, Any]]:
        """Find admins exceeding workload threshold."""
        stmt = (
            select(
                AdminUser,
                func.count(AdminHostelAssignment.id).label('assignment_count')
            )
            .join(
                AdminHostelAssignment,
                AdminUser.id == AdminHostelAssignment.admin_id
            )
            .where(AdminUser.is_active == True)
            .where(AdminUser.is_deleted == False)
            .where(AdminHostelAssignment.is_active == True)
            .where(AdminHostelAssignment.is_deleted == False)
            .group_by(AdminUser.id)
            .having(func.count(AdminHostelAssignment.id) > threshold)
            .order_by(desc(func.count(AdminHostelAssignment.id)))
        )

        result = await self.db.execute(stmt)
        
        overloaded = []
        for admin, count in result:
            overloaded.append({
                'admin': admin,
                'assignment_count': count,
                'max_limit': admin.max_hostel_limit,
                'overload_amount': count - threshold,
                'utilization_rate': (count / admin.max_hostel_limit * 100) 
                    if admin.max_hostel_limit else None
            })

        return overloaded

    # ==================== COVERAGE ANALYSIS ====================

    async def get_coverage_gaps(self) -> List[Dict[str, Any]]:
        """Identify hostels without adequate admin coverage."""
        stmt = (
            select(
                Hostel.id,
                Hostel.name,
                Hostel.is_active,
                func.count(AdminHostelAssignment.id).label('admin_count')
            )
            .outerjoin(
                AdminHostelAssignment,
                and_(
                    Hostel.id == AdminHostelAssignment.hostel_id,
                    AdminHostelAssignment.is_active == True,
                    AdminHostelAssignment.is_deleted == False
                )
            )
            .where(Hostel.is_deleted == False)
            .group_by(Hostel.id, Hostel.name, Hostel.is_active)
            .having(func.count(AdminHostelAssignment.id) < 1)
        )

        result = await self.db.execute(stmt)
        
        gaps = []
        for hostel_id, name, is_active, admin_count in result:
            gaps.append({
                'hostel_id': hostel_id,
                'hostel_name': name,
                'is_active': is_active,
                'admin_count': admin_count,
                'priority': 'high' if is_active else 'medium'
            })

        return gaps

    async def recommend_assignments(
        self,
        hostel_id: UUID,
        criteria: Optional[Dict[str, Any]] = None
    ) -> List[Dict[str, Any]]:
        """
        Recommend admins for hostel assignment.
        
        Considers:
        - Current workload
        - Admin level and permissions
        - Geographic proximity
        - Performance history
        """
        # Get admins with capacity
        stmt = (
            select(
                AdminUser,
                func.count(AdminHostelAssignment.id).label('current_assignments')
            )
            .outerjoin(
                AdminHostelAssignment,
                and_(
                    AdminUser.id == AdminHostelAssignment.admin_id,
                    AdminHostelAssignment.is_active == True,
                    AdminHostelAssignment.is_deleted == False
                )
            )
            .where(AdminUser.is_active == True)
            .where(AdminUser.is_deleted == False)
            .group_by(AdminUser.id)
        )

        result = await self.db.execute(stmt)
        
        recommendations = []
        for admin, current_count in result:
            # Check if admin has capacity
            has_capacity = (
                not admin.max_hostel_limit or 
                current_count < admin.max_hostel_limit
            )
            
            if has_capacity:
                # Calculate recommendation score
                score = 100 - (current_count * 10)  # Prefer less loaded admins
                score += admin.admin_level * 5  # Higher level = higher score
                
                # Apply criteria filters if provided
                if criteria:
                    if criteria.get('min_level') and admin.admin_level < criteria['min_level']:
                        continue
                    if criteria.get('department') and admin.department != criteria['department']:
                        continue

                recommendations.append({
                    'admin': admin,
                    'current_assignments': current_count,
                    'available_capacity': (
                        admin.max_hostel_limit - current_count
                        if admin.max_hostel_limit else 'unlimited'
                    ),
                    'recommendation_score': score,
                    'reason': self._generate_recommendation_reason(
                        admin, current_count
                    )
                })

        # Sort by score
        recommendations.sort(key=lambda x: x['recommendation_score'], reverse=True)
        
        return recommendations[:10]  # Top 10 recommendations

    def _generate_recommendation_reason(
        self,
        admin: AdminUser,
        current_count: int
    ) -> str:
        """Generate human-readable recommendation reason."""
        reasons = []
        
        if current_count == 0:
            reasons.append("Currently unassigned - available for immediate assignment")
        elif current_count < 3:
            reasons.append(f"Low workload ({current_count} assignments)")
        
        if admin.admin_level >= 7:
            reasons.append("Senior admin with advanced permissions")
        
        if admin.is_super_admin:
            reasons.append("Super admin with full platform access")
        
        return "; ".join(reasons) if reasons else "Available for assignment"

    # ==================== ASSIGNMENT ANALYTICS ====================

    async def track_assignment_history(
        self,
        admin_id: Optional[UUID] = None,
        hostel_id: Optional[UUID] = None,
        limit: int = 50
    ) -> List[AssignmentHistory]:
        """Get assignment history with filters."""
        stmt = (
            select(AssignmentHistory)
            .options(
                selectinload(AssignmentHistory.admin),
                selectinload(AssignmentHistory.hostel)
            )
            .order_by(desc(AssignmentHistory.action_timestamp))
            .limit(limit)
        )

        if admin_id:
            stmt = stmt.where(AssignmentHistory.admin_id == admin_id)
        
        if hostel_id:
            stmt = stmt.where(AssignmentHistory.hostel_id == hostel_id)

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    async def get_assignment_statistics(
        self,
        admin_id: Optional[UUID] = None,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None
    ) -> Dict[str, Any]:
        """Get comprehensive assignment statistics."""
        if not start_date:
            start_date = date.today() - timedelta(days=30)
        if not end_date:
            end_date = date.today()

        base_filter = and_(
            AdminHostelAssignment.is_deleted == False,
            AdminHostelAssignment.assigned_date >= start_date,
            AdminHostelAssignment.assigned_date <= end_date
        )

        if admin_id:
            base_filter = and_(base_filter, AdminHostelAssignment.admin_id == admin_id)

        # Total assignments
        total_stmt = select(func.count(AdminHostelAssignment.id)).where(base_filter)
        total = await self.db.scalar(total_stmt)

        # Active assignments
        active_stmt = select(func.count(AdminHostelAssignment.id)).where(
            and_(base_filter, AdminHostelAssignment.is_active == True)
        )
        active = await self.db.scalar(active_stmt)

        # Average duration
        avg_duration_stmt = select(
            func.avg(AdminHostelAssignment.assignment_duration_days)
        ).where(base_filter)
        avg_duration = await self.db.scalar(avg_duration_stmt)

        return {
            'period': {'start': start_date, 'end': end_date},
            'total_assignments': total,
            'active_assignments': active,
            'revoked_assignments': total - active,
            'avg_assignment_duration_days': float(avg_duration) if avg_duration else 0,
            'admin_id': admin_id
        }

    async def update_activity_metrics(
        self,
        assignment_id: UUID,
        actions_performed: int = 1,
        decisions_made: int = 0,
        session_duration_minutes: int = 0
    ) -> AdminHostelAssignment:
        """Update assignment activity metrics."""
        assignment = await self.find_by_id(assignment_id)
        if not assignment:
            raise EntityNotFoundError(f"Assignment {assignment_id} not found")

        assignment.last_accessed = datetime.utcnow()
        assignment.access_count += 1
        assignment.actions_performed += actions_performed
        assignment.decisions_made += decisions_made
        assignment.total_session_time_minutes += session_duration_minutes

        await self.db.flush()
        return assignment

    # ==================== HELPER METHODS ====================

    async def _get_active_assignment_count(self, admin_id: UUID) -> int:
        """Get count of active assignments for admin."""
        stmt = select(func.count(AdminHostelAssignment.id)).where(
            and_(
                AdminHostelAssignment.admin_id == admin_id,
                AdminHostelAssignment.is_active == True,
                AdminHostelAssignment.is_deleted == False
            )
        )
        return await self.db.scalar(stmt) or 0

    async def _check_assignment_conflicts(
        self,
        admin_id: UUID,
        hostel_ids: List[UUID]
    ) -> List[UUID]:
        """Check for existing active assignments."""
        stmt = (
            select(AdminHostelAssignment.hostel_id)
            .where(AdminHostelAssignment.admin_id == admin_id)
            .where(AdminHostelAssignment.hostel_id.in_(hostel_ids))
            .where(AdminHostelAssignment.is_active == True)
            .where(AdminHostelAssignment.is_deleted == False)
        )

        result = await self.db.execute(stmt)
        return result.scalars().all()

    async def _validate_hostels_exist(self, hostel_ids: List[UUID]) -> None:
        """Validate all hostels exist."""
        stmt = select(func.count(Hostel.id)).where(
            and_(
                Hostel.id.in_(hostel_ids),
                Hostel.is_deleted == False
            )
        )
        count = await self.db.scalar(stmt)
        
        if count != len(hostel_ids):
            raise ValidationError("One or more hostels not found")

    async def _create_assignment_history(
        self,
        assignment_id: UUID,
        admin_id: UUID,
        hostel_id: UUID,
        action: str,
        performed_by_id: UUID,
        old_values: Optional[Dict] = None,
        new_values: Optional[Dict] = None,
        reason: Optional[str] = None
    ) -> AssignmentHistory:
        """Create assignment history record."""
        # Determine changed fields
        changed_fields = []
        if old_values and new_values:
            changed_fields = [
                key for key in new_values.keys()
                if old_values.get(key) != new_values.get(key)
            ]

        history = AssignmentHistory(
            assignment_id=assignment_id,
            admin_id=admin_id,
            hostel_id=hostel_id,
            action=action,
            action_timestamp=datetime.utcnow(),
            performed_by_id=performed_by_id,
            old_values=old_values,
            new_values=new_values,
            changed_fields=changed_fields,
            reason=reason
        )

        self.db.add(history)
        await self.db.flush()
        return history

    def _assignment_to_dict(self, assignment: AdminHostelAssignment) -> Dict[str, Any]:
        """Convert assignment to dictionary for audit."""
        return {
            'is_active': assignment.is_active,
            'is_primary': assignment.is_primary,
            'permission_level': assignment.permission_level,
            'permissions': assignment.permissions,
            'effective_from': assignment.effective_from.isoformat() if assignment.effective_from else None,
            'effective_until': assignment.effective_until.isoformat() if assignment.effective_until else None,
        }

# --- File: C:\Hostel-Main\app\repositories\admin\admin_override_repository.py ---
"""
Admin Override Repository

Manages admin overrides of supervisor decisions with impact tracking,
approval workflows, and compliance monitoring.
"""

from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import datetime, timedelta
from decimal import Decimal
from sqlalchemy import select, and_, or_, func, desc, case
from sqlalchemy.orm import Session, selectinload, joinedload
from sqlalchemy.exc import IntegrityError

from app.models.admin.admin_override import (
    AdminOverride,
    OverrideReason,
    OverrideApproval,
    OverrideImpact
)
from app.models.admin.admin_user import AdminUser
from app.models.supervisor.supervisor import Supervisor
from app.repositories.base.base_repository import BaseRepository
from app.core.exceptions import (
    EntityNotFoundError,
    ValidationError,
    AuthorizationError
)


class AdminOverrideRepository(BaseRepository[AdminOverride]):
    """
    Override decision tracking with:
    - Impact analysis and tracking
    - Multi-level approval workflows
    - Pattern analysis for policy improvement
    - Compliance and audit reporting
    """

    def __init__(self, db: Session):
        super().__init__(AdminOverride, db)

    # ==================== OVERRIDE CREATION ====================

    async def create_override(
        self,
        admin_id: UUID,
        supervisor_id: Optional[UUID],
        hostel_id: UUID,
        override_type: str,
        entity_type: str,
        entity_id: UUID,
        reason: str,
        original_action: Optional[Dict] = None,
        override_action: Dict = None,
        severity: str = 'medium',
        requires_approval: bool = False
    ) -> AdminOverride:
        """
        Create admin override record.
        
        Args:
            admin_id: Admin performing override
            supervisor_id: Supervisor whose action is overridden
            hostel_id: Hostel context
            override_type: Type of override
            entity_type: Entity being modified
            entity_id: Entity ID
            reason: Detailed reason
            original_action: Original supervisor action
            override_action: Admin's override action
            severity: Override severity
            requires_approval: Needs higher approval
            
        Returns:
            Created AdminOverride instance
        """
        # Calculate action diff if both provided
        action_diff = None
        if original_action and override_action:
            action_diff = self._calculate_action_diff(original_action, override_action)

        override = AdminOverride(
            admin_id=admin_id,
            supervisor_id=supervisor_id,
            hostel_id=hostel_id,
            override_type=override_type,
            entity_type=entity_type,
            entity_id=entity_id,
            override_timestamp=datetime.utcnow(),
            reason=reason,
            original_action=original_action,
            override_action=override_action,
            action_diff=action_diff,
            severity=severity,
            requires_approval=requires_approval,
            approval_status='pending' if requires_approval else 'approved'
        )

        self.db.add(override)

        try:
            await self.db.flush()

            # Create impact assessment
            if severity in ('high', 'critical'):
                await self._create_impact_assessment(override.id)

            # Notify supervisor if specified
            if supervisor_id and not override.supervisor_notified:
                await self._notify_supervisor(override)

            return override

        except IntegrityError as e:
            await self.db.rollback()
            raise ValidationError(f"Failed to create override: {str(e)}")

    def _calculate_action_diff(
        self,
        original: Dict,
        override: Dict
    ) -> Dict[str, Any]:
        """Calculate differences between actions."""
        diff = {
            'changed_fields': [],
            'original_values': {},
            'new_values': {}
        }

        all_keys = set(original.keys()) | set(override.keys())
        
        for key in all_keys:
            orig_val = original.get(key)
            new_val = override.get(key)
            
            if orig_val != new_val:
                diff['changed_fields'].append(key)
                diff['original_values'][key] = orig_val
                diff['new_values'][key] = new_val

        return diff

    # ==================== OVERRIDE QUERIES ====================

    async def find_by_entity(
        self,
        entity_type: str,
        entity_id: UUID
    ) -> List[AdminOverride]:
        """Find all overrides for specific entity."""
        stmt = (
            select(AdminOverride)
            .where(AdminOverride.entity_type == entity_type)
            .where(AdminOverride.entity_id == entity_id)
            .options(
                selectinload(AdminOverride.admin),
                selectinload(AdminOverride.supervisor)
            )
            .order_by(desc(AdminOverride.override_timestamp))
        )

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    async def find_by_admin(
        self,
        admin_id: UUID,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> List[AdminOverride]:
        """Find overrides by specific admin."""
        stmt = (
            select(AdminOverride)
            .where(AdminOverride.admin_id == admin_id)
            .options(selectinload(AdminOverride.override_impact))
        )

        if start_date:
            stmt = stmt.where(AdminOverride.override_timestamp >= start_date)
        if end_date:
            stmt = stmt.where(AdminOverride.override_timestamp <= end_date)

        stmt = stmt.order_by(desc(AdminOverride.override_timestamp))

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    async def find_by_supervisor(
        self,
        supervisor_id: UUID,
        start_date: Optional[datetime] = None
    ) -> List[AdminOverride]:
        """Find overrides of specific supervisor's actions."""
        stmt = (
            select(AdminOverride)
            .where(AdminOverride.supervisor_id == supervisor_id)
            .options(selectinload(AdminOverride.admin))
        )

        if start_date:
            stmt = stmt.where(AdminOverride.override_timestamp >= start_date)

        stmt = stmt.order_by(desc(AdminOverride.override_timestamp))

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    async def find_pending_approval(
        self,
        hostel_id: Optional[UUID] = None
    ) -> List[AdminOverride]:
        """Find overrides pending approval."""
        stmt = (
            select(AdminOverride)
            .where(AdminOverride.requires_approval == True)
            .where(AdminOverride.approval_status == 'pending')
            .options(
                selectinload(AdminOverride.admin),
                selectinload(AdminOverride.supervisor)
            )
        )

        if hostel_id:
            stmt = stmt.where(AdminOverride.hostel_id == hostel_id)

        stmt = stmt.order_by(
            desc(AdminOverride.severity),
            AdminOverride.override_timestamp
        )

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    async def find_high_impact_overrides(
        self,
        days: int = 30,
        min_impact_score: float = 70.0
    ) -> List[AdminOverride]:
        """Find high-impact overrides in period."""
        cutoff = datetime.utcnow() - timedelta(days=days)

        stmt = (
            select(AdminOverride)
            .join(AdminOverride.override_impact)
            .where(AdminOverride.override_timestamp >= cutoff)
            .where(OverrideImpact.overall_impact_score >= min_impact_score)
            .options(
                selectinload(AdminOverride.override_impact),
                selectinload(AdminOverride.admin)
            )
            .order_by(desc(OverrideImpact.overall_impact_score))
        )

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    # ==================== APPROVAL WORKFLOW ====================

    async def create_approval_request(
        self,
        override_id: UUID,
        approver_id: UUID,
        escalation_level: int = 1,
        expires_in_hours: int = 48
    ) -> OverrideApproval:
        """Create approval request for override."""
        override = await self.find_by_id(override_id)
        if not override:
            raise EntityNotFoundError(f"Override {override_id} not found")

        approval = OverrideApproval(
            override_id=override_id,
            approver_id=approver_id,
            approval_status='pending',
            escalation_level=escalation_level,
            expires_at=datetime.utcnow() + timedelta(hours=expires_in_hours)
        )

        self.db.add(approval)
        await self.db.flush()
        return approval

    async def approve_override(
        self,
        override_id: UUID,
        approver_id: UUID,
        decision_notes: Optional[str] = None,
        conditions: Optional[List[str]] = None
    ) -> AdminOverride:
        """Approve override request."""
        override = await self.find_by_id(override_id)
        if not override:
            raise EntityNotFoundError(f"Override {override_id} not found")

        if not override.requires_approval:
            raise ValidationError("Override does not require approval")

        # Find pending approval
        approval_stmt = (
            select(OverrideApproval)
            .where(OverrideApproval.override_id == override_id)
            .where(OverrideApproval.approver_id == approver_id)
            .where(OverrideApproval.approval_status == 'pending')
        )
        result = await self.db.execute(approval_stmt)
        approval = result.scalar_one_or_none()

        if not approval:
            raise EntityNotFoundError("No pending approval found")

        # Update approval
        approval.approval_status = 'approved'
        approval.decision_timestamp = datetime.utcnow()
        approval.decision_notes = decision_notes
        approval.conditions = conditions or []
        approval.conditions_met = len(conditions or []) == 0

        # Update override
        override.approval_status = 'approved'
        override.approved_by_id = approver_id
        override.approved_at = datetime.utcnow()
        override.approval_notes = decision_notes

        await self.db.flush()
        return override

    async def reject_override(
        self,
        override_id: UUID,
        approver_id: UUID,
        rejection_notes: str
    ) -> AdminOverride:
        """Reject override request."""
        override = await self.find_by_id(override_id)
        if not override:
            raise EntityNotFoundError(f"Override {override_id} not found")

        # Find and update approval
        approval_stmt = (
            select(OverrideApproval)
            .where(OverrideApproval.override_id == override_id)
            .where(OverrideApproval.approver_id == approver_id)
            .where(OverrideApproval.approval_status == 'pending')
        )
        result = await self.db.execute(approval_stmt)
        approval = result.scalar_one_or_none()

        if approval:
            approval.approval_status = 'rejected'
            approval.decision_timestamp = datetime.utcnow()
            approval.decision_notes = rejection_notes

        # Update override
        override.approval_status = 'rejected'
        override.approval_notes = rejection_notes

        # Auto-reverse the override
        await self.reverse_override(override_id, approver_id, "Approval rejected")

        await self.db.flush()
        return override

    # ==================== OVERRIDE REVERSAL ====================

    async def reverse_override(
        self,
        override_id: UUID,
        reversed_by_id: UUID,
        reversal_reason: str
    ) -> AdminOverride:
        """Reverse an override decision."""
        override = await self.find_by_id(override_id)
        if not override:
            raise EntityNotFoundError(f"Override {override_id} not found")

        if override.is_reversed:
            raise ValidationError("Override already reversed")

        override.is_reversed = True
        override.reversed_at = datetime.utcnow()
        override.reversed_by_id = reversed_by_id
        override.reversal_reason = reversal_reason

        await self.db.flush()
        return override

    # ==================== IMPACT ASSESSMENT ====================

    async def _create_impact_assessment(
        self,
        override_id: UUID
    ) -> OverrideImpact:
        """Create initial impact assessment."""
        impact = OverrideImpact(
            override_id=override_id,
            operational_impact_score=Decimal('0.00'),
            financial_impact_score=Decimal('0.00'),
            stakeholder_impact_score=Decimal('0.00'),
            reputation_impact_score=Decimal('0.00'),
            overall_impact_score=Decimal('0.00')
        )

        self.db.add(impact)
        await self.db.flush()
        return impact

    async def update_impact_assessment(
        self,
        override_id: UUID,
        impact_data: Dict[str, Any],
        assessed_by_id: Optional[UUID] = None
    ) -> OverrideImpact:
        """Update impact assessment with detailed data."""
        # Get or create impact
        stmt = select(OverrideImpact).where(
            OverrideImpact.override_id == override_id
        )
        result = await self.db.execute(stmt)
        impact = result.scalar_one_or_none()

        if not impact:
            impact = await self._create_impact_assessment(override_id)

        # Update impact scores
        if 'operational_impact_score' in impact_data:
            impact.operational_impact_score = Decimal(str(impact_data['operational_impact_score']))
        if 'financial_impact_score' in impact_data:
            impact.financial_impact_score = Decimal(str(impact_data['financial_impact_score']))
        if 'stakeholder_impact_score' in impact_data:
            impact.stakeholder_impact_score = Decimal(str(impact_data['stakeholder_impact_score']))
        if 'reputation_impact_score' in impact_data:
            impact.reputation_impact_score = Decimal(str(impact_data['reputation_impact_score']))

        # Calculate overall impact
        impact.overall_impact_score = (
            impact.operational_impact_score +
            impact.financial_impact_score +
            impact.stakeholder_impact_score +
            impact.reputation_impact_score
        ) / 4

        # Update financial details
        if 'estimated_cost' in impact_data:
            impact.estimated_cost = Decimal(str(impact_data['estimated_cost']))
        if 'actual_cost' in impact_data:
            impact.actual_cost = Decimal(str(impact_data['actual_cost']))
        if 'cost_savings' in impact_data:
            impact.cost_savings = Decimal(str(impact_data['cost_savings']))
        if 'revenue_impact' in impact_data:
            impact.revenue_impact = Decimal(str(impact_data['revenue_impact']))

        # Update stakeholder impact
        if 'students_affected' in impact_data:
            impact.students_affected = impact_data['students_affected']
        if 'staff_affected' in impact_data:
            impact.staff_affected = impact_data['staff_affected']
        if 'affected_parties_details' in impact_data:
            impact.affected_parties_details = impact_data['affected_parties_details']

        # Update outcome
        if 'outcome_status' in impact_data:
            impact.outcome_status = impact_data['outcome_status']
        if 'outcome_description' in impact_data:
            impact.outcome_description = impact_data['outcome_description']

        impact.assessed_by_id = assessed_by_id
        impact.assessed_at = datetime.utcnow()

        await self.db.flush()
        return impact

    # ==================== PATTERN ANALYSIS ====================

    async def find_pattern_overrides(
        self,
        pattern_type: str = 'type',
        days: int = 90,
        min_occurrences: int = 3
    ) -> List[Dict[str, Any]]:
        """
        Analyze override patterns for policy improvement.
        
        Args:
            pattern_type: 'type', 'reason', or 'entity'
            days: Analysis period
            min_occurrences: Minimum pattern occurrences
        """
        cutoff = datetime.utcnow() - timedelta(days=days)

        if pattern_type == 'type':
            group_field = AdminOverride.override_type
        elif pattern_type == 'entity':
            group_field = AdminOverride.entity_type
        else:
            # For reason, we'd need to analyze reason_category
            # Simplified here
            group_field = AdminOverride.override_type

        stmt = (
            select(
                group_field.label('pattern'),
                func.count(AdminOverride.id).label('occurrence_count'),
                func.avg(
                    case(
                        (OverrideImpact.overall_impact_score.isnot(None),
                         OverrideImpact.overall_impact_score),
                        else_=0
                    )
                ).label('avg_impact')
            )
            .outerjoin(AdminOverride.override_impact)
            .where(AdminOverride.override_timestamp >= cutoff)
            .group_by(group_field)
            .having(func.count(AdminOverride.id) >= min_occurrences)
            .order_by(desc('occurrence_count'))
        )

        result = await self.db.execute(stmt)
        
        patterns = []
        for row in result:
            patterns.append({
                'pattern': row.pattern,
                'occurrence_count': row.occurrence_count,
                'avg_impact_score': float(row.avg_impact or 0),
                'recommendation': self._generate_pattern_recommendation(
                    row.pattern,
                    row.occurrence_count,
                    row.avg_impact
                )
            })

        return patterns

    def _generate_pattern_recommendation(
        self,
        pattern: str,
        count: int,
        avg_impact: Optional[Decimal]
    ) -> str:
        """Generate recommendation based on pattern analysis."""
        if count >= 10:
            return f"High frequency pattern '{pattern}' ({count} occurrences). Consider policy review."
        elif avg_impact and float(avg_impact) > 70:
            return f"High impact pattern '{pattern}'. Review approval requirements."
        else:
            return f"Monitor pattern '{pattern}' for trends."

    # ==================== ANALYTICS & REPORTING ====================

    async def get_override_statistics(
        self,
        admin_id: Optional[UUID] = None,
        hostel_id: Optional[UUID] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """Get comprehensive override statistics."""
        if not start_date:
            start_date = datetime.utcnow() - timedelta(days=30)
        if not end_date:
            end_date = datetime.utcnow()

        # Base filter
        filters = [
            AdminOverride.override_timestamp >= start_date,
            AdminOverride.override_timestamp <= end_date
        ]
        if admin_id:
            filters.append(AdminOverride.admin_id == admin_id)
        if hostel_id:
            filters.append(AdminOverride.hostel_id == hostel_id)

        # Total overrides
        total_stmt = select(func.count(AdminOverride.id)).where(and_(*filters))
        total_overrides = await self.db.scalar(total_stmt) or 0

        # By severity
        severity_stmt = (
            select(
                AdminOverride.severity,
                func.count(AdminOverride.id).label('count')
            )
            .where(and_(*filters))
            .group_by(AdminOverride.severity)
        )
        severity_result = await self.db.execute(severity_stmt)
        by_severity = {row.severity: row.count for row in severity_result}

        # Approval stats
        approval_stmt = (
            select(
                AdminOverride.approval_status,
                func.count(AdminOverride.id).label('count')
            )
            .where(and_(*filters))
            .where(AdminOverride.requires_approval == True)
            .group_by(AdminOverride.approval_status)
        )
        approval_result = await self.db.execute(approval_stmt)
        by_approval_status = {row.approval_status: row.count for row in approval_result}

        # Average impact
        avg_impact_stmt = (
            select(func.avg(OverrideImpact.overall_impact_score))
            .join(AdminOverride.override_impact)
            .where(and_(*filters))
        )
        avg_impact = await self.db.scalar(avg_impact_stmt) or 0

        # Reversal rate
        reversed_stmt = select(func.count(AdminOverride.id)).where(
            and_(
                *filters,
                AdminOverride.is_reversed == True
            )
        )
        reversed_count = await self.db.scalar(reversed_stmt) or 0
        reversal_rate = (reversed_count / total_overrides * 100) if total_overrides > 0 else 0

        return {
            'period': {
                'start': start_date,
                'end': end_date
            },
            'total_overrides': total_overrides,
            'by_severity': by_severity,
            'by_approval_status': by_approval_status,
            'avg_impact_score': float(avg_impact),
            'reversed_count': reversed_count,
            'reversal_rate_percentage': round(reversal_rate, 2),
            'approval_required_count': sum(by_approval_status.values())
        }

    # ==================== HELPER METHODS ====================

    async def _notify_supervisor(self, override: AdminOverride) -> None:
        """Notify supervisor of override (placeholder)."""
        # Implementation would send actual notification
        override.supervisor_notified = True
        override.supervisor_notified_at = datetime.utcnow()
        override.notification_method = 'email'
        # Actual notification sending would go here

# --- File: C:\Hostel-Main\app\repositories\admin\admin_permissions_repository.py ---
"""
Admin Permissions Repository

Manages granular permission control with role-based access,
inheritance, validation, and optimization.
"""

from typing import List, Optional, Dict, Any, Set
from uuid import UUID
from datetime import datetime, date
from sqlalchemy import select, and_, or_, func, desc
from sqlalchemy.orm import Session, selectinload
from sqlalchemy.exc import IntegrityError

from app.models.admin.admin_permissions import (
    AdminPermission,
    PermissionGroup,
    RolePermission,
    PermissionAudit,
    PermissionTemplate
)
from app.models.admin.admin_user import AdminUser, AdminRole
from app.repositories.base.base_repository import BaseRepository
from app.core.exceptions import (
    EntityNotFoundError,
    ValidationError,
    DuplicateError,
    ConflictError
)


class AdminPermissionsRepository(BaseRepository[AdminPermission]):
    """
    Comprehensive permission management with:
    - Granular permission control per hostel
    - Role-based inheritance
    - Permission conflict detection and resolution
    - Usage tracking and optimization
    - Template-based permission assignment
    """

    def __init__(self, db: Session):
        super().__init__(AdminPermission, db)

    # ==================== PERMISSION CRUD ====================

    async def create_permission_set(
        self,
        admin_id: UUID,
        hostel_id: Optional[UUID],
        permissions: Dict[str, Any],
        granted_by_id: Optional[UUID] = None,
        notes: Optional[str] = None
    ) -> AdminPermission:
        """
        Create permission set for admin.
        
        Args:
            admin_id: Admin user ID
            hostel_id: Hostel ID (None for global permissions)
            permissions: Permission configuration
            granted_by_id: Who granted these permissions
            notes: Additional notes
            
        Returns:
            Created AdminPermission instance
        """
        # Check for existing permission set
        existing = await self.find_by_admin_and_hostel(admin_id, hostel_id)
        if existing:
            raise DuplicateError(
                f"Permission set already exists for admin {admin_id} "
                f"and hostel {hostel_id or 'global'}"
            )

        # Validate permission keys
        valid_permissions = self._validate_permission_keys(permissions)

        permission_set = AdminPermission(
            admin_id=admin_id,
            hostel_id=hostel_id,
            permission_level=permissions.get('permission_level', 'FULL_ACCESS'),
            granted_by_id=granted_by_id,
            granted_at=datetime.utcnow(),
            notes=notes,
            **valid_permissions
        )

        self.db.add(permission_set)

        try:
            await self.db.flush()

            # Create audit record
            await self._create_audit_record(
                permission_id=permission_set.id,
                admin_id=admin_id,
                action='created',
                new_values=valid_permissions,
                changed_by_id=granted_by_id
            )

            return permission_set

        except IntegrityError as e:
            await self.db.rollback()
            raise ValidationError(f"Failed to create permissions: {str(e)}")

    async def find_by_admin_and_hostel(
        self,
        admin_id: UUID,
        hostel_id: Optional[UUID]
    ) -> Optional[AdminPermission]:
        """Find permission set for admin and specific hostel."""
        stmt = (
            select(AdminPermission)
            .where(AdminPermission.admin_id == admin_id)
            .where(AdminPermission.is_deleted == False)
        )

        if hostel_id:
            stmt = stmt.where(AdminPermission.hostel_id == hostel_id)
        else:
            stmt = stmt.where(AdminPermission.hostel_id.is_(None))

        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()

    async def get_all_permissions_for_admin(
        self,
        admin_id: UUID
    ) -> List[AdminPermission]:
        """Get all permission sets for admin (global + hostel-specific)."""
        stmt = (
            select(AdminPermission)
            .where(AdminPermission.admin_id == admin_id)
            .where(AdminPermission.is_deleted == False)
            .order_by(AdminPermission.hostel_id.nullsfirst())
        )

        result = await self.db.execute(stmt)
        return result.scalars().all()

    # ==================== EFFECTIVE PERMISSIONS ====================

    async def get_effective_permissions(
        self,
        admin_id: UUID,
        hostel_id: Optional[UUID] = None
    ) -> Dict[str, bool]:
        """
        Calculate effective permissions with proper inheritance.
        
        Priority:
        1. Hostel-specific permissions (if hostel_id provided)
        2. Global admin permissions
        3. Role-based permissions
        4. Default permissions
        """
        # Get admin
        admin = await self.db.get(AdminUser, admin_id)
        if not admin:
            raise EntityNotFoundError(f"Admin {admin_id} not found")

        # Initialize with default permissions
        effective = self._get_default_permissions()

        # Super admin gets all permissions
        if admin.is_super_admin:
            return self._get_super_admin_permissions()

        # Apply global permissions
        global_perms = await self.find_by_admin_and_hostel(admin_id, None)
        if global_perms:
            effective.update(self._extract_permission_dict(global_perms))

        # Apply hostel-specific permissions
        if hostel_id:
            hostel_perms = await self.find_by_admin_and_hostel(admin_id, hostel_id)
            if hostel_perms:
                effective.update(self._extract_permission_dict(hostel_perms))

        # Apply admin-level overrides
        if admin.permissions_override:
            effective.update(admin.permissions_override)

        return effective

    def _extract_permission_dict(self, permission: AdminPermission) -> Dict[str, bool]:
        """Extract all permission flags from AdminPermission object."""
        return {
            'can_manage_rooms': permission.can_manage_rooms,
            'can_manage_beds': permission.can_manage_beds,
            'can_manage_students': permission.can_manage_students,
            'can_check_in_students': permission.can_check_in_students,
            'can_check_out_students': permission.can_check_out_students,
            'can_approve_bookings': permission.can_approve_bookings,
            'can_manage_waitlist': permission.can_manage_waitlist,
            'can_manage_fees': permission.can_manage_fees,
            'can_process_payments': permission.can_process_payments,
            'can_issue_refunds': permission.can_issue_refunds,
            'can_manage_supervisors': permission.can_manage_supervisors,
            'can_configure_supervisor_permissions': permission.can_configure_supervisor_permissions,
            'can_override_supervisor_actions': permission.can_override_supervisor_actions,
            'can_view_financials': permission.can_view_financials,
            'can_export_financial_data': permission.can_export_financial_data,
            'can_manage_hostel_settings': permission.can_manage_hostel_settings,
            'can_manage_hostel_profile': permission.can_manage_hostel_profile,
            'can_toggle_public_visibility': permission.can_toggle_public_visibility,
            'can_delete_records': permission.can_delete_records,
            'can_export_data': permission.can_export_data,
            'can_import_data': permission.can_import_data,
            'can_view_analytics': permission.can_view_analytics,
            'can_manage_announcements': permission.can_manage_announcements,
            'can_manage_maintenance': permission.can_manage_maintenance,
            'can_approve_maintenance_costs': permission.can_approve_maintenance_costs,
            'can_manage_complaints': permission.can_manage_complaints,
            'can_escalate_complaints': permission.can_escalate_complaints,
            'can_manage_mess_menu': permission.can_manage_mess_menu,
            'can_manage_dietary_options': permission.can_manage_dietary_options,
            'can_manage_attendance': permission.can_manage_attendance,
            'can_configure_attendance_policies': permission.can_configure_attendance_policies,
            'can_approve_leaves': permission.can_approve_leaves,
            'can_manage_leave_policies': permission.can_manage_leave_policies,
        }

    def _get_default_permissions(self) -> Dict[str, bool]:
        """Get default permission set (all False)."""
        return {
            'can_manage_rooms': False,
            'can_manage_beds': False,
            'can_manage_students': False,
            'can_check_in_students': False,
            'can_check_out_students': False,
            'can_approve_bookings': False,
            'can_manage_waitlist': False,
            'can_manage_fees': False,
            'can_process_payments': False,
            'can_issue_refunds': False,
            'can_manage_supervisors': False,
            'can_configure_supervisor_permissions': False,
            'can_override_supervisor_actions': False,
            'can_view_financials': False,
            'can_export_financial_data': False,
            'can_manage_hostel_settings': False,
            'can_manage_hostel_profile': False,
            'can_toggle_public_visibility': False,
            'can_delete_records': False,
            'can_export_data': False,
            'can_import_data': False,
            'can_view_analytics': False,
            'can_manage_announcements': False,
            'can_manage_maintenance': False,
            'can_approve_maintenance_costs': False,
            'can_manage_complaints': False,
            'can_escalate_complaints': False,
            'can_manage_mess_menu': False,
            'can_manage_dietary_options': False,
            'can_manage_attendance': False,
            'can_configure_attendance_policies': False,
            'can_approve_leaves': False,
            'can_manage_leave_policies': False,
        }

    def _get_super_admin_permissions(self) -> Dict[str, bool]:
        """Get super admin permission set (all True)."""
        return {key: True for key in self._get_default_permissions().keys()}

    # ==================== PERMISSION VALIDATION ====================

    async def validate_permission_set(
        self,
        permissions: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Validate permission configuration.
        
        Returns:
            Dict with validation results and warnings
        """
        validation_result = {
            'is_valid': True,
            'errors': [],
            'warnings': [],
            'validated_permissions': {}
        }

        # Check for unknown permission keys
        valid_keys = set(self._get_default_permissions().keys())
        provided_keys = set(permissions.keys())
        unknown_keys = provided_keys - valid_keys

        if unknown_keys:
            validation_result['warnings'].append(
                f"Unknown permission keys: {', '.join(unknown_keys)}"
            )

        # Validate permission values
        for key, value in permissions.items():
            if key in valid_keys:
                if not isinstance(value, bool):
                    validation_result['errors'].append(
                        f"Permission '{key}' must be boolean, got {type(value)}"
                    )
                    validation_result['is_valid'] = False
                else:
                    validation_result['validated_permissions'][key] = value

        # Check for conflicting permissions
        conflicts = self._check_permission_conflicts(
            validation_result['validated_permissions']
        )
        if conflicts:
            validation_result['warnings'].extend(conflicts)

        return validation_result

    def _check_permission_conflicts(self, permissions: Dict[str, bool]) -> List[str]:
        """Check for conflicting permission combinations."""
        conflicts = []

        # Example: Can't manage fees without viewing financials
        if permissions.get('can_manage_fees') and not permissions.get('can_view_financials'):
            conflicts.append(
                "Permission conflict: 'can_manage_fees' requires 'can_view_financials'"
            )

        # Can't issue refunds without processing payments
        if permissions.get('can_issue_refunds') and not permissions.get('can_process_payments'):
            conflicts.append(
                "Permission conflict: 'can_issue_refunds' requires 'can_process_payments'"
            )

        # Can't configure supervisor permissions without managing supervisors
        if (permissions.get('can_configure_supervisor_permissions') and 
            not permissions.get('can_manage_supervisors')):
            conflicts.append(
                "Permission conflict: 'can_configure_supervisor_permissions' "
                "requires 'can_manage_supervisors'"
            )

        return conflicts

    def _validate_permission_keys(self, permissions: Dict[str, Any]) -> Dict[str, bool]:
        """Validate and extract only valid permission keys."""
        valid_keys = set(self._get_default_permissions().keys())
        return {
            k: bool(v) for k, v in permissions.items()
            if k in valid_keys and isinstance(v, bool)
        }

    async def find_permission_conflicts(self, admin_id: UUID) -> List[Dict[str, Any]]:
        """Find all permission conflicts for an admin across hostels."""
        all_perms = await self.get_all_permissions_for_admin(admin_id)
        conflicts = []

        for perm_set in all_perms:
            perm_dict = self._extract_permission_dict(perm_set)
            conflict_list = self._check_permission_conflicts(perm_dict)

            if conflict_list:
                conflicts.append({
                    'permission_id': perm_set.id,
                    'hostel_id': perm_set.hostel_id,
                    'conflicts': conflict_list
                })

        return conflicts

    # ==================== PERMISSION TEMPLATES ====================

    async def create_template(
        self,
        name: str,
        display_name: str,
        category: str,
        permissions: Dict[str, bool],
        description: Optional[str] = None,
        created_by_id: Optional[UUID] = None
    ) -> PermissionTemplate:
        """Create reusable permission template."""
        # Validate permissions
        validation = await self.validate_permission_set(permissions)
        if not validation['is_valid']:
            raise ValidationError(f"Invalid permissions: {validation['errors']}")

        template = PermissionTemplate(
            name=name,
            display_name=display_name,
            description=description,
            category=category,
            permissions=validation['validated_permissions'],
            created_by_id=created_by_id,
            is_active=True
        )

        self.db.add(template)
        await self.db.flush()
        return template

    async def apply_template(
        self,
        template_id: UUID,
        admin_id: UUID,
        hostel_id: Optional[UUID] = None,
        applied_by_id: Optional[UUID] = None
    ) -> AdminPermission:
        """Apply permission template to admin."""
        template = await self.db.get(PermissionTemplate, template_id)
        if not template or not template.is_active:
            raise EntityNotFoundError(f"Template {template_id} not found or inactive")

        # Create permission set from template
        permission_set = await self.create_permission_set(
            admin_id=admin_id,
            hostel_id=hostel_id,
            permissions=template.permissions,
            granted_by_id=applied_by_id,
            notes=f"Applied from template: {template.name}"
        )

        # Update template usage stats
        template.usage_count += 1
        template.last_used_at = datetime.utcnow()

        await self.db.flush()
        return permission_set

    async def get_templates_by_category(self, category: str) -> List[PermissionTemplate]:
        """Get all active templates in category."""
        stmt = (
            select(PermissionTemplate)
            .where(PermissionTemplate.category == category)
            .where(PermissionTemplate.is_active == True)
            .where(PermissionTemplate.is_deleted == False)
            .order_by(PermissionTemplate.display_order, PermissionTemplate.name)
        )

        result = await self.db.execute(stmt)
        return result.scalars().all()

    # ==================== PERMISSION AUDITING ====================

    async def _create_audit_record(
        self,
        permission_id: UUID,
        admin_id: UUID,
        action: str,
        old_values: Optional[Dict] = None,
        new_values: Optional[Dict] = None,
        changed_by_id: Optional[UUID] = None,
        reason: Optional[str] = None
    ) -> PermissionAudit:
        """Create permission change audit record."""
        # Determine changed fields
        changed_fields = []
        if old_values and new_values:
            changed_fields = [
                key for key in new_values.keys()
                if old_values.get(key) != new_values.get(key)
            ]

        audit = PermissionAudit(
            permission_id=permission_id,
            admin_id=admin_id,
            action=action,
            changed_at=datetime.utcnow(),
            changed_by_id=changed_by_id,
            old_values=old_values,
            new_values=new_values,
            changed_fields=changed_fields,
            reason=reason
        )

        self.db.add(audit)
        await self.db.flush()
        return audit

    async def get_permission_history(
        self,
        admin_id: UUID,
        hostel_id: Optional[UUID] = None,
        limit: int = 50
    ) -> List[PermissionAudit]:
        """Get permission change history for admin."""
        stmt = (
            select(PermissionAudit)
            .where(PermissionAudit.admin_id == admin_id)
            .order_by(desc(PermissionAudit.changed_at))
            .limit(limit)
        )

        if hostel_id:
            # Join with AdminPermission to filter by hostel
            stmt = stmt.join(
                AdminPermission,
                PermissionAudit.permission_id == AdminPermission.id
            ).where(AdminPermission.hostel_id == hostel_id)

        result = await self.db.execute(stmt)
        return result.scalars().all()

    # ==================== PERMISSION ANALYTICS ====================

    async def track_permission_usage(
        self,
        admin_id: UUID,
        permission_key: str,
        hostel_id: Optional[UUID] = None
    ) -> None:
        """Track permission usage for analytics."""
        # This would typically update a usage counter or log to analytics system
        # For now, we'll just note the pattern for future implementation
        pass

    async def get_permission_statistics(self) -> Dict[str, Any]:
        """Get overall permission statistics."""
        # Total permission sets
        total_stmt = select(func.count(AdminPermission.id)).where(
            AdminPermission.is_deleted == False
        )
        total_sets = await self.db.scalar(total_stmt)

        # Global vs hostel-specific
        global_stmt = select(func.count(AdminPermission.id)).where(
            and_(
                AdminPermission.is_deleted == False,
                AdminPermission.hostel_id.is_(None)
            )
        )
        global_sets = await self.db.scalar(global_stmt)

        # Most common permissions
        # This would require analyzing the permission JSON fields
        # Simplified for now

        return {
            'total_permission_sets': total_sets,
            'global_permissions': global_sets,
            'hostel_specific_permissions': total_sets - global_sets,
            'avg_permissions_per_admin': total_sets / max(1, global_sets)
        }

    async def suggest_role_optimization(
        self,
        admin_id: UUID
    ) -> Dict[str, Any]:
        """Suggest role optimizations based on permission patterns."""
        all_perms = await self.get_all_permissions_for_admin(admin_id)

        if not all_perms:
            return {'suggestions': [], 'current_complexity': 0}

        # Analyze permission patterns
        permission_counts = {}
        for perm_set in all_perms:
            perm_dict = self._extract_permission_dict(perm_set)
            for key, value in perm_dict.items():
                if value:
                    permission_counts[key] = permission_counts.get(key, 0) + 1

        # Find most common permissions
        common_perms = sorted(
            permission_counts.items(),
            key=lambda x: x[1],
            reverse=True
        )[:10]

        suggestions = []

        # Suggest consolidation if too many permission sets
        if len(all_perms) > 5:
            suggestions.append({
                'type': 'consolidation',
                'message': f'Consider consolidating {len(all_perms)} permission sets',
                'priority': 'medium'
            })

        # Suggest template if pattern matches existing
        # This would query against templates
        # Simplified for now

        return {
            'current_complexity': len(all_perms),
            'common_permissions': common_perms,
            'suggestions': suggestions
        }

# --- File: C:\Hostel-Main\app\repositories\admin\admin_user_repository.py ---
"""
Admin User Repository

Manages admin users with role-based access, security monitoring,
multi-tenant support, and comprehensive activity tracking.
"""

from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from datetime import datetime, date, timedelta
from decimal import Decimal
from sqlalchemy import select, and_, or_, func, desc, asc, exists
from sqlalchemy.orm import Session, selectinload, joinedload
from sqlalchemy.exc import IntegrityError

from app.models.admin.admin_user import (
    AdminUser,
    AdminProfile,
    AdminRole,
    AdminSession
)
from app.models.user.user import User
from app.models.admin.admin_hostel_assignment import AdminHostelAssignment
from app.repositories.base.base_repository import BaseRepository
from app.core.exceptions import (
    EntityNotFoundError,
    ValidationError,
    SecurityError,
    DuplicateError
)


class AdminUserRepository(BaseRepository[AdminUser]):
    """
    Comprehensive admin user management with:
    - Role-based access control with inheritance
    - Multi-hostel assignment tracking
    - Security monitoring and threat detection
    - Performance analytics and reporting
    - Session management with concurrent login control
    """

    def __init__(self, db: Session):
        super().__init__(AdminUser, db)

    # ==================== CORE CRUD OPERATIONS ====================

    async def create_admin(
        self,
        user_id: UUID,
        admin_data: Dict[str, Any],
        created_by_id: Optional[UUID] = None,
        audit_context: Optional[Dict] = None
    ) -> AdminUser:
        """
        Create new admin with validation and audit trail.
        
        Args:
            user_id: Base user account ID
            admin_data: Admin-specific attributes
            created_by_id: Admin who created this account
            audit_context: Audit trail information
            
        Returns:
            Created AdminUser instance
            
        Raises:
            ValidationError: Invalid data
            DuplicateError: Admin already exists for user
        """
        # Check if admin already exists for this user
        existing = await self.find_by_user_id(user_id)
        if existing:
            raise DuplicateError(f"Admin already exists for user {user_id}")

        # Validate admin level
        admin_level = admin_data.get('admin_level', 1)
        if not 1 <= admin_level <= 10:
            raise ValidationError("Admin level must be between 1 and 10")

        # Create admin user
        admin = AdminUser(
            user_id=user_id,
            admin_level=admin_level,
            is_super_admin=admin_data.get('is_super_admin', False),
            reports_to_id=admin_data.get('reports_to_id'),
            employee_id=admin_data.get('employee_id'),
            department=admin_data.get('department'),
            designation=admin_data.get('designation'),
            join_date=admin_data.get('join_date', datetime.utcnow()),
            is_active=admin_data.get('is_active', True),
            can_manage_admins=admin_data.get('can_manage_admins', False),
            can_access_all_hostels=admin_data.get('can_access_all_hostels', False),
            max_hostel_limit=admin_data.get('max_hostel_limit'),
            permissions_override=admin_data.get('permissions_override'),
            settings=admin_data.get('settings', {})
        )

        self.db.add(admin)
        
        try:
            await self.db.flush()
            
            # Create admin profile if profile data provided
            if 'profile' in admin_data:
                await self._create_admin_profile(admin.id, admin_data['profile'])
            
            # Log creation audit
            await self._log_audit('CREATE_ADMIN', admin, audit_context)
            
            return admin
            
        except IntegrityError as e:
            await self.db.rollback()
            raise ValidationError(f"Failed to create admin: {str(e)}")

    async def find_by_user_id(self, user_id: UUID) -> Optional[AdminUser]:
        """Find admin by base user ID with eager loading."""
        stmt = (
            select(AdminUser)
            .where(AdminUser.user_id == user_id)
            .where(AdminUser.is_deleted == False)
            .options(
                joinedload(AdminUser.user),
                selectinload(AdminUser.admin_profile),
                selectinload(AdminUser.hostel_assignments)
            )
        )
        result = await self.db.execute(stmt)
        return result.unique().scalar_one_or_none()

    async def find_by_email(self, email: str) -> Optional[AdminUser]:
        """Find admin by email address."""
        stmt = (
            select(AdminUser)
            .join(AdminUser.user)
            .where(User.email == email)
            .where(AdminUser.is_deleted == False)
            .options(
                joinedload(AdminUser.user),
                selectinload(AdminUser.admin_profile)
            )
        )
        result = await self.db.execute(stmt)
        return result.unique().scalar_one_or_none()

    async def find_by_employee_id(self, employee_id: str) -> Optional[AdminUser]:
        """Find admin by employee ID."""
        stmt = (
            select(AdminUser)
            .where(AdminUser.employee_id == employee_id)
            .where(AdminUser.is_deleted == False)
            .options(joinedload(AdminUser.user))
        )
        result = await self.db.execute(stmt)
        return result.unique().scalar_one_or_none()

    # ==================== SEARCH & FILTERING ====================

    async def find_by_permissions(
        self,
        required_permissions: List[str],
        match_all: bool = True
    ) -> List[AdminUser]:
        """
        Find admins with specific permissions.
        
        Args:
            required_permissions: List of permission keys
            match_all: If True, admin must have all permissions
            
        Returns:
            List of admins with matching permissions
        """
        stmt = select(AdminUser).where(AdminUser.is_deleted == False)

        if match_all:
            # Admin must have all specified permissions
            for perm in required_permissions:
                stmt = stmt.where(
                    AdminUser.permissions_override[perm].astext.cast(Boolean) == True
                )
        else:
            # Admin must have at least one permission
            or_conditions = [
                AdminUser.permissions_override[perm].astext.cast(Boolean) == True
                for perm in required_permissions
            ]
            stmt = stmt.where(or_(*or_conditions))

        result = await self.db.execute(stmt)
        return result.scalars().all()

    async def find_multi_hostel_admins(self) -> List[AdminUser]:
        """Find admins managing multiple hostels."""
        subquery = (
            select(AdminHostelAssignment.admin_id)
            .where(AdminHostelAssignment.is_active == True)
            .where(AdminHostelAssignment.is_deleted == False)
            .group_by(AdminHostelAssignment.admin_id)
            .having(func.count(AdminHostelAssignment.hostel_id) > 1)
        )

        stmt = (
            select(AdminUser)
            .where(AdminUser.id.in_(subquery))
            .where(AdminUser.is_deleted == False)
            .options(selectinload(AdminUser.hostel_assignments))
        )

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    async def find_by_activity_level(
        self,
        period_days: int = 30,
        min_logins: int = 1
    ) -> List[AdminUser]:
        """
        Find admins by activity level.
        
        Args:
            period_days: Period to check activity
            min_logins: Minimum login count
            
        Returns:
            Active admins within period
        """
        cutoff_date = datetime.utcnow() - timedelta(days=period_days)

        stmt = (
            select(AdminUser)
            .where(AdminUser.is_deleted == False)
            .where(AdminUser.last_active_at >= cutoff_date)
            .where(AdminUser.login_count >= min_logins)
            .order_by(desc(AdminUser.last_active_at))
        )

        result = await self.db.execute(stmt)
        return result.scalars().all()

    async def find_inactive_admins(self, days_inactive: int = 90) -> List[AdminUser]:
        """Find admins with no activity for specified days."""
        cutoff_date = datetime.utcnow() - timedelta(days=days_inactive)

        stmt = (
            select(AdminUser)
            .where(AdminUser.is_deleted == False)
            .where(AdminUser.is_active == True)
            .where(
                or_(
                    AdminUser.last_active_at < cutoff_date,
                    AdminUser.last_active_at.is_(None)
                )
            )
            .order_by(asc(AdminUser.last_active_at))
        )

        result = await self.db.execute(stmt)
        return result.scalars().all()

    async def find_pending_approval(self) -> List[AdminUser]:
        """Find admin accounts pending verification/approval."""
        stmt = (
            select(AdminUser)
            .where(AdminUser.is_deleted == False)
            .where(AdminUser.is_verified == False)
            .order_by(asc(AdminUser.created_at))
        )

        result = await self.db.execute(stmt)
        return result.scalars().all()

    async def find_expiring_access(self, days: int = 30) -> List[Dict[str, Any]]:
        """
        Find admins with assignments expiring within specified days.
        
        Returns:
            List of dicts with admin and expiring assignment info
        """
        cutoff_date = date.today() + timedelta(days=days)

        stmt = (
            select(
                AdminUser,
                AdminHostelAssignment,
                func.count(AdminHostelAssignment.id).over(
                    partition_by=AdminUser.id
                ).label('expiring_count')
            )
            .join(AdminUser.hostel_assignments)
            .where(AdminUser.is_deleted == False)
            .where(AdminHostelAssignment.is_active == True)
            .where(AdminHostelAssignment.effective_until <= cutoff_date)
            .order_by(AdminHostelAssignment.effective_until)
        )

        result = await self.db.execute(stmt)
        
        expiring_data = []
        for row in result:
            expiring_data.append({
                'admin': row.AdminUser,
                'assignment': row.AdminHostelAssignment,
                'expiring_count': row.expiring_count,
                'days_until_expiry': (row.AdminHostelAssignment.effective_until - date.today()).days
            })

        return expiring_data

    # ==================== HIERARCHY & REPORTING ====================

    async def get_admin_hierarchy(
        self,
        admin_id: UUID,
        include_subordinates: bool = True
    ) -> Dict[str, Any]:
        """
        Get complete reporting hierarchy for admin.
        
        Returns:
            Dict with managers (upward) and subordinates (downward)
        """
        admin = await self.find_by_id(admin_id)
        if not admin:
            raise EntityNotFoundError(f"Admin {admin_id} not found")

        hierarchy = {
            'admin': admin,
            'managers': [],
            'subordinates': [] if include_subordinates else None
        }

        # Get upward hierarchy (managers)
        current_admin = admin
        while current_admin.reports_to_id:
            manager = await self.find_by_id(current_admin.reports_to_id)
            if not manager:
                break
            hierarchy['managers'].append(manager)
            current_admin = manager

        # Get downward hierarchy (subordinates)
        if include_subordinates:
            subordinates = await self._get_all_subordinates(admin_id)
            hierarchy['subordinates'] = subordinates

        return hierarchy

    async def _get_all_subordinates(
        self,
        admin_id: UUID,
        depth: int = 0,
        max_depth: int = 10
    ) -> List[Dict[str, Any]]:
        """Recursively get all subordinates with depth tracking."""
        if depth >= max_depth:
            return []

        stmt = (
            select(AdminUser)
            .where(AdminUser.reports_to_id == admin_id)
            .where(AdminUser.is_deleted == False)
        )
        result = await self.db.execute(stmt)
        direct_reports = result.scalars().all()

        subordinates = []
        for subordinate in direct_reports:
            sub_data = {
                'admin': subordinate,
                'depth': depth + 1,
                'subordinates': await self._get_all_subordinates(
                    subordinate.id,
                    depth + 1,
                    max_depth
                )
            }
            subordinates.append(sub_data)

        return subordinates

    async def get_team_statistics(self, admin_id: UUID) -> Dict[str, Any]:
        """Get statistics for admin's team."""
        hierarchy = await self.get_admin_hierarchy(admin_id)
        
        def count_subordinates(subs):
            count = len(subs)
            for sub in subs:
                count += count_subordinates(sub.get('subordinates', []))
            return count

        total_subordinates = count_subordinates(hierarchy['subordinates'])
        direct_reports = len(hierarchy['subordinates'])

        return {
            'admin_id': admin_id,
            'total_subordinates': total_subordinates,
            'direct_reports': direct_reports,
            'hierarchy_depth': len(hierarchy['managers']),
            'team_size': total_subordinates + 1,  # +1 for the admin themselves
        }

    # ==================== PERMISSION MANAGEMENT ====================

    async def get_effective_permissions(
        self,
        admin_id: UUID,
        hostel_id: Optional[UUID] = None
    ) -> Dict[str, Any]:
        """
        Calculate effective permissions with inheritance and overrides.
        
        Priority (highest to lowest):
        1. Hostel-specific assignment permissions
        2. Global admin permission overrides
        3. Role-based permissions
        4. Default permissions based on admin level
        """
        admin = await self.find_by_id(admin_id)
        if not admin:
            raise EntityNotFoundError(f"Admin {admin_id} not found")

        # Start with default permissions based on level
        permissions = self._get_default_permissions(admin.admin_level)

        # Apply super admin override
        if admin.is_super_admin:
            permissions = self._get_super_admin_permissions()

        # Apply global permission overrides
        if admin.permissions_override:
            permissions.update(admin.permissions_override)

        # Apply hostel-specific permissions if context provided
        if hostel_id:
            hostel_perms = await self._get_hostel_specific_permissions(
                admin_id,
                hostel_id
            )
            if hostel_perms:
                permissions.update(hostel_perms)

        return {
            'admin_id': admin_id,
            'hostel_id': hostel_id,
            'effective_permissions': permissions,
            'permission_source': self._determine_permission_source(
                admin, hostel_id
            ),
            'is_super_admin': admin.is_super_admin
        }

    def _get_default_permissions(self, admin_level: int) -> Dict[str, bool]:
        """Get default permissions based on admin level."""
        # Level 1-3: Basic permissions
        if admin_level <= 3:
            return {
                'can_view_data': True,
                'can_manage_students': False,
                'can_approve_bookings': False,
                'can_manage_fees': False,
                'can_view_financials': False
            }
        # Level 4-6: Intermediate permissions
        elif admin_level <= 6:
            return {
                'can_view_data': True,
                'can_manage_students': True,
                'can_approve_bookings': True,
                'can_manage_fees': False,
                'can_view_financials': True
            }
        # Level 7-10: Advanced permissions
        else:
            return {
                'can_view_data': True,
                'can_manage_students': True,
                'can_approve_bookings': True,
                'can_manage_fees': True,
                'can_view_financials': True,
                'can_export_data': True
            }

    def _get_super_admin_permissions(self) -> Dict[str, bool]:
        """Get all permissions for super admin."""
        return {
            'can_view_data': True,
            'can_manage_students': True,
            'can_approve_bookings': True,
            'can_manage_fees': True,
            'can_view_financials': True,
            'can_export_data': True,
            'can_manage_admins': True,
            'can_manage_hostel_settings': True,
            'can_delete_records': True,
            'can_override_supervisor_actions': True
        }

    async def _get_hostel_specific_permissions(
        self,
        admin_id: UUID,
        hostel_id: UUID
    ) -> Optional[Dict[str, bool]]:
        """Get permissions for specific hostel assignment."""
        stmt = (
            select(AdminHostelAssignment.permissions)
            .where(AdminHostelAssignment.admin_id == admin_id)
            .where(AdminHostelAssignment.hostel_id == hostel_id)
            .where(AdminHostelAssignment.is_active == True)
            .where(AdminHostelAssignment.is_deleted == False)
        )
        result = await self.db.execute(stmt)
        permissions = result.scalar_one_or_none()
        return permissions if permissions else None

    def _determine_permission_source(
        self,
        admin: AdminUser,
        hostel_id: Optional[UUID]
    ) -> str:
        """Determine the source of effective permissions."""
        if admin.is_super_admin:
            return 'super_admin'
        elif hostel_id:
            return 'hostel_assignment'
        elif admin.permissions_override:
            return 'admin_override'
        else:
            return 'default_level'

    async def validate_permission(
        self,
        admin_id: UUID,
        permission_key: str,
        hostel_id: Optional[UUID] = None
    ) -> bool:
        """Validate if admin has specific permission."""
        permissions = await self.get_effective_permissions(admin_id, hostel_id)
        return permissions['effective_permissions'].get(permission_key, False)

    # ==================== SECURITY & SESSION MANAGEMENT ====================

    async def track_login(
        self,
        admin_id: UUID,
        ip_address: str,
        user_agent: str,
        device_info: Optional[Dict] = None
    ) -> AdminSession:
        """
        Track admin login with security monitoring.
        
        Creates session and updates login metrics.
        Detects suspicious activity patterns.
        """
        admin = await self.find_by_id(admin_id)
        if not admin:
            raise EntityNotFoundError(f"Admin {admin_id} not found")

        # Check if admin can login
        if not admin.can_login:
            raise SecurityError(
                f"Admin login disabled: "
                f"{'suspended' if admin.is_suspended else 'terminated'}"
            )

        # Update login metrics
        admin.last_login_at = datetime.utcnow()
        admin.last_active_at = datetime.utcnow()
        admin.login_count += 1

        # Create session
        session = AdminSession(
            admin_id=admin_id,
            session_token=self._generate_session_token(),
            started_at=datetime.utcnow(),
            expires_at=datetime.utcnow() + timedelta(hours=8),
            ip_address=ip_address,
            user_agent=user_agent,
            device_info=device_info or {},
            is_active=True
        )

        self.db.add(session)

        # Security checks
        is_suspicious = await self._check_suspicious_login(
            admin_id,
            ip_address,
            user_agent
        )
        if is_suspicious:
            session.is_suspicious = True
            session.security_flags = ['unusual_location', 'new_device']
            # Notify security team
            await self._notify_suspicious_activity(admin, session)

        await self.db.flush()
        return session

    async def _check_suspicious_login(
        self,
        admin_id: UUID,
        ip_address: str,
        user_agent: str
    ) -> bool:
        """Detect suspicious login patterns."""
        # Get recent sessions
        recent_sessions = await self._get_recent_sessions(admin_id, hours=24)

        # Check for unusual patterns
        suspicious_indicators = []

        # 1. New IP address
        known_ips = {s.ip_address for s in recent_sessions if s.ip_address}
        if ip_address not in known_ips and len(known_ips) > 0:
            suspicious_indicators.append('new_ip')

        # 2. Multiple login attempts from different IPs
        unique_ips_today = len({s.ip_address for s in recent_sessions})
        if unique_ips_today > 5:
            suspicious_indicators.append('multiple_ips')

        # 3. High frequency logins
        if len(recent_sessions) > 20:
            suspicious_indicators.append('high_frequency')

        return len(suspicious_indicators) >= 2

    async def _get_recent_sessions(
        self,
        admin_id: UUID,
        hours: int = 24
    ) -> List[AdminSession]:
        """Get recent sessions for security analysis."""
        cutoff = datetime.utcnow() - timedelta(hours=hours)

        stmt = (
            select(AdminSession)
            .where(AdminSession.admin_id == admin_id)
            .where(AdminSession.started_at >= cutoff)
            .order_by(desc(AdminSession.started_at))
        )

        result = await self.db.execute(stmt)
        return result.scalars().all()

    async def end_session(self, session_id: UUID, reason: str = 'logout') -> bool:
        """End admin session."""
        session = await self.db.get(AdminSession, session_id)
        if not session:
            return False

        session.is_active = False
        session.ended_at = datetime.utcnow()
        session.end_reason = reason

        await self.db.flush()
        return True

    async def get_active_sessions(self, admin_id: UUID) -> List[AdminSession]:
        """Get all active sessions for admin."""
        stmt = (
            select(AdminSession)
            .where(AdminSession.admin_id == admin_id)
            .where(AdminSession.is_active == True)
            .where(AdminSession.expires_at > datetime.utcnow())
            .order_by(desc(AdminSession.started_at))
        )

        result = await self.db.execute(stmt)
        return result.scalars().all()

    async def terminate_all_sessions(
        self,
        admin_id: UUID,
        reason: str = 'force_logout'
    ) -> int:
        """Terminate all active sessions for admin."""
        sessions = await self.get_active_sessions(admin_id)
        
        for session in sessions:
            session.is_active = False
            session.ended_at = datetime.utcnow()
            session.end_reason = reason

        await self.db.flush()
        return len(sessions)

    # ==================== ADMIN STATUS MANAGEMENT ====================

    async def suspend_admin(
        self,
        admin_id: UUID,
        suspended_by_id: UUID,
        reason: str,
        audit_context: Optional[Dict] = None
    ) -> AdminUser:
        """Suspend admin account."""
        admin = await self.find_by_id(admin_id)
        if not admin:
            raise EntityNotFoundError(f"Admin {admin_id} not found")

        admin.is_active = False
        admin.suspended_at = datetime.utcnow()
        admin.suspended_by_id = suspended_by_id
        admin.suspension_reason = reason

        # Terminate all active sessions
        await self.terminate_all_sessions(admin_id, 'account_suspended')

        # Log audit
        await self._log_audit('SUSPEND_ADMIN', admin, audit_context)

        await self.db.flush()
        return admin

    async def reactivate_admin(
        self,
        admin_id: UUID,
        reactivated_by_id: UUID,
        audit_context: Optional[Dict] = None
    ) -> AdminUser:
        """Reactivate suspended admin."""
        admin = await self.find_by_id(admin_id)
        if not admin:
            raise EntityNotFoundError(f"Admin {admin_id} not found")

        admin.is_active = True
        admin.suspended_at = None
        admin.suspended_by_id = None
        admin.suspension_reason = None

        # Log audit
        await self._log_audit('REACTIVATE_ADMIN', admin, audit_context)

        await self.db.flush()
        return admin

    async def terminate_admin(
        self,
        admin_id: UUID,
        reason: str,
        terminated_by_id: UUID,
        audit_context: Optional[Dict] = None
    ) -> AdminUser:
        """Permanently terminate admin account."""
        admin = await self.find_by_id(admin_id)
        if not admin:
            raise EntityNotFoundError(f"Admin {admin_id} not found")

        admin.is_active = False
        admin.terminated_at = datetime.utcnow()
        admin.termination_reason = reason

        # Terminate all sessions
        await self.terminate_all_sessions(admin_id, 'account_terminated')

        # Deactivate all hostel assignments
        await self._deactivate_all_assignments(admin_id)

        # Log audit
        await self._log_audit('TERMINATE_ADMIN', admin, audit_context)

        await self.db.flush()
        return admin

    async def _deactivate_all_assignments(self, admin_id: UUID) -> None:
        """Deactivate all hostel assignments for admin."""
        stmt = (
            select(AdminHostelAssignment)
            .where(AdminHostelAssignment.admin_id == admin_id)
            .where(AdminHostelAssignment.is_active == True)
        )
        result = await self.db.execute(stmt)
        assignments = result.scalars().all()

        for assignment in assignments:
            assignment.is_active = False
            assignment.revoked_date = date.today()
            assignment.revoke_reason = "Admin account terminated"

    # ==================== ANALYTICS & REPORTING ====================

    async def get_admin_statistics(
        self,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None
    ) -> Dict[str, Any]:
        """Get comprehensive admin statistics."""
        if not start_date:
            start_date = date.today() - timedelta(days=30)
        if not end_date:
            end_date = date.today()

        # Total admins
        total_stmt = select(func.count(AdminUser.id)).where(
            AdminUser.is_deleted == False
        )
        total_admins = await self.db.scalar(total_stmt)

        # Active admins
        active_stmt = select(func.count(AdminUser.id)).where(
            and_(
                AdminUser.is_deleted == False,
                AdminUser.is_active == True,
                AdminUser.terminated_at.is_(None)
            )
        )
        active_admins = await self.db.scalar(active_stmt)

        # Super admins
        super_stmt = select(func.count(AdminUser.id)).where(
            and_(
                AdminUser.is_deleted == False,
                AdminUser.is_super_admin == True
            )
        )
        super_admins = await self.db.scalar(super_stmt)

        # New admins in period
        new_stmt = select(func.count(AdminUser.id)).where(
            and_(
                AdminUser.is_deleted == False,
                AdminUser.created_at >= start_date,
                AdminUser.created_at <= end_date
            )
        )
        new_admins = await self.db.scalar(new_stmt)

        # By admin level distribution
        level_dist_stmt = (
            select(
                AdminUser.admin_level,
                func.count(AdminUser.id).label('count')
            )
            .where(AdminUser.is_deleted == False)
            .group_by(AdminUser.admin_level)
        )
        level_result = await self.db.execute(level_dist_stmt)
        level_distribution = {
            row.admin_level: row.count for row in level_result
        }

        return {
            'period': {'start': start_date, 'end': end_date},
            'total_admins': total_admins,
            'active_admins': active_admins,
            'super_admins': super_admins,
            'inactive_admins': total_admins - active_admins,
            'new_admins': new_admins,
            'level_distribution': level_distribution,
            'activity_rate': (active_admins / total_admins * 100) if total_admins > 0 else 0
        }

    async def get_admin_performance_metrics(
        self,
        admin_id: UUID,
        period_days: int = 30
    ) -> Dict[str, Any]:
        """Get performance metrics for specific admin."""
        admin = await self.find_by_id(admin_id)
        if not admin:
            raise EntityNotFoundError(f"Admin {admin_id} not found")

        start_date = datetime.utcnow() - timedelta(days=period_days)

        # Session statistics
        sessions = await self._get_recent_sessions(admin_id, period_days * 24)
        total_sessions = len(sessions)
        avg_session_duration = (
            sum(s.duration_seconds for s in sessions if s.duration_seconds) / total_sessions
            if total_sessions > 0 else 0
        )

        # Hostel assignment stats
        assignment_stmt = (
            select(func.count(AdminHostelAssignment.id))
            .where(AdminHostelAssignment.admin_id == admin_id)
            .where(AdminHostelAssignment.is_active == True)
        )
        active_assignments = await self.db.scalar(assignment_stmt)

        return {
            'admin_id': admin_id,
            'period_days': period_days,
            'login_count': admin.login_count,
            'total_sessions': total_sessions,
            'avg_session_duration_minutes': avg_session_duration / 60,
            'active_hostel_assignments': active_assignments,
            'last_active': admin.last_active_at,
            'account_age_days': (datetime.utcnow() - admin.created_at).days,
        }

    # ==================== HELPER METHODS ====================

    async def _create_admin_profile(
        self,
        admin_id: UUID,
        profile_data: Dict[str, Any]
    ) -> AdminProfile:
        """Create admin profile with extended information."""
        profile = AdminProfile(
            admin_id=admin_id,
            date_of_birth=profile_data.get('date_of_birth'),
            nationality=profile_data.get('nationality'),
            id_proof_type=profile_data.get('id_proof_type'),
            id_proof_number=profile_data.get('id_proof_number'),
            contract_type=profile_data.get('contract_type'),
            work_phone=profile_data.get('work_phone'),
            personal_phone=profile_data.get('personal_phone'),
            emergency_contact_name=profile_data.get('emergency_contact_name'),
            emergency_contact_phone=profile_data.get('emergency_contact_phone'),
            current_address=profile_data.get('current_address'),
            qualifications=profile_data.get('qualifications'),
            experience_years=profile_data.get('experience_years'),
            skills=profile_data.get('skills'),
            bio=profile_data.get('bio'),
            profile_picture_url=profile_data.get('profile_picture_url')
        )

        self.db.add(profile)
        await self.db.flush()
        return profile

    def _generate_session_token(self) -> str:
        """Generate secure session token."""
        import secrets
        return secrets.token_urlsafe(32)

    async def _notify_suspicious_activity(
        self,
        admin: AdminUser,
        session: AdminSession
    ) -> None:
        """Notify security team of suspicious login."""
        # Implementation would send notification via email/SMS/Slack
        # For now, just log it
        pass

    async def _log_audit(
        self,
        action: str,
        entity: Any,
        context: Optional[Dict]
    ) -> None:
        """Log audit trail for admin actions."""
        # Implementation would create audit log entry
        pass

# --- File: C:\Hostel-Main\app\repositories\admin\hostel_context_repository.py ---
"""
Hostel Context Repository

Manages hostel context switching and session tracking for multi-hostel admins.
Provides session management, context history, and performance optimization.
"""

from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import datetime, timedelta
from decimal import Decimal
from sqlalchemy import select, and_, or_, func, desc, asc
from sqlalchemy.orm import Session, selectinload, joinedload
from sqlalchemy.exc import IntegrityError

from app.models.admin.hostel_context import (
    HostelContext,
    ContextSwitch,
    ContextPreference,
    ContextSnapshot
)
from app.models.admin.admin_user import AdminUser
from app.models.hostel.hostel import Hostel
from app.repositories.base.base_repository import BaseRepository
from app.core.exceptions import (
    EntityNotFoundError,
    ValidationError,
    ConflictError
)


class HostelContextRepository(BaseRepository[HostelContext]):
    """
    Context switching management with:
    - Active context tracking
    - Session duration monitoring
    - Quick stats caching
    - Context preferences
    - Switch history and analytics
    """

    def __init__(self, db: Session):
        super().__init__(HostelContext, db)

    # ==================== CONTEXT MANAGEMENT ====================

    async def get_active_context(
        self,
        admin_id: UUID,
        include_preferences: bool = False
    ) -> Optional[HostelContext]:
        """Get admin's current active context."""
        stmt = (
            select(HostelContext)
            .where(HostelContext.admin_id == admin_id)
            .where(HostelContext.is_active == True)
            .options(
                selectinload(HostelContext.active_hostel),
                selectinload(HostelContext.previous_hostel)
            )
        )

        if include_preferences:
            stmt = stmt.options(selectinload(HostelContext.preferences))

        result = await self.db.execute(stmt)
        return result.unique().scalar_one_or_none()

    async def set_active_context(
        self,
        admin_id: UUID,
        hostel_id: UUID,
        device_info: Optional[Dict] = None,
        ip_address: Optional[str] = None
    ) -> HostelContext:
        """
        Set or switch active context for admin.
        
        Args:
            admin_id: Admin user ID
            hostel_id: Hostel to make active
            device_info: Device information
            ip_address: Client IP address
            
        Returns:
            Active HostelContext
        """
        # Validate admin and hostel
        admin = await self.db.get(AdminUser, admin_id)
        if not admin:
            raise EntityNotFoundError(f"Admin {admin_id} not found")

        hostel = await self.db.get(Hostel, hostel_id)
        if not hostel:
            raise EntityNotFoundError(f"Hostel {hostel_id} not found")

        # Get current active context
        current_context = await self.get_active_context(admin_id)

        # If switching to different hostel, record switch
        if current_context and current_context.active_hostel_id != hostel_id:
            await self._record_context_switch(
                admin_id=admin_id,
                from_hostel_id=current_context.active_hostel_id,
                to_hostel_id=hostel_id,
                context_id=current_context.id,
                device_info=device_info,
                ip_address=ip_address
            )

            # Update current context
            current_context.previous_hostel_id = current_context.active_hostel_id
            current_context.active_hostel_id = hostel_id
            current_context.switch_count += 1
            current_context.last_accessed_at = datetime.utcnow()

            # Reset session duration for new context
            current_context.context_started_at = datetime.utcnow()

            await self.db.flush()
            return current_context

        # If no context exists, create new one
        if not current_context:
            context = HostelContext(
                admin_id=admin_id,
                active_hostel_id=hostel_id,
                context_started_at=datetime.utcnow(),
                last_accessed_at=datetime.utcnow(),
                is_active=True,
                device_type=device_info.get('type') if device_info else None,
                device_info=device_info,
                ip_address=ip_address
            )

            self.db.add(context)
            await self.db.flush()

            # Initialize quick stats
            await self.refresh_context_stats(context.id)

            return context

        # Same hostel, just update activity
        await self.update_activity(current_context.id)
        return current_context

    async def end_context(
        self,
        admin_id: UUID,
        reason: str = 'logout'
    ) -> Optional[HostelContext]:
        """End active context session."""
        context = await self.get_active_context(admin_id)
        if not context:
            return None

        context.is_active = False
        
        # Update final session duration
        duration_delta = datetime.utcnow() - context.last_accessed_at
        context.session_duration_minutes += int(duration_delta.total_seconds() / 60)

        await self.db.flush()
        return context

    async def update_activity(
        self,
        context_id: UUID,
        actions_performed: int = 0,
        decisions_made: int = 0
    ) -> HostelContext:
        """Update context activity metrics."""
        context = await self.find_by_id(context_id)
        if not context:
            raise EntityNotFoundError(f"Context {context_id} not found")

        # Update timestamp and duration
        now = datetime.utcnow()
        duration_delta = now - context.last_accessed_at
        context.session_duration_minutes += int(duration_delta.total_seconds() / 60)
        context.last_accessed_at = now

        # Update activity counters
        context.actions_performed += actions_performed
        context.decisions_made += decisions_made

        # Reset expiration
        if context.expires_at:
            context.expires_at = now + timedelta(hours=8)

        await self.db.flush()
        return context

    # ==================== CONTEXT STATISTICS ====================

    async def refresh_context_stats(
        self,
        context_id: UUID,
        stats_data: Optional[Dict[str, Any]] = None
    ) -> HostelContext:
        """
        Refresh cached statistics for context.
        
        Args:
            context_id: Context ID
            stats_data: Optional pre-calculated stats
            
        Returns:
            Updated context with fresh stats
        """
        context = await self.find_by_id(context_id)
        if not context:
            raise EntityNotFoundError(f"Context {context_id} not found")

        if stats_data:
            # Use provided stats
            context.total_students = stats_data.get('total_students', 0)
            context.active_students = stats_data.get('active_students', 0)
            context.occupancy_percentage = Decimal(str(stats_data.get('occupancy_percentage', 0)))
            context.pending_tasks = stats_data.get('pending_tasks', 0)
            context.urgent_alerts = stats_data.get('urgent_alerts', 0)
            context.unread_notifications = stats_data.get('unread_notifications', 0)
            context.revenue_this_month = Decimal(str(stats_data.get('revenue_this_month', 0)))
            context.outstanding_payments = Decimal(str(stats_data.get('outstanding_payments', 0)))
        else:
            # Calculate stats from database
            # This would typically call other repositories to get real data
            # Simplified here for demonstration
            context.total_students = 0
            context.active_students = 0
            context.occupancy_percentage = Decimal('0.00')
            context.pending_tasks = 0
            context.urgent_alerts = 0
            context.unread_notifications = 0
            context.revenue_this_month = Decimal('0.00')
            context.outstanding_payments = Decimal('0.00')

        context.stats_last_updated = datetime.utcnow()
        await self.db.flush()
        return context

    async def get_context_with_stats(
        self,
        admin_id: UUID,
        refresh_if_stale: bool = True,
        stale_threshold_minutes: int = 5
    ) -> Optional[HostelContext]:
        """Get context with stats, refreshing if stale."""
        context = await self.get_active_context(admin_id)
        if not context:
            return None

        # Check if stats are stale
        if refresh_if_stale and context.stats_last_updated:
            age = datetime.utcnow() - context.stats_last_updated
            if age.total_seconds() / 60 > stale_threshold_minutes:
                await self.refresh_context_stats(context.id)
                # Reload context to get fresh data
                context = await self.find_by_id(context.id)

        return context

    # ==================== CONTEXT SWITCHING ====================

    async def _record_context_switch(
        self,
        admin_id: UUID,
        from_hostel_id: UUID,
        to_hostel_id: UUID,
        context_id: UUID,
        device_info: Optional[Dict] = None,
        ip_address: Optional[str] = None,
        reason: Optional[str] = None,
        triggered_by: str = 'manual'
    ) -> ContextSwitch:
        """Record context switch event."""
        # Get current context to capture session metrics
        context = await self.find_by_id(context_id)
        
        session_duration = None
        if context:
            session_duration = (
                datetime.utcnow() - context.context_started_at
            ).total_seconds() / 60

        switch = ContextSwitch(
            context_id=context_id,
            admin_id=admin_id,
            from_hostel_id=from_hostel_id,
            to_hostel_id=to_hostel_id,
            switched_at=datetime.utcnow(),
            session_duration_minutes=int(session_duration) if session_duration else None,
            switch_reason=reason,
            triggered_by=triggered_by,
            actions_performed=context.actions_performed if context else 0,
            decisions_made=context.decisions_made if context else 0,
            device_type=device_info.get('type') if device_info else None,
            ip_address=ip_address
        )

        self.db.add(switch)
        await self.db.flush()

        # Create snapshot if significant switch
        if context and (context.actions_performed > 0 or context.decisions_made > 0):
            await self._create_context_snapshot(switch.id, context)

        return switch

    async def get_switch_history(
        self,
        admin_id: UUID,
        limit: int = 50,
        include_snapshots: bool = False
    ) -> List[ContextSwitch]:
        """Get context switch history for admin."""
        stmt = (
            select(ContextSwitch)
            .where(ContextSwitch.admin_id == admin_id)
            .options(
                selectinload(ContextSwitch.from_hostel),
                selectinload(ContextSwitch.to_hostel)
            )
            .order_by(desc(ContextSwitch.switched_at))
            .limit(limit)
        )

        if include_snapshots:
            stmt = stmt.options(selectinload(ContextSwitch.snapshot))

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    async def get_switch_analytics(
        self,
        admin_id: UUID,
        days: int = 30
    ) -> Dict[str, Any]:
        """Get context switching analytics."""
        cutoff = datetime.utcnow() - timedelta(days=days)

        # Total switches
        total_stmt = (
            select(func.count(ContextSwitch.id))
            .where(ContextSwitch.admin_id == admin_id)
            .where(ContextSwitch.switched_at >= cutoff)
        )
        total_switches = await self.db.scalar(total_stmt) or 0

        # Most switched-to hostels
        popular_stmt = (
            select(
                ContextSwitch.to_hostel_id,
                Hostel.name,
                func.count(ContextSwitch.id).label('switch_count')
            )
            .join(Hostel, ContextSwitch.to_hostel_id == Hostel.id)
            .where(ContextSwitch.admin_id == admin_id)
            .where(ContextSwitch.switched_at >= cutoff)
            .group_by(ContextSwitch.to_hostel_id, Hostel.name)
            .order_by(desc('switch_count'))
            .limit(5)
        )
        popular_result = await self.db.execute(popular_stmt)
        most_visited = [
            {'hostel_id': row[0], 'hostel_name': row[1], 'switch_count': row[2]}
            for row in popular_result
        ]

        # Average session duration
        avg_duration_stmt = (
            select(func.avg(ContextSwitch.session_duration_minutes))
            .where(ContextSwitch.admin_id == admin_id)
            .where(ContextSwitch.switched_at >= cutoff)
            .where(ContextSwitch.session_duration_minutes.isnot(None))
        )
        avg_duration = await self.db.scalar(avg_duration_stmt) or 0

        # Switches by trigger type
        by_trigger_stmt = (
            select(
                ContextSwitch.triggered_by,
                func.count(ContextSwitch.id).label('count')
            )
            .where(ContextSwitch.admin_id == admin_id)
            .where(ContextSwitch.switched_at >= cutoff)
            .group_by(ContextSwitch.triggered_by)
        )
        trigger_result = await self.db.execute(by_trigger_stmt)
        by_trigger = {row[0]: row[1] for row in trigger_result}

        return {
            'period_days': days,
            'total_switches': total_switches,
            'avg_switches_per_day': round(total_switches / days, 2),
            'avg_session_duration_minutes': round(float(avg_duration), 2),
            'most_visited_hostels': most_visited,
            'switches_by_trigger': by_trigger
        }

    # ==================== CONTEXT PREFERENCES ====================

    async def get_context_preferences(
        self,
        context_id: UUID,
        create_if_missing: bool = True
    ) -> Optional[ContextPreference]:
        """Get preferences for context."""
        stmt = (
            select(ContextPreference)
            .where(ContextPreference.context_id == context_id)
        )

        result = await self.db.execute(stmt)
        preferences = result.scalar_one_or_none()

        if not preferences and create_if_missing:
            preferences = ContextPreference(
                context_id=context_id,
                dashboard_layout='default',
                default_view='dashboard',
                records_per_page=25,
                auto_refresh_enabled=True,
                auto_refresh_interval_seconds=300
            )
            self.db.add(preferences)
            await self.db.flush()

        return preferences

    async def update_context_preferences(
        self,
        context_id: UUID,
        preferences_data: Dict[str, Any]
    ) -> ContextPreference:
        """Update context preferences."""
        preferences = await self.get_context_preferences(context_id)
        if not preferences:
            raise EntityNotFoundError(f"Preferences for context {context_id} not found")

        # Update preference fields
        for key, value in preferences_data.items():
            if hasattr(preferences, key):
                setattr(preferences, key, value)

        await self.db.flush()
        return preferences

    async def save_ui_state(
        self,
        context_id: UUID,
        ui_state: Dict[str, Any]
    ) -> HostelContext:
        """Save UI state for session restoration."""
        context = await self.find_by_id(context_id)
        if not context:
            raise EntityNotFoundError(f"Context {context_id} not found")

        context.ui_state = ui_state
        await self.db.flush()
        return context

    # ==================== CONTEXT SNAPSHOTS ====================

    async def _create_context_snapshot(
        self,
        switch_id: UUID,
        context: HostelContext
    ) -> ContextSnapshot:
        """Create snapshot of context state at switch."""
        snapshot = ContextSnapshot(
            switch_id=switch_id,
            snapshot_timestamp=datetime.utcnow(),
            hostel_state={
                'total_students': context.total_students,
                'active_students': context.active_students,
                'occupancy_percentage': float(context.occupancy_percentage),
                'revenue_this_month': float(context.revenue_this_month),
                'outstanding_payments': float(context.outstanding_payments)
            },
            stats_snapshot={
                'pending_tasks': context.pending_tasks,
                'urgent_alerts': context.urgent_alerts,
                'unread_notifications': context.unread_notifications,
                'actions_performed': context.actions_performed,
                'decisions_made': context.decisions_made
            },
            ui_state=context.ui_state,
            snapshot_version='1.0'
        )

        self.db.add(snapshot)
        await self.db.flush()
        return snapshot

    async def get_context_snapshot(
        self,
        switch_id: UUID
    ) -> Optional[ContextSnapshot]:
        """Get snapshot for specific switch."""
        stmt = (
            select(ContextSnapshot)
            .where(ContextSnapshot.switch_id == switch_id)
        )

        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()

    # ==================== CONTEXT CLEANUP ====================

    async def cleanup_stale_contexts(
        self,
        inactive_hours: int = 24
    ) -> int:
        """Clean up stale inactive contexts."""
        cutoff = datetime.utcnow() - timedelta(hours=inactive_hours)

        stmt = (
            select(HostelContext)
            .where(HostelContext.is_active == True)
            .where(HostelContext.last_accessed_at < cutoff)
        )

        result = await self.db.execute(stmt)
        stale_contexts = result.scalars().all()

        for context in stale_contexts:
            context.is_active = False

        await self.db.flush()
        return len(stale_contexts)

    async def cleanup_old_snapshots(
        self,
        retention_days: int = 90
    ) -> int:
        """Delete old context snapshots."""
        cutoff = datetime.utcnow() - timedelta(days=retention_days)

        stmt = (
            select(ContextSnapshot)
            .where(ContextSnapshot.snapshot_timestamp < cutoff)
        )

        result = await self.db.execute(stmt)
        old_snapshots = result.scalars().all()

        for snapshot in old_snapshots:
            await self.db.delete(snapshot)

        await self.db.flush()
        return len(old_snapshots)

    # ==================== CONTEXT RECOMMENDATIONS ====================

    async def recommend_context_switch(
        self,
        admin_id: UUID
    ) -> List[Dict[str, Any]]:
        """
        Recommend hostel context switches based on:
        - Urgent alerts
        - Pending tasks
        - Recent activity
        - Access patterns
        """
        # Get admin's active assignments
        from app.repositories.admin.admin_hostel_assignment_repository import (
            AdminHostelAssignmentRepository
        )
        
        assignment_repo = AdminHostelAssignmentRepository(self.db)
        assignments = await assignment_repo.get_admin_assignments(admin_id)

        recommendations = []

        for assignment in assignments:
            # Calculate recommendation score
            score = 0
            reasons = []

            # Check for urgent items (would need to query actual data)
            # Simplified for demonstration
            urgent_count = 0  # Placeholder
            pending_count = 0  # Placeholder

            if urgent_count > 0:
                score += urgent_count * 10
                reasons.append(f"{urgent_count} urgent alerts")

            if pending_count > 5:
                score += pending_count * 2
                reasons.append(f"{pending_count} pending tasks")

            # Recent access pattern
            recent_switches = await self._get_recent_switches_to_hostel(
                admin_id,
                assignment.hostel_id,
                hours=24
            )
            
            if recent_switches == 0:
                score += 5
                reasons.append("Not accessed today")

            if score > 0:
                recommendations.append({
                    'hostel_id': assignment.hostel_id,
                    'hostel_name': assignment.hostel.name if assignment.hostel else None,
                    'recommendation_score': score,
                    'reasons': reasons,
                    'priority': 'high' if score >= 20 else 'medium' if score >= 10 else 'low'
                })

        # Sort by score
        recommendations.sort(key=lambda x: x['recommendation_score'], reverse=True)
        
        return recommendations[:5]  # Top 5 recommendations

    async def _get_recent_switches_to_hostel(
        self,
        admin_id: UUID,
        hostel_id: UUID,
        hours: int = 24
    ) -> int:
        """Count recent switches to specific hostel."""
        cutoff = datetime.utcnow() - timedelta(hours=hours)

        stmt = (
            select(func.count(ContextSwitch.id))
            .where(ContextSwitch.admin_id == admin_id)
            .where(ContextSwitch.to_hostel_id == hostel_id)
            .where(ContextSwitch.switched_at >= cutoff)
        )

        return await self.db.scalar(stmt) or 0

# --- File: C:\Hostel-Main\app\repositories\admin\hostel_selector_repository.py ---
"""
Hostel Selector Repository

Manages hostel selection UI with recent access, favorites,
quick stats, and pre-computed selector cache.
"""

from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import datetime, timedelta, date
from decimal import Decimal
from sqlalchemy import select, and_, or_, func, desc, asc, case
from sqlalchemy.orm import Session, selectinload, joinedload
from sqlalchemy.exc import IntegrityError

from app.models.admin.hostel_selector import (
    RecentHostel,
    FavoriteHostel,
    HostelQuickStats,
    HostelSelectorCache
)
from app.models.admin.admin_user import AdminUser
from app.models.hostel.hostel import Hostel
from app.repositories.base.base_repository import BaseRepository
from app.core.exceptions import (
    EntityNotFoundError,
    ValidationError,
    DuplicateError
)


class HostelSelectorRepository(BaseRepository[RecentHostel]):
    """
    Hostel selector management with:
    - Recent access tracking with frequency scoring
    - Favorites with customization
    - Quick stats caching
    - Pre-computed selector data
    """

    def __init__(self, db: Session):
        super().__init__(RecentHostel, db)

    # ==================== RECENT HOSTELS ====================

    async def track_hostel_access(
        self,
        admin_id: UUID,
        hostel_id: UUID,
        session_duration_minutes: int = 0,
        last_action: Optional[str] = None
    ) -> RecentHostel:
        """Track hostel access for recent list."""
        # Get or create recent entry
        stmt = (
            select(RecentHostel)
            .where(RecentHostel.admin_id == admin_id)
            .where(RecentHostel.hostel_id == hostel_id)
        )

        result = await self.db.execute(stmt)
        recent = result.scalar_one_or_none()

        if recent:
            # Update existing
            recent.last_accessed = datetime.utcnow()
            recent.access_count += 1
            recent.access_count_last_7_days += 1
            recent.access_count_last_30_days += 1
            
            if session_duration_minutes > 0:
                recent.total_session_time_minutes += session_duration_minutes
                recent.avg_session_duration_minutes = Decimal(
                    recent.total_session_time_minutes / recent.access_count
                )
            
            if last_action:
                recent.last_action_performed = last_action

            # Recalculate frequency score
            recent.frequency_score = self._calculate_frequency_score(recent)

        else:
            # Create new entry
            recent = RecentHostel(
                admin_id=admin_id,
                hostel_id=hostel_id,
                last_accessed=datetime.utcnow(),
                first_accessed=datetime.utcnow(),
                access_count=1,
                access_count_last_7_days=1,
                access_count_last_30_days=1,
                total_session_time_minutes=session_duration_minutes,
                avg_session_duration_minutes=Decimal(str(session_duration_minutes)),
                last_action_performed=last_action,
                frequency_score=Decimal('50.00')  # Initial score
            )
            self.db.add(recent)

        await self.db.flush()
        return recent

    def _calculate_frequency_score(self, recent: RecentHostel) -> Decimal:
        """
        Calculate frequency score based on recency and frequency.
        Score range: 0-100
        """
        # Recency component (0-50 points)
        hours_since = (datetime.utcnow() - recent.last_accessed).total_seconds() / 3600
        recency_score = max(0, 50 - hours_since)

        # Frequency component (0-50 points)
        frequency_score = min(recent.access_count_last_7_days * 5, 50)

        total_score = Decimal(str(recency_score + frequency_score))
        return total_score.quantize(Decimal('0.01'))

    async def get_recent_hostels(
        self,
        admin_id: UUID,
        limit: int = 10,
        min_score: float = 0.0
    ) -> List[RecentHostel]:
        """Get recent hostels sorted by frequency score."""
        stmt = (
            select(RecentHostel)
            .where(RecentHostel.admin_id == admin_id)
            .where(RecentHostel.frequency_score >= min_score)
            .options(selectinload(RecentHostel.hostel))
            .order_by(desc(RecentHostel.frequency_score))
            .limit(limit)
        )

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    async def cleanup_old_recent_entries(
        self,
        admin_id: UUID,
        keep_count: int = 20
    ) -> int:
        """Keep only top N recent entries per admin."""
        # Get all entries for admin
        stmt = (
            select(RecentHostel)
            .where(RecentHostel.admin_id == admin_id)
            .order_by(desc(RecentHostel.frequency_score))
        )

        result = await self.db.execute(stmt)
        all_entries = result.scalars().all()

        if len(all_entries) <= keep_count:
            return 0

        # Delete entries beyond keep_count
        to_delete = all_entries[keep_count:]
        for entry in to_delete:
            await self.db.delete(entry)

        await self.db.flush()
        return len(to_delete)

    async def decay_access_counts(self) -> int:
        """
        Decay access counts for time-based accuracy.
        Run daily to reset 7-day and 30-day counters.
        """
        # Reset 7-day counts for entries older than 7 days
        seven_days_ago = datetime.utcnow() - timedelta(days=7)
        
        stmt = (
            select(RecentHostel)
            .where(RecentHostel.last_accessed < seven_days_ago)
        )

        result = await self.db.execute(stmt)
        entries = result.scalars().all()

        for entry in entries:
            entry.access_count_last_7_days = 0
            entry.frequency_score = self._calculate_frequency_score(entry)

        await self.db.flush()
        return len(entries)

    # ==================== FAVORITE HOSTELS ====================

    async def add_favorite(
        self,
        admin_id: UUID,
        hostel_id: UUID,
        custom_label: Optional[str] = None,
        notes: Optional[str] = None,
        color_code: Optional[str] = None,
        display_order: int = 0
    ) -> FavoriteHostel:
        """Add hostel to favorites."""
        # Check for existing favorite
        existing = await self.find_favorite(admin_id, hostel_id)
        if existing and not existing.is_deleted:
            raise DuplicateError(f"Hostel {hostel_id} already in favorites")

        favorite = FavoriteHostel(
            admin_id=admin_id,
            hostel_id=hostel_id,
            custom_label=custom_label,
            notes=notes,
            color_code=color_code,
            display_order=display_order,
            added_to_favorites=datetime.utcnow()
        )

        self.db.add(favorite)
        await self.db.flush()
        return favorite

    async def find_favorite(
        self,
        admin_id: UUID,
        hostel_id: UUID
    ) -> Optional[FavoriteHostel]:
        """Find specific favorite."""
        stmt = (
            select(FavoriteHostel)
            .where(FavoriteHostel.admin_id == admin_id)
            .where(FavoriteHostel.hostel_id == hostel_id)
            .where(FavoriteHostel.is_deleted == False)
        )

        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()

    async def get_favorites(
        self,
        admin_id: UUID,
        include_stats: bool = True
    ) -> List[FavoriteHostel]:
        """Get all favorites for admin."""
        stmt = (
            select(FavoriteHostel)
            .where(FavoriteHostel.admin_id == admin_id)
            .where(FavoriteHostel.is_deleted == False)
            .options(selectinload(FavoriteHostel.hostel))
            .order_by(FavoriteHostel.display_order, FavoriteHostel.added_to_favorites)
        )

        result = await self.db.execute(stmt)
        favorites = result.unique().scalars().all()

        # Update quick stats if requested
        if include_stats:
            for favorite in favorites:
                await self._update_favorite_stats(favorite)

        return favorites

    async def update_favorite(
        self,
        favorite_id: UUID,
        updates: Dict[str, Any]
    ) -> FavoriteHostel:
        """Update favorite hostel settings."""
        favorite = await self.db.get(FavoriteHostel, favorite_id)
        if not favorite:
            raise EntityNotFoundError(f"Favorite {favorite_id} not found")

        for key, value in updates.items():
            if hasattr(favorite, key):
                setattr(favorite, key, value)

        await self.db.flush()
        return favorite

    async def remove_favorite(
        self,
        admin_id: UUID,
        hostel_id: UUID
    ) -> bool:
        """Remove hostel from favorites (soft delete)."""
        favorite = await self.find_favorite(admin_id, hostel_id)
        if not favorite:
            return False

        favorite.is_deleted = True
        favorite.deleted_at = datetime.utcnow()
        await self.db.flush()
        return True

    async def reorder_favorites(
        self,
        admin_id: UUID,
        ordered_hostel_ids: List[UUID]
    ) -> List[FavoriteHostel]:
        """Reorder favorites based on provided sequence."""
        favorites = await self.get_favorites(admin_id, include_stats=False)
        
        favorite_map = {f.hostel_id: f for f in favorites}

        updated = []
        for idx, hostel_id in enumerate(ordered_hostel_ids):
            if hostel_id in favorite_map:
                favorite = favorite_map[hostel_id]
                favorite.display_order = idx
                updated.append(favorite)

        await self.db.flush()
        return updated

    async def _update_favorite_stats(self, favorite: FavoriteHostel) -> None:
        """Update cached quick stats for favorite."""
        # This would typically query real data
        # Simplified here
        favorite.current_occupancy = Decimal('75.50')
        favorite.pending_items = 5
        favorite.last_accessed = datetime.utcnow()

    # ==================== QUICK STATS ====================

    async def get_hostel_quick_stats(
        self,
        hostel_id: UUID,
        refresh_if_stale: bool = True
    ) -> Optional[HostelQuickStats]:
        """Get quick stats for hostel."""
        stmt = (
            select(HostelQuickStats)
            .where(HostelQuickStats.hostel_id == hostel_id)
        )

        result = await self.db.execute(stmt)
        stats = result.scalar_one_or_none()

        if stats and refresh_if_stale and stats.is_stale:
            await self.refresh_quick_stats(hostel_id)
            # Reload
            result = await self.db.execute(stmt)
            stats = result.scalar_one_or_none()

        return stats

    async def refresh_quick_stats(
        self,
        hostel_id: UUID,
        stats_data: Optional[Dict[str, Any]] = None
    ) -> HostelQuickStats:
        """Refresh quick stats for hostel."""
        stmt = (
            select(HostelQuickStats)
            .where(HostelQuickStats.hostel_id == hostel_id)
        )

        result = await self.db.execute(stmt)
        stats = result.scalar_one_or_none()

        if not stats:
            stats = HostelQuickStats(hostel_id=hostel_id)
            self.db.add(stats)

        if stats_data:
            # Use provided data
            stats.total_students = stats_data.get('total_students', 0)
            stats.active_students = stats_data.get('active_students', 0)
            stats.total_capacity = stats_data.get('total_capacity', 0)
            stats.available_beds = stats_data.get('available_beds', 0)
            stats.occupancy_percentage = Decimal(str(stats_data.get('occupancy_percentage', 0)))
            stats.pending_tasks = stats_data.get('pending_tasks', 0)
            stats.urgent_alerts = stats_data.get('urgent_alerts', 0)
            stats.pending_bookings = stats_data.get('pending_bookings', 0)
            stats.open_complaints = stats_data.get('open_complaints', 0)
            stats.maintenance_requests = stats_data.get('maintenance_requests', 0)
            stats.revenue_this_month = Decimal(str(stats_data.get('revenue_this_month', 0)))
            stats.outstanding_payments = Decimal(str(stats_data.get('outstanding_payments', 0)))
            stats.health_score = Decimal(str(stats_data.get('health_score', 0)))
            stats.status_indicator = stats_data.get('status_indicator', 'normal')
            stats.requires_attention = stats_data.get('requires_attention', False)
        else:
            # Calculate from database (simplified)
            stats.total_students = 0
            stats.active_students = 0
            stats.total_capacity = 0
            stats.available_beds = 0
            stats.occupancy_percentage = Decimal('0.00')
            stats.pending_tasks = 0
            stats.urgent_alerts = 0
            stats.health_score = Decimal('0.00')
            stats.status_indicator = 'normal'

        stats.last_updated = datetime.utcnow()
        await self.db.flush()
        return stats

    async def bulk_refresh_stats(
        self,
        hostel_ids: List[UUID]
    ) -> List[HostelQuickStats]:
        """Refresh stats for multiple hostels."""
        stats_list = []
        for hostel_id in hostel_ids:
            stats = await self.refresh_quick_stats(hostel_id)
            stats_list.append(stats)
        return stats_list

    # ==================== SELECTOR CACHE ====================

    async def get_selector_cache(
        self,
        admin_id: UUID,
        refresh_if_stale: bool = True
    ) -> Optional[HostelSelectorCache]:
        """Get pre-computed selector cache for admin."""
        stmt = (
            select(HostelSelectorCache)
            .where(HostelSelectorCache.admin_id == admin_id)
        )

        result = await self.db.execute(stmt)
        cache = result.scalar_one_or_none()

        if cache and refresh_if_stale and cache.is_stale:
            await self.rebuild_selector_cache(admin_id)
            # Reload
            result = await self.db.execute(stmt)
            cache = result.scalar_one_or_none()

        return cache

    async def rebuild_selector_cache(
        self,
        admin_id: UUID
    ) -> HostelSelectorCache:
        """Rebuild complete selector cache for admin."""
        start_time = datetime.utcnow()

        # Get or create cache
        stmt = (
            select(HostelSelectorCache)
            .where(HostelSelectorCache.admin_id == admin_id)
        )

        result = await self.db.execute(stmt)
        cache = result.scalar_one_or_none()

        if not cache:
            cache = HostelSelectorCache(admin_id=admin_id)
            self.db.add(cache)

        # Get admin's assignments
        from app.repositories.admin.admin_hostel_assignment_repository import (
            AdminHostelAssignmentRepository
        )
        
        assignment_repo = AdminHostelAssignmentRepository(self.db)
        assignments = await assignment_repo.get_admin_assignments(admin_id)

        # Build cache data
        cache.total_hostels = len(assignments)
        cache.active_hostels = len([a for a in assignments if a.is_active])

        # Recent hostel IDs
        recent = await self.get_recent_hostels(admin_id, limit=10)
        cache.recent_hostel_ids = [str(r.hostel_id) for r in recent]

        # Favorite hostel IDs
        favorites = await self.get_favorites(admin_id, include_stats=False)
        cache.favorite_hostel_ids = [str(f.hostel_id) for f in favorites]

        # Hostels requiring attention
        attention_required = []
        for assignment in assignments:
            stats = await self.get_hostel_quick_stats(
                assignment.hostel_id,
                refresh_if_stale=False
            )
            if stats and (stats.urgent_alerts > 0 or stats.requires_attention):
                attention_required.append(str(assignment.hostel_id))

        cache.attention_required_ids = attention_required

        # Aggregate stats
        total_pending = 0
        total_alerts = 0
        occupancy_sum = Decimal('0.00')

        for assignment in assignments:
            stats = await self.get_hostel_quick_stats(
                assignment.hostel_id,
                refresh_if_stale=False
            )
            if stats:
                total_pending += stats.pending_tasks
                total_alerts += stats.urgent_alerts
                occupancy_sum += stats.occupancy_percentage

        cache.total_pending_tasks = total_pending
        cache.total_urgent_alerts = total_alerts
        cache.avg_occupancy_percentage = (
            occupancy_sum / cache.total_hostels
            if cache.total_hostels > 0 else Decimal('0.00')
        )

        # Build complete hostel data
        hostels_data = {}
        for assignment in assignments:
            stats = await self.get_hostel_quick_stats(
                assignment.hostel_id,
                refresh_if_stale=False
            )
            
            hostels_data[str(assignment.hostel_id)] = {
                'name': assignment.hostel.name if assignment.hostel else None,
                'is_primary': assignment.is_primary,
                'occupancy': float(stats.occupancy_percentage) if stats else 0,
                'pending_tasks': stats.pending_tasks if stats else 0,
                'urgent_alerts': stats.urgent_alerts if stats else 0,
                'status': stats.status_indicator if stats else 'unknown'
            }

        cache.hostels_data = hostels_data

        # Update metadata
        cache.last_updated = datetime.utcnow()
        cache.build_duration_ms = int(
            (datetime.utcnow() - start_time).total_seconds() * 1000
        )

        await self.db.flush()
        return cache

    async def invalidate_selector_cache(
        self,
        admin_id: UUID
    ) -> bool:
        """Force invalidate selector cache."""
        cache = await self.get_selector_cache(admin_id, refresh_if_stale=False)
        if not cache:
            return False

        # Set last_updated to past to force refresh
        cache.last_updated = datetime.utcnow() - timedelta(
            seconds=cache.cache_ttl_seconds + 1
        )
        await self.db.flush()
        return True

    # ==================== ANALYTICS ====================

    async def get_selector_analytics(
        self,
        admin_id: UUID,
        days: int = 30
    ) -> Dict[str, Any]:
        """Get analytics about hostel selector usage."""
        cutoff = datetime.utcnow() - timedelta(days=days)

        # Most accessed hostels
        recent_stmt = (
            select(
                RecentHostel.hostel_id,
                Hostel.name,
                RecentHostel.access_count,
                RecentHostel.frequency_score
            )
            .join(Hostel, RecentHostel.hostel_id == Hostel.id)
            .where(RecentHostel.admin_id == admin_id)
            .where(RecentHostel.last_accessed >= cutoff)
            .order_by(desc(RecentHostel.access_count))
            .limit(5)
        )

        recent_result = await self.db.execute(recent_stmt)
        most_accessed = [
            {
                'hostel_id': row[0],
                'hostel_name': row[1],
                'access_count': row[2],
                'frequency_score': float(row[3])
            }
            for row in recent_result
        ]

        # Favorite count
        fav_count_stmt = (
            select(func.count(FavoriteHostel.id))
            .where(FavoriteHostel.admin_id == admin_id)
            .where(FavoriteHostel.is_deleted == False)
        )
        favorite_count = await self.db.scalar(fav_count_stmt) or 0

        return {
            'period_days': days,
            'most_accessed_hostels': most_accessed,
            'total_favorites': favorite_count,
            'unique_hostels_accessed': len(most_accessed)
        }

# --- File: C:\Hostel-Main\app\repositories\admin\multi_hostel_dashboard_repository.py ---
"""
Multi-Hostel Dashboard Repository

Manages aggregated dashboard data, cross-hostel analytics,
performance comparisons, and portfolio-wide insights.
"""

from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from datetime import datetime, date, timedelta
from decimal import Decimal
from sqlalchemy import select, and_, or_, func, desc, asc, case
from sqlalchemy.orm import Session, selectinload, joinedload
from sqlalchemy.exc import IntegrityError

from app.models.admin.multi_hostel_dashboard import (
    MultiHostelDashboard,
    CrossHostelMetric,
    HostelPerformanceRanking,
    DashboardWidget,
    DashboardSnapshot
)
from app.models.admin.admin_user import AdminUser
from app.models.hostel.hostel import Hostel
from app.repositories.base.base_repository import BaseRepository
from app.core.exceptions import (
    EntityNotFoundError,
    ValidationError
)


class MultiHostelDashboardRepository(BaseRepository[MultiHostelDashboard]):
    """
    Multi-hostel dashboard management with:
    - Aggregated metrics across hostels
    - Cross-hostel comparisons
    - Performance rankings
    - Customizable widgets
    - Historical snapshots
    """

    def __init__(self, db: Session):
        super().__init__(MultiHostelDashboard, db)

    # ==================== DASHBOARD MANAGEMENT ====================

    async def get_dashboard(
        self,
        admin_id: UUID,
        dashboard_date: Optional[date] = None,
        refresh_if_stale: bool = True
    ) -> Optional[MultiHostelDashboard]:
        """Get dashboard for admin and date."""
        if not dashboard_date:
            dashboard_date = date.today()

        stmt = (
            select(MultiHostelDashboard)
            .where(MultiHostelDashboard.admin_id == admin_id)
            .where(MultiHostelDashboard.dashboard_date == dashboard_date)
            .options(
                selectinload(MultiHostelDashboard.cross_hostel_metrics),
                selectinload(MultiHostelDashboard.performance_rankings)
            )
        )

        result = await self.db.execute(stmt)
        dashboard = result.unique().scalar_one_or_none()

        if dashboard and refresh_if_stale and dashboard.is_stale:
            await self.refresh_dashboard(admin_id, dashboard_date)
            # Reload
            result = await self.db.execute(stmt)
            dashboard = result.unique().scalar_one_or_none()

        return dashboard

    async def refresh_dashboard(
        self,
        admin_id: UUID,
        dashboard_date: Optional[date] = None,
        force: bool = False
    ) -> MultiHostelDashboard:
        """
        Refresh dashboard with latest data.
        
        Args:
            admin_id: Admin user ID
            dashboard_date: Dashboard date (default: today)
            force: Force refresh even if not stale
            
        Returns:
            Refreshed dashboard
        """
        start_time = datetime.utcnow()
        
        if not dashboard_date:
            dashboard_date = date.today()

        # Get or create dashboard
        dashboard = await self.get_dashboard(
            admin_id,
            dashboard_date,
            refresh_if_stale=False
        )

        if not dashboard:
            dashboard = MultiHostelDashboard(
                admin_id=admin_id,
                dashboard_date=dashboard_date,
                period_start=dashboard_date.replace(day=1),  # First of month
                period_end=dashboard_date
            )
            self.db.add(dashboard)
            await self.db.flush()

        # Skip refresh if not stale and not forced
        if not force and not dashboard.is_stale:
            return dashboard

        # Get admin's hostels
        from app.repositories.admin.admin_hostel_assignment_repository import (
            AdminHostelAssignmentRepository
        )
        
        assignment_repo = AdminHostelAssignmentRepository(self.db)
        assignments = await assignment_repo.get_admin_assignments(admin_id)

        # Update portfolio statistics
        dashboard.total_hostels = len(assignments)
        dashboard.active_hostels = len([a for a in assignments if a.is_active])

        # Aggregate student statistics
        total_students = 0
        active_students = 0
        total_capacity = 0
        occupancy_list = []

        # Workload statistics
        total_pending = 0
        total_alerts = 0
        total_complaints = 0
        tasks_today = 0

        # Financial statistics
        total_revenue = Decimal('0.00')
        total_outstanding = Decimal('0.00')
        collection_rates = []

        # Performance tracking
        best_performer = None
        best_score = Decimal('0.00')
        worst_performer = None
        worst_score = Decimal('100.00')

        # Aggregate data from each hostel
        from app.repositories.admin.hostel_selector_repository import (
            HostelSelectorRepository
        )
        
        selector_repo = HostelSelectorRepository(self.db)

        for assignment in assignments:
            stats = await selector_repo.get_hostel_quick_stats(
                assignment.hostel_id,
                refresh_if_stale=True
            )

            if stats:
                total_students += stats.total_students
                active_students += stats.active_students
                total_capacity += stats.total_capacity
                occupancy_list.append(stats.occupancy_percentage)

                total_pending += stats.pending_tasks
                total_alerts += stats.urgent_alerts
                total_complaints += stats.open_complaints

                total_revenue += stats.revenue_this_month
                total_outstanding += stats.outstanding_payments
                if stats.collection_rate:
                    collection_rates.append(stats.collection_rate)

                # Track best/worst performers
                if stats.health_score > best_score:
                    best_score = stats.health_score
                    best_performer = assignment.hostel_id

                if stats.health_score < worst_score:
                    worst_score = stats.health_score
                    worst_performer = assignment.hostel_id

        # Update dashboard aggregates
        dashboard.total_students = total_students
        dashboard.active_students = active_students
        dashboard.total_capacity = total_capacity

        # Calculate occupancy metrics
        if occupancy_list:
            dashboard.avg_occupancy_percentage = sum(occupancy_list) / len(occupancy_list)
            dashboard.highest_occupancy_percentage = max(occupancy_list)
            dashboard.lowest_occupancy_percentage = min(occupancy_list)
        else:
            dashboard.avg_occupancy_percentage = Decimal('0.00')
            dashboard.highest_occupancy_percentage = Decimal('0.00')
            dashboard.lowest_occupancy_percentage = Decimal('0.00')

        # Update workload
        dashboard.total_pending_tasks = total_pending
        dashboard.total_urgent_alerts = total_alerts
        dashboard.total_open_complaints = total_complaints
        dashboard.tasks_completed_today = tasks_today

        # Update financials
        dashboard.total_revenue_this_month = total_revenue
        dashboard.total_outstanding_payments = total_outstanding
        if collection_rates:
            dashboard.avg_collection_rate = sum(collection_rates) / len(collection_rates)
        else:
            dashboard.avg_collection_rate = Decimal('0.00')

        # Calculate portfolio health
        dashboard.portfolio_health_score = self._calculate_portfolio_health(
            dashboard
        )

        # Determine attention level
        dashboard.attention_level = self._determine_attention_level(dashboard)
        dashboard.hostels_requiring_attention = len([
            s for s in occupancy_list if s < Decimal('50.00')
        ])

        # Set top/bottom performers
        dashboard.top_performer_hostel_id = best_performer
        dashboard.top_performer_score = best_score
        dashboard.bottom_performer_hostel_id = worst_performer
        dashboard.bottom_performer_score = worst_score

        # Update metadata
        dashboard.last_updated = datetime.utcnow()
        dashboard.build_duration_ms = int(
            (datetime.utcnow() - start_time).total_seconds() * 1000
        )

        await self.db.flush()

        # Refresh cross-hostel metrics
        await self._refresh_cross_hostel_metrics(dashboard.id, assignments)

        # Refresh performance rankings
        await self._refresh_performance_rankings(dashboard.id, assignments)

        return dashboard

    def _calculate_portfolio_health(
        self,
        dashboard: MultiHostelDashboard
    ) -> Decimal:
        """Calculate overall portfolio health score (0-100)."""
        scores = []

        # Occupancy score (0-30 points)
        occupancy_score = min(
            float(dashboard.avg_occupancy_percentage) / 100 * 30,
            30
        )
        scores.append(occupancy_score)

        # Financial health (0-30 points)
        if dashboard.total_revenue_this_month > 0:
            outstanding_ratio = float(
                dashboard.total_outstanding_payments / dashboard.total_revenue_this_month
            )
            financial_score = max(0, 30 - (outstanding_ratio * 30))
        else:
            financial_score = 0
        scores.append(financial_score)

        # Operational efficiency (0-20 points)
        if dashboard.total_hostels > 0:
            tasks_per_hostel = dashboard.total_pending_tasks / dashboard.total_hostels
            operational_score = max(0, 20 - tasks_per_hostel)
        else:
            operational_score = 0
        scores.append(operational_score)

        # Alert management (0-20 points)
        alert_score = max(0, 20 - dashboard.total_urgent_alerts)
        scores.append(alert_score)

        total_score = sum(scores)
        return Decimal(str(total_score)).quantize(Decimal('0.01'))

    def _determine_attention_level(
        self,
        dashboard: MultiHostelDashboard
    ) -> str:
        """Determine overall attention level required."""
        if dashboard.total_urgent_alerts > 10:
            return 'critical'
        elif dashboard.total_urgent_alerts > 5 or dashboard.hostels_requiring_attention > 2:
            return 'high'
        elif dashboard.total_pending_tasks > 50:
            return 'medium'
        else:
            return 'low'

    # ==================== CROSS-HOSTEL METRICS ====================

    async def _refresh_cross_hostel_metrics(
        self,
        dashboard_id: UUID,
        assignments: List
    ) -> List[CrossHostelMetric]:
        """Refresh cross-hostel metric comparisons."""
        # Delete existing metrics
        delete_stmt = select(CrossHostelMetric).where(
            CrossHostelMetric.dashboard_id == dashboard_id
        )
        result = await self.db.execute(delete_stmt)
        existing = result.scalars().all()
        for metric in existing:
            await self.db.delete(metric)

        # Define metrics to compare
        metrics_to_compare = [
            ('occupancy', 'Occupancy Rate', '%'),
            ('revenue', 'Monthly Revenue', 'currency'),
            ('collection_rate', 'Collection Rate', '%'),
            ('student_count', 'Active Students', 'count'),
        ]

        from app.repositories.admin.hostel_selector_repository import (
            HostelSelectorRepository
        )
        
        selector_repo = HostelSelectorRepository(self.db)

        new_metrics = []

        for metric_name, display_name, unit in metrics_to_compare:
            # Collect values from all hostels
            values = {}
            
            for assignment in assignments:
                stats = await selector_repo.get_hostel_quick_stats(
                    assignment.hostel_id,
                    refresh_if_stale=False
                )

                if stats:
                    if metric_name == 'occupancy':
                        value = stats.occupancy_percentage
                    elif metric_name == 'revenue':
                        value = stats.revenue_this_month
                    elif metric_name == 'collection_rate':
                        value = stats.collection_rate
                    elif metric_name == 'student_count':
                        value = Decimal(str(stats.active_students))
                    else:
                        value = Decimal('0.00')

                    values[assignment.hostel_id] = value

            if not values:
                continue

            # Calculate statistics
            values_list = list(values.values())
            portfolio_avg = sum(values_list) / len(values_list)
            
            # Find best and worst
            best_hostel = max(values.items(), key=lambda x: x[1])
            worst_hostel = min(values.items(), key=lambda x: x[1])

            # Calculate variance
            variance = max(values_list) - min(values_list)

            metric = CrossHostelMetric(
                dashboard_id=dashboard_id,
                metric_name=metric_name,
                metric_category='operational' if metric_name in ['occupancy', 'student_count'] else 'financial',
                display_unit=unit,
                portfolio_average=portfolio_avg,
                portfolio_median=sorted(values_list)[len(values_list) // 2],
                best_hostel_id=best_hostel[0],
                best_value=best_hostel[1],
                worst_hostel_id=worst_hostel[0],
                worst_value=worst_hostel[1],
                value_range=variance,
                hostel_values=values
            )

            self.db.add(metric)
            new_metrics.append(metric)

        await self.db.flush()
        return new_metrics

    async def get_cross_hostel_metrics(
        self,
        dashboard_id: UUID,
        category: Optional[str] = None
    ) -> List[CrossHostelMetric]:
        """Get cross-hostel metrics with optional category filter."""
        stmt = (
            select(CrossHostelMetric)
            .where(CrossHostelMetric.dashboard_id == dashboard_id)
            .options(
                selectinload(CrossHostelMetric.best_hostel),
                selectinload(CrossHostelMetric.worst_hostel)
            )
        )

        if category:
            stmt = stmt.where(CrossHostelMetric.metric_category == category)

        stmt = stmt.order_by(CrossHostelMetric.metric_name)

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    # ==================== PERFORMANCE RANKINGS ====================

    async def _refresh_performance_rankings(
        self,
        dashboard_id: UUID,
        assignments: List
    ) -> List[HostelPerformanceRanking]:
        """Refresh performance rankings for all hostels."""
        # Delete existing rankings
        delete_stmt = select(HostelPerformanceRanking).where(
            HostelPerformanceRanking.dashboard_id == dashboard_id
        )
        result = await self.db.execute(delete_stmt)
        existing = result.scalars().all()
        for ranking in existing:
            await self.db.delete(ranking)

        from app.repositories.admin.hostel_selector_repository import (
            HostelSelectorRepository
        )
        
        selector_repo = HostelSelectorRepository(self.db)

        # Calculate scores for each hostel
        hostel_scores = []

        for assignment in assignments:
            stats = await selector_repo.get_hostel_quick_stats(
                assignment.hostel_id,
                refresh_if_stale=False
            )

            if not stats:
                continue

            # Calculate dimensional scores
            occupancy_score = min(float(stats.occupancy_percentage), 100)
            
            financial_score = 0
            if stats.revenue_this_month > 0:
                collection_ratio = float(
                    (stats.revenue_this_month - stats.outstanding_payments) / 
                    stats.revenue_this_month
                )
                financial_score = collection_ratio * 100

            operational_score = max(0, 100 - (stats.pending_tasks * 2))
            
            satisfaction_score = float(stats.student_satisfaction_score or 0)

            # Calculate overall score (weighted average)
            overall_score = (
                occupancy_score * 0.3 +
                financial_score * 0.3 +
                operational_score * 0.2 +
                satisfaction_score * 0.2
            )

            hostel_scores.append({
                'hostel_id': assignment.hostel_id,
                'overall_score': Decimal(str(overall_score)),
                'occupancy_score': Decimal(str(occupancy_score)),
                'financial_score': Decimal(str(financial_score)),
                'operational_score': Decimal(str(operational_score)),
                'satisfaction_score': Decimal(str(satisfaction_score))
            })

        # Sort by overall score
        hostel_scores.sort(key=lambda x: x['overall_score'], reverse=True)

        # Create rankings
        rankings = []
        for rank, score_data in enumerate(hostel_scores, 1):
            # Determine performance category
            score = float(score_data['overall_score'])
            if score >= 90:
                category = 'excellent'
            elif score >= 75:
                category = 'good'
            elif score >= 60:
                category = 'fair'
            else:
                category = 'poor'

            # Identify strengths and weaknesses
            strengths = []
            weaknesses = []

            scores = {
                'occupancy': float(score_data['occupancy_score']),
                'financial': float(score_data['financial_score']),
                'operational': float(score_data['operational_score']),
                'satisfaction': float(score_data['satisfaction_score'])
            }

            for key, value in scores.items():
                if value >= 80:
                    strengths.append(key)
                elif value < 60:
                    weaknesses.append(key)

            ranking = HostelPerformanceRanking(
                dashboard_id=dashboard_id,
                hostel_id=score_data['hostel_id'],
                overall_rank=rank,
                overall_score=score_data['overall_score'],
                occupancy_score=score_data['occupancy_score'],
                financial_score=score_data['financial_score'],
                operational_score=score_data['operational_score'],
                satisfaction_score=score_data['satisfaction_score'],
                occupancy_rank=rank,  # Simplified - would need separate ranking
                financial_rank=rank,
                operational_rank=rank,
                satisfaction_rank=rank,
                performance_category=category,
                top_strengths=strengths[:3] if strengths else None,
                areas_for_improvement=weaknesses[:3] if weaknesses else None
            )

            self.db.add(ranking)
            rankings.append(ranking)

        await self.db.flush()
        return rankings

    async def get_performance_rankings(
        self,
        dashboard_id: UUID,
        min_rank: Optional[int] = None,
        max_rank: Optional[int] = None
    ) -> List[HostelPerformanceRanking]:
        """Get performance rankings with optional rank filter."""
        stmt = (
            select(HostelPerformanceRanking)
            .where(HostelPerformanceRanking.dashboard_id == dashboard_id)
            .options(selectinload(HostelPerformanceRanking.hostel))
            .order_by(HostelPerformanceRanking.overall_rank)
        )

        if min_rank:
            stmt = stmt.where(HostelPerformanceRanking.overall_rank >= min_rank)
        if max_rank:
            stmt = stmt.where(HostelPerformanceRanking.overall_rank <= max_rank)

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    async def get_top_performers(
        self,
        dashboard_id: UUID,
        count: int = 5
    ) -> List[HostelPerformanceRanking]:
        """Get top N performing hostels."""
        return await self.get_performance_rankings(
            dashboard_id,
            max_rank=count
        )

    async def get_underperformers(
        self,
        dashboard_id: UUID,
        threshold_score: float = 60.0
    ) -> List[HostelPerformanceRanking]:
        """Get hostels performing below threshold."""
        stmt = (
            select(HostelPerformanceRanking)
            .where(HostelPerformanceRanking.dashboard_id == dashboard_id)
            .where(HostelPerformanceRanking.overall_score < threshold_score)
            .options(selectinload(HostelPerformanceRanking.hostel))
            .order_by(HostelPerformanceRanking.overall_score)
        )

        result = await self.db.execute(stmt)
        return result.unique().scalars().all()

    # ==================== DASHBOARD WIDGETS ====================

    async def get_admin_widgets(
        self,
        admin_id: UUID,
        visible_only: bool = True
    ) -> List[DashboardWidget]:
        """Get dashboard widgets for admin."""
        stmt = (
            select(DashboardWidget)
            .where(DashboardWidget.admin_id == admin_id)
            .order_by(
                DashboardWidget.position_row,
                DashboardWidget.position_col
            )
        )

        if visible_only:
            stmt = stmt.where(DashboardWidget.is_visible == True)

        result = await self.db.execute(stmt)
        return result.scalars().all()

    async def create_widget(
        self,
        admin_id: UUID,
        widget_type: str,
        widget_title: str,
        widget_config: Dict[str, Any],
        position: Optional[Tuple[int, int]] = None
    ) -> DashboardWidget:
        """Create new dashboard widget."""
        if position:
            row, col = position
        else:
            # Find next available position
            row, col = await self._find_next_widget_position(admin_id)

        widget = DashboardWidget(
            admin_id=admin_id,
            widget_type=widget_type,
            widget_title=widget_title,
            widget_config=widget_config,
            position_row=row,
            position_col=col,
            data_source=widget_config.get('data_source', 'default'),
            is_visible=True
        )

        self.db.add(widget)
        await self.db.flush()
        return widget

    async def update_widget(
        self,
        widget_id: UUID,
        updates: Dict[str, Any]
    ) -> DashboardWidget:
        """Update widget configuration."""
        widget = await self.db.get(DashboardWidget, widget_id)
        if not widget:
            raise EntityNotFoundError(f"Widget {widget_id} not found")

        for key, value in updates.items():
            if hasattr(widget, key):
                setattr(widget, key, value)

        await self.db.flush()
        return widget

    async def delete_widget(self, widget_id: UUID) -> bool:
        """Delete dashboard widget."""
        widget = await self.db.get(DashboardWidget, widget_id)
        if not widget:
            return False

        await self.db.delete(widget)
        await self.db.flush()
        return True

    async def refresh_widget_data(
        self,
        widget_id: UUID
    ) -> DashboardWidget:
        """Refresh cached data for widget."""
        widget = await self.db.get(DashboardWidget, widget_id)
        if not widget:
            raise EntityNotFoundError(f"Widget {widget_id} not found")

        # Widget data refresh logic would go here
        # This would depend on widget type and data source
        
        widget.last_refreshed = datetime.utcnow()
        await self.db.flush()
        return widget

    async def _find_next_widget_position(
        self,
        admin_id: UUID
    ) -> Tuple[int, int]:
        """Find next available widget position."""
        stmt = (
            select(
                func.max(DashboardWidget.position_row).label('max_row'),
                func.max(DashboardWidget.position_col).label('max_col')
            )
            .where(DashboardWidget.admin_id == admin_id)
        )

        result = await self.db.execute(stmt)
        row = result.first()

        if row and row.max_row is not None:
            # Place in next column, or new row if at column limit
            if row.max_col < 3:  # Assuming 4 columns max
                return (row.max_row, row.max_col + 1)
            else:
                return (row.max_row + 1, 0)
        else:
            # First widget
            return (0, 0)

    # ==================== DASHBOARD SNAPSHOTS ====================

    async def create_snapshot(
        self,
        admin_id: UUID,
        snapshot_type: str = 'daily',
        retention_days: int = 90
    ) -> DashboardSnapshot:
        """Create dashboard snapshot for historical tracking."""
        # Get current dashboard
        dashboard = await self.get_dashboard(admin_id, refresh_if_stale=True)
        if not dashboard:
            raise ValidationError(f"No dashboard found for admin {admin_id}")

        # Create snapshot
        snapshot = DashboardSnapshot(
            admin_id=admin_id,
            snapshot_timestamp=datetime.utcnow(),
            snapshot_date=date.today(),
            snapshot_type=snapshot_type,
            dashboard_data={
                'total_hostels': dashboard.total_hostels,
                'avg_occupancy': float(dashboard.avg_occupancy_percentage),
                'total_revenue': float(dashboard.total_revenue_this_month),
                'portfolio_health': float(dashboard.portfolio_health_score),
                'pending_tasks': dashboard.total_pending_tasks,
                'urgent_alerts': dashboard.total_urgent_alerts
            },
            total_hostels=dashboard.total_hostels,
            avg_occupancy=dashboard.avg_occupancy_percentage,
            total_revenue=dashboard.total_revenue_this_month,
            portfolio_health_score=dashboard.portfolio_health_score,
            retention_days=retention_days
        )

        self.db.add(snapshot)
        await self.db.flush()
        return snapshot

    async def get_snapshots(
        self,
        admin_id: UUID,
        snapshot_type: Optional[str] = None,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
        limit: int = 50
    ) -> List[DashboardSnapshot]:
        """Get dashboard snapshots with filters."""
        stmt = (
            select(DashboardSnapshot)
            .where(DashboardSnapshot.admin_id == admin_id)
            .order_by(desc(DashboardSnapshot.snapshot_date))
            .limit(limit)
        )

        if snapshot_type:
            stmt = stmt.where(DashboardSnapshot.snapshot_type == snapshot_type)

        if start_date:
            stmt = stmt.where(DashboardSnapshot.snapshot_date >= start_date)

        if end_date:
            stmt = stmt.where(DashboardSnapshot.snapshot_date <= end_date)

        result = await self.db.execute(stmt)
        return result.scalars().all()

    async def cleanup_old_snapshots(self) -> int:
        """Delete snapshots past their retention period."""
        stmt = (
            select(DashboardSnapshot)
            .where(DashboardSnapshot.should_be_deleted == True)
        )

        result = await self.db.execute(stmt)
        old_snapshots = result.scalars().all()

        for snapshot in old_snapshots:
            await self.db.delete(snapshot)

        await self.db.flush()
        return len(old_snapshots)

    async def get_trend_data(
        self,
        admin_id: UUID,
        metric: str,
        days: int = 30
    ) -> List[Dict[str, Any]]:
        """Get trend data for specific metric from snapshots."""
        start_date = date.today() - timedelta(days=days)

        snapshots = await self.get_snapshots(
            admin_id=admin_id,
            start_date=start_date,
            snapshot_type='daily'
        )

        trend_data = []
        for snapshot in reversed(snapshots):  # Chronological order
            value = None
            
            if metric == 'occupancy':
                value = float(snapshot.avg_occupancy)
            elif metric == 'revenue':
                value = float(snapshot.total_revenue)
            elif metric == 'health':
                value = float(snapshot.portfolio_health_score)
            elif metric == 'hostels':
                value = snapshot.total_hostels

            if value is not None:
                trend_data.append({
                    'date': snapshot.snapshot_date,
                    'value': value
                })

        return trend_data

    # ==================== ANALYTICS ====================

    async def get_portfolio_summary(
        self,
        admin_id: UUID
    ) -> Dict[str, Any]:
        """Get comprehensive portfolio summary."""
        dashboard = await self.get_dashboard(admin_id, refresh_if_stale=True)
        if not dashboard:
            return {}

        # Get top performers
        top_performers = await self.get_top_performers(dashboard.id, count=3)
        
        # Get underperformers
        underperformers = await self.get_underperformers(
            dashboard.id,
            threshold_score=60.0
        )

        # Get cross-hostel metrics
        metrics = await self.get_cross_hostel_metrics(dashboard.id)

        return {
            'portfolio_health': float(dashboard.portfolio_health_score),
            'attention_level': dashboard.attention_level,
            'total_hostels': dashboard.total_hostels,
            'avg_occupancy': float(dashboard.avg_occupancy_percentage),
            'total_revenue': float(dashboard.total_revenue_this_month),
            'outstanding_payments': float(dashboard.total_outstanding_payments),
            'pending_tasks': dashboard.total_pending_tasks,
            'urgent_alerts': dashboard.total_urgent_alerts,
            'top_performers': [
                {
                    'hostel_id': r.hostel_id,
                    'rank': r.overall_rank,
                    'score': float(r.overall_score),
                    'category': r.performance_category
                }
                for r in top_performers
            ],
            'underperformers': [
                {
                    'hostel_id': r.hostel_id,
                    'rank': r.overall_rank,
                    'score': float(r.overall_score),
                    'areas_for_improvement': r.areas_for_improvement
                }
                for r in underperformers
            ],
            'key_metrics': [
                {
                    'name': m.metric_name,
                    'avg': float(m.portfolio_average),
                    'best': float(m.best_value),
                    'worst': float(m.worst_value)
                }
                for m in metrics[:5]  # Top 5 metrics
            ]
        }

# --- File: C:\Hostel-Main\app\repositories\admin\__init__.py ---
"""
Admin Module Repositories

Provides data access layer for all admin-related operations including
user management, permissions, assignments, overrides, context switching,
hostel selection, and multi-hostel dashboards.
"""

from app.repositories.admin.admin_user_repository import AdminUserRepository
from app.repositories.admin.admin_permissions_repository import AdminPermissionsRepository
from app.repositories.admin.admin_hostel_assignment_repository import AdminHostelAssignmentRepository
from app.repositories.admin.admin_override_repository import AdminOverrideRepository
from app.repositories.admin.hostel_context_repository import HostelContextRepository
from app.repositories.admin.hostel_selector_repository import HostelSelectorRepository
from app.repositories.admin.multi_hostel_dashboard_repository import MultiHostelDashboardRepository


__all__ = [
    # Core Admin Management
    "AdminUserRepository",
    "AdminPermissionsRepository",
    
    # Assignment & Access Control
    "AdminHostelAssignmentRepository",
    "AdminOverrideRepository",
    
    # UX & Performance
    "HostelContextRepository",
    "HostelSelectorRepository",
    
    # Analytics & Reporting
    "MultiHostelDashboardRepository",
]


# Repository factory for dependency injection
class AdminRepositoryFactory:
    """
    Factory for creating admin repository instances.
    Supports dependency injection and centralized configuration.
    """
    
    def __init__(self, db_session):
        """
        Initialize factory with database session.
        
        Args:
            db_session: SQLAlchemy session
        """
        self.db = db_session
        self._repositories = {}
    
    def get_admin_user_repository(self) -> AdminUserRepository:
        """Get or create AdminUserRepository instance."""
        if 'admin_user' not in self._repositories:
            self._repositories['admin_user'] = AdminUserRepository(self.db)
        return self._repositories['admin_user']
    
    def get_admin_permissions_repository(self) -> AdminPermissionsRepository:
        """Get or create AdminPermissionsRepository instance."""
        if 'admin_permissions' not in self._repositories:
            self._repositories['admin_permissions'] = AdminPermissionsRepository(self.db)
        return self._repositories['admin_permissions']
    
    def get_admin_assignment_repository(self) -> AdminHostelAssignmentRepository:
        """Get or create AdminHostelAssignmentRepository instance."""
        if 'admin_assignment' not in self._repositories:
            self._repositories['admin_assignment'] = AdminHostelAssignmentRepository(self.db)
        return self._repositories['admin_assignment']
    
    def get_admin_override_repository(self) -> AdminOverrideRepository:
        """Get or create AdminOverrideRepository instance."""
        if 'admin_override' not in self._repositories:
            self._repositories['admin_override'] = AdminOverrideRepository(self.db)
        return self._repositories['admin_override']
    
    def get_hostel_context_repository(self) -> HostelContextRepository:
        """Get or create HostelContextRepository instance."""
        if 'hostel_context' not in self._repositories:
            self._repositories['hostel_context'] = HostelContextRepository(self.db)
        return self._repositories['hostel_context']
    
    def get_hostel_selector_repository(self) -> HostelSelectorRepository:
        """Get or create HostelSelectorRepository instance."""
        if 'hostel_selector' not in self._repositories:
            self._repositories['hostel_selector'] = HostelSelectorRepository(self.db)
        return self._repositories['hostel_selector']
    
    def get_dashboard_repository(self) -> MultiHostelDashboardRepository:
        """Get or create MultiHostelDashboardRepository instance."""
        if 'dashboard' not in self._repositories:
            self._repositories['dashboard'] = MultiHostelDashboardRepository(self.db)
        return self._repositories['dashboard']
    
    def clear_cache(self) -> None:
        """Clear all cached repository instances."""
        self._repositories.clear()


# Convenience function for getting repository factory
def get_admin_repository_factory(db_session) -> AdminRepositoryFactory:
    """
    Get admin repository factory instance.
    
    Args:
        db_session: SQLAlchemy database session
        
    Returns:
        AdminRepositoryFactory instance
    """
    return AdminRepositoryFactory(db_session)


# Module metadata
__version__ = "1.0.0"
__author__ = "Hostel Management System Team"
__description__ = "Admin module data access repositories"
