### Combined Content from Folder: C:\Hostel-Main\app\repositories\announcement ###



# ===== Folder: C:\Hostel-Main\app\repositories\announcement =====

# --- File: C:\Hostel-Main\app\repositories\announcement\announcement_aggregate_repository.py ---
"""
Announcement Aggregate Repository

High-level orchestrator for complex announcement operations involving 
multiple sub-repositories and cross-cutting concerns.
"""

from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from decimal import Decimal

from sqlalchemy.orm import Session
from sqlalchemy import func, and_, or_

from app.models.announcement import (
    Announcement,
    AnnouncementTarget,
    AnnouncementSchedule,
    AnnouncementApproval,
    AnnouncementDelivery,
    AnnouncementRecipient,
    EngagementMetric,
)
from app.models.base.enums import (
    AnnouncementCategory,
    AnnouncementStatus,
    Priority,
    TargetAudience,
)
from app.repositories.announcement.announcement_repository import AnnouncementRepository
from app.repositories.announcement.announcement_targeting_repository import AnnouncementTargetingRepository
from app.repositories.announcement.announcement_scheduling_repository import AnnouncementSchedulingRepository
from app.repositories.announcement.announcement_approval_repository import AnnouncementApprovalRepository
from app.repositories.announcement.announcement_delivery_repository import AnnouncementDeliveryRepository
from app.repositories.announcement.announcement_tracking_repository import AnnouncementTrackingRepository
from app.core.exceptions import (
    ResourceNotFoundError,
    ValidationError,
    BusinessLogicError,
)


class AnnouncementAggregateRepository:
    """
    Orchestrator repository for the Announcement module.
    
    Coordinates complex workflows across multiple repositories:
    - Complete announcement lifecycle management
    - Multi-step creation workflows
    - Approval and publication pipelines
    - Batch delivery orchestration
    - Cross-module analytics
    - Data synchronization
    - Cleanup and maintenance
    """
    
    def __init__(self, session: Session):
        self.session = session
        
        # Initialize sub-repositories
        self.announcements = AnnouncementRepository(session)
        self.targeting = AnnouncementTargetingRepository(session)
        self.scheduling = AnnouncementSchedulingRepository(session)
        self.approval = AnnouncementApprovalRepository(session)
        self.delivery = AnnouncementDeliveryRepository(session)
        self.tracking = AnnouncementTrackingRepository(session)
    
    # ==================== Complete Workflows ====================
    
    def create_complete_announcement(
        self,
        hostel_id: UUID,
        created_by_id: UUID,
        announcement_data: Dict[str, Any],
        targeting_data: Dict[str, Any],
        schedule_data: Optional[Dict[str, Any]] = None,
        approval_data: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Create complete announcement with targeting, scheduling, and approval.
        
        This is a transactional workflow that creates all related entities
        in a single operation.
        
        Args:
            hostel_id: Hostel UUID
            created_by_id: Creator user UUID
            announcement_data: Core announcement fields
            targeting_data: Targeting configuration
            schedule_data: Optional scheduling configuration
            approval_data: Optional approval configuration
            
        Returns:
            Dictionary with created entities
        """
        try:
            # 1. Create core announcement
            announcement = self.announcements.create_draft(
                hostel_id=hostel_id,
                created_by_id=created_by_id,
                **announcement_data
            )
            
            # 2. Setup targeting
            target = self.targeting.build_audience_segment(
                announcement_id=announcement.id,
                created_by_id=created_by_id,
                **targeting_data
            )
            
            # 3. Calculate target reach
            reach = self.targeting.calculate_target_reach(
                announcement_id=announcement.id,
                update_cache=True
            )
            
            # Update announcement with recipient count
            announcement.total_recipients = reach['actual_recipients']
            
            # 4. Setup scheduling (if provided)
            schedule = None
            if schedule_data:
                if schedule_data.get('is_recurring'):
                    schedule = self.scheduling.create_recurring_schedule(
                        announcement_id=announcement.id,
                        scheduled_by_id=created_by_id,
                        **schedule_data
                    )
                else:
                    schedule = self.scheduling.create_schedule(
                        announcement_id=announcement.id,
                        scheduled_by_id=created_by_id,
                        **schedule_data
                    )
            
            # 5. Setup approval workflow (if required)
            approval = None
            if approval_data or announcement.requires_approval:
                approval = self.approval.create_approval_request(
                    announcement_id=announcement.id,
                    requested_by_id=created_by_id,
                    **(approval_data or {})
                )
            
            self.session.flush()
            
            return {
                'announcement': announcement,
                'target': target,
                'reach': reach,
                'schedule': schedule,
                'approval': approval,
                'success': True,
                'message': 'Announcement created successfully'
            }
            
        except Exception as e:
            self.session.rollback()
            raise BusinessLogicError(
                f"Failed to create complete announcement: {str(e)}"
            )
    
    def process_approval_and_publish(
        self,
        announcement_id: UUID,
        approved_by_id: UUID,
        approval_notes: Optional[str] = None,
        publish_immediately: bool = True
    ) -> Dict[str, Any]:
        """
        Process approval and optionally publish announcement.
        
        Args:
            announcement_id: Announcement UUID
            approved_by_id: Approver user UUID
            approval_notes: Approval notes
            publish_immediately: Whether to publish immediately
            
        Returns:
            Dictionary with approval and publication results
        """
        try:
            # 1. Get approval request
            approval_request = self.approval.find_by_announcement(announcement_id)
            if not approval_request:
                raise ResourceNotFoundError(
                    f"No approval request found for announcement {announcement_id}"
                )
            
            # 2. Approve announcement
            approval = self.approval.approve_announcement(
                approval_id=approval_request.id,
                approved_by_id=approved_by_id,
                approval_notes=approval_notes,
                auto_publish=publish_immediately
            )
            
            # 3. Publish if requested
            published = False
            if publish_immediately:
                announcement = self.announcements.publish_announcement(
                    announcement_id=announcement_id,
                    published_by_id=approved_by_id
                )
                published = True
                
                # 4. Initialize delivery
                delivery_result = self.initialize_delivery(announcement_id)
            else:
                delivery_result = None
            
            self.session.flush()
            
            return {
                'approval': approval,
                'published': published,
                'delivery_initialized': delivery_result is not None,
                'delivery_result': delivery_result,
                'success': True,
                'message': 'Announcement approved and published successfully' if published else 'Announcement approved'
            }
            
        except Exception as e:
            self.session.rollback()
            raise BusinessLogicError(
                f"Failed to process approval: {str(e)}"
            )
    
    def initialize_delivery(
        self,
        announcement_id: UUID,
        batch_size: int = 100
    ) -> Dict[str, Any]:
        """
        Initialize delivery for published announcement.
        
        Creates delivery records and batches for all recipients
        across all configured channels.
        
        Args:
            announcement_id: Announcement UUID
            batch_size: Number of recipients per batch
            
        Returns:
            Delivery initialization results
        """
        try:
            announcement = self.announcements.find_by_id(announcement_id)
            if not announcement:
                raise ResourceNotFoundError(
                    f"Announcement {announcement_id} not found"
                )
            
            if not announcement.is_published:
                raise BusinessLogicError(
                    "Cannot initialize delivery for unpublished announcement"
                )
            
            # 1. Get target audience
            reach = self.targeting.calculate_target_reach(
                announcement_id=announcement_id,
                update_cache=False
            )
            
            student_ids = [UUID(sid) for sid in reach['student_ids']]
            
            if not student_ids:
                return {
                    'success': True,
                    'message': 'No recipients to deliver to',
                    'total_recipients': 0,
                    'channels': [],
                    'batches_created': 0
                }
            
            # 2. Determine delivery channels
            channels = []
            if announcement.send_push:
                channels.append('push')
            if announcement.send_email:
                channels.append('email')
            if announcement.send_sms:
                channels.append('sms')
            
            # Always include in-app
            if 'in_app' not in channels:
                channels.append('in_app')
            
            # 3. Create recipient records
            self._create_recipient_records(announcement_id, student_ids)
            
            # 4. Create delivery batches and records
            batches_created = 0
            deliveries_created = 0
            
            for channel in channels:
                # Split recipients into batches
                num_batches = (len(student_ids) + batch_size - 1) // batch_size
                
                for batch_num in range(num_batches):
                    start_idx = batch_num * batch_size
                    end_idx = min(start_idx + batch_size, len(student_ids))
                    batch_student_ids = student_ids[start_idx:end_idx]
                    
                    # Create batch
                    batch = self.delivery.create_delivery_batch(
                        announcement_id=announcement_id,
                        channel=channel,
                        batch_number=batch_num + 1,
                        total_recipients=len(batch_student_ids)
                    )
                    batches_created += 1
                    
                    # Create delivery records
                    deliveries = self.delivery.create_bulk_deliveries(
                        announcement_id=announcement_id,
                        recipient_ids=batch_student_ids,
                        channels=[channel],
                        batch_id=batch.id
                    )
                    deliveries_created += len(deliveries)
            
            self.session.flush()
            
            return {
                'success': True,
                'message': 'Delivery initialized successfully',
                'total_recipients': len(student_ids),
                'channels': channels,
                'batches_created': batches_created,
                'deliveries_created': deliveries_created
            }
            
        except Exception as e:
            self.session.rollback()
            raise BusinessLogicError(
                f"Failed to initialize delivery: {str(e)}"
            )
    
    def process_scheduled_publications(
        self,
        batch_size: int = 50
    ) -> Dict[str, Any]:
        """
        Process all due scheduled publications.
        
        Args:
            batch_size: Maximum number to process
            
        Returns:
            Processing results
        """
        try:
            # 1. Get pending publications from queue
            pending = self.scheduling.get_pending_publications(
                limit=batch_size
            )
            
            published_count = 0
            failed_count = 0
            results = []
            
            for queue_item in pending:
                try:
                    # 2. Acquire lock
                    locked = self.scheduling.acquire_queue_lock(
                        queue_id=queue_item.id,
                        worker_id='scheduler_worker'
                    )
                    
                    if not locked:
                        continue
                    
                    # 3. Publish announcement
                    announcement = self.announcements.publish_announcement(
                        announcement_id=queue_item.announcement_id,
                        published_by_id=None  # System published
                    )
                    
                    # 4. Initialize delivery
                    delivery_result = self.initialize_delivery(
                        announcement_id=queue_item.announcement_id
                    )
                    
                    # 5. Mark queue item as complete
                    self.scheduling.complete_queue_item(
                        queue_id=queue_item.id,
                        success=True
                    )
                    
                    published_count += 1
                    results.append({
                        'announcement_id': str(queue_item.announcement_id),
                        'status': 'published',
                        'deliveries_created': delivery_result['deliveries_created']
                    })
                    
                except Exception as e:
                    # Mark as failed
                    self.scheduling.complete_queue_item(
                        queue_id=queue_item.id,
                        success=False,
                        error=str(e)
                    )
                    
                    failed_count += 1
                    results.append({
                        'announcement_id': str(queue_item.announcement_id),
                        'status': 'failed',
                        'error': str(e)
                    })
            
            self.session.flush()
            
            return {
                'success': True,
                'total_processed': len(pending),
                'published': published_count,
                'failed': failed_count,
                'results': results
            }
            
        except Exception as e:
            self.session.rollback()
            raise BusinessLogicError(
                f"Failed to process scheduled publications: {str(e)}"
            )
    
    def process_recurring_announcements(
        self,
        batch_size: int = 50
    ) -> Dict[str, Any]:
        """
        Process due recurring announcements.
        
        Args:
            batch_size: Maximum number to process
            
        Returns:
            Processing results
        """
        try:
            # Process recurring templates
            created_announcements = self.scheduling.process_due_recurring_announcements(
                batch_size=batch_size
            )
            
            published_count = 0
            results = []
            
            for announcement in created_announcements:
                try:
                    # Initialize delivery for each created announcement
                    delivery_result = self.initialize_delivery(
                        announcement_id=announcement.id
                    )
                    
                    published_count += 1
                    results.append({
                        'announcement_id': str(announcement.id),
                        'title': announcement.title,
                        'status': 'published',
                        'recipients': delivery_result['total_recipients']
                    })
                    
                except Exception as e:
                    results.append({
                        'announcement_id': str(announcement.id),
                        'status': 'failed',
                        'error': str(e)
                    })
            
            self.session.flush()
            
            return {
                'success': True,
                'total_created': len(created_announcements),
                'published': published_count,
                'results': results
            }
            
        except Exception as e:
            self.session.rollback()
            raise BusinessLogicError(
                f"Failed to process recurring announcements: {str(e)}"
            )
    
    # ==================== Analytics & Reporting ====================
    
    def generate_comprehensive_report(
        self,
        hostel_id: UUID,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """
        Generate comprehensive announcement analytics report.
        
        Args:
            hostel_id: Hostel UUID
            start_date: Report start date
            end_date: Report end date
            
        Returns:
            Comprehensive analytics report
        """
        # Default to last 30 days if not specified
        if not end_date:
            end_date = datetime.utcnow()
        if not start_date:
            start_date = end_date - timedelta(days=30)
        
        # 1. Basic announcement statistics
        announcement_stats = self.announcements.get_announcement_statistics(
            hostel_id=hostel_id,
            start_date=start_date,
            end_date=end_date
        )
        
        # 2. Approval statistics
        approval_stats = self.approval.get_approval_statistics(
            hostel_id=hostel_id,
            start_date=start_date,
            end_date=end_date
        )
        
        # 3. Top performing announcements
        top_performers = self.announcements.get_top_performing_announcements(
            hostel_id=hostel_id,
            limit=10,
            metric='engagement_rate'
        )
        
        # 4. Low engagement students
        low_engagement = self.tracking.identify_low_engagement_students(
            hostel_id=hostel_id,
            threshold_percentage=50.0,
            days=30
        )
        
        # 5. Channel performance
        channel_performance = self._analyze_channel_performance(
            hostel_id, start_date, end_date
        )
        
        # 6. Category breakdown
        category_performance = self._analyze_category_performance(
            hostel_id, start_date, end_date
        )
        
        return {
            'report_period': {
                'start_date': start_date.isoformat(),
                'end_date': end_date.isoformat(),
                'days': (end_date - start_date).days
            },
            'hostel_id': str(hostel_id),
            'announcement_statistics': announcement_stats,
            'approval_statistics': approval_stats,
            'top_performing_announcements': [
                {
                    'announcement_id': str(ann.id),
                    'title': ann.title,
                    'engagement_rate': float(metric)
                }
                for ann, metric in top_performers
            ],
            'low_engagement_students': low_engagement[:20],  # Top 20
            'channel_performance': channel_performance,
            'category_performance': category_performance,
            'generated_at': datetime.utcnow().isoformat()
        }
    
    def get_hostel_dashboard_metrics(
        self,
        hostel_id: UUID
    ) -> Dict[str, Any]:
        """
        Get real-time dashboard metrics for hostel.
        
        Args:
            hostel_id: Hostel UUID
            
        Returns:
            Dashboard metrics
        """
        now = datetime.utcnow()
        
        # Active announcements
        active_count = self.session.query(func.count(Announcement.id)).filter(
            Announcement.hostel_id == hostel_id,
            Announcement.is_published == True,
            Announcement.is_archived == False,
            Announcement.is_deleted == False,
            or_(
                Announcement.expires_at.is_(None),
                Announcement.expires_at > now
            )
        ).scalar() or 0
        
        # Pending approvals
        pending_approvals = self.session.query(
            func.count(AnnouncementApproval.id)
        ).join(Announcement).filter(
            Announcement.hostel_id == hostel_id,
            AnnouncementApproval.approval_status == 'pending'
        ).scalar() or 0
        
        # Urgent announcements
        urgent_count = self.session.query(
            func.count(Announcement.id)
        ).filter(
            Announcement.hostel_id == hostel_id,
            Announcement.is_urgent == True,
            Announcement.is_published == True,
            Announcement.is_deleted == False
        ).scalar() or 0
        
        # Pending acknowledgments
        pending_acks = self.session.query(
            func.count(AnnouncementRecipient.id)
        ).join(Announcement).filter(
            Announcement.hostel_id == hostel_id,
            Announcement.requires_acknowledgment == True,
            AnnouncementRecipient.is_acknowledged == False
        ).scalar() or 0
        
        # Average engagement rate (last 30 days)
        thirty_days_ago = now - timedelta(days=30)
        avg_engagement = self.session.query(
            func.avg(EngagementMetric.engagement_score)
        ).join(Announcement).filter(
            Announcement.hostel_id == hostel_id,
            Announcement.published_at >= thirty_days_ago
        ).scalar() or 0
        
        # Scheduled publications (next 24 hours)
        tomorrow = now + timedelta(hours=24)
        upcoming_scheduled = self.session.query(
            func.count(AnnouncementSchedule.id)
        ).join(Announcement).filter(
            Announcement.hostel_id == hostel_id,
            AnnouncementSchedule.status == 'pending',
            AnnouncementSchedule.next_publish_at.between(now, tomorrow)
        ).scalar() or 0
        
        return {
            'active_announcements': active_count,
            'urgent_announcements': urgent_count,
            'pending_approvals': pending_approvals,
            'pending_acknowledgments': pending_acks,
            'average_engagement_rate': round(float(avg_engagement), 2),
            'upcoming_scheduled': upcoming_scheduled,
            'timestamp': now.isoformat()
        }
    
    # ==================== Maintenance & Cleanup ====================
    
    def cleanup_expired_announcements(
        self,
        hostel_id: UUID,
        auto_archive: bool = True
    ) -> Dict[str, Any]:
        """
        Cleanup expired announcements.
        
        Args:
            hostel_id: Hostel UUID
            auto_archive: Whether to auto-archive expired
            
        Returns:
            Cleanup results
        """
        try:
            now = datetime.utcnow()
            
            # Find expired announcements
            expired = self.announcements.find_expiring_soon(
                hostel_id=hostel_id,
                hours=-1  # Already expired
            )
            
            archived_count = 0
            
            if auto_archive:
                # Archive expired announcements
                for announcement in expired:
                    if not announcement.is_archived:
                        self.announcements.archive_announcement(
                            announcement_id=announcement.id,
                            archived_by_id=None,  # System archived
                            reason="Automatically archived - expired"
                        )
                        archived_count += 1
            
            self.session.flush()
            
            return {
                'success': True,
                'expired_found': len(expired),
                'archived': archived_count,
                'timestamp': now.isoformat()
            }
            
        except Exception as e:
            self.session.rollback()
            raise BusinessLogicError(
                f"Failed to cleanup expired announcements: {str(e)}"
            )
    
    def recalculate_all_metrics(
        self,
        announcement_id: UUID
    ) -> Dict[str, Any]:
        """
        Recalculate all metrics for an announcement.
        
        Args:
            announcement_id: Announcement UUID
            
        Returns:
            Recalculation results
        """
        try:
            # 1. Update engagement metrics
            engagement = self.tracking.calculate_engagement_metrics(
                announcement_id=announcement_id
            )
            
            # 2. Update reading time analytics
            reading_analytics = self.tracking.generate_reading_time_analytics(
                announcement_id=announcement_id
            )
            
            # 3. Update announcement aggregate counts
            announcement = self.announcements.update_engagement_metrics(
                announcement_id=announcement_id
            )
            
            self.session.flush()
            
            return {
                'success': True,
                'announcement_id': str(announcement_id),
                'engagement_score': float(engagement.engagement_score),
                'read_rate': float(engagement.read_rate),
                'acknowledgment_rate': float(engagement.acknowledgment_rate),
                'average_reading_time': float(reading_analytics.average_reading_time_seconds) if reading_analytics else 0,
                'recalculated_at': datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            self.session.rollback()
            raise BusinessLogicError(
                f"Failed to recalculate metrics: {str(e)}"
            )
    
    # ==================== Helper Methods ====================
    
    def _create_recipient_records(
        self,
        announcement_id: UUID,
        student_ids: List[UUID]
    ) -> None:
        """Create recipient records for tracking."""
        for student_id in student_ids:
            recipient = AnnouncementRecipient(
                announcement_id=announcement_id,
                student_id=student_id,
                matched_by='targeted'
            )
            self.session.add(recipient)
    
    def _analyze_channel_performance(
        self,
        hostel_id: UUID,
        start_date: datetime,
        end_date: datetime
    ) -> Dict[str, Any]:
        """Analyze delivery channel performance."""
        channels = ['email', 'sms', 'push', 'in_app']
        performance = {}
        
        for channel in channels:
            total = self.session.query(
                func.count(AnnouncementDelivery.id)
            ).join(Announcement).filter(
                Announcement.hostel_id == hostel_id,
                AnnouncementDelivery.channel == channel,
                AnnouncementDelivery.created_at.between(start_date, end_date)
            ).scalar() or 0
            
            delivered = self.session.query(
                func.count(AnnouncementDelivery.id)
            ).join(Announcement).filter(
                Announcement.hostel_id == hostel_id,
                AnnouncementDelivery.channel == channel,
                AnnouncementDelivery.is_delivered == True,
                AnnouncementDelivery.created_at.between(start_date, end_date)
            ).scalar() or 0
            
            performance[channel] = {
                'total_sent': total,
                'delivered': delivered,
                'delivery_rate': round((delivered / total * 100), 2) if total > 0 else 0
            }
        
        return performance
    
    def _analyze_category_performance(
        self,
        hostel_id: UUID,
        start_date: datetime,
        end_date: datetime
    ) -> Dict[str, Any]:
        """Analyze performance by announcement category."""
        categories = self.session.query(
            Announcement.category,
            func.count(Announcement.id).label('count'),
            func.avg(EngagementMetric.engagement_score).label('avg_engagement')
        ).outerjoin(EngagementMetric).filter(
            Announcement.hostel_id == hostel_id,
            Announcement.created_at.between(start_date, end_date)
        ).group_by(Announcement.category).all()
        
        return {
            cat.value: {
                'count': count,
                'average_engagement': round(float(avg_eng or 0), 2)
            }
            for cat, count, avg_eng in categories
        }

# --- File: C:\Hostel-Main\app\repositories\announcement\announcement_approval_repository.py ---
"""
Announcement Approval Repository

Approval workflow management with multi-level approval, SLA tracking, and decision history.
"""

from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from decimal import Decimal

from sqlalchemy import and_, or_, func, select, case
from sqlalchemy.orm import Session, joinedload, selectinload
from sqlalchemy.sql import Select

from app.models.announcement import (
    AnnouncementApproval,
    ApprovalWorkflow,
    ApprovalHistory,
    ApprovalRule,
    Announcement,
)
from app.models.user.user import User
from app.repositories.base.base_repository import BaseRepository
from app.repositories.base.query_builder import QueryBuilder
from app.repositories.base.pagination import PaginationParams, PaginatedResult
from app.core.exceptions import (
    ResourceNotFoundError,
    ValidationError,
    BusinessLogicError,
)


class AnnouncementApprovalRepository(BaseRepository[AnnouncementApproval]):
    """
    Repository for announcement approval workflows.
    
    Provides comprehensive approval management including:
    - Multi-level approval workflows
    - Automatic approval rules
    - SLA monitoring and escalation
    - Approval history and audit trail
    - Performance analytics
    - Assignment and routing
    """
    
    def __init__(self, session: Session):
        super().__init__(AnnouncementApproval, session)
    
    # ==================== Approval Request Management ====================
    
    def create_approval_request(
        self,
        announcement_id: UUID,
        requested_by_id: UUID,
        approval_reason: Optional[str] = None,
        is_urgent: bool = False,
        preferred_approver_id: Optional[UUID] = None,
        auto_publish: bool = True
    ) -> AnnouncementApproval:
        """
        Create approval request for announcement.
        
        Args:
            announcement_id: Announcement UUID
            requested_by_id: Requester user UUID
            approval_reason: Justification for approval
            is_urgent: Urgent approval flag
            preferred_approver_id: Preferred approver UUID
            auto_publish: Auto-publish on approval
            
        Returns:
            Created approval request
        """
        # Check if already has approval request
        existing = self.find_by_announcement(announcement_id)
        if existing:
            raise BusinessLogicError(
                f"Approval request already exists for announcement {announcement_id}"
            )
        
        # Get announcement
        announcement = self.session.get(Announcement, announcement_id)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        # Calculate SLA deadline
        sla_deadline = self._calculate_sla_deadline(
            announcement.hostel_id,
            is_urgent
        )
        
        approval = AnnouncementApproval(
            announcement_id=announcement_id,
            requested_by_id=requested_by_id,
            approval_reason=approval_reason,
            is_urgent_request=is_urgent,
            preferred_approver_id=preferred_approver_id,
            auto_publish_on_approval=auto_publish,
            approval_status='pending',
            submitted_at=datetime.utcnow(),
            sla_deadline=sla_deadline,
        )
        
        self.session.add(approval)
        self.session.flush()
        
        # Record in history
        self._record_history(
            approval=approval,
            action='submitted',
            performed_by_id=requested_by_id,
            previous_status=None,
            new_status='pending',
            notes=approval_reason
        )
        
        # Check auto-approval rules
        if self._check_auto_approval(approval):
            return self.auto_approve(approval.id)
        
        # Assign to approver
        self._assign_approver(approval)
        
        self.session.flush()
        return approval
    
    def approve_announcement(
        self,
        approval_id: UUID,
        approved_by_id: UUID,
        approval_notes: Optional[str] = None,
        auto_publish: Optional[bool] = None
    ) -> AnnouncementApproval:
        """
        Approve announcement.
        
        Args:
            approval_id: Approval request UUID
            approved_by_id: Approver user UUID
            approval_notes: Approval notes
            auto_publish: Override auto-publish setting
            
        Returns:
            Approved request
        """
        approval = self.find_by_id(approval_id)
        if not approval:
            raise ResourceNotFoundError(f"Approval {approval_id} not found")
        
        if approval.approval_status != 'pending':
            raise BusinessLogicError(
                f"Cannot approve request in {approval.approval_status} status"
            )
        
        # Verify approver has authority
        self._verify_approval_authority(approved_by_id, approval)
        
        now = datetime.utcnow()
        
        # Update approval
        approval.approved = True
        approval.decided_by_id = approved_by_id
        approval.decided_at = now
        approval.approval_status = 'approved'
        approval.approval_notes = approval_notes
        
        # Calculate time pending
        if approval.submitted_at:
            time_diff = now - approval.submitted_at
            approval.time_pending_hours = time_diff.total_seconds() / 3600
        
        # Record in history
        self._record_history(
            approval=approval,
            action='approved',
            performed_by_id=approved_by_id,
            previous_status='pending',
            new_status='approved',
            notes=approval_notes
        )
        
        # Auto-publish if configured
        should_publish = (
            auto_publish if auto_publish is not None
            else approval.auto_publish_on_approval
        )
        
        if should_publish:
            self._publish_announcement(approval, approved_by_id)
        
        self.session.flush()
        return approval
    
    def reject_announcement(
        self,
        approval_id: UUID,
        rejected_by_id: UUID,
        rejection_reason: str,
        suggested_modifications: Optional[str] = None,
        allow_resubmission: bool = True
    ) -> AnnouncementApproval:
        """
        Reject announcement.
        
        Args:
            approval_id: Approval request UUID
            rejected_by_id: Rejector user UUID
            rejection_reason: Reason for rejection
            suggested_modifications: Suggestions for improvement
            allow_resubmission: Allow resubmission
            
        Returns:
            Rejected request
        """
        approval = self.find_by_id(approval_id)
        if not approval:
            raise ResourceNotFoundError(f"Approval {approval_id} not found")
        
        if approval.approval_status != 'pending':
            raise BusinessLogicError(
                f"Cannot reject request in {approval.approval_status} status"
            )
        
        # Verify rejector has authority
        self._verify_approval_authority(rejected_by_id, approval)
        
        now = datetime.utcnow()
        
        # Update approval
        approval.approved = False
        approval.decided_by_id = rejected_by_id
        approval.decided_at = now
        approval.approval_status = 'rejected'
        approval.rejection_reason = rejection_reason
        approval.suggested_modifications = suggested_modifications
        approval.allow_resubmission = allow_resubmission
        
        # Calculate time pending
        if approval.submitted_at:
            time_diff = now - approval.submitted_at
            approval.time_pending_hours = time_diff.total_seconds() / 3600
        
        # Record in history
        self._record_history(
            approval=approval,
            action='rejected',
            performed_by_id=rejected_by_id,
            previous_status='pending',
            new_status='rejected',
            notes=f"{rejection_reason}\n\nSuggestions: {suggested_modifications or 'None'}"
        )
        
        self.session.flush()
        return approval
    
    def resubmit_for_approval(
        self,
        approval_id: UUID,
        resubmitted_by_id: UUID,
        changes_made: str,
        new_approval_reason: Optional[str] = None
    ) -> AnnouncementApproval:
        """
        Resubmit rejected announcement for approval.
        
        Args:
            approval_id: Original approval UUID
            resubmitted_by_id: User resubmitting
            changes_made: Description of changes
            new_approval_reason: Updated approval reason
            
        Returns:
            Updated approval request
        """
        approval = self.find_by_id(approval_id)
        if not approval:
            raise ResourceNotFoundError(f"Approval {approval_id} not found")
        
        if approval.approval_status != 'rejected':
            raise BusinessLogicError(
                f"Can only resubmit rejected requests"
            )
        
        if not approval.allow_resubmission:
            raise BusinessLogicError(
                "Resubmission not allowed for this request"
            )
        
        # Reset approval status
        approval.approval_status = 'pending'
        approval.approved = None
        approval.decided_by_id = None
        approval.decided_at = None
        approval.submitted_at = datetime.utcnow()
        
        if new_approval_reason:
            approval.approval_reason = new_approval_reason
        
        # Recalculate SLA
        approval.sla_deadline = self._calculate_sla_deadline(
            approval.announcement.hostel_id,
            approval.is_urgent_request
        )
        approval.sla_breached = False
        
        # Record in history
        self._record_history(
            approval=approval,
            action='resubmitted',
            performed_by_id=resubmitted_by_id,
            previous_status='rejected',
            new_status='pending',
            notes=f"Resubmitted after changes: {changes_made}"
        )
        
        # Reassign
        self._assign_approver(approval)
        
        self.session.flush()
        return approval
    
    # ==================== Assignment and Routing ====================
    
    def assign_to_approver(
        self,
        approval_id: UUID,
        approver_id: UUID,
        assigned_by_id: Optional[UUID] = None
    ) -> AnnouncementApproval:
        """
        Manually assign approval to specific approver.
        
        Args:
            approval_id: Approval UUID
            approver_id: Approver user UUID
            assigned_by_id: User making assignment
            
        Returns:
            Updated approval
        """
        approval = self.find_by_id(approval_id)
        if not approval:
            raise ResourceNotFoundError(f"Approval {approval_id} not found")
        
        if approval.approval_status != 'pending':
            raise BusinessLogicError(
                f"Cannot assign approval in {approval.approval_status} status"
            )
        
        # Verify approver has authority
        self._verify_approval_authority(approver_id, approval)
        
        approval.assigned_to_id = approver_id
        approval.assigned_at = datetime.utcnow()
        
        # Record in history
        self._record_history(
            approval=approval,
            action='assigned',
            performed_by_id=assigned_by_id or approver_id,
            previous_status='pending',
            new_status='pending',
            notes=f"Assigned to approver"
        )
        
        self.session.flush()
        return approval
    
    def escalate_approval(
        self,
        approval_id: UUID,
        escalation_reason: str,
        escalated_by_id: Optional[UUID] = None
    ) -> AnnouncementApproval:
        """
        Escalate approval request.
        
        Args:
            approval_id: Approval UUID
            escalation_reason: Reason for escalation
            escalated_by_id: User escalating
            
        Returns:
            Escalated approval
        """
        approval = self.find_by_id(approval_id)
        if not approval:
            raise ResourceNotFoundError(f"Approval {approval_id} not found")
        
        if approval.approval_status != 'pending':
            raise BusinessLogicError(
                f"Cannot escalate approval in {approval.approval_status} status"
            )
        
        now = datetime.utcnow()
        
        approval.is_escalated = True
        approval.escalated_at = now
        approval.escalation_reason = escalation_reason
        
        # Find escalation approver
        escalation_approver = self._find_escalation_approver(approval)
        if escalation_approver:
            approval.assigned_to_id = escalation_approver
            approval.assigned_at = now
        
        # Record in history
        self._record_history(
            approval=approval,
            action='escalated',
            performed_by_id=escalated_by_id,
            previous_status='pending',
            new_status='pending',
            notes=f"Escalated: {escalation_reason}"
        )
        
        self.session.flush()
        return approval
    
    # ==================== Auto-Approval ====================
    
    def auto_approve(
        self,
        approval_id: UUID
    ) -> AnnouncementApproval:
        """
        Automatically approve based on rules.
        
        Args:
            approval_id: Approval UUID
            
        Returns:
            Auto-approved request
        """
        approval = self.find_by_id(approval_id)
        if not approval:
            raise ResourceNotFoundError(f"Approval {approval_id} not found")
        
        now = datetime.utcnow()
        
        approval.approved = True
        approval.decided_at = now
        approval.approval_status = 'approved'
        approval.approval_notes = "Auto-approved based on approval rules"
        
        # Record in history
        self._record_history(
            approval=approval,
            action='auto_approved',
            performed_by_id=None,
            previous_status='pending',
            new_status='approved',
            notes="Automatically approved"
        )
        
        # Auto-publish if configured
        if approval.auto_publish_on_approval:
            self._publish_announcement(approval, None)
        
        self.session.flush()
        return approval
    
    def create_approval_rule(
        self,
        hostel_id: UUID,
        created_by_id: UUID,
        rule_name: str,
        conditions: List[Dict[str, Any]],
        priority: int = 0,
        description: Optional[str] = None
    ) -> ApprovalRule:
        """
        Create automatic approval rule.
        
        Args:
            hostel_id: Hostel UUID
            created_by_id: Creator user UUID
            rule_name: Rule name
            conditions: List of conditions
            priority: Rule priority
            description: Rule description
            
        Returns:
            Created approval rule
        """
        rule = ApprovalRule(
            hostel_id=hostel_id,
            created_by_id=created_by_id,
            rule_name=rule_name,
            description=description,
            conditions=conditions,
            priority=priority,
            is_active=True,
        )
        
        self.session.add(rule)
        self.session.flush()
        return rule
    
    # ==================== SLA Monitoring ====================
    
    def check_sla_breaches(
        self,
        hostel_id: Optional[UUID] = None
    ) -> List[AnnouncementApproval]:
        """
        Find approval requests that have breached SLA.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of SLA-breached approvals
        """
        now = datetime.utcnow()
        
        query = (
            select(AnnouncementApproval)
            .join(Announcement)
            .where(
                AnnouncementApproval.approval_status == 'pending',
                AnnouncementApproval.sla_deadline < now,
                AnnouncementApproval.sla_breached == False
            )
        )
        
        if hostel_id:
            query = query.where(Announcement.hostel_id == hostel_id)
        
        result = self.session.execute(query)
        breached_approvals = list(result.scalars().all())
        
        # Mark as breached and escalate
        for approval in breached_approvals:
            approval.sla_breached = True
            
            # Auto-escalate if enabled
            workflow = self._get_workflow(approval.announcement.hostel_id)
            if workflow and workflow.escalation_enabled:
                self.escalate_approval(
                    approval.id,
                    "SLA deadline exceeded",
                    None
                )
        
        self.session.flush()
        return breached_approvals
    
    # ==================== Query Operations ====================
    
    def find_by_announcement(
        self,
        announcement_id: UUID
    ) -> Optional[AnnouncementApproval]:
        """Find approval request for announcement."""
        return (
            self.session.query(AnnouncementApproval)
            .filter(AnnouncementApproval.announcement_id == announcement_id)
            .first()
        )
    
    def find_pending_approvals(
        self,
        hostel_id: Optional[UUID] = None,
        assigned_to_id: Optional[UUID] = None,
        urgent_only: bool = False,
        pagination: Optional[PaginationParams] = None
    ) -> PaginatedResult[AnnouncementApproval]:
        """
        Find pending approval requests.
        
        Args:
            hostel_id: Optional hostel filter
            assigned_to_id: Optional assignee filter
            urgent_only: Only urgent requests
            pagination: Pagination parameters
            
        Returns:
            Paginated pending approvals
        """
        query = (
            QueryBuilder(AnnouncementApproval, self.session)
            .join(Announcement, AnnouncementApproval.announcement_id == Announcement.id)
            .where(AnnouncementApproval.approval_status == 'pending')
        )
        
        if hostel_id:
            query = query.where(Announcement.hostel_id == hostel_id)
        
        if assigned_to_id:
            query = query.where(
                AnnouncementApproval.assigned_to_id == assigned_to_id
            )
        
        if urgent_only:
            query = query.where(AnnouncementApproval.is_urgent_request == True)
        
        query = query.order_by(
            AnnouncementApproval.is_urgent_request.desc(),
            AnnouncementApproval.sla_deadline.asc(),
            AnnouncementApproval.submitted_at.asc()
        )
        
        return query.paginate(pagination or PaginationParams())
    
    def get_approval_history(
        self,
        approval_id: UUID,
        limit: int = 50
    ) -> List[ApprovalHistory]:
        """
        Get approval history.
        
        Args:
            approval_id: Approval UUID
            limit: Maximum records
            
        Returns:
            List of history entries
        """
        query = (
            select(ApprovalHistory)
            .where(ApprovalHistory.approval_id == approval_id)
            .order_by(ApprovalHistory.performed_at.desc())
            .limit(limit)
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def get_approval_statistics(
        self,
        hostel_id: UUID,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """
        Get approval statistics.
        
        Args:
            hostel_id: Hostel UUID
            start_date: Optional start date
            end_date: Optional end date
            
        Returns:
            Statistics dictionary
        """
        query = (
            select(AnnouncementApproval)
            .join(Announcement)
            .where(Announcement.hostel_id == hostel_id)
        )
        
        if start_date:
            query = query.where(AnnouncementApproval.submitted_at >= start_date)
        if end_date:
            query = query.where(AnnouncementApproval.submitted_at <= end_date)
        
        approvals = self.session.execute(query).scalars().all()
        
        total_requests = len(approvals)
        approved_count = sum(1 for a in approvals if a.approval_status == 'approved')
        rejected_count = sum(1 for a in approvals if a.approval_status == 'rejected')
        pending_count = sum(1 for a in approvals if a.approval_status == 'pending')
        
        # Calculate average time to decision
        decided_approvals = [
            a for a in approvals
            if a.decided_at and a.submitted_at
        ]
        
        if decided_approvals:
            total_hours = sum(a.time_pending_hours or 0 for a in decided_approvals)
            avg_time_hours = total_hours / len(decided_approvals)
        else:
            avg_time_hours = 0
        
        # SLA compliance
        sla_breaches = sum(1 for a in approvals if a.sla_breached)
        sla_compliance_rate = (
            ((total_requests - sla_breaches) / total_requests * 100)
            if total_requests > 0 else 100
        )
        
        return {
            'total_requests': total_requests,
            'approved': approved_count,
            'rejected': rejected_count,
            'pending': pending_count,
            'approval_rate': (
                (approved_count / total_requests * 100)
                if total_requests > 0 else 0
            ),
            'rejection_rate': (
                (rejected_count / total_requests * 100)
                if total_requests > 0 else 0
            ),
            'average_decision_time_hours': round(avg_time_hours, 2),
            'sla_breaches': sla_breaches,
            'sla_compliance_rate': round(sla_compliance_rate, 2),
        }
    
    # ==================== Workflow Management ====================
    
    def create_approval_workflow(
        self,
        hostel_id: UUID,
        created_by_id: UUID,
        workflow_name: str,
        steps: List[Dict[str, Any]],
        sla_hours: Optional[int] = None,
        escalation_enabled: bool = True,
        escalation_after_hours: Optional[int] = None,
        **kwargs
    ) -> ApprovalWorkflow:
        """
        Create approval workflow.
        
        Args:
            hostel_id: Hostel UUID
            created_by_id: Creator user UUID
            workflow_name: Workflow name
            steps: Workflow steps
            sla_hours: SLA in hours
            escalation_enabled: Enable escalation
            escalation_after_hours: Escalation threshold
            **kwargs: Additional parameters
            
        Returns:
            Created workflow
        """
        workflow = ApprovalWorkflow(
            hostel_id=hostel_id,
            created_by_id=created_by_id,
            workflow_name=workflow_name,
            steps=steps,
            sla_hours=sla_hours,
            escalation_enabled=escalation_enabled,
            escalation_after_hours=escalation_after_hours,
            is_active=True,
            **kwargs
        )
        
        self.session.add(workflow)
        self.session.flush()
        return workflow
    
    # ==================== Helper Methods ====================
    
    def _record_history(
        self,
        approval: AnnouncementApproval,
        action: str,
        performed_by_id: Optional[UUID],
        previous_status: Optional[str],
        new_status: str,
        notes: Optional[str] = None
    ) -> ApprovalHistory:
        """Record approval history entry."""
        # Get performer details
        performer_name = None
        performer_role = None
        
        if performed_by_id:
            performer = self.session.get(User, performed_by_id)
            if performer:
                performer_name = performer.full_name
                performer_role = performer.role
        
        history = ApprovalHistory(
            approval_id=approval.id,
            announcement_id=approval.announcement_id,
            performed_by_id=performed_by_id,
            action=action,
            previous_status=previous_status,
            new_status=new_status,
            performed_by_name=performer_name,
            performed_by_role=performer_role,
            notes=notes,
            performed_at=datetime.utcnow(),
        )
        
        self.session.add(history)
        return history
    
    def _check_auto_approval(self, approval: AnnouncementApproval) -> bool:
        """Check if approval qualifies for auto-approval."""
        announcement = approval.announcement
        
        # Get active approval rules
        rules = (
            self.session.query(ApprovalRule)
            .filter(
                ApprovalRule.hostel_id == announcement.hostel_id,
                ApprovalRule.is_active == True
            )
            .order_by(ApprovalRule.priority.asc())
            .all()
        )
        
        for rule in rules:
            if self._evaluate_approval_rule(rule, announcement, approval):
                # Update rule usage
                rule.times_applied += 1
                rule.last_applied_at = datetime.utcnow()
                return True
        
        return False
    
    def _evaluate_approval_rule(
        self,
        rule: ApprovalRule,
        announcement: Announcement,
        approval: AnnouncementApproval
    ) -> bool:
        """Evaluate if approval rule conditions are met."""
        for condition in rule.conditions:
            field = condition.get('field')
            operator = condition.get('operator')
            value = condition.get('value')
            
            # Get field value from announcement or approval
            if hasattr(announcement, field):
                actual_value = getattr(announcement, field)
            elif hasattr(approval, field):
                actual_value = getattr(approval, field)
            else:
                return False
            
            # Evaluate condition
            if operator == 'equals':
                if actual_value != value:
                    return False
            elif operator == 'in':
                if actual_value not in value:
                    return False
            elif operator == 'less_than':
                if not (actual_value < value):
                    return False
            elif operator == 'greater_than':
                if not (actual_value > value):
                    return False
            else:
                return False
        
        return True
    
    def _assign_approver(self, approval: AnnouncementApproval) -> None:
        """Automatically assign approver based on workflow."""
        # Check if preferred approver specified
        if approval.preferred_approver_id:
            approval.assigned_to_id = approval.preferred_approver_id
            approval.assigned_at = datetime.utcnow()
            return
        
        # Get workflow
        workflow = self._get_workflow(approval.announcement.hostel_id)
        if not workflow or not workflow.default_approvers:
            return
        
        # Find approver with least workload
        approver_workloads = (
            self.session.query(
                AnnouncementApproval.assigned_to_id,
                func.count(AnnouncementApproval.id).label('workload')
            )
            .filter(
                AnnouncementApproval.assigned_to_id.in_(workflow.default_approvers),
                AnnouncementApproval.approval_status == 'pending'
            )
            .group_by(AnnouncementApproval.assigned_to_id)
            .all()
        )
        
        workload_dict = {str(aid): count for aid, count in approver_workloads}
        
        # Find approver with minimum workload
        min_workload_approver = None
        min_workload = float('inf')
        
        for approver_id in workflow.default_approvers:
            workload = workload_dict.get(str(approver_id), 0)
            if workload < min_workload:
                min_workload = workload
                min_workload_approver = approver_id
        
        if min_workload_approver:
            approval.assigned_to_id = min_workload_approver
            approval.assigned_at = datetime.utcnow()
    
    def _verify_approval_authority(
        self,
        approver_id: UUID,
        approval: AnnouncementApproval
    ) -> None:
        """Verify user has authority to approve."""
        approver = self.session.get(User, approver_id)
        if not approver:
            raise ResourceNotFoundError(f"Approver {approver_id} not found")
        
        # Check if user has admin or supervisor role
        if approver.role not in ['admin', 'supervisor']:
            raise BusinessLogicError(
                f"User does not have approval authority"
            )
        
        # Additional checks can be added based on business rules
    
    def _calculate_sla_deadline(
        self,
        hostel_id: UUID,
        is_urgent: bool
    ) -> datetime:
        """Calculate SLA deadline for approval."""
        workflow = self._get_workflow(hostel_id)
        
        if workflow and workflow.sla_hours:
            hours = workflow.sla_hours
        else:
            # Default SLA: 24 hours for normal, 4 hours for urgent
            hours = 4 if is_urgent else 24
        
        return datetime.utcnow() + timedelta(hours=hours)
    
    def _find_escalation_approver(
        self,
        approval: AnnouncementApproval
    ) -> Optional[UUID]:
        """Find escalation approver."""
        workflow = self._get_workflow(approval.announcement.hostel_id)
        
        if workflow and workflow.escalation_approvers:
            # Return first escalation approver
            return workflow.escalation_approvers[0]
        
        return None
    
    def _get_workflow(self, hostel_id: UUID) -> Optional[ApprovalWorkflow]:
        """Get active approval workflow for hostel."""
        return (
            self.session.query(ApprovalWorkflow)
            .filter(
                ApprovalWorkflow.hostel_id == hostel_id,
                ApprovalWorkflow.is_active == True
            )
            .first()
        )
    
    def _publish_announcement(
        self,
        approval: AnnouncementApproval,
        published_by_id: Optional[UUID]
    ) -> None:
        """Publish announcement after approval."""
        announcement = approval.announcement
        
        now = datetime.utcnow()
        announcement.is_published = True
        announcement.published_at = now
        announcement.published_by_id = published_by_id or approval.decided_by_id
        announcement.status = 'published'
        
        # Update approval
        approval.auto_published = True
        approval.published_at = now

# --- File: C:\Hostel-Main\app\repositories\announcement\announcement_delivery_repository.py ---
"""
Announcement Delivery Repository

Multi-channel delivery with optimization, failover, and performance tracking.
"""

from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from decimal import Decimal
from collections import defaultdict

from sqlalchemy import and_, or_, func, select, case
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.sql import Select

from app.models.announcement import (
    AnnouncementDelivery,
    DeliveryChannel,
    DeliveryBatch,
    DeliveryFailure,
    DeliveryRetry,
    Announcement,
)
from app.models.user.user import User
from app.repositories.base.base_repository import BaseRepository
from app.repositories.base.query_builder import QueryBuilder
from app.repositories.base.pagination import PaginationParams, PaginatedResult
from app.core.exceptions import (
    ResourceNotFoundError,
    ValidationError,
    BusinessLogicError,
)


class AnnouncementDeliveryRepository(BaseRepository[AnnouncementDelivery]):
    """
    Repository for announcement delivery management.
    
    Provides comprehensive delivery capabilities including:
    - Multi-channel delivery (email, SMS, push, in-app)
    - Batch processing and queue management
    - Delivery failure handling and retry logic
    - Channel optimization and selection
    - Performance tracking and analytics
    - Rate limiting and throttling
    """
    
    def __init__(self, session: Session):
        super().__init__(AnnouncementDelivery, session)
    
    # ==================== Delivery Creation ====================
    
    def create_delivery(
        self,
        announcement_id: UUID,
        recipient_id: UUID,
        channel: str,
        scheduled_for: Optional[datetime] = None,
        batch_id: Optional[UUID] = None,
        **kwargs
    ) -> AnnouncementDelivery:
        """
        Create delivery record for announcement recipient.
        
        Args:
            announcement_id: Announcement UUID
            recipient_id: Recipient user UUID
            channel: Delivery channel
            scheduled_for: Scheduled delivery time
            batch_id: Associated batch UUID
            **kwargs: Additional delivery parameters
            
        Returns:
            Created delivery record
        """
        # Validate channel
        if channel not in ['email', 'sms', 'push', 'in_app']:
            raise ValidationError(f"Invalid delivery channel: {channel}")
        
        # Get recipient contact info
        recipient = self.session.get(User, recipient_id)
        if not recipient:
            raise ResourceNotFoundError(f"Recipient {recipient_id} not found")
        
        delivery = AnnouncementDelivery(
            announcement_id=announcement_id,
            recipient_id=recipient_id,
            channel=channel,
            scheduled_for=scheduled_for or datetime.utcnow(),
            batch_id=batch_id,
            recipient_email=recipient.email if channel == 'email' else None,
            recipient_phone=recipient.phone if channel == 'sms' else None,
            status='pending',
            **kwargs
        )
        
        self.session.add(delivery)
        self.session.flush()
        return delivery
    
    def create_bulk_deliveries(
        self,
        announcement_id: UUID,
        recipient_ids: List[UUID],
        channels: List[str],
        batch_id: Optional[UUID] = None
    ) -> List[AnnouncementDelivery]:
        """
        Create multiple delivery records efficiently.
        
        Args:
            announcement_id: Announcement UUID
            recipient_ids: List of recipient UUIDs
            channels: List of delivery channels
            batch_id: Associated batch UUID
            
        Returns:
            List of created deliveries
        """
        deliveries = []
        
        for recipient_id in recipient_ids:
            for channel in channels:
                try:
                    delivery = self.create_delivery(
                        announcement_id=announcement_id,
                        recipient_id=recipient_id,
                        channel=channel,
                        batch_id=batch_id
                    )
                    deliveries.append(delivery)
                except Exception as e:
                    # Log error but continue with other deliveries
                    print(f"Error creating delivery: {e}")
                    continue
        
        self.session.flush()
        return deliveries
    
    # ==================== Delivery Execution ====================
    
    def execute_delivery(
        self,
        delivery_id: UUID,
        provider: str,
        provider_message_id: Optional[str] = None,
        provider_response: Optional[Dict] = None
    ) -> AnnouncementDelivery:
        """
        Execute delivery and update status.
        
        Args:
            delivery_id: Delivery UUID
            provider: Service provider name
            provider_message_id: Provider's message ID
            provider_response: Provider response data
            
        Returns:
            Updated delivery record
        """
        delivery = self.find_by_id(delivery_id)
        if not delivery:
            raise ResourceNotFoundError(f"Delivery {delivery_id} not found")
        
        start_time = datetime.utcnow()
        
        delivery.status = 'processing'
        delivery.provider = provider
        delivery.provider_message_id = provider_message_id
        delivery.provider_response = provider_response
        
        self.session.flush()
        return delivery
    
    def mark_delivered(
        self,
        delivery_id: UUID,
        delivered_at: Optional[datetime] = None
    ) -> AnnouncementDelivery:
        """
        Mark delivery as successfully delivered.
        
        Args:
            delivery_id: Delivery UUID
            delivered_at: Delivery timestamp
            
        Returns:
            Updated delivery record
        """
        delivery = self.find_by_id(delivery_id)
        if not delivery:
            raise ResourceNotFoundError(f"Delivery {delivery_id} not found")
        
        now = delivered_at or datetime.utcnow()
        
        delivery.is_delivered = True
        delivery.delivered_at = now
        delivery.status = 'completed'
        
        if delivery.scheduled_for:
            time_diff = now - delivery.scheduled_for
            delivery.delivery_time_seconds = int(time_diff.total_seconds())
        
        self.session.flush()
        return delivery
    
    def mark_failed(
        self,
        delivery_id: UUID,
        failure_reason: str,
        failure_code: Optional[str] = None,
        is_permanent: bool = False
    ) -> AnnouncementDelivery:
        """
        Mark delivery as failed.
        
        Args:
            delivery_id: Delivery UUID
            failure_reason: Reason for failure
            failure_code: Error code
            is_permanent: Whether failure is permanent
            
        Returns:
            Updated delivery record
        """
        delivery = self.find_by_id(delivery_id)
        if not delivery:
            raise ResourceNotFoundError(f"Delivery {delivery_id} not found")
        
        delivery.status = 'failed'
        delivery.failure_reason = failure_reason
        delivery.failure_code = failure_code
        
        # Record failure
        self._record_failure(
            delivery=delivery,
            failure_reason=failure_reason,
            failure_code=failure_code,
            is_permanent=is_permanent
        )
        
        # Schedule retry if not permanent and under limit
        if not is_permanent and delivery.retry_count < delivery.max_retries:
            self._schedule_retry(delivery)
        
        self.session.flush()
        return delivery
    
    # ==================== Batch Processing ====================
    
    def create_delivery_batch(
        self,
        announcement_id: UUID,
        channel: str,
        batch_number: int,
        total_recipients: int,
        scheduled_at: Optional[datetime] = None
    ) -> DeliveryBatch:
        """
        Create delivery batch for processing.
        
        Args:
            announcement_id: Announcement UUID
            channel: Delivery channel
            batch_number: Batch sequence number
            total_recipients: Total recipients in batch
            scheduled_at: Scheduled processing time
            
        Returns:
            Created batch
        """
        batch = DeliveryBatch(
            announcement_id=announcement_id,
            batch_number=batch_number,
            batch_size=total_recipients,
            channel=channel,
            total_recipients=total_recipients,
            scheduled_at=scheduled_at or datetime.utcnow(),
            status='pending',
        )
        
        self.session.add(batch)
        self.session.flush()
        return batch
    
    def process_batch(
        self,
        batch_id: UUID,
        worker_id: str
    ) -> DeliveryBatch:
        """
        Process delivery batch.
        
        Args:
            batch_id: Batch UUID
            worker_id: Worker processing batch
            
        Returns:
            Updated batch
        """
        batch = self.session.get(DeliveryBatch, batch_id)
        if not batch:
            raise ResourceNotFoundError(f"Batch {batch_id} not found")
        
        if batch.status != 'pending':
            raise BusinessLogicError(
                f"Cannot process batch in {batch.status} status"
            )
        
        batch.status = 'processing'
        batch.started_at = datetime.utcnow()
        batch.worker_id = worker_id
        
        self.session.flush()
        return batch
    
    def complete_batch(
        self,
        batch_id: UUID,
        sent_count: int,
        failed_count: int
    ) -> DeliveryBatch:
        """
        Mark batch as completed.
        
        Args:
            batch_id: Batch UUID
            sent_count: Number successfully sent
            failed_count: Number failed
            
        Returns:
            Completed batch
        """
        batch = self.session.get(DeliveryBatch, batch_id)
        if not batch:
            raise ResourceNotFoundError(f"Batch {batch_id} not found")
        
        now = datetime.utcnow()
        
        batch.status = 'completed'
        batch.completed_at = now
        batch.processed_count = sent_count + failed_count
        batch.sent_count = sent_count
        batch.failed_count = failed_count
        
        if batch.started_at:
            duration = now - batch.started_at
            batch.processing_duration_seconds = int(duration.total_seconds())
            
            if sent_count > 0:
                batch.average_delivery_time_seconds = Decimal(
                    batch.processing_duration_seconds / sent_count
                )
        
        self.session.flush()
        return batch
    
    # ==================== Channel Management ====================
    
    def get_optimal_channel(
        self,
        announcement_id: UUID,
        recipient_id: UUID,
        preferred_channels: Optional[List[str]] = None
    ) -> str:
        """
        Determine optimal delivery channel for recipient.
        
        Args:
            announcement_id: Announcement UUID
            recipient_id: Recipient UUID
            preferred_channels: Preferred channel list
            
        Returns:
            Optimal channel name
        """
        announcement = self.session.get(Announcement, announcement_id)
        recipient = self.session.get(User, recipient_id)
        
        if not announcement or not recipient:
            return 'in_app'  # Default fallback
        
        # Get recipient preferences
        prefs = recipient.metadata.get('notification_preferences', {}) if recipient.metadata else {}
        
        # Build available channels based on announcement settings
        available_channels = []
        if announcement.send_push and prefs.get('push', True):
            available_channels.append('push')
        if announcement.send_email and prefs.get('email', True) and recipient.email:
            available_channels.append('email')
        if announcement.send_sms and prefs.get('sms', False) and recipient.phone:
            available_channels.append('sms')
        
        # Always include in-app
        available_channels.append('in_app')
        
        # Filter by preferred channels if specified
        if preferred_channels:
            available_channels = [
                ch for ch in available_channels if ch in preferred_channels
            ]
        
        if not available_channels:
            return 'in_app'
        
        # Get channel performance
        channel_performance = self._get_channel_performance(announcement.hostel_id)
        
        # Select channel with best performance
        best_channel = max(
            available_channels,
            key=lambda ch: channel_performance.get(ch, {}).get('success_rate', 0)
        )
        
        return best_channel
    
    def configure_delivery_channel(
        self,
        hostel_id: UUID,
        channel_type: str,
        provider_name: str,
        provider_config: Dict[str, Any],
        **kwargs
    ) -> DeliveryChannel:
        """
        Configure delivery channel.
        
        Args:
            hostel_id: Hostel UUID
            channel_type: Channel type
            provider_name: Provider name
            provider_config: Provider configuration
            **kwargs: Additional parameters
            
        Returns:
            Created/updated channel configuration
        """
        # Check for existing configuration
        existing = (
            self.session.query(DeliveryChannel)
            .filter(
                DeliveryChannel.hostel_id == hostel_id,
                DeliveryChannel.channel_type == channel_type,
                DeliveryChannel.provider_name == provider_name
            )
            .first()
        )
        
        if existing:
            existing.provider_config = provider_config
            for key, value in kwargs.items():
                if hasattr(existing, key):
                    setattr(existing, key, value)
            self.session.flush()
            return existing
        
        channel = DeliveryChannel(
            hostel_id=hostel_id,
            channel_type=channel_type,
            provider_name=provider_name,
            provider_config=provider_config,
            is_enabled=True,
            **kwargs
        )
        
        self.session.add(channel)
        self.session.flush()
        return channel
    
    # ==================== Query Operations ====================
    
    def find_pending_deliveries(
        self,
        channel: Optional[str] = None,
        limit: int = 100
    ) -> List[AnnouncementDelivery]:
        """
        Find pending deliveries ready for processing.
        
        Args:
            channel: Optional channel filter
            limit: Maximum results
            
        Returns:
            List of pending deliveries
        """
        now = datetime.utcnow()
        
        query = (
            select(AnnouncementDelivery)
            .where(
                AnnouncementDelivery.status == 'pending',
                or_(
                    AnnouncementDelivery.scheduled_for.is_(None),
                    AnnouncementDelivery.scheduled_for <= now
                ),
                or_(
                    AnnouncementDelivery.next_retry_at.is_(None),
                    AnnouncementDelivery.next_retry_at <= now
                )
            )
            .order_by(AnnouncementDelivery.scheduled_for.asc())
            .limit(limit)
        )
        
        if channel:
            query = query.where(AnnouncementDelivery.channel == channel)
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_failed_deliveries(
        self,
        announcement_id: Optional[UUID] = None,
        permanent_only: bool = False,
        limit: int = 100
    ) -> List[AnnouncementDelivery]:
        """
        Find failed deliveries.
        
        Args:
            announcement_id: Optional announcement filter
            permanent_only: Only permanent failures
            limit: Maximum results
            
        Returns:
            List of failed deliveries
        """
        query = (
            select(AnnouncementDelivery)
            .where(AnnouncementDelivery.status == 'failed')
            .order_by(AnnouncementDelivery.created_at.desc())
            .limit(limit)
        )
        
        if announcement_id:
            query = query.where(
                AnnouncementDelivery.announcement_id == announcement_id
            )
        
        if permanent_only:
            # Join with failures to filter permanent
            query = query.join(DeliveryFailure).where(
                DeliveryFailure.is_permanent == True
            )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def get_delivery_statistics(
        self,
        announcement_id: UUID
    ) -> Dict[str, Any]:
        """
        Get delivery statistics for announcement.
        
        Args:
            announcement_id: Announcement UUID
            
        Returns:
            Statistics dictionary
        """
        deliveries = (
            self.session.query(AnnouncementDelivery)
            .filter(AnnouncementDelivery.announcement_id == announcement_id)
            .all()
        )
        
        total = len(deliveries)
        delivered = sum(1 for d in deliveries if d.is_delivered)
        failed = sum(1 for d in deliveries if d.status == 'failed')
        pending = sum(1 for d in deliveries if d.status == 'pending')
        
        # Channel breakdown
        channel_stats = defaultdict(lambda: {'total': 0, 'delivered': 0, 'failed': 0})
        for d in deliveries:
            channel_stats[d.channel]['total'] += 1
            if d.is_delivered:
                channel_stats[d.channel]['delivered'] += 1
            elif d.status == 'failed':
                channel_stats[d.channel]['failed'] += 1
        
        # Calculate average delivery time
        delivered_with_time = [
            d for d in deliveries
            if d.is_delivered and d.delivery_time_seconds
        ]
        avg_delivery_time = (
            sum(d.delivery_time_seconds for d in delivered_with_time) / len(delivered_with_time)
            if delivered_with_time else 0
        )
        
        return {
            'total_deliveries': total,
            'delivered': delivered,
            'failed': failed,
            'pending': pending,
            'delivery_rate': (delivered / total * 100) if total > 0 else 0,
            'failure_rate': (failed / total * 100) if total > 0 else 0,
            'average_delivery_time_seconds': round(avg_delivery_time, 2),
            'channel_breakdown': dict(channel_stats),
        }
    
    # ==================== Helper Methods ====================
    
    def _record_failure(
        self,
        delivery: AnnouncementDelivery,
        failure_reason: str,
        failure_code: Optional[str],
        is_permanent: bool
    ) -> DeliveryFailure:
        """Record delivery failure."""
        failure = DeliveryFailure(
            delivery_id=delivery.id,
            announcement_id=delivery.announcement_id,
            recipient_id=delivery.recipient_id,
            channel=delivery.channel,
            failure_reason=failure_reason,
            failure_code=failure_code,
            failed_at=datetime.utcnow(),
            provider_name=delivery.provider,
            provider_error_message=delivery.provider_response.get('error') if delivery.provider_response else None,
            recipient_contact=(
                delivery.recipient_email if delivery.channel == 'email'
                else delivery.recipient_phone if delivery.channel == 'sms'
                else None
            ),
            is_permanent=is_permanent,
            is_temporary=not is_permanent,
        )
        
        self.session.add(failure)
        return failure
    
    def _schedule_retry(self, delivery: AnnouncementDelivery) -> DeliveryRetry:
        """Schedule delivery retry."""
        delivery.retry_count += 1
        
        # Calculate delay with exponential backoff
        delay_minutes = 2 ** delivery.retry_count  # 2, 4, 8, 16...
        delay = timedelta(minutes=min(delay_minutes, 60))  # Max 1 hour
        
        delivery.next_retry_at = datetime.utcnow() + delay
        delivery.status = 'pending'
        
        # Record retry
        retry = DeliveryRetry(
            delivery_id=delivery.id,
            retry_number=delivery.retry_count,
            retry_scheduled_at=delivery.next_retry_at,
            retry_strategy='exponential_backoff',
            delay_seconds=int(delay.total_seconds()),
            channel_used=delivery.channel,
            status='pending',
        )
        
        self.session.add(retry)
        return retry
    
    def _get_channel_performance(
        self,
        hostel_id: UUID
    ) -> Dict[str, Dict[str, float]]:
        """Get channel performance metrics."""
        channels = (
            self.session.query(DeliveryChannel)
            .filter(
                DeliveryChannel.hostel_id == hostel_id,
                DeliveryChannel.is_enabled == True
            )
            .all()
        )
        
        performance = {}
        for channel in channels:
            if channel.total_sent > 0:
                success_rate = (channel.total_delivered / channel.total_sent) * 100
            else:
                success_rate = 0
            
            performance[channel.channel_type] = {
                'success_rate': success_rate,
                'total_sent': channel.total_sent,
                'total_delivered': channel.total_delivered,
                'is_healthy': channel.is_healthy,
            }
        
        return performance

# --- File: C:\Hostel-Main\app\repositories\announcement\announcement_repository.py ---
"""
Announcement Repository

Comprehensive announcement management with content lifecycle, audience targeting,
and effectiveness tracking.
"""

from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from decimal import Decimal

from sqlalchemy import and_, or_, func, case, exists, select
from sqlalchemy.orm import Session, joinedload, selectinload, contains_eager
from sqlalchemy.sql import Select

from app.models.announcement import (
    Announcement,
    AnnouncementAttachment,
    AnnouncementVersion,
    AnnouncementRecipient,
)
from app.models.base.enums import (
    AnnouncementCategory,
    AnnouncementStatus,
    Priority,
    TargetAudience,
)
from app.repositories.base.base_repository import BaseRepository
from app.repositories.base.query_builder import QueryBuilder
from app.repositories.base.specifications import Specification
from app.repositories.base.pagination import PaginationParams, PaginatedResult
from app.repositories.base.filtering import FilterCriteria
from app.core.exceptions import (
    ResourceNotFoundError,
    ValidationError,
    BusinessLogicError,
)


class ActiveAnnouncementsSpec(Specification):
    """Specification for active announcements."""
    
    def is_satisfied_by(self, announcement: Announcement) -> bool:
        return announcement.is_active
    
    def to_sqlalchemy(self) -> Any:
        now = datetime.utcnow()
        return and_(
            Announcement.is_published == True,
            Announcement.is_archived == False,
            Announcement.is_deleted == False,
            or_(
                Announcement.expires_at.is_(None),
                Announcement.expires_at > now
            )
        )


class UrgentAnnouncementsSpec(Specification):
    """Specification for urgent announcements."""
    
    def to_sqlalchemy(self) -> Any:
        return and_(
            Announcement.is_urgent == True,
            Announcement.is_published == True,
            Announcement.is_deleted == False,
        )


class RequiresAcknowledgmentSpec(Specification):
    """Specification for announcements requiring acknowledgment."""
    
    def to_sqlalchemy(self) -> Any:
        return and_(
            Announcement.requires_acknowledgment == True,
            Announcement.is_published == True,
        )


class AnnouncementRepository(BaseRepository[Announcement]):
    """
    Repository for announcement management.
    
    Provides comprehensive announcement operations including:
    - Content lifecycle management
    - Advanced search and filtering
    - Performance tracking
    - Version control
    - Archival and cleanup
    """
    
    def __init__(self, session: Session):
        super().__init__(Announcement, session)
    
    # ==================== Create Operations ====================
    
    def create_draft(
        self,
        hostel_id: UUID,
        created_by_id: UUID,
        title: str,
        content: str,
        category: AnnouncementCategory,
        priority: Priority = Priority.MEDIUM,
        **kwargs
    ) -> Announcement:
        """
        Create announcement draft with auto-save functionality.
        
        Args:
            hostel_id: Hostel UUID
            created_by_id: Creator user UUID
            title: Announcement title
            content: Announcement content
            category: Category enum
            priority: Priority level
            **kwargs: Additional announcement fields
            
        Returns:
            Created announcement draft
        """
        announcement = Announcement(
            hostel_id=hostel_id,
            created_by_id=created_by_id,
            title=title,
            content=content,
            category=category,
            priority=priority,
            status=AnnouncementStatus.DRAFT,
            version_number=1,
            **kwargs
        )
        
        self.session.add(announcement)
        self.session.flush()
        
        # Create initial version
        self._create_version(announcement, created_by_id, "Initial draft")
        
        return announcement
    
    def create_from_template(
        self,
        template_id: UUID,
        hostel_id: UUID,
        created_by_id: UUID,
        overrides: Optional[Dict[str, Any]] = None
    ) -> Announcement:
        """
        Create announcement from template.
        
        Args:
            template_id: Template announcement UUID
            hostel_id: Target hostel UUID
            created_by_id: Creator user UUID
            overrides: Field overrides for template
            
        Returns:
            New announcement based on template
        """
        template = self.find_by_id(template_id)
        if not template:
            raise ResourceNotFoundError(f"Template {template_id} not found")
        
        # Copy template fields
        announcement_data = {
            'title': template.title,
            'content': template.content,
            'category': template.category,
            'priority': template.priority,
            'target_audience': template.target_audience,
            'send_email': template.send_email,
            'send_sms': template.send_sms,
            'send_push': template.send_push,
            'requires_acknowledgment': template.requires_acknowledgment,
        }
        
        # Apply overrides
        if overrides:
            announcement_data.update(overrides)
        
        return self.create_draft(
            hostel_id=hostel_id,
            created_by_id=created_by_id,
            **announcement_data
        )
    
    # ==================== Read Operations ====================
    
    def find_by_id_with_details(
        self,
        announcement_id: UUID,
        include_deleted: bool = False
    ) -> Optional[Announcement]:
        """
        Find announcement with all related data eagerly loaded.
        
        Args:
            announcement_id: Announcement UUID
            include_deleted: Include soft-deleted records
            
        Returns:
            Announcement with relationships loaded or None
        """
        query = (
            select(Announcement)
            .where(Announcement.id == announcement_id)
            .options(
                joinedload(Announcement.hostel),
                joinedload(Announcement.created_by),
                joinedload(Announcement.published_by),
                selectinload(Announcement.attachments_rel),
                selectinload(Announcement.targets),
                selectinload(Announcement.recipients),
            )
        )
        
        if not include_deleted:
            query = query.where(Announcement.is_deleted == False)
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def find_by_hostel(
        self,
        hostel_id: UUID,
        filters: Optional[FilterCriteria] = None,
        pagination: Optional[PaginationParams] = None,
        include_archived: bool = False
    ) -> PaginatedResult[Announcement]:
        """
        Find announcements for a hostel with filtering and pagination.
        
        Args:
            hostel_id: Hostel UUID
            filters: Filter criteria
            pagination: Pagination parameters
            include_archived: Include archived announcements
            
        Returns:
            Paginated announcement results
        """
        query = (
            QueryBuilder(Announcement, self.session)
            .where(Announcement.hostel_id == hostel_id)
            .where(Announcement.is_deleted == False)
        )
        
        if not include_archived:
            query = query.where(Announcement.is_archived == False)
        
        # Apply filters
        if filters:
            query = self._apply_filters(query, filters)
        
        # Default ordering
        query = query.order_by(
            Announcement.is_pinned.desc(),
            Announcement.is_urgent.desc(),
            Announcement.published_at.desc(),
            Announcement.created_at.desc()
        )
        
        return query.paginate(pagination or PaginationParams())
    
    def find_active_by_hostel(
        self,
        hostel_id: UUID,
        pagination: Optional[PaginationParams] = None
    ) -> PaginatedResult[Announcement]:
        """
        Find active announcements for a hostel.
        
        Args:
            hostel_id: Hostel UUID
            pagination: Pagination parameters
            
        Returns:
            Paginated active announcements
        """
        spec = ActiveAnnouncementsSpec()
        
        query = (
            QueryBuilder(Announcement, self.session)
            .where(Announcement.hostel_id == hostel_id)
            .where(spec.to_sqlalchemy())
            .order_by(
                Announcement.is_pinned.desc(),
                Announcement.is_urgent.desc(),
                Announcement.published_at.desc()
            )
        )
        
        return query.paginate(pagination or PaginationParams())
    
    def find_drafts_by_creator(
        self,
        created_by_id: UUID,
        hostel_id: Optional[UUID] = None,
        pagination: Optional[PaginationParams] = None
    ) -> PaginatedResult[Announcement]:
        """
        Find draft announcements by creator.
        
        Args:
            created_by_id: Creator user UUID
            hostel_id: Optional hostel filter
            pagination: Pagination parameters
            
        Returns:
            Paginated draft announcements
        """
        query = (
            QueryBuilder(Announcement, self.session)
            .where(Announcement.created_by_id == created_by_id)
            .where(Announcement.status == AnnouncementStatus.DRAFT)
            .where(Announcement.is_deleted == False)
        )
        
        if hostel_id:
            query = query.where(Announcement.hostel_id == hostel_id)
        
        query = query.order_by(Announcement.updated_at.desc())
        
        return query.paginate(pagination or PaginationParams())
    
    def find_urgent_announcements(
        self,
        hostel_id: UUID,
        limit: int = 10
    ) -> List[Announcement]:
        """
        Find urgent announcements for immediate attention.
        
        Args:
            hostel_id: Hostel UUID
            limit: Maximum number of results
            
        Returns:
            List of urgent announcements
        """
        spec = UrgentAnnouncementsSpec()
        
        query = (
            select(Announcement)
            .where(Announcement.hostel_id == hostel_id)
            .where(spec.to_sqlalchemy())
            .order_by(
                Announcement.priority.desc(),
                Announcement.published_at.desc()
            )
            .limit(limit)
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_requiring_acknowledgment(
        self,
        hostel_id: UUID,
        student_id: Optional[UUID] = None,
        pending_only: bool = True
    ) -> List[Announcement]:
        """
        Find announcements requiring acknowledgment.
        
        Args:
            hostel_id: Hostel UUID
            student_id: Optional student filter
            pending_only: Only unacknowledged announcements
            
        Returns:
            List of announcements requiring acknowledgment
        """
        spec = RequiresAcknowledgmentSpec()
        
        query = (
            select(Announcement)
            .where(Announcement.hostel_id == hostel_id)
            .where(spec.to_sqlalchemy())
        )
        
        if student_id and pending_only:
            # Only announcements not yet acknowledged by this student
            from app.models.announcement import Acknowledgment
            
            acknowledged_subq = (
                select(Acknowledgment.announcement_id)
                .where(Acknowledgment.student_id == student_id)
            )
            
            query = query.where(
                ~Announcement.id.in_(acknowledged_subq)
            )
        
        query = query.order_by(
            Announcement.acknowledgment_deadline.asc().nullslast(),
            Announcement.published_at.desc()
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_expiring_soon(
        self,
        hostel_id: UUID,
        hours: int = 24
    ) -> List[Announcement]:
        """
        Find announcements expiring within specified hours.
        
        Args:
            hostel_id: Hostel UUID
            hours: Hours until expiration
            
        Returns:
            List of expiring announcements
        """
        now = datetime.utcnow()
        expiry_threshold = now + timedelta(hours=hours)
        
        query = (
            select(Announcement)
            .where(Announcement.hostel_id == hostel_id)
            .where(Announcement.is_published == True)
            .where(Announcement.is_deleted == False)
            .where(Announcement.expires_at.isnot(None))
            .where(Announcement.expires_at > now)
            .where(Announcement.expires_at <= expiry_threshold)
            .order_by(Announcement.expires_at.asc())
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def search_announcements(
        self,
        hostel_id: UUID,
        search_term: str,
        filters: Optional[FilterCriteria] = None,
        pagination: Optional[PaginationParams] = None
    ) -> PaginatedResult[Announcement]:
        """
        Full-text search with relevance ranking.
        
        Args:
            hostel_id: Hostel UUID
            search_term: Search query
            filters: Additional filters
            pagination: Pagination parameters
            
        Returns:
            Paginated search results
        """
        # PostgreSQL full-text search
        search_query = func.to_tsquery('english', search_term)
        
        query = (
            QueryBuilder(Announcement, self.session)
            .where(Announcement.hostel_id == hostel_id)
            .where(Announcement.is_deleted == False)
            .where(
                or_(
                    func.to_tsvector('english', Announcement.title)
                    .match(search_query),
                    func.to_tsvector('english', Announcement.content)
                    .match(search_query)
                )
            )
        )
        
        if filters:
            query = self._apply_filters(query, filters)
        
        # Relevance ranking
        title_rank = func.ts_rank(
            func.to_tsvector('english', Announcement.title),
            search_query
        )
        content_rank = func.ts_rank(
            func.to_tsvector('english', Announcement.content),
            search_query
        )
        
        query = query.order_by(
            (title_rank * 2 + content_rank).desc(),
            Announcement.published_at.desc()
        )
        
        return query.paginate(pagination or PaginationParams())
    
    # ==================== Update Operations ====================
    
    def update_content(
        self,
        announcement_id: UUID,
        title: Optional[str] = None,
        content: Optional[str] = None,
        modified_by_id: UUID = None,
        change_summary: Optional[str] = None
    ) -> Announcement:
        """
        Update announcement content with versioning.
        
        Args:
            announcement_id: Announcement UUID
            title: New title
            content: New content
            modified_by_id: User making changes
            change_summary: Summary of changes
            
        Returns:
            Updated announcement
        """
        announcement = self.find_by_id(announcement_id)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        if announcement.is_published:
            raise BusinessLogicError(
                "Cannot edit published announcement. Create new version instead."
            )
        
        changed_fields = []
        
        if title and title != announcement.title:
            announcement.title = title
            changed_fields.append('title')
        
        if content and content != announcement.content:
            announcement.content = content
            changed_fields.append('content')
        
        if changed_fields:
            announcement.version_number += 1
            announcement.updated_at = datetime.utcnow()
            
            # Create version snapshot
            self._create_version(
                announcement,
                modified_by_id,
                change_summary or f"Updated {', '.join(changed_fields)}",
                changed_fields
            )
        
        self.session.flush()
        return announcement
    
    def publish_announcement(
        self,
        announcement_id: UUID,
        published_by_id: UUID,
        scheduled_for: Optional[datetime] = None
    ) -> Announcement:
        """
        Publish announcement immediately or schedule for later.
        
        Args:
            announcement_id: Announcement UUID
            published_by_id: Publisher user UUID
            scheduled_for: Optional scheduled publication time
            
        Returns:
            Published/scheduled announcement
        """
        announcement = self.find_by_id(announcement_id)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        if announcement.is_published:
            raise BusinessLogicError("Announcement already published")
        
        if scheduled_for:
            # Schedule for future publication
            announcement.scheduled_publish_at = scheduled_for
            announcement.status = AnnouncementStatus.SCHEDULED
        else:
            # Publish immediately
            now = datetime.utcnow()
            announcement.is_published = True
            announcement.published_at = now
            announcement.published_by_id = published_by_id
            announcement.status = AnnouncementStatus.PUBLISHED
        
        self.session.flush()
        return announcement
    
    def unpublish_announcement(
        self,
        announcement_id: UUID,
        reason: Optional[str] = None
    ) -> Announcement:
        """
        Unpublish announcement (retract).
        
        Args:
            announcement_id: Announcement UUID
            reason: Reason for unpublishing
            
        Returns:
            Unpublished announcement
        """
        announcement = self.find_by_id(announcement_id)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        if not announcement.is_published:
            raise BusinessLogicError("Announcement not published")
        
        announcement.is_published = False
        announcement.status = AnnouncementStatus.DRAFT
        announcement.metadata = announcement.metadata or {}
        announcement.metadata['unpublish_reason'] = reason
        announcement.metadata['unpublished_at'] = datetime.utcnow().isoformat()
        
        self.session.flush()
        return announcement
    
    def pin_announcement(
        self,
        announcement_id: UUID,
        pinned: bool = True
    ) -> Announcement:
        """
        Pin/unpin announcement to top of list.
        
        Args:
            announcement_id: Announcement UUID
            pinned: Pin status
            
        Returns:
            Updated announcement
        """
        announcement = self.find_by_id(announcement_id)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        announcement.is_pinned = pinned
        self.session.flush()
        return announcement
    
    def mark_urgent(
        self,
        announcement_id: UUID,
        urgent: bool = True
    ) -> Announcement:
        """
        Mark announcement as urgent/normal.
        
        Args:
            announcement_id: Announcement UUID
            urgent: Urgent status
            
        Returns:
            Updated announcement
        """
        announcement = self.find_by_id(announcement_id)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        announcement.is_urgent = urgent
        self.session.flush()
        return announcement
    
    def update_engagement_metrics(
        self,
        announcement_id: UUID
    ) -> Announcement:
        """
        Recalculate and update engagement metrics.
        
        Args:
            announcement_id: Announcement UUID
            
        Returns:
            Updated announcement
        """
        announcement = self.find_by_id(announcement_id)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        # Count reads
        from app.models.announcement import ReadReceipt
        read_count = (
            self.session.query(func.count(ReadReceipt.id))
            .filter(ReadReceipt.announcement_id == announcement_id)
            .scalar()
        ) or 0
        
        # Count acknowledgments if required
        acknowledged_count = 0
        if announcement.requires_acknowledgment:
            from app.models.announcement import Acknowledgment
            acknowledged_count = (
                self.session.query(func.count(Acknowledgment.id))
                .filter(Acknowledgment.announcement_id == announcement_id)
                .scalar()
            ) or 0
        
        # Update metrics
        announcement.read_count = read_count
        announcement.acknowledged_count = acknowledged_count
        
        # Calculate engagement rate
        if announcement.total_recipients > 0:
            if announcement.requires_acknowledgment:
                rate = (acknowledged_count / announcement.total_recipients) * 100
            else:
                rate = (read_count / announcement.total_recipients) * 100
            announcement.engagement_rate = Decimal(str(round(rate, 2)))
        
        self.session.flush()
        return announcement
    
    # ==================== Archive Operations ====================
    
    def archive_announcement(
        self,
        announcement_id: UUID,
        archived_by_id: UUID,
        reason: Optional[str] = None
    ) -> Announcement:
        """
        Archive announcement.
        
        Args:
            announcement_id: Announcement UUID
            archived_by_id: User archiving
            reason: Archive reason
            
        Returns:
            Archived announcement
        """
        announcement = self.find_by_id(announcement_id)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        if announcement.is_archived:
            raise BusinessLogicError("Announcement already archived")
        
        now = datetime.utcnow()
        announcement.is_archived = True
        announcement.archived_at = now
        announcement.archived_by_id = archived_by_id
        announcement.status = AnnouncementStatus.ARCHIVED
        
        if reason:
            announcement.metadata = announcement.metadata or {}
            announcement.metadata['archive_reason'] = reason
        
        self.session.flush()
        return announcement
    
    def unarchive_announcement(
        self,
        announcement_id: UUID
    ) -> Announcement:
        """
        Restore announcement from archive.
        
        Args:
            announcement_id: Announcement UUID
            
        Returns:
            Restored announcement
        """
        announcement = self.find_by_id(announcement_id, include_deleted=True)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        if not announcement.is_archived:
            raise BusinessLogicError("Announcement not archived")
        
        announcement.is_archived = False
        announcement.archived_at = None
        announcement.archived_by_id = None
        announcement.status = (
            AnnouncementStatus.PUBLISHED
            if announcement.is_published
            else AnnouncementStatus.DRAFT
        )
        
        self.session.flush()
        return announcement
    
    def bulk_archive_expired(
        self,
        hostel_id: UUID,
        archived_by_id: UUID
    ) -> int:
        """
        Bulk archive expired announcements.
        
        Args:
            hostel_id: Hostel UUID
            archived_by_id: User performing archive
            
        Returns:
            Number of announcements archived
        """
        now = datetime.utcnow()
        
        expired_announcements = (
            self.session.query(Announcement)
            .filter(
                Announcement.hostel_id == hostel_id,
                Announcement.is_deleted == False,
                Announcement.is_archived == False,
                Announcement.expires_at.isnot(None),
                Announcement.expires_at <= now
            )
            .all()
        )
        
        count = 0
        for announcement in expired_announcements:
            announcement.is_archived = True
            announcement.archived_at = now
            announcement.archived_by_id = archived_by_id
            announcement.status = AnnouncementStatus.ARCHIVED
            count += 1
        
        self.session.flush()
        return count
    
    # ==================== Statistics & Analytics ====================
    
    def get_announcement_statistics(
        self,
        hostel_id: UUID,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """
        Get comprehensive announcement statistics.
        
        Args:
            hostel_id: Hostel UUID
            start_date: Optional start date filter
            end_date: Optional end date filter
            
        Returns:
            Statistics dictionary
        """
        query = (
            select(Announcement)
            .where(Announcement.hostel_id == hostel_id)
            .where(Announcement.is_deleted == False)
        )
        
        if start_date:
            query = query.where(Announcement.created_at >= start_date)
        if end_date:
            query = query.where(Announcement.created_at <= end_date)
        
        # Total counts by status
        status_counts = (
            self.session.query(
                Announcement.status,
                func.count(Announcement.id)
            )
            .filter(Announcement.hostel_id == hostel_id)
            .filter(Announcement.is_deleted == False)
            .group_by(Announcement.status)
            .all()
        )
        
        # Category distribution
        category_counts = (
            self.session.query(
                Announcement.category,
                func.count(Announcement.id)
            )
            .filter(Announcement.hostel_id == hostel_id)
            .filter(Announcement.is_deleted == False)
            .group_by(Announcement.category)
            .all()
        )
        
        # Engagement metrics
        avg_engagement = (
            self.session.query(
                func.avg(Announcement.engagement_rate),
                func.avg(Announcement.read_count),
                func.avg(Announcement.acknowledged_count)
            )
            .filter(Announcement.hostel_id == hostel_id)
            .filter(Announcement.is_published == True)
            .filter(Announcement.is_deleted == False)
            .first()
        )
        
        return {
            'total_announcements': sum(count for _, count in status_counts),
            'status_breakdown': {
                status.value: count for status, count in status_counts
            },
            'category_breakdown': {
                category.value: count for category, count in category_counts
            },
            'average_engagement_rate': float(avg_engagement[0] or 0),
            'average_read_count': float(avg_engagement[1] or 0),
            'average_acknowledged_count': float(avg_engagement[2] or 0),
            'active_announcements': self._count_active(hostel_id),
            'urgent_announcements': self._count_urgent(hostel_id),
            'pending_acknowledgment': self._count_pending_acknowledgment(hostel_id),
        }
    
    def get_performance_metrics(
        self,
        announcement_id: UUID
    ) -> Dict[str, Any]:
        """
        Get detailed performance metrics for an announcement.
        
        Args:
            announcement_id: Announcement UUID
            
        Returns:
            Performance metrics dictionary
        """
        announcement = self.find_by_id(announcement_id)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        # Read receipt analysis
        from app.models.announcement import ReadReceipt, AnnouncementView
        
        total_views = (
            self.session.query(func.count(AnnouncementView.id))
            .filter(AnnouncementView.announcement_id == announcement_id)
            .scalar()
        ) or 0
        
        unique_viewers = (
            self.session.query(func.count(func.distinct(AnnouncementView.student_id)))
            .filter(AnnouncementView.announcement_id == announcement_id)
            .scalar()
        ) or 0
        
        avg_reading_time = (
            self.session.query(func.avg(ReadReceipt.reading_time_seconds))
            .filter(ReadReceipt.announcement_id == announcement_id)
            .scalar()
        ) or 0
        
        return {
            'announcement_id': str(announcement_id),
            'total_recipients': announcement.total_recipients,
            'read_count': announcement.read_count,
            'read_percentage': announcement.read_percentage,
            'acknowledged_count': announcement.acknowledged_count,
            'acknowledgment_percentage': announcement.acknowledgment_percentage,
            'engagement_rate': float(announcement.engagement_rate),
            'total_views': total_views,
            'unique_viewers': unique_viewers,
            'average_reading_time_seconds': float(avg_reading_time),
            'is_active': announcement.is_active,
            'is_expired': announcement.is_expired,
        }
    
    def get_top_performing_announcements(
        self,
        hostel_id: UUID,
        limit: int = 10,
        metric: str = 'engagement_rate'
    ) -> List[Tuple[Announcement, float]]:
        """
        Get top performing announcements by metric.
        
        Args:
            hostel_id: Hostel UUID
            limit: Number of results
            metric: Performance metric to rank by
            
        Returns:
            List of (announcement, metric_value) tuples
        """
        metric_column = getattr(Announcement, metric, Announcement.engagement_rate)
        
        query = (
            select(Announcement, metric_column)
            .where(Announcement.hostel_id == hostel_id)
            .where(Announcement.is_published == True)
            .where(Announcement.is_deleted == False)
            .order_by(metric_column.desc())
            .limit(limit)
        )
        
        result = self.session.execute(query)
        return [(row[0], float(row[1]) if row[1] else 0) for row in result]
    
    # ==================== Helper Methods ====================
    
    def _create_version(
        self,
        announcement: Announcement,
        modified_by_id: UUID,
        change_summary: str,
        changed_fields: Optional[List[str]] = None
    ) -> AnnouncementVersion:
        """Create version snapshot of announcement."""
        version = AnnouncementVersion(
            announcement_id=announcement.id,
            modified_by_id=modified_by_id,
            version_number=announcement.version_number,
            title=announcement.title,
            content=announcement.content,
            change_summary=change_summary,
            changed_fields=changed_fields,
            version_data={
                'title': announcement.title,
                'content': announcement.content,
                'category': announcement.category.value,
                'priority': announcement.priority.value,
                'target_audience': announcement.target_audience.value,
                'is_urgent': announcement.is_urgent,
                'is_pinned': announcement.is_pinned,
            }
        )
        
        self.session.add(version)
        return version
    
    def _apply_filters(
        self,
        query: QueryBuilder,
        filters: FilterCriteria
    ) -> QueryBuilder:
        """Apply filter criteria to query."""
        if filters.category:
            query = query.where(Announcement.category == filters.category)
        
        if filters.priority:
            query = query.where(Announcement.priority == filters.priority)
        
        if filters.status:
            query = query.where(Announcement.status == filters.status)
        
        if filters.is_urgent is not None:
            query = query.where(Announcement.is_urgent == filters.is_urgent)
        
        if filters.is_pinned is not None:
            query = query.where(Announcement.is_pinned == filters.is_pinned)
        
        if filters.date_from:
            query = query.where(Announcement.created_at >= filters.date_from)
        
        if filters.date_to:
            query = query.where(Announcement.created_at <= filters.date_to)
        
        return query
    
    def _count_active(self, hostel_id: UUID) -> int:
        """Count active announcements."""
        spec = ActiveAnnouncementsSpec()
        return (
            self.session.query(func.count(Announcement.id))
            .filter(Announcement.hostel_id == hostel_id)
            .filter(spec.to_sqlalchemy())
            .scalar()
        ) or 0
    
    def _count_urgent(self, hostel_id: UUID) -> int:
        """Count urgent announcements."""
        spec = UrgentAnnouncementsSpec()
        return (
            self.session.query(func.count(Announcement.id))
            .filter(Announcement.hostel_id == hostel_id)
            .filter(spec.to_sqlalchemy())
            .scalar()
        ) or 0
    
    def _count_pending_acknowledgment(self, hostel_id: UUID) -> int:
        """Count announcements with pending acknowledgments."""
        now = datetime.utcnow()
        return (
            self.session.query(func.count(Announcement.id))
            .filter(
                Announcement.hostel_id == hostel_id,
                Announcement.requires_acknowledgment == True,
                Announcement.is_published == True,
                Announcement.acknowledged_count < Announcement.total_recipients,
                or_(
                    Announcement.acknowledgment_deadline.is_(None),
                    Announcement.acknowledgment_deadline > now
                )
            )
            .scalar()
        ) or 0

# --- File: C:\Hostel-Main\app\repositories\announcement\announcement_scheduling_repository.py ---
"""
Announcement Scheduling Repository

Advanced scheduling with recurring patterns, queue management, and execution tracking.
"""

from datetime import datetime, timedelta, time
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
import pytz

from sqlalchemy import and_, or_, func, select, case
from sqlalchemy.orm import Session, joinedload, selectinload
from sqlalchemy.sql import Select

from app.models.announcement import (
    AnnouncementSchedule,
    RecurringAnnouncement,
    ScheduleExecution,
    PublishQueue,
    Announcement,
)
from app.repositories.base.base_repository import BaseRepository
from app.repositories.base.query_builder import QueryBuilder
from app.repositories.base.pagination import PaginationParams, PaginatedResult
from app.core.exceptions import (
    ResourceNotFoundError,
    ValidationError,
    BusinessLogicError,
)


class AnnouncementSchedulingRepository(BaseRepository[AnnouncementSchedule]):
    """
    Repository for announcement scheduling.
    
    Provides comprehensive scheduling capabilities including:
    - One-time and recurring schedules
    - Timezone-aware scheduling
    - Queue management
    - Execution tracking
    - SLA monitoring
    - Auto-expiry management
    """
    
    def __init__(self, session: Session):
        super().__init__(AnnouncementSchedule, session)
    
    # ==================== Schedule Management ====================
    
    def create_schedule(
        self,
        announcement_id: UUID,
        scheduled_by_id: UUID,
        publish_at: datetime,
        timezone: str = 'UTC',
        auto_expire: bool = False,
        expire_after_hours: Optional[int] = None,
        **kwargs
    ) -> AnnouncementSchedule:
        """
        Create announcement schedule.
        
        Args:
            announcement_id: Announcement UUID
            scheduled_by_id: User creating schedule
            publish_at: Publication datetime
            timezone: Timezone for scheduling
            auto_expire: Enable auto-expiry
            expire_after_hours: Hours until expiry
            **kwargs: Additional schedule parameters
            
        Returns:
            Created schedule
        """
        # Validate timezone
        try:
            tz = pytz.timezone(timezone)
        except pytz.UnknownTimeZoneError:
            raise ValidationError(f"Invalid timezone: {timezone}")
        
        # Calculate expiry if auto-expire enabled
        calculated_expire_at = None
        if auto_expire and expire_after_hours:
            calculated_expire_at = publish_at + timedelta(hours=expire_after_hours)
        
        # Calculate SLA deadline (default 1 hour before publish)
        sla_deadline = publish_at - timedelta(hours=1)
        
        schedule = AnnouncementSchedule(
            announcement_id=announcement_id,
            scheduled_by_id=scheduled_by_id,
            scheduled_publish_at=publish_at,
            timezone=timezone,
            auto_expire=auto_expire,
            expire_after_hours=expire_after_hours,
            calculated_expire_at=calculated_expire_at,
            next_publish_at=publish_at,
            sla_deadline=sla_deadline,
            **kwargs
        )
        
        self.session.add(schedule)
        self.session.flush()
        
        # Add to publish queue
        self._add_to_publish_queue(schedule)
        
        return schedule
    
    def create_recurring_schedule(
        self,
        announcement_id: UUID,
        scheduled_by_id: UUID,
        first_publish_at: datetime,
        recurrence_pattern: str,
        timezone: str = 'UTC',
        end_date: Optional[datetime] = None,
        max_occurrences: Optional[int] = None,
        **kwargs
    ) -> AnnouncementSchedule:
        """
        Create recurring announcement schedule.
        
        Args:
            announcement_id: Announcement UUID
            scheduled_by_id: User creating schedule
            first_publish_at: First publication datetime
            recurrence_pattern: Pattern (daily, weekly, monthly)
            timezone: Timezone for scheduling
            end_date: When recurrence ends
            max_occurrences: Maximum occurrences
            **kwargs: Additional parameters
            
        Returns:
            Created recurring schedule
        """
        if recurrence_pattern not in ['daily', 'weekly', 'biweekly', 'monthly']:
            raise ValidationError(f"Invalid recurrence pattern: {recurrence_pattern}")
        
        if not end_date and not max_occurrences:
            raise ValidationError(
                "Either end_date or max_occurrences must be specified"
            )
        
        schedule = self.create_schedule(
            announcement_id=announcement_id,
            scheduled_by_id=scheduled_by_id,
            publish_at=first_publish_at,
            timezone=timezone,
            is_recurring=True,
            recurrence_pattern=recurrence_pattern,
            recurrence_end_date=end_date,
            max_occurrences=max_occurrences,
            **kwargs
        )
        
        return schedule
    
    def update_schedule(
        self,
        schedule_id: UUID,
        new_publish_at: Optional[datetime] = None,
        **updates
    ) -> AnnouncementSchedule:
        """
        Update scheduled announcement.
        
        Args:
            schedule_id: Schedule UUID
            new_publish_at: New publication time
            **updates: Additional field updates
            
        Returns:
            Updated schedule
        """
        schedule = self.find_by_id(schedule_id)
        if not schedule:
            raise ResourceNotFoundError(f"Schedule {schedule_id} not found")
        
        if schedule.status != 'pending':
            raise BusinessLogicError(
                f"Cannot update schedule in {schedule.status} status"
            )
        
        if new_publish_at:
            schedule.scheduled_publish_at = new_publish_at
            schedule.next_publish_at = new_publish_at
            
            # Update queue
            self._update_publish_queue(schedule)
        
        # Apply other updates
        for key, value in updates.items():
            if hasattr(schedule, key):
                setattr(schedule, key, value)
        
        self.session.flush()
        return schedule
    
    def cancel_schedule(
        self,
        schedule_id: UUID,
        cancelled_by_id: UUID,
        reason: Optional[str] = None
    ) -> AnnouncementSchedule:
        """
        Cancel scheduled announcement.
        
        Args:
            schedule_id: Schedule UUID
            cancelled_by_id: User cancelling
            reason: Cancellation reason
            
        Returns:
            Cancelled schedule
        """
        schedule = self.find_by_id(schedule_id)
        if not schedule:
            raise ResourceNotFoundError(f"Schedule {schedule_id} not found")
        
        if schedule.status == 'published':
            raise BusinessLogicError("Cannot cancel already published schedule")
        
        schedule.is_cancelled = True
        schedule.cancelled_at = datetime.utcnow()
        schedule.cancelled_by_id = cancelled_by_id
        schedule.cancellation_reason = reason
        schedule.status = 'cancelled'
        
        # Remove from publish queue
        self._remove_from_publish_queue(schedule.announcement_id)
        
        self.session.flush()
        return schedule
    
    # ==================== Recurring Announcements ====================
    
    def create_recurring_announcement(
        self,
        hostel_id: UUID,
        created_by_id: UUID,
        title_template: str,
        content_template: str,
        recurrence_pattern: str,
        publish_time: time,
        start_date: datetime,
        timezone: str = 'UTC',
        **kwargs
    ) -> RecurringAnnouncement:
        """
        Create recurring announcement template.
        
        Args:
            hostel_id: Hostel UUID
            created_by_id: Creator user UUID
            title_template: Title template
            content_template: Content template
            recurrence_pattern: Recurrence pattern
            publish_time: Time of day to publish
            start_date: Start date
            timezone: Timezone
            **kwargs: Additional parameters
            
        Returns:
            Created recurring announcement
        """
        recurring = RecurringAnnouncement(
            hostel_id=hostel_id,
            created_by_id=created_by_id,
            title_template=title_template,
            content_template=content_template,
            recurrence_pattern=recurrence_pattern,
            publish_time=publish_time,
            start_date=start_date,
            timezone=timezone,
            **kwargs
        )
        
        # Calculate next publish time
        recurring.next_publish_at = self._calculate_next_occurrence(
            start_date, publish_time, recurrence_pattern, timezone
        )
        
        self.session.add(recurring)
        self.session.flush()
        
        return recurring
    
    def process_due_recurring_announcements(
        self,
        batch_size: int = 50
    ) -> List[Announcement]:
        """
        Process recurring announcements that are due.
        
        Args:
            batch_size: Maximum to process
            
        Returns:
            List of created announcements
        """
        now = datetime.utcnow()
        
        # Find due recurring announcements
        due_recurring = (
            self.session.query(RecurringAnnouncement)
            .filter(
                RecurringAnnouncement.is_active == True,
                RecurringAnnouncement.is_paused == False,
                RecurringAnnouncement.next_publish_at <= now
            )
            .limit(batch_size)
            .all()
        )
        
        created_announcements = []
        
        for recurring in due_recurring:
            # Create announcement from template
            announcement = self._create_from_recurring_template(recurring)
            created_announcements.append(announcement)
            
            # Update recurring announcement
            recurring.total_published += 1
            recurring.last_published_at = now
            
            # Calculate next occurrence
            if self._should_continue_recurrence(recurring):
                recurring.next_publish_at = self._calculate_next_occurrence(
                    recurring.next_publish_at,
                    recurring.publish_time,
                    recurring.recurrence_pattern,
                    recurring.timezone
                )
            else:
                # End of recurrence
                recurring.is_active = False
                recurring.next_publish_at = None
            
            # Track generated announcement
            if not recurring.generated_announcement_ids:
                recurring.generated_announcement_ids = []
            recurring.generated_announcement_ids.append(announcement.id)
        
        self.session.flush()
        return created_announcements
    
    # ==================== Queue Management ====================
    
    def get_pending_publications(
        self,
        limit: int = 100,
        priority_threshold: int = 0
    ) -> List[PublishQueue]:
        """
        Get pending publications from queue.
        
        Args:
            limit: Maximum items to return
            priority_threshold: Minimum priority level
            
        Returns:
            List of queue items
        """
        now = datetime.utcnow()
        
        query = (
            select(PublishQueue)
            .where(
                PublishQueue.status == 'pending',
                PublishQueue.scheduled_publish_at <= now,
                PublishQueue.priority >= priority_threshold
            )
            .order_by(
                PublishQueue.is_urgent.desc(),
                PublishQueue.priority.desc(),
                PublishQueue.scheduled_publish_at.asc()
            )
            .limit(limit)
        )
        
        # Check for expired locks
        query = query.where(
            or_(
                PublishQueue.lock_expires_at.is_(None),
                PublishQueue.lock_expires_at < now
            )
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def acquire_queue_lock(
        self,
        queue_id: UUID,
        worker_id: str,
        lock_duration_minutes: int = 5
    ) -> Optional[PublishQueue]:
        """
        Acquire lock on queue item for processing.
        
        Args:
            queue_id: Queue item UUID
            worker_id: Worker identifier
            lock_duration_minutes: Lock duration
            
        Returns:
            Locked queue item or None if already locked
        """
        queue_item = self.session.get(PublishQueue, queue_id)
        if not queue_item:
            return None
        
        now = datetime.utcnow()
        
        # Check if already locked by another worker
        if queue_item.lock_expires_at and queue_item.lock_expires_at > now:
            if queue_item.worker_id != worker_id:
                return None
        
        # Acquire lock
        queue_item.worker_id = worker_id
        queue_item.lock_acquired_at = now
        queue_item.lock_expires_at = now + timedelta(minutes=lock_duration_minutes)
        queue_item.status = 'processing'
        queue_item.processing_started_at = now
        
        self.session.flush()
        return queue_item
    
    def complete_queue_item(
        self,
        queue_id: UUID,
        success: bool = True,
        error: Optional[str] = None
    ) -> PublishQueue:
        """
        Mark queue item as completed.
        
        Args:
            queue_id: Queue item UUID
            success: Whether processing succeeded
            error: Error message if failed
            
        Returns:
            Updated queue item
        """
        queue_item = self.session.get(PublishQueue, queue_id)
        if not queue_item:
            raise ResourceNotFoundError(f"Queue item {queue_id} not found")
        
        now = datetime.utcnow()
        
        if success:
            queue_item.status = 'completed'
            queue_item.processing_completed_at = now
        else:
            queue_item.status = 'failed'
            queue_item.last_error = error
            
            # Add to error history
            if not queue_item.error_history:
                queue_item.error_history = []
            queue_item.error_history.append({
                'timestamp': now.isoformat(),
                'error': error,
                'retry_count': queue_item.retry_count
            })
            
            # Schedule retry if under limit
            if queue_item.retry_count < queue_item.max_retries:
                queue_item.retry_count += 1
                retry_delay = self._calculate_retry_delay(queue_item.retry_count)
                queue_item.next_retry_at = now + retry_delay
                queue_item.status = 'pending'
        
        # Release lock
        queue_item.worker_id = None
        queue_item.lock_acquired_at = None
        queue_item.lock_expires_at = None
        
        self.session.flush()
        return queue_item
    
    # ==================== Execution Tracking ====================
    
    def record_execution(
        self,
        schedule_id: UUID,
        announcement_id: UUID,
        scheduled_for: datetime,
        status: str,
        published: bool = False,
        recipients_count: int = 0,
        error_message: Optional[str] = None
    ) -> ScheduleExecution:
        """
        Record schedule execution.
        
        Args:
            schedule_id: Schedule UUID
            announcement_id: Announcement UUID
            scheduled_for: Scheduled time
            status: Execution status
            published: Whether published
            recipients_count: Number of recipients
            error_message: Error if failed
            
        Returns:
            Created execution record
        """
        start_time = datetime.utcnow()
        
        execution = ScheduleExecution(
            schedule_id=schedule_id,
            announcement_id=announcement_id,
            scheduled_for=scheduled_for,
            executed_at=start_time,
            status=status,
            published=published,
            recipients_count=recipients_count,
            error_message=error_message
        )
        
        self.session.add(execution)
        self.session.flush()
        
        # Update schedule
        schedule = self.session.get(AnnouncementSchedule, schedule_id)
        if schedule:
            schedule.last_executed_at = start_time
            schedule.execution_count += 1
            
            if status == 'failed':
                schedule.failure_count += 1
                schedule.last_failure_at = start_time
                schedule.last_failure_reason = error_message
            
            if published and schedule.is_recurring:
                schedule.occurrences_completed += 1
                
                # Calculate next occurrence
                if self._should_continue_schedule(schedule):
                    schedule.next_publish_at = self._calculate_next_occurrence(
                        schedule.next_publish_at,
                        schedule.scheduled_publish_at.time(),
                        schedule.recurrence_pattern,
                        schedule.timezone
                    )
                else:
                    schedule.status = 'completed'
        
        self.session.flush()
        return execution
    
    def get_execution_history(
        self,
        schedule_id: UUID,
        limit: int = 50
    ) -> List[ScheduleExecution]:
        """
        Get execution history for schedule.
        
        Args:
            schedule_id: Schedule UUID
            limit: Maximum records
            
        Returns:
            List of execution records
        """
        query = (
            select(ScheduleExecution)
            .where(ScheduleExecution.schedule_id == schedule_id)
            .order_by(ScheduleExecution.executed_at.desc())
            .limit(limit)
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    # ==================== SLA Monitoring ====================
    
    def check_sla_breaches(
        self,
        hostel_id: Optional[UUID] = None
    ) -> List[AnnouncementSchedule]:
        """
        Find schedules that have breached SLA.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of schedules with SLA breach
        """
        now = datetime.utcnow()
        
        query = (
            select(AnnouncementSchedule)
            .join(Announcement)
            .where(
                AnnouncementSchedule.status == 'pending',
                AnnouncementSchedule.sla_deadline < now,
                AnnouncementSchedule.sla_breached == False
            )
        )
        
        if hostel_id:
            query = query.where(Announcement.hostel_id == hostel_id)
        
        result = self.session.execute(query)
        breached_schedules = list(result.scalars().all())
        
        # Mark as breached
        for schedule in breached_schedules:
            schedule.sla_breached = True
        
        self.session.flush()
        return breached_schedules
    
    # ==================== Query Operations ====================
    
    def find_by_announcement(
        self,
        announcement_id: UUID
    ) -> Optional[AnnouncementSchedule]:
        """Find schedule for announcement."""
        return (
            self.session.query(AnnouncementSchedule)
            .filter(AnnouncementSchedule.announcement_id == announcement_id)
            .first()
        )
    
    def find_upcoming_schedules(
        self,
        hostel_id: UUID,
        hours_ahead: int = 24,
        limit: int = 50
    ) -> List[AnnouncementSchedule]:
        """
        Find upcoming scheduled announcements.
        
        Args:
            hostel_id: Hostel UUID
            hours_ahead: Hours to look ahead
            limit: Maximum results
            
        Returns:
            List of upcoming schedules
        """
        now = datetime.utcnow()
        end_time = now + timedelta(hours=hours_ahead)
        
        query = (
            select(AnnouncementSchedule)
            .join(Announcement)
            .where(
                Announcement.hostel_id == hostel_id,
                AnnouncementSchedule.status == 'pending',
                AnnouncementSchedule.next_publish_at.between(now, end_time)
            )
            .order_by(AnnouncementSchedule.next_publish_at.asc())
            .limit(limit)
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_recurring_announcements(
        self,
        hostel_id: UUID,
        active_only: bool = True
    ) -> List[RecurringAnnouncement]:
        """Find recurring announcement templates."""
        query = (
            select(RecurringAnnouncement)
            .where(RecurringAnnouncement.hostel_id == hostel_id)
        )
        
        if active_only:
            query = query.where(RecurringAnnouncement.is_active == True)
        
        query = query.order_by(RecurringAnnouncement.next_publish_at.asc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    # ==================== Helper Methods ====================
    
    def _add_to_publish_queue(
        self,
        schedule: AnnouncementSchedule
    ) -> PublishQueue:
        """Add schedule to publish queue."""
        # Check if already in queue
        existing = (
            self.session.query(PublishQueue)
            .filter(PublishQueue.announcement_id == schedule.announcement_id)
            .first()
        )
        
        if existing:
            # Update existing
            existing.scheduled_publish_at = schedule.scheduled_publish_at
            existing.schedule_id = schedule.id
            return existing
        
        # Determine priority
        announcement = self.session.get(Announcement, schedule.announcement_id)
        priority = 10 if announcement.priority.value == 'high' else 5
        
        queue_item = PublishQueue(
            announcement_id=schedule.announcement_id,
            schedule_id=schedule.id,
            scheduled_publish_at=schedule.scheduled_publish_at,
            priority=priority,
            is_urgent=announcement.is_urgent,
        )
        
        self.session.add(queue_item)
        self.session.flush()
        return queue_item
    
    def _update_publish_queue(
        self,
        schedule: AnnouncementSchedule
    ) -> None:
        """Update queue item with new schedule."""
        queue_item = (
            self.session.query(PublishQueue)
            .filter(PublishQueue.announcement_id == schedule.announcement_id)
            .first()
        )
        
        if queue_item:
            queue_item.scheduled_publish_at = schedule.scheduled_publish_at
            self.session.flush()
    
    def _remove_from_publish_queue(
        self,
        announcement_id: UUID
    ) -> None:
        """Remove announcement from publish queue."""
        queue_item = (
            self.session.query(PublishQueue)
            .filter(PublishQueue.announcement_id == announcement_id)
            .first()
        )
        
        if queue_item:
            queue_item.status = 'cancelled'
            self.session.flush()
    
    def _calculate_next_occurrence(
        self,
        current_time: datetime,
        publish_time: time,
        pattern: str,
        timezone_str: str
    ) -> datetime:
        """Calculate next occurrence for recurring pattern."""
        tz = pytz.timezone(timezone_str)
        
        # Localize current time
        if current_time.tzinfo is None:
            current_time = tz.localize(current_time)
        
        # Calculate next occurrence
        if pattern == 'daily':
            next_date = current_time.date() + timedelta(days=1)
        elif pattern == 'weekly':
            next_date = current_time.date() + timedelta(weeks=1)
        elif pattern == 'biweekly':
            next_date = current_time.date() + timedelta(weeks=2)
        elif pattern == 'monthly':
            # Same day next month
            month = current_time.month + 1
            year = current_time.year
            if month > 12:
                month = 1
                year += 1
            try:
                next_date = current_time.date().replace(year=year, month=month)
            except ValueError:
                # Handle day overflow (e.g., Jan 31 -> Feb 28)
                next_date = current_time.date().replace(
                    year=year, month=month, day=1
                ) + timedelta(days=27)
                while next_date.month != month:
                    next_date -= timedelta(days=1)
        else:
            raise ValidationError(f"Invalid recurrence pattern: {pattern}")
        
        # Combine date and time
        next_datetime = tz.localize(
            datetime.combine(next_date, publish_time)
        )
        
        return next_datetime
    
    def _should_continue_recurrence(
        self,
        recurring: RecurringAnnouncement
    ) -> bool:
        """Check if recurrence should continue."""
        # Check end date
        if recurring.end_date:
            if datetime.utcnow() >= recurring.end_date:
                return False
        
        # Check max occurrences
        if recurring.max_occurrences:
            if recurring.total_published >= recurring.max_occurrences:
                return False
        
        return True
    
    def _should_continue_schedule(
        self,
        schedule: AnnouncementSchedule
    ) -> bool:
        """Check if recurring schedule should continue."""
        if not schedule.is_recurring:
            return False
        
        # Check end date
        if schedule.recurrence_end_date:
            if datetime.utcnow() >= schedule.recurrence_end_date:
                return False
        
        # Check max occurrences
        if schedule.max_occurrences:
            if schedule.occurrences_completed >= schedule.max_occurrences:
                return False
        
        return True
    
    def _create_from_recurring_template(
        self,
        recurring: RecurringAnnouncement
    ) -> Announcement:
        """Create announcement from recurring template."""
        from app.models.announcement import Announcement
        
        # Process templates (simple variable substitution)
        now = datetime.utcnow()
        title = recurring.title_template.replace('{date}', now.strftime('%Y-%m-%d'))
        content = recurring.content_template.replace('{date}', now.strftime('%Y-%m-%d'))
        
        announcement = Announcement(
            hostel_id=recurring.hostel_id,
            created_by_id=recurring.created_by_id,
            title=title,
            content=content,
            category=recurring.metadata.get('category', 'general'),
            priority=recurring.metadata.get('priority', 'medium'),
            target_audience=recurring.target_audience,
            target_room_ids=recurring.target_room_ids,
            target_floor_numbers=recurring.target_floor_numbers,
            send_push=recurring.send_push,
            send_email=recurring.send_email,
            send_sms=recurring.send_sms,
            is_published=True,
            published_at=now,
            published_by_id=recurring.created_by_id,
        )
        
        self.session.add(announcement)
        self.session.flush()
        return announcement
    
    def _calculate_retry_delay(self, retry_count: int) -> timedelta:
        """Calculate exponential backoff delay."""
        # Exponential backoff: 2^retry_count minutes
        delay_minutes = 2 ** retry_count
        return timedelta(minutes=min(delay_minutes, 60))  # Max 1 hour

# --- File: C:\Hostel-Main\app\repositories\announcement\announcement_targeting_repository.py ---
"""
Announcement Targeting Repository

Advanced audience targeting with segmentation, personalization, and delivery optimization.
"""

from datetime import datetime
from typing import List, Optional, Dict, Any, Set, Tuple
from uuid import UUID
from collections import defaultdict

from sqlalchemy import and_, or_, func, select, exists
from sqlalchemy.orm import Session, joinedload, selectinload
from sqlalchemy.dialects.postgresql import array

from app.models.announcement import (
    AnnouncementTarget,
    TargetingRule,
    TargetAudienceCache,
    BulkTargetingRule,
    Announcement,
)
from app.models.base.enums import TargetAudience, RoomType
from app.models.user.user import User
from app.models.room.room import Room
from app.repositories.base.base_repository import BaseRepository
from app.repositories.base.query_builder import QueryBuilder
from app.core.exceptions import (
    ResourceNotFoundError,
    ValidationError,
    BusinessLogicError,
)


class AnnouncementTargetingRepository(BaseRepository[AnnouncementTarget]):
    """
    Repository for announcement audience targeting.
    
    Provides sophisticated targeting capabilities including:
    - Dynamic audience segmentation
    - Target reach calculation
    - Delivery timing optimization
    - Content personalization
    - Targeting effectiveness tracking
    - Audience preference management
    - Over-messaging prevention
    """
    
    def __init__(self, session: Session):
        super().__init__(AnnouncementTarget, session)
    
    # ==================== Audience Segmentation ====================
    
    def build_audience_segment(
        self,
        announcement_id: UUID,
        target_type: TargetAudience,
        created_by_id: UUID,
        **targeting_params
    ) -> AnnouncementTarget:
        """
        Build audience segment for announcement.
        
        Args:
            announcement_id: Announcement UUID
            target_type: Target audience type
            created_by_id: User creating target
            **targeting_params: Additional targeting parameters
            
        Returns:
            Created targeting configuration
        """
        target = AnnouncementTarget(
            announcement_id=announcement_id,
            created_by_id=created_by_id,
            target_type=target_type,
            **targeting_params
        )
        
        self.session.add(target)
        self.session.flush()
        
        # Calculate recipients
        student_ids = self._calculate_target_audience(target)
        target.estimated_recipients = len(student_ids)
        
        # Validate targeting
        self._validate_targeting(target)
        
        self.session.flush()
        return target
    
    def build_multi_criteria_segment(
        self,
        announcement_id: UUID,
        created_by_id: UUID,
        criteria: List[Dict[str, Any]]
    ) -> AnnouncementTarget:
        """
        Build segment with multiple targeting criteria.
        
        Args:
            announcement_id: Announcement UUID
            created_by_id: User creating target
            criteria: List of targeting criteria
            
        Returns:
            Created targeting configuration with rules
        """
        target = AnnouncementTarget(
            announcement_id=announcement_id,
            created_by_id=created_by_id,
            target_type=TargetAudience.CUSTOM,
        )
        
        self.session.add(target)
        self.session.flush()
        
        # Create targeting rules
        for priority, criterion in enumerate(criteria):
            rule = TargetingRule(
                target_id=target.id,
                rule_type=criterion['type'],
                rule_field=criterion['field'],
                rule_operator=criterion['operator'],
                rule_value=criterion['value'],
                priority=priority,
                is_inclusion=criterion.get('is_inclusion', True),
                description=criterion.get('description'),
            )
            self.session.add(rule)
        
        self.session.flush()
        
        # Calculate recipients
        student_ids = self._calculate_target_audience(target)
        target.estimated_recipients = len(student_ids)
        target.is_validated = True
        target.validated_at = datetime.utcnow()
        
        self.session.flush()
        return target
    
    def calculate_target_reach(
        self,
        announcement_id: UUID,
        update_cache: bool = True
    ) -> Dict[str, Any]:
        """
        Calculate and analyze target audience reach.
        
        Args:
            announcement_id: Announcement UUID
            update_cache: Whether to update audience cache
            
        Returns:
            Reach analysis dictionary
        """
        target = self._get_target_by_announcement(announcement_id)
        if not target:
            raise ResourceNotFoundError(
                f"No targeting found for announcement {announcement_id}"
            )
        
        # Calculate audience
        student_ids = self._calculate_target_audience(target)
        
        # Get detailed breakdown
        breakdown = self._get_audience_breakdown(student_ids)
        
        # Update target
        target.actual_recipients = len(student_ids)
        
        # Cache results if requested
        if update_cache:
            self._update_audience_cache(target, student_ids, breakdown)
        
        self.session.flush()
        
        return {
            'announcement_id': str(announcement_id),
            'target_type': target.target_type.value,
            'estimated_recipients': target.estimated_recipients,
            'actual_recipients': len(student_ids),
            'student_ids': [str(sid) for sid in student_ids],
            'breakdown_by_room': breakdown['by_room'],
            'breakdown_by_floor': breakdown['by_floor'],
            'breakdown_by_status': breakdown['by_status'],
        }
    
    def optimize_delivery_timing(
        self,
        announcement_id: UUID,
        student_ids: Optional[List[UUID]] = None
    ) -> Dict[str, Any]:
        """
        Calculate optimal delivery time for target audience.
        
        Args:
            announcement_id: Announcement UUID
            student_ids: Optional specific student list
            
        Returns:
            Optimal timing recommendations
        """
        if not student_ids:
            target = self._get_target_by_announcement(announcement_id)
            student_ids = self._calculate_target_audience(target)
        
        # Analyze historical engagement patterns
        from app.models.announcement import AnnouncementView
        
        # Get hour-of-day engagement distribution
        hourly_engagement = (
            self.session.query(
                func.extract('hour', AnnouncementView.viewed_at).label('hour'),
                func.count(AnnouncementView.id).label('views')
            )
            .filter(AnnouncementView.student_id.in_(student_ids))
            .group_by('hour')
            .all()
        )
        
        # Get day-of-week engagement
        daily_engagement = (
            self.session.query(
                func.extract('dow', AnnouncementView.viewed_at).label('day'),
                func.count(AnnouncementView.id).label('views')
            )
            .filter(AnnouncementView.student_id.in_(student_ids))
            .group_by('day')
            .all()
        )
        
        # Find peak engagement times
        peak_hour = max(hourly_engagement, key=lambda x: x.views) if hourly_engagement else None
        peak_day = max(daily_engagement, key=lambda x: x.views) if daily_engagement else None
        
        return {
            'optimal_hour': int(peak_hour.hour) if peak_hour else 9,  # Default to 9 AM
            'optimal_day': int(peak_day.day) if peak_day else 1,  # Default to Monday
            'hourly_distribution': {
                int(h.hour): h.views for h in hourly_engagement
            },
            'daily_distribution': {
                int(d.day): d.views for d in daily_engagement
            },
            'total_students_analyzed': len(student_ids),
        }
    
    def personalize_content(
        self,
        announcement_id: UUID,
        student_id: UUID
    ) -> Dict[str, Any]:
        """
        Generate personalized content based on recipient profile.
        
        Args:
            announcement_id: Announcement UUID
            student_id: Student UUID
            
        Returns:
            Personalization data
        """
        # Get student profile
        student = self.session.get(User, student_id)
        if not student:
            raise ResourceNotFoundError(f"Student {student_id} not found")
        
        # Get announcement
        announcement = self.session.get(Announcement, announcement_id)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        # Build personalization context
        personalization = {
            'student_name': student.full_name,
            'student_first_name': student.first_name,
            'room_number': student.room.room_number if student.room else None,
            'floor_number': student.room.floor_number if student.room else None,
            'preferred_language': student.preferred_language or 'en',
            'notification_preferences': self._get_notification_preferences(student_id),
            'past_engagement': self._get_engagement_history(student_id),
        }
        
        return personalization
    
    def track_targeting_effectiveness(
        self,
        announcement_id: UUID
    ) -> Dict[str, Any]:
        """
        Track and analyze targeting strategy effectiveness.
        
        Args:
            announcement_id: Announcement UUID
            
        Returns:
            Effectiveness metrics
        """
        target = self._get_target_by_announcement(announcement_id)
        if not target:
            raise ResourceNotFoundError(
                f"No targeting found for announcement {announcement_id}"
            )
        
        announcement = self.session.get(Announcement, announcement_id)
        
        # Calculate effectiveness metrics
        from app.models.announcement import ReadReceipt, Acknowledgment
        
        actual_reads = (
            self.session.query(func.count(ReadReceipt.id))
            .filter(ReadReceipt.announcement_id == announcement_id)
            .scalar()
        ) or 0
        
        actual_acknowledgments = 0
        if announcement.requires_acknowledgment:
            actual_acknowledgments = (
                self.session.query(func.count(Acknowledgment.id))
                .filter(Acknowledgment.announcement_id == announcement_id)
                .scalar()
            ) or 0
        
        # Calculate rates
        total_recipients = target.actual_recipients or target.estimated_recipients
        read_rate = (actual_reads / total_recipients * 100) if total_recipients > 0 else 0
        ack_rate = (actual_acknowledgments / total_recipients * 100) if total_recipients > 0 else 0
        
        return {
            'target_type': target.target_type.value,
            'estimated_recipients': target.estimated_recipients,
            'actual_recipients': target.actual_recipients,
            'accuracy': self._calculate_estimation_accuracy(target),
            'read_rate': round(read_rate, 2),
            'acknowledgment_rate': round(ack_rate, 2),
            'effectiveness_score': self._calculate_effectiveness_score(
                read_rate, ack_rate, announcement.requires_acknowledgment
            ),
        }
    
    def manage_audience_preferences(
        self,
        student_id: UUID,
        preferences: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Manage student notification and targeting preferences.
        
        Args:
            student_id: Student UUID
            preferences: Preference settings
            
        Returns:
            Updated preferences
        """
        student = self.session.get(User, student_id)
        if not student:
            raise ResourceNotFoundError(f"Student {student_id} not found")
        
        # Update preferences in student metadata
        if not student.metadata:
            student.metadata = {}
        
        student.metadata['notification_preferences'] = preferences
        student.metadata['preferences_updated_at'] = datetime.utcnow().isoformat()
        
        self.session.flush()
        
        return preferences
    
    def prevent_over_messaging(
        self,
        student_ids: List[UUID],
        timeframe_hours: int = 24,
        max_announcements: int = 5
    ) -> Tuple[List[UUID], List[UUID]]:
        """
        Filter students to prevent announcement fatigue.
        
        Args:
            student_ids: List of student UUIDs
            timeframe_hours: Time window to check
            max_announcements: Maximum announcements allowed
            
        Returns:
            Tuple of (eligible_students, filtered_out_students)
        """
        cutoff_time = datetime.utcnow() - timedelta(hours=timeframe_hours)
        
        # Count announcements received by each student
        from app.models.announcement import AnnouncementRecipient
        
        announcement_counts = (
            self.session.query(
                AnnouncementRecipient.student_id,
                func.count(AnnouncementRecipient.id).label('count')
            )
            .filter(
                AnnouncementRecipient.student_id.in_(student_ids),
                AnnouncementRecipient.created_at >= cutoff_time
            )
            .group_by(AnnouncementRecipient.student_id)
            .all()
        )
        
        # Build count dictionary
        student_counts = {str(sid): count for sid, count in announcement_counts}
        
        # Filter students
        eligible = []
        filtered_out = []
        
        for student_id in student_ids:
            count = student_counts.get(str(student_id), 0)
            if count < max_announcements:
                eligible.append(student_id)
            else:
                filtered_out.append(student_id)
        
        return eligible, filtered_out
    
    # ==================== Bulk Targeting ====================
    
    def create_bulk_targeting_rule(
        self,
        announcement_id: UUID,
        created_by_id: UUID,
        rule_name: str,
        target_ids: List[UUID],
        combine_mode: str = 'union',
        global_exclusions: Optional[List[UUID]] = None
    ) -> BulkTargetingRule:
        """
        Create bulk targeting rule with multiple segments.
        
        Args:
            announcement_id: Announcement UUID
            created_by_id: User creating rule
            rule_name: Descriptive name
            target_ids: List of targeting configuration IDs
            combine_mode: How to combine (union/intersection)
            global_exclusions: Students to exclude
            
        Returns:
            Created bulk targeting rule
        """
        bulk_rule = BulkTargetingRule(
            announcement_id=announcement_id,
            created_by_id=created_by_id,
            rule_name=rule_name,
            target_ids=target_ids,
            combine_mode=combine_mode,
            global_exclude_student_ids=global_exclusions or [],
        )
        
        self.session.add(bulk_rule)
        self.session.flush()
        
        return bulk_rule
    
    def process_bulk_targeting(
        self,
        bulk_rule_id: UUID
    ) -> BulkTargetingRule:
        """
        Process bulk targeting rule to calculate final audience.
        
        Args:
            bulk_rule_id: Bulk rule UUID
            
        Returns:
            Processed bulk rule with final audience
        """
        bulk_rule = self.session.get(BulkTargetingRule, bulk_rule_id)
        if not bulk_rule:
            raise ResourceNotFoundError(f"Bulk rule {bulk_rule_id} not found")
        
        # Get all target configurations
        targets = (
            self.session.query(AnnouncementTarget)
            .filter(AnnouncementTarget.id.in_(bulk_rule.target_ids))
            .all()
        )
        
        # Calculate audiences for each target
        audience_sets = []
        for target in targets:
            student_ids = self._calculate_target_audience(target)
            audience_sets.append(set(student_ids))
        
        # Combine based on mode
        if bulk_rule.combine_mode == 'union':
            final_audience = set.union(*audience_sets) if audience_sets else set()
        elif bulk_rule.combine_mode == 'intersection':
            final_audience = set.intersection(*audience_sets) if audience_sets else set()
        else:
            raise ValidationError(f"Invalid combine mode: {bulk_rule.combine_mode}")
        
        # Apply global exclusions
        if bulk_rule.global_exclude_student_ids:
            exclusions = set(bulk_rule.global_exclude_student_ids)
            final_audience = final_audience - exclusions
        
        # Update bulk rule
        bulk_rule.final_student_ids = list(final_audience)
        bulk_rule.final_count = len(final_audience)
        bulk_rule.is_processed = True
        bulk_rule.processed_at = datetime.utcnow()
        
        self.session.flush()
        return bulk_rule
    
    # ==================== Audience Cache Management ====================
    
    def get_cached_audience(
        self,
        announcement_id: UUID,
        refresh_if_stale: bool = True
    ) -> Optional[TargetAudienceCache]:
        """
        Get cached audience data.
        
        Args:
            announcement_id: Announcement UUID
            refresh_if_stale: Refresh cache if stale
            
        Returns:
            Cached audience or None
        """
        cache = (
            self.session.query(TargetAudienceCache)
            .filter(TargetAudienceCache.announcement_id == announcement_id)
            .first()
        )
        
        if not cache:
            return None
        
        # Check if stale
        if cache.is_stale and refresh_if_stale:
            target = self._get_target_by_announcement(announcement_id)
            if target:
                student_ids = self._calculate_target_audience(target)
                breakdown = self._get_audience_breakdown(student_ids)
                cache = self._update_audience_cache(target, student_ids, breakdown)
        
        return cache
    
    def invalidate_audience_cache(
        self,
        announcement_id: UUID
    ) -> None:
        """
        Mark audience cache as stale.
        
        Args:
            announcement_id: Announcement UUID
        """
        cache = (
            self.session.query(TargetAudienceCache)
            .filter(TargetAudienceCache.announcement_id == announcement_id)
            .first()
        )
        
        if cache:
            cache.is_stale = True
            self.session.flush()
    
    # ==================== Query Operations ====================
    
    def find_by_announcement(
        self,
        announcement_id: UUID
    ) -> Optional[AnnouncementTarget]:
        """
        Find targeting configuration for announcement.
        
        Args:
            announcement_id: Announcement UUID
            
        Returns:
            Targeting configuration or None
        """
        return self._get_target_by_announcement(announcement_id)
    
    def get_targeting_rules(
        self,
        target_id: UUID,
        active_only: bool = True
    ) -> List[TargetingRule]:
        """
        Get targeting rules for a target configuration.
        
        Args:
            target_id: Target configuration UUID
            active_only: Only active rules
            
        Returns:
            List of targeting rules
        """
        query = (
            select(TargetingRule)
            .where(TargetingRule.target_id == target_id)
            .order_by(TargetingRule.priority.asc())
        )
        
        if active_only:
            query = query.where(TargetingRule.is_active == True)
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    # ==================== Helper Methods ====================
    
    def _calculate_target_audience(
        self,
        target: AnnouncementTarget
    ) -> List[UUID]:
        """
        Calculate actual student IDs based on targeting configuration.
        
        Args:
            target: Targeting configuration
            
        Returns:
            List of student UUIDs
        """
        announcement = self.session.get(Announcement, target.announcement_id)
        hostel_id = announcement.hostel_id
        
        # Base query for students in hostel
        query = (
            select(User.id)
            .join(Room, User.room_id == Room.id)
            .where(Room.hostel_id == hostel_id)
        )
        
        # Apply target type filters
        if target.target_type == TargetAudience.ALL:
            # All students in hostel
            pass
        
        elif target.target_type == TargetAudience.SPECIFIC_ROOMS:
            if target.room_ids:
                query = query.where(User.room_id.in_(target.room_ids))
        
        elif target.target_type == TargetAudience.SPECIFIC_FLOORS:
            if target.floor_numbers:
                query = query.where(Room.floor_number.in_(target.floor_numbers))
        
        elif target.target_type == TargetAudience.SPECIFIC_STUDENTS:
            if target.student_ids:
                query = select(User.id).where(User.id.in_(target.student_ids))
        
        elif target.target_type == TargetAudience.CUSTOM:
            # Apply custom targeting rules
            rules = self.get_targeting_rules(target.id)
            for rule in rules:
                rule_filter = self._build_rule_filter(rule)
                if rule.is_inclusion:
                    query = query.where(rule_filter)
                else:
                    query = query.where(~rule_filter)
        
        # Apply status filters
        if target.include_active_students:
            query = query.where(User.status == 'ACTIVE')
        
        if target.include_inactive_students:
            query = query.where(User.status == 'INACTIVE')
        
        if target.include_notice_period_students:
            query = query.where(User.status == 'NOTICE_PERIOD')
        
        # Apply exclusions
        if target.exclude_student_ids:
            query = query.where(~User.id.in_(target.exclude_student_ids))
        
        if target.exclude_room_ids:
            query = query.where(~User.room_id.in_(target.exclude_room_ids))
        
        # Execute query
        result = self.session.execute(query)
        return [row[0] for row in result]
    
    def _build_rule_filter(self, rule: TargetingRule):
        """Build SQLAlchemy filter from targeting rule."""
        field = getattr(User, rule.rule_field, None)
        if not field:
            # Try Room model
            field = getattr(Room, rule.rule_field, None)
        
        if not field:
            raise ValidationError(f"Invalid rule field: {rule.rule_field}")
        
        operator = rule.rule_operator
        value = rule.rule_value.get('value')
        
        if operator == 'equals':
            return field == value
        elif operator == 'in':
            return field.in_(value)
        elif operator == 'contains':
            return field.contains(value)
        elif operator == 'greater_than':
            return field > value
        elif operator == 'less_than':
            return field < value
        elif operator == 'between':
            return and_(field >= value[0], field <= value[1])
        else:
            raise ValidationError(f"Invalid operator: {operator}")
    
    def _get_audience_breakdown(
        self,
        student_ids: List[UUID]
    ) -> Dict[str, Dict]:
        """Get detailed breakdown of audience by various dimensions."""
        if not student_ids:
            return {
                'by_room': {},
                'by_floor': {},
                'by_status': {},
            }
        
        # Breakdown by room
        room_breakdown = (
            self.session.query(
                Room.room_number,
                func.count(User.id)
            )
            .join(User, User.room_id == Room.id)
            .filter(User.id.in_(student_ids))
            .group_by(Room.room_number)
            .all()
        )
        
        # Breakdown by floor
        floor_breakdown = (
            self.session.query(
                Room.floor_number,
                func.count(User.id)
            )
            .join(User, User.room_id == Room.id)
            .filter(User.id.in_(student_ids))
            .group_by(Room.floor_number)
            .all()
        )
        
        # Breakdown by status
        status_breakdown = (
            self.session.query(
                User.status,
                func.count(User.id)
            )
            .filter(User.id.in_(student_ids))
            .group_by(User.status)
            .all()
        )
        
        return {
            'by_room': {room: count for room, count in room_breakdown},
            'by_floor': {floor: count for floor, count in floor_breakdown},
            'by_status': {status: count for status, count in status_breakdown},
        }
    
    def _update_audience_cache(
        self,
        target: AnnouncementTarget,
        student_ids: List[UUID],
        breakdown: Dict[str, Dict]
    ) -> TargetAudienceCache:
        """Update or create audience cache."""
        cache = (
            self.session.query(TargetAudienceCache)
            .filter(
                TargetAudienceCache.announcement_id == target.announcement_id,
                TargetAudienceCache.target_id == target.id
            )
            .first()
        )
        
        now = datetime.utcnow()
        
        if cache:
            cache.student_ids = student_ids
            cache.total_count = len(student_ids)
            cache.breakdown_by_room = breakdown['by_room']
            cache.breakdown_by_floor = breakdown['by_floor']
            cache.calculated_at = now
            cache.is_stale = False
            cache.expires_at = now + timedelta(hours=24)
            cache.cache_version = f"v{int(now.timestamp())}"
        else:
            cache = TargetAudienceCache(
                announcement_id=target.announcement_id,
                target_id=target.id,
                student_ids=student_ids,
                total_count=len(student_ids),
                breakdown_by_room=breakdown['by_room'],
                breakdown_by_floor=breakdown['by_floor'],
                calculated_at=now,
                expires_at=now + timedelta(hours=24),
                is_stale=False,
                cache_version=f"v{int(now.timestamp())}"
            )
            self.session.add(cache)
        
        self.session.flush()
        return cache
    
    def _validate_targeting(self, target: AnnouncementTarget) -> None:
        """Validate targeting configuration."""
        errors = []
        
        # Check estimated recipients
        if target.estimated_recipients == 0:
            errors.append("No recipients match targeting criteria")
        
        # Validate specific targets
        if target.target_type == TargetAudience.SPECIFIC_ROOMS:
            if not target.room_ids:
                errors.append("Room IDs required for SPECIFIC_ROOMS targeting")
        
        if target.target_type == TargetAudience.SPECIFIC_FLOORS:
            if not target.floor_numbers:
                errors.append("Floor numbers required for SPECIFIC_FLOORS targeting")
        
        if target.target_type == TargetAudience.SPECIFIC_STUDENTS:
            if not target.student_ids:
                errors.append("Student IDs required for SPECIFIC_STUDENTS targeting")
        
        target.validation_errors = errors if errors else None
        target.is_validated = len(errors) == 0
        target.validated_at = datetime.utcnow()
    
    def _get_target_by_announcement(
        self,
        announcement_id: UUID
    ) -> Optional[AnnouncementTarget]:
        """Get targeting configuration for announcement."""
        return (
            self.session.query(AnnouncementTarget)
            .filter(AnnouncementTarget.announcement_id == announcement_id)
            .first()
        )
    
    def _get_notification_preferences(
        self,
        student_id: UUID
    ) -> Dict[str, Any]:
        """Get student notification preferences."""
        student = self.session.get(User, student_id)
        if not student or not student.metadata:
            return {
                'email': True,
                'sms': False,
                'push': True,
            }
        
        return student.metadata.get('notification_preferences', {
            'email': True,
            'sms': False,
            'push': True,
        })
    
    def _get_engagement_history(
        self,
        student_id: UUID,
        limit: int = 10
    ) -> Dict[str, Any]:
        """Get student's engagement history."""
        from app.models.announcement import ReadReceipt
        
        recent_reads = (
            self.session.query(
                ReadReceipt.announcement_id,
                ReadReceipt.read_at,
                ReadReceipt.reading_time_seconds
            )
            .filter(ReadReceipt.student_id == student_id)
            .order_by(ReadReceipt.read_at.desc())
            .limit(limit)
            .all()
        )
        
        total_reads = (
            self.session.query(func.count(ReadReceipt.id))
            .filter(ReadReceipt.student_id == student_id)
            .scalar()
        ) or 0
        
        avg_reading_time = (
            self.session.query(func.avg(ReadReceipt.reading_time_seconds))
            .filter(ReadReceipt.student_id == student_id)
            .scalar()
        ) or 0
        
        return {
            'total_reads': total_reads,
            'average_reading_time_seconds': float(avg_reading_time),
            'recent_reads': [
                {
                    'announcement_id': str(r.announcement_id),
                    'read_at': r.read_at.isoformat(),
                    'reading_time': r.reading_time_seconds
                }
                for r in recent_reads
            ]
        }
    
    def _calculate_estimation_accuracy(
        self,
        target: AnnouncementTarget
    ) -> float:
        """Calculate accuracy of recipient estimation."""
        if target.estimated_recipients == 0:
            return 0.0
        
        actual = target.actual_recipients or target.estimated_recipients
        estimated = target.estimated_recipients
        
        # Calculate percentage accuracy
        difference = abs(actual - estimated)
        accuracy = (1 - (difference / estimated)) * 100
        
        return max(0.0, min(100.0, accuracy))
    
    def _calculate_effectiveness_score(
        self,
        read_rate: float,
        ack_rate: float,
        requires_ack: bool
    ) -> float:
        """Calculate overall targeting effectiveness score."""
        if requires_ack:
            # Weight acknowledgment more heavily
            score = (read_rate * 0.3) + (ack_rate * 0.7)
        else:
            # Only consider read rate
            score = read_rate
        
        return round(score, 2)


from datetime import timedelta

# --- File: C:\Hostel-Main\app\repositories\announcement\announcement_tracking_repository.py ---
# Complete Implementation: announcement_tracking_repository.py

Here's the **comprehensive and production-ready** implementation of the announcement tracking repository with all advanced features:

---

## File: announcement_tracking_repository.py

```python
"""
Announcement Tracking Repository

Comprehensive engagement tracking with read receipts, acknowledgments, 
reading time analytics, and behavioral insights.
"""

from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
from decimal import Decimal
from collections import defaultdict
import statistics

from sqlalchemy import and_, or_, func, select, desc, case, extract
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.sql import Select

from app.models.announcement import (
    AnnouncementView,
    ReadReceipt,
    Acknowledgment,
    EngagementMetric,
    ReadingTimeAnalytic,
    Announcement,
    AnnouncementRecipient,
)
from app.models.user.user import User
from app.repositories.base.base_repository import BaseRepository
from app.repositories.base.query_builder import QueryBuilder
from app.repositories.base.pagination import PaginationParams, PaginatedResult
from app.core.exceptions import (
    ResourceNotFoundError,
    ValidationError,
    BusinessLogicError,
)


class AnnouncementTrackingRepository(BaseRepository[AnnouncementView]):
    """
    Repository for announcement engagement tracking.
    
    Provides comprehensive tracking capabilities including:
    - View and reading behavior tracking
    - Read receipt management
    - Acknowledgment processing
    - Real-time engagement metrics
    - Reading time analytics
    - Behavioral pattern analysis
    - Student engagement profiling
    - Performance benchmarking
    """
    
    def __init__(self, session: Session):
        super().__init__(AnnouncementView, session)
    
    # ==================== View Tracking ====================
    
    def record_view(
        self,
        announcement_id: UUID,
        student_id: UUID,
        device_type: Optional[str] = None,
        source: str = "app",
        session_id: Optional[str] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        metadata: Optional[Dict] = None
    ) -> AnnouncementView:
        """
        Record a student viewing an announcement.
        
        Args:
            announcement_id: Announcement UUID
            student_id: Student UUID
            device_type: Device type (mobile, web, tablet, desktop)
            source: Access source (app, email, push_notification, web)
            session_id: User session identifier
            ip_address: IP address
            user_agent: User agent string
            metadata: Additional metadata
            
        Returns:
            Created view record
        """
        # Validate device type
        if device_type and device_type not in ['mobile', 'web', 'tablet', 'desktop']:
            raise ValidationError(f"Invalid device type: {device_type}")
        
        # Check if this is a repeat view in same session
        existing_view = None
        if session_id:
            existing_view = (
                self.session.query(AnnouncementView)
                .filter(
                    AnnouncementView.announcement_id == announcement_id,
                    AnnouncementView.student_id == student_id,
                    AnnouncementView.session_id == session_id
                )
                .first()
            )
        
        if existing_view:
            # Increment view count for this session
            existing_view.view_count += 1
            self.session.flush()
            return existing_view
        
        view = AnnouncementView(
            announcement_id=announcement_id,
            student_id=student_id,
            viewed_at=datetime.utcnow(),
            device_type=device_type,
            source=source,
            session_id=session_id,
            ip_address=ip_address,
            user_agent=user_agent,
            view_count=1,
            metadata=metadata or {}
        )
        
        self.session.add(view)
        self.session.flush()
        
        return view
    
    def update_reading_metrics(
        self,
        view_id: UUID,
        reading_time_seconds: int,
        scroll_percentage: int,
        clicked_links: bool = False,
        downloaded_attachments: bool = False,
        shared: bool = False
    ) -> AnnouncementView:
        """
        Update reading behavior metrics for a view.
        
        Args:
            view_id: View record UUID
            reading_time_seconds: Time spent reading
            scroll_percentage: Scroll completion percentage
            clicked_links: Whether user clicked links
            downloaded_attachments: Whether user downloaded attachments
            shared: Whether user shared
            
        Returns:
            Updated view record
        """
        view = self.session.get(AnnouncementView, view_id)
        if not view:
            raise ResourceNotFoundError(f"View record {view_id} not found")
        
        # Validate metrics
        if reading_time_seconds < 0 or reading_time_seconds > 3600:
            raise ValidationError("Reading time must be between 0 and 3600 seconds")
        
        if scroll_percentage < 0 or scroll_percentage > 100:
            raise ValidationError("Scroll percentage must be between 0 and 100")
        
        view.reading_time_seconds = reading_time_seconds
        view.scroll_percentage = scroll_percentage
        view.clicked_links = clicked_links
        view.downloaded_attachments = downloaded_attachments
        view.shared = shared
        
        # Auto-create read receipt if user scrolled significantly
        if scroll_percentage >= 90:
            self.mark_as_read(
                announcement_id=view.announcement_id,
                student_id=view.student_id,
                reading_time_seconds=reading_time_seconds,
                scroll_percentage=scroll_percentage,
                device_type=view.device_type,
                source=view.source
            )
        
        self.session.flush()
        return view
    
    def record_engagement_action(
        self,
        view_id: UUID,
        action_type: str,
        action_details: Optional[Dict] = None
    ) -> AnnouncementView:
        """
        Record specific engagement action.
        
        Args:
            view_id: View record UUID
            action_type: Action type (link_click, download, share, etc.)
            action_details: Action details
            
        Returns:
            Updated view record
        """
        view = self.session.get(AnnouncementView, view_id)
        if not view:
            raise ResourceNotFoundError(f"View record {view_id} not found")
        
        # Update flags based on action
        if action_type == 'link_click':
            view.clicked_links = True
        elif action_type == 'download':
            view.downloaded_attachments = True
        elif action_type == 'share':
            view.shared = True
        
        # Store action in metadata
        if not view.metadata:
            view.metadata = {}
        if 'actions' not in view.metadata:
            view.metadata['actions'] = []
        
        view.metadata['actions'].append({
            'type': action_type,
            'timestamp': datetime.utcnow().isoformat(),
            'details': action_details
        })
        
        # Mark as modified for SQLAlchemy to detect JSONB change
        from sqlalchemy.orm.attributes import flag_modified
        flag_modified(view, 'metadata')
        
        self.session.flush()
        return view
    
    # ==================== Read Receipt Management ====================
    
    def mark_as_read(
        self,
        announcement_id: UUID,
        student_id: UUID,
        reading_time_seconds: Optional[int] = None,
        scroll_percentage: Optional[int] = None,
        device_type: Optional[str] = None,
        source: str = "app"
    ) -> ReadReceipt:
        """
        Confirm that a student has read an announcement.
        
        Args:
            announcement_id: Announcement UUID
            student_id: Student UUID
            reading_time_seconds: Time spent reading
            scroll_percentage: Scroll completion
            device_type: Device used
            source: Access source
            
        Returns:
            Created or updated read receipt
        """
        # Check if receipt already exists
        receipt = (
            self.session.query(ReadReceipt)
            .filter(
                ReadReceipt.announcement_id == announcement_id,
                ReadReceipt.student_id == student_id
            )
            .first()
        )
        
        if receipt:
            # Update existing receipt (in case of re-read)
            if reading_time_seconds:
                receipt.reading_time_seconds = reading_time_seconds
            if scroll_percentage:
                receipt.scroll_percentage = scroll_percentage
            
            # Update completion status
            if scroll_percentage and scroll_percentage >= 90:
                receipt.completed_reading = True
            
            self.session.flush()
            return receipt
        
        # Calculate time from delivery to read
        from app.models.announcement import AnnouncementDelivery
        delivery = (
            self.session.query(AnnouncementDelivery)
            .filter(
                AnnouncementDelivery.announcement_id == announcement_id,
                AnnouncementDelivery.recipient_id == student_id
            )
            .first()
        )
        
        now = datetime.utcnow()
        time_to_read = None
        delivered_at = None
        
        if delivery and delivery.delivered_at:
            delivered_at = delivery.delivered_at
            time_diff = now - delivery.delivered_at
            time_to_read = int(time_diff.total_seconds())
        
        # Create new receipt
        receipt = ReadReceipt(
            announcement_id=announcement_id,
            student_id=student_id,
            read_at=now,
            device_type=device_type,
            source=source,
            reading_time_seconds=reading_time_seconds,
            scroll_percentage=scroll_percentage,
            completed_reading=(scroll_percentage >= 90) if scroll_percentage else False,
            delivered_at=delivered_at,
            time_to_read_seconds=time_to_read,
            is_first_read=True
        )
        
        self.session.add(receipt)
        
        # Update announcement read count
        announcement = self.session.get(Announcement, announcement_id)
        if announcement:
            announcement.read_count += 1
        
        # Update recipient status
        recipient = (
            self.session.query(AnnouncementRecipient)
            .filter(
                AnnouncementRecipient.announcement_id == announcement_id,
                AnnouncementRecipient.student_id == student_id
            )
            .first()
        )
        
        if recipient:
            recipient.is_read = True
            recipient.read_at = now
        
        self.session.flush()
        return receipt
    
    def bulk_mark_as_read(
        self,
        announcement_id: UUID,
        student_ids: List[UUID]
    ) -> int:
        """
        Bulk mark multiple students as having read announcement.
        
        Args:
            announcement_id: Announcement UUID
            student_ids: List of student UUIDs
            
        Returns:
            Number of receipts created
        """
        count = 0
        for student_id in student_ids:
            try:
                self.mark_as_read(announcement_id, student_id)
                count += 1
            except Exception as e:
                # Log error but continue
                print(f"Error marking as read for student {student_id}: {e}")
                continue
        
        return count
    
    # ==================== Acknowledgment Management ====================
    
    def acknowledge_announcement(
        self,
        announcement_id: UUID,
        student_id: UUID,
        acknowledgment_note: Optional[str] = None,
        action_taken: Optional[str] = None,
        device_type: Optional[str] = None,
        ip_address: Optional[str] = None
    ) -> Acknowledgment:
        """
        Submit student acknowledgment for announcement.
        
        Args:
            announcement_id: Announcement UUID
            student_id: Student UUID
            acknowledgment_note: Optional note from student
            action_taken: Description of action taken
            device_type: Device used
            ip_address: IP address
            
        Returns:
            Created acknowledgment
        """
        announcement = self.session.get(Announcement, announcement_id)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        if not announcement.requires_acknowledgment:
            raise BusinessLogicError(
                "This announcement does not require acknowledgment"
            )
        
        # Check if already acknowledged
        existing = (
            self.session.query(Acknowledgment)
            .filter(
                Acknowledgment.announcement_id == announcement_id,
                Acknowledgment.student_id == student_id
            )
            .first()
        )
        
        if existing:
            raise BusinessLogicError(
                "Student has already acknowledged this announcement"
            )
        
        # Check if student has read the announcement
        read_receipt = (
            self.session.query(ReadReceipt)
            .filter(
                ReadReceipt.announcement_id == announcement_id,
                ReadReceipt.student_id == student_id
            )
            .first()
        )
        
        # Calculate delivery time
        from app.models.announcement import AnnouncementDelivery
        delivery = (
            self.session.query(AnnouncementDelivery)
            .filter(
                AnnouncementDelivery.announcement_id == announcement_id,
                AnnouncementDelivery.recipient_id == student_id
            )
            .first()
        )
        
        now = datetime.utcnow()
        time_to_ack = None
        delivered_at = None
        
        if delivery and delivery.delivered_at:
            delivered_at = delivery.delivered_at
            time_diff = now - delivery.delivered_at
            time_to_ack = int(time_diff.total_seconds())
        
        # Check if on time
        on_time = True
        if announcement.acknowledgment_deadline:
            on_time = now <= announcement.acknowledgment_deadline
        
        ack = Acknowledgment(
            announcement_id=announcement_id,
            student_id=student_id,
            acknowledged_at=now,
            acknowledgment_note=acknowledgment_note,
            action_taken=action_taken,
            deadline=announcement.acknowledgment_deadline,
            on_time=on_time,
            delivered_at=delivered_at,
            time_to_acknowledge_seconds=time_to_ack,
            read_before_acknowledge=read_receipt is not None,
            read_at=read_receipt.read_at if read_receipt else None,
            ip_address=ip_address,
            device_type=device_type
        )
        
        self.session.add(ack)
        
        # Update announcement acknowledged count
        announcement.acknowledged_count += 1
        
        # Update recipient status
        recipient = (
            self.session.query(AnnouncementRecipient)
            .filter(
                AnnouncementRecipient.announcement_id == announcement_id,
                AnnouncementRecipient.student_id == student_id
            )
            .first()
        )
        
        if recipient:
            recipient.is_acknowledged = True
            recipient.acknowledged_at = now
        
        self.session.flush()
        return ack
    
    def verify_acknowledgment(
        self,
        acknowledgment_id: UUID,
        verified_by_id: UUID,
        verification_notes: Optional[str] = None
    ) -> Acknowledgment:
        """
        Verify acknowledgment (for action-required announcements).
        
        Args:
            acknowledgment_id: Acknowledgment UUID
            verified_by_id: Verifier user UUID
            verification_notes: Verification notes
            
        Returns:
            Updated acknowledgment
        """
        ack = self.session.get(Acknowledgment, acknowledgment_id)
        if not ack:
            raise ResourceNotFoundError(
                f"Acknowledgment {acknowledgment_id} not found"
            )
        
        ack.action_verified = True
        ack.verified_by_id = verified_by_id
        ack.verified_at = datetime.utcnow()
        ack.verification_notes = verification_notes
        
        self.session.flush()
        return ack
    
    # ==================== Engagement Metrics ====================
    
    def calculate_engagement_metrics(
        self,
        announcement_id: UUID
    ) -> EngagementMetric:
        """
        Calculate and store comprehensive engagement metrics.
        
        Args:
            announcement_id: Announcement UUID
            
        Returns:
            Calculated engagement metrics
        """
        announcement = self.session.get(Announcement, announcement_id)
        if not announcement:
            raise ResourceNotFoundError(
                f"Announcement {announcement_id} not found"
            )
        
        # Get or create metric record
        metric = (
            self.session.query(EngagementMetric)
            .filter(EngagementMetric.announcement_id == announcement_id)
            .first()
        )
        
        if not metric:
            metric = EngagementMetric(announcement_id=announcement_id)
            self.session.add(metric)
        
        # Total recipients
        total_recipients = announcement.total_recipients or 1
        metric.total_recipients = total_recipients
        
        # Delivery metrics
        from app.models.announcement import AnnouncementDelivery
        delivered_count = (
            self.session.query(func.count(AnnouncementDelivery.id))
            .filter(
                AnnouncementDelivery.announcement_id == announcement_id,
                AnnouncementDelivery.is_delivered == True
            )
            .scalar()
        ) or 0
        
        metric.delivered_count = delivered_count
        metric.delivery_rate = Decimal(
            str(round((delivered_count / total_recipients * 100), 2))
        ) if total_recipients > 0 else Decimal('0.00')
        
        # View metrics
        total_views = (
            self.session.query(func.count(AnnouncementView.id))
            .filter(AnnouncementView.announcement_id == announcement_id)
            .scalar()
        ) or 0
        
        unique_viewers = (
            self.session.query(func.count(func.distinct(AnnouncementView.student_id)))
            .filter(AnnouncementView.announcement_id == announcement_id)
            .scalar()
        ) or 0
        
        metric.view_count = total_views
        metric.unique_readers = unique_viewers
        
        # Read metrics
        read_count = (
            self.session.query(func.count(ReadReceipt.id))
            .filter(ReadReceipt.announcement_id == announcement_id)
            .scalar()
        ) or 0
        
        metric.unique_readers = read_count  # Override with actual read count
        metric.read_rate = Decimal(
            str(round((read_count / total_recipients * 100), 2))
        ) if total_recipients > 0 else Decimal('0.00')
        
        # Reading depth metrics
        avg_reading_time = (
            self.session.query(func.avg(ReadReceipt.reading_time_seconds))
            .filter(ReadReceipt.announcement_id == announcement_id)
            .scalar()
        )
        
        avg_scroll = (
            self.session.query(func.avg(ReadReceipt.scroll_percentage))
            .filter(ReadReceipt.announcement_id == announcement_id)
            .scalar()
        )
        
        completed_count = (
            self.session.query(func.count(ReadReceipt.id))
            .filter(
                ReadReceipt.announcement_id == announcement_id,
                ReadReceipt.completed_reading == True
            )
            .scalar()
        ) or 0
        
        metric.average_reading_time_seconds = (
            Decimal(str(round(avg_reading_time, 2))) if avg_reading_time else None
        )
        metric.average_scroll_percentage = (
            Decimal(str(round(avg_scroll, 2))) if avg_scroll else None
        )
        metric.completion_rate = Decimal(
            str(round((completed_count / read_count * 100), 2))
        ) if read_count > 0 else Decimal('0.00')
        
        # Acknowledgment metrics
        if announcement.requires_acknowledgment:
            metric.requires_acknowledgment = True
            
            total_acks = (
                self.session.query(func.count(Acknowledgment.id))
                .filter(Acknowledgment.announcement_id == announcement_id)
                .scalar()
            ) or 0
            
            on_time_acks = (
                self.session.query(func.count(Acknowledgment.id))
                .filter(
                    Acknowledgment.announcement_id == announcement_id,
                    Acknowledgment.on_time == True
                )
                .scalar()
            ) or 0
            
            late_acks = total_acks - on_time_acks
            
            metric.acknowledged_count = total_acks
            metric.on_time_acknowledgments = on_time_acks
            metric.late_acknowledgments = late_acks
            metric.acknowledgment_rate = Decimal(
                str(round((total_acks / total_recipients * 100), 2))
            ) if total_recipients > 0 else Decimal('0.00')
        
        # Timing metrics
        avg_time_to_read = (
            self.session.query(func.avg(ReadReceipt.time_to_read_seconds))
            .filter(ReadReceipt.announcement_id == announcement_id)
            .scalar()
        )
        
        if avg_time_to_read:
            metric.average_time_to_read_hours = Decimal(
                str(round(avg_time_to_read / 3600, 2))
            )
        
        if announcement.requires_acknowledgment:
            avg_time_to_ack = (
                self.session.query(func.avg(Acknowledgment.time_to_acknowledge_seconds))
                .filter(Acknowledgment.announcement_id == announcement_id)
                .scalar()
            )
            
            if avg_time_to_ack:
                metric.average_time_to_acknowledge_hours = Decimal(
                    str(round(avg_time_to_ack / 3600, 2))
                )
        
        # Channel breakdown
        channel_stats = (
            self.session.query(
                AnnouncementDelivery.channel,
                func.count(AnnouncementDelivery.id)
            )
            .filter(
                AnnouncementDelivery.announcement_id == announcement_id,
                AnnouncementDelivery.is_delivered == True
            )
            .group_by(AnnouncementDelivery.channel)
            .all()
        )
        
        for channel, count in channel_stats:
            if channel == 'email':
                metric.email_delivered = count
            elif channel == 'sms':
                metric.sms_delivered = count
            elif channel == 'push':
                metric.push_delivered = count
            elif channel == 'in_app':
                metric.in_app_delivered = count
        
        # Device breakdown
        device_stats = (
            self.session.query(
                AnnouncementView.device_type,
                func.count(AnnouncementView.id)
            )
            .filter(AnnouncementView.announcement_id == announcement_id)
            .group_by(AnnouncementView.device_type)
            .all()
        )
        
        for device, count in device_stats:
            if device == 'mobile':
                metric.mobile_views = count
            elif device == 'web':
                metric.web_views = count
            elif device == 'tablet':
                metric.tablet_views = count
            elif device == 'desktop':
                metric.desktop_views = count
        
        # Interaction metrics
        metric.link_clicks = (
            self.session.query(func.count(AnnouncementView.id))
            .filter(
                AnnouncementView.announcement_id == announcement_id,
                AnnouncementView.clicked_links == True
            )
            .scalar()
        ) or 0
        
        metric.attachment_downloads = (
            self.session.query(func.count(AnnouncementView.id))
            .filter(
                AnnouncementView.announcement_id == announcement_id,
                AnnouncementView.downloaded_attachments == True
            )
            .scalar()
        ) or 0
        
        metric.shares = (
            self.session.query(func.count(AnnouncementView.id))
            .filter(
                AnnouncementView.announcement_id == announcement_id,
                AnnouncementView.shared == True
            )
            .scalar()
        ) or 0
        
        # Calculate overall engagement score
        metric.engagement_score = self._calculate_engagement_score(
            announcement, metric
        )
        
        metric.last_calculated_at = datetime.utcnow()
        
        self.session.flush()
        return metric
    
    def generate_reading_time_analytics(
        self,
        announcement_id: UUID
    ) -> ReadingTimeAnalytic:
        """
        Generate detailed reading time analytics.
        
        Args:
            announcement_id: Announcement UUID
            
        Returns:
            Reading time analytics
        """
        # Get all reading times
        reading_times = (
            self.session.query(ReadReceipt.reading_time_seconds)
            .filter(
                ReadReceipt.announcement_id == announcement_id,
                ReadReceipt.reading_time_seconds.isnot(None)
            )
            .all()
        )
        
        if not reading_times:
            return None
        
        time_list = [t[0] for t in reading_times]
        
        # Get or create analytics record
        analytic = (
            self.session.query(ReadingTimeAnalytic)
            .filter(ReadingTimeAnalytic.announcement_id == announcement_id)
            .first()
        )
        
        if not analytic:
            analytic = ReadingTimeAnalytic(announcement_id=announcement_id)
            self.session.add(analytic)
        
        # Basic statistics
        analytic.total_readers = len(time_list)
        analytic.average_reading_time_seconds = Decimal(
            str(round(statistics.mean(time_list), 2))
        )
        analytic.median_reading_time_seconds = Decimal(
            str(round(statistics.median(time_list), 2))
        )
        analytic.min_reading_time_seconds = min(time_list)
        analytic.max_reading_time_seconds = max(time_list)
        
        # Reader classification
        quick = [t for t in time_list if t < 30]
        normal = [t for t in time_list if 30 <= t <= 120]
        thorough = [t for t in time_list if t > 120]
        
        analytic.quick_readers = len(quick)
        analytic.normal_readers = len(normal)
        analytic.thorough_readers = len(thorough)
        
        total = len(time_list)
        analytic.quick_readers_percentage = Decimal(
            str(round((len(quick) / total * 100), 2))
        )
        analytic.normal_readers_percentage = Decimal(
            str(round((len(normal) / total * 100), 2))
        )
        analytic.thorough_readers_percentage = Decimal(
            str(round((len(thorough) / total * 100), 2))
        )
        
        # Time distribution by hour
        hourly_distribution = (
            self.session.query(
                extract('hour', ReadReceipt.read_at).label('hour'),
                func.count(ReadReceipt.id).label('count')
            )
            .filter(ReadReceipt.announcement_id == announcement_id)
            .group_by('hour')
            .all()
        )
        
        analytic.reads_by_hour = {
            int(hour): count for hour, count in hourly_distribution
        }
        
        # Device-based reading time
        mobile_times = (
            self.session.query(func.avg(ReadReceipt.reading_time_seconds))
            .filter(
                ReadReceipt.announcement_id == announcement_id,
                ReadReceipt.device_type == 'mobile',
                ReadReceipt.reading_time_seconds.isnot(None)
            )
            .scalar()
        )
        
        web_times = (
            self.session.query(func.avg(ReadReceipt.reading_time_seconds))
            .filter(
                ReadReceipt.announcement_id == announcement_id,
                ReadReceipt.device_type == 'web',
                ReadReceipt.reading_time_seconds.isnot(None)
            )
            .scalar()
        )
        
        if mobile_times:
            analytic.mobile_avg_time = Decimal(str(round(mobile_times, 2)))
        if web_times:
            analytic.web_avg_time = Decimal(str(round(web_times, 2)))
        
        analytic.last_calculated_at = datetime.utcnow()
        
        self.session.flush()
        return analytic
    
    # ==================== Query Operations ====================
    
    def get_student_read_announcements(
        self,
        student_id: UUID,
        limit: int = 50
    ) -> List[ReadReceipt]:
        """
        Get announcements read by student.
        
        Args:
            student_id: Student UUID
            limit: Maximum results
            
        Returns:
            List of read receipts
        """
        query = (
            select(ReadReceipt)
            .where(ReadReceipt.student_id == student_id)
            .order_by(ReadReceipt.read_at.desc())
            .limit(limit)
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def get_student_acknowledgments(
        self,
        student_id: UUID,
        pending_only: bool = False
    ) -> List[Acknowledgment]:
        """
        Get acknowledgments by student.
        
        Args:
            student_id: Student UUID
            pending_only: Only pending acknowledgments
            
        Returns:
            List of acknowledgments
        """
        query = select(Acknowledgment).where(
            Acknowledgment.student_id == student_id
        )
        
        if pending_only:
            # Get announcements requiring acknowledgment but not yet done
            acknowledged_ids = (
                select(Acknowledgment.announcement_id)
                .where(Acknowledgment.student_id == student_id)
            )
            
            query = (
                select(Announcement)
                .join(AnnouncementRecipient)
                .where(
                    AnnouncementRecipient.student_id == student_id,
                    Announcement.requires_acknowledgment == True,
                    Announcement.is_published == True,
                    ~Announcement.id.in_(acknowledged_ids)
                )
            )
        else:
            query = query.order_by(Acknowledgment.acknowledged_at.desc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def get_pending_acknowledgments(
        self,
        announcement_id: UUID
    ) -> List[User]:
        """
        Find students who haven't acknowledged yet.
        
        Args:
            announcement_id: Announcement UUID
            
        Returns:
            List of students pending acknowledgment
        """
        acknowledged_subq = (
            select(Acknowledgment.student_id)
            .where(Acknowledgment.announcement_id == announcement_id)
        )
        
        query = (
            select(User)
            .join(AnnouncementRecipient, User.id == AnnouncementRecipient.student_id)
            .where(
                AnnouncementRecipient.announcement_id == announcement_id,
                ~User.id.in_(acknowledged_subq)
            )
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def get_overdue_acknowledgments(
        self,
        announcement_id: UUID
    ) -> List[User]:
        """
        Find students with overdue acknowledgments.
        
        Args:
            announcement_id: Announcement UUID
            
        Returns:
            List of students with overdue acknowledgments
        """
        announcement = self.session.get(Announcement, announcement_id)
        if not announcement or not announcement.acknowledgment_deadline:
            return []
        
        now = datetime.utcnow()
        if now <= announcement.acknowledgment_deadline:
            return []
        
        # Get pending students
        return self.get_pending_acknowledgments(announcement_id)
    
    def get_student_engagement_profile(
        self,
        student_id: UUID,
        days: int = 30
    ) -> Dict[str, Any]:
        """
        Generate student engagement profile.
        
        Args:
            student_id: Student UUID
            days: Number of days to analyze
            
        Returns:
            Engagement profile dictionary
        """
        cutoff_date = datetime.utcnow() - timedelta(days=days)
        
        # Total announcements targeted to student
        total_targeted = (
            self.session.query(func.count(AnnouncementRecipient.id))
            .filter(
                AnnouncementRecipient.student_id == student_id,
                AnnouncementRecipient.created_at >= cutoff_date
            )
            .scalar()
        ) or 0
        
        # Read count
        read_count = (
            self.session.query(func.count(ReadReceipt.id))
            .filter(
                ReadReceipt.student_id == student_id,
                ReadReceipt.read_at >= cutoff_date
            )
            .scalar()
        ) or 0
        
        # Acknowledgment metrics
        total_acks = (
            self.session.query(func.count(Acknowledgment.id))
            .filter(
                Acknowledgment.student_id == student_id,
                Acknowledgment.acknowledged_at >= cutoff_date
            )
            .scalar()
        ) or 0
        
        on_time_acks = (
            self.session.query(func.count(Acknowledgment.id))
            .filter(
                Acknowledgment.student_id == student_id,
                Acknowledgment.acknowledged_at >= cutoff_date,
                Acknowledgment.on_time == True
            )
            .scalar()
        ) or 0
        
        # Average reading time
        avg_reading_time = (
            self.session.query(func.avg(ReadReceipt.reading_time_seconds))
            .filter(
                ReadReceipt.student_id == student_id,
                ReadReceipt.read_at >= cutoff_date
            )
            .scalar()
        ) or 0
        
        # Preferred device
        device_usage = (
            self.session.query(
                AnnouncementView.device_type,
                func.count(AnnouncementView.id)
            )
            .filter(
                AnnouncementView.student_id == student_id,
                AnnouncementView.viewed_at >= cutoff_date
            )
            .group_by(AnnouncementView.device_type)
            .all()
        )
        
        preferred_device = None
        if device_usage:
            preferred_device = max(device_usage, key=lambda x: x[1])[0]
        
        # Calculate engagement rate
        engagement_rate = (
            (read_count / total_targeted * 100)
            if total_targeted > 0 else 0
        )
        
        # Calculate compliance rate
        compliance_rate = (
            (on_time_acks / total_acks * 100)
            if total_acks > 0 else 0
        )
        
        return {
            'student_id': str(student_id),
            'period_days': days,
            'total_announcements': total_targeted,
            'read_count': read_count,
            'engagement_rate': round(engagement_rate, 2),
            'acknowledgments_total': total_acks,
            'acknowledgments_on_time': on_time_acks,
            'compliance_rate': round(compliance_rate, 2),
            'average_reading_time_seconds': round(avg_reading_time, 2),
            'preferred_device': preferred_device,
            'device_usage': {device: count for device, count in device_usage},
        }
    
    def get_announcement_timeline(
        self,
        announcement_id: UUID
    ) -> List[Dict[str, Any]]:
        """
        Get complete engagement timeline for announcement.
        
        Args:
            announcement_id: Announcement UUID
            
        Returns:
            List of timeline events
        """
        timeline = []
        
        # Get announcement creation
        announcement = self.session.get(Announcement, announcement_id)
        if announcement:
            timeline.append({
                'event': 'created',
                'timestamp': announcement.created_at,
                'actor': str(announcement.created_by_id),
            })
            
            if announcement.published_at:
                timeline.append({
                    'event': 'published',
                    'timestamp': announcement.published_at,
                    'actor': str(announcement.published_by_id),
                })
        
        # Get views
        views = (
            self.session.query(AnnouncementView)
            .filter(AnnouncementView.announcement_id == announcement_id)
            .order_by(AnnouncementView.viewed_at)
            .all()
        )
        
        for view in views:
            timeline.append({
                'event': 'viewed',
                'timestamp': view.viewed_at,
                'actor': str(view.student_id),
                'device': view.device_type,
                'source': view.source,
            })
        
        # Get reads
        reads = (
            self.session.query(ReadReceipt)
            .filter(ReadReceipt.announcement_id == announcement_id)
            .order_by(ReadReceipt.read_at)
            .all()
        )
        
        for read in reads:
            timeline.append({
                'event': 'read',
                'timestamp': read.read_at,
                'actor': str(read.student_id),
                'reading_time': read.reading_time_seconds,
            })
        
        # Get acknowledgments
        acks = (
            self.session.query(Acknowledgment)
            .filter(Acknowledgment.announcement_id == announcement_id)
            .order_by(Acknowledgment.acknowledged_at)
            .all()
        )
        
        for ack in acks:
            timeline.append({
                'event': 'acknowledged',
                'timestamp': ack.acknowledged_at,
                'actor': str(ack.student_id),
                'on_time': ack.on_time,
            })
        
        # Sort by timestamp
        timeline.sort(key=lambda x: x['timestamp'])
        
        return timeline
    
    # ==================== Analytics & Insights ====================
    
    def compare_announcement_performance(
        self,
        announcement_ids: List[UUID]
    ) -> Dict[str, Any]:
        """
        Compare performance across multiple announcements.
        
        Args:
            announcement_ids: List of announcement UUIDs
            
        Returns:
            Comparative performance data
        """
        comparison = {}
        
        for announcement_id in announcement_ids:
            metric = (
                self.session.query(EngagementMetric)
                .filter(EngagementMetric.announcement_id == announcement_id)
                .first()
            )
            
            if not metric:
                # Calculate if not exists
                metric = self.calculate_engagement_metrics(announcement_id)
            
            announcement = self.session.get(Announcement, announcement_id)
            
            comparison[str(announcement_id)] = {
                'title': announcement.title if announcement else 'Unknown',
                'category': announcement.category.value if announcement else None,
                'read_rate': float(metric.read_rate),
                'acknowledgment_rate': float(metric.acknowledgment_rate),
                'engagement_score': float(metric.engagement_score),
                'average_reading_time': float(metric.average_reading_time_seconds or 0),
            }
        
        return comparison
    
    def identify_low_engagement_students(
        self,
        hostel_id: UUID,
        threshold_percentage: float = 50.0,
        days: int = 30
    ) -> List[Dict[str, Any]]:
        """
        Identify students with low engagement rates.
        
        Args:
            hostel_id: Hostel UUID
            threshold_percentage: Engagement threshold
            days: Period to analyze
            
        Returns:
            List of low-engagement students
        """
        cutoff_date = datetime.utcnow() - timedelta(days=days)
        
        # Get all students in hostel
        students = (
            self.session.query(User)
            .join(Room, User.room_id == Room.id)
            .filter(Room.hostel_id == hostel_id)
            .all()
        )
        
        low_engagement = []
        
        for student in students:
            profile = self.get_student_engagement_profile(student.id, days)
            
            if profile['engagement_rate'] < threshold_percentage:
                low_engagement.append({
                    'student_id': str(student.id),
                    'student_name': student.full_name,
                    'engagement_rate': profile['engagement_rate'],
                    'total_announcements': profile['total_announcements'],
                    'read_count': profile['read_count'],
                })
        
        # Sort by engagement rate ascending
        low_engagement.sort(key=lambda x: x['engagement_rate'])
        
        return low_engagement
    
    # ==================== Helper Methods ====================
    
    def _calculate_engagement_score(
        self,
        announcement: Announcement,
        metric: EngagementMetric
    ) -> Decimal:
        """
        Calculate overall engagement score (0-100).
        
        Weighted formula:
        - 30% delivery rate
        - 30% read rate
        - 20% completion rate
        - 20% acknowledgment rate (if required)
        """
        delivery_weight = 0.3
        read_weight = 0.3
        completion_weight = 0.2
        ack_weight = 0.2
        
        score = (
            float(metric.delivery_rate) * delivery_weight +
            float(metric.read_rate) * read_weight +
            float(metric.completion_rate) * completion_weight
        )
        
        if announcement.requires_acknowledgment:
            score += float(metric.acknowledgment_rate) * ack_weight
        else:
            # Redistribute ack weight to other metrics
            score += float(metric.read_rate) * ack_weight
        
        return Decimal(str(round(score, 2)))


# --- File: C:\Hostel-Main\app\repositories\announcement\__init__.py ---
"""
Announcement Repositories Package

This package provides a comprehensive repository layer for the Announcement module,
implementing the Repository pattern with Domain-Driven Design (DDD) principles.

Architecture:
- Core Repositories: Individual domain entity repositories
- Aggregate Repository: Orchestrates complex cross-repository workflows
- Base Repository: Abstract foundation with common CRUD operations

Repositories:
- AnnouncementRepository: Core announcement CRUD and lifecycle management
- AnnouncementTargetingRepository: Audience targeting and segmentation
- AnnouncementSchedulingRepository: Scheduling and recurring patterns
- AnnouncementApprovalRepository: Approval workflows and SLA tracking
- AnnouncementDeliveryRepository: Multi-channel delivery management
- AnnouncementTrackingRepository: Engagement tracking and analytics
- AnnouncementAggregateRepository: Workflow orchestration

Usage:
    from app.repositories.announcement import (
        AnnouncementRepository,
        AnnouncementAggregateRepository
    )
    
    # Initialize repositories
    announcement_repo = AnnouncementRepository(session)
    aggregate_repo = AnnouncementAggregateRepository(session)
    
    # Create complete announcement workflow
    result = aggregate_repo.create_complete_announcement(
        hostel_id=hostel_uuid,
        created_by_id=user_uuid,
        announcement_data={...},
        targeting_data={...},
        schedule_data={...}
    )

Features:
- Transactional integrity across operations
- Separation of concerns with specialized repositories
- Complex workflow orchestration via aggregate repository
- Comprehensive query operations with filtering and pagination
- Performance-optimized bulk operations
- Real-time analytics and metrics calculation
- Audit trail and versioning support
"""

from app.repositories.announcement.announcement_repository import (
    AnnouncementRepository,
    ActiveAnnouncementsSpec,
    UrgentAnnouncementsSpec,
    RequiresAcknowledgmentSpec,
)
from app.repositories.announcement.announcement_targeting_repository import (
    AnnouncementTargetingRepository,
)
from app.repositories.announcement.announcement_scheduling_repository import (
    AnnouncementSchedulingRepository,
)
from app.repositories.announcement.announcement_approval_repository import (
    AnnouncementApprovalRepository,
)
from app.repositories.announcement.announcement_delivery_repository import (
    AnnouncementDeliveryRepository,
)
from app.repositories.announcement.announcement_tracking_repository import (
    AnnouncementTrackingRepository,
)
from app.repositories.announcement.announcement_aggregate_repository import (
    AnnouncementAggregateRepository,
)

# Public API
__all__ = [
    # Core Repositories
    "AnnouncementRepository",
    "AnnouncementTargetingRepository",
    "AnnouncementSchedulingRepository",
    "AnnouncementApprovalRepository",
    "AnnouncementDeliveryRepository",
    "AnnouncementTrackingRepository",
    
    # Aggregate Repository
    "AnnouncementAggregateRepository",
    
    # Specifications
    "ActiveAnnouncementsSpec",
    "UrgentAnnouncementsSpec",
    "RequiresAcknowledgmentSpec",
]

# Package metadata
__version__ = "1.0.0"
__author__ = "Hostel Management System Team"
__description__ = "Comprehensive announcement repository layer with DDD patterns"

# Repository registry for dependency injection
REPOSITORY_REGISTRY = {
    'announcement': AnnouncementRepository,
    'targeting': AnnouncementTargetingRepository,
    'scheduling': AnnouncementSchedulingRepository,
    'approval': AnnouncementApprovalRepository,
    'delivery': AnnouncementDeliveryRepository,
    'tracking': AnnouncementTrackingRepository,
    'aggregate': AnnouncementAggregateRepository,
}


def get_repository(repository_name: str, session):
    """
    Factory function to get repository instance by name.
    
    Args:
        repository_name: Name of repository
        session: Database session
        
    Returns:
        Repository instance
        
    Example:
        repo = get_repository('announcement', session)
    """
    repo_class = REPOSITORY_REGISTRY.get(repository_name)
    if not repo_class:
        raise ValueError(f"Unknown repository: {repository_name}")
    return repo_class(session)
