### Combined Content from Folder: C:\Hostel-Main\app\repositories\complaint ###



# ===== Folder: C:\Hostel-Main\app\repositories\complaint =====

# --- File: C:\Hostel-Main\app\repositories\complaint\complaint_aggregate_repository.py ---
# --- File: complaint_aggregate_repository.py ---
"""
Complaint aggregate repository for complex multi-entity queries.

Provides high-level aggregation queries combining data from multiple
complaint-related entities for comprehensive insights.
"""

from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional

from sqlalchemy import and_, desc, func, select
from sqlalchemy.orm import Session, joinedload

from app.models.complaint.complaint import Complaint
from app.models.complaint.complaint_assignment import ComplaintAssignment
from app.models.complaint.complaint_comment import ComplaintComment
from app.models.complaint.complaint_escalation import ComplaintEscalation
from app.models.complaint.complaint_feedback import ComplaintFeedback
from app.models.complaint.complaint_resolution import ComplaintResolution
from app.models.hostel.hostel import Hostel
from app.models.student.student import Student
from app.models.user.user import User
from app.repositories.base.base_repository import BaseRepository


class ComplaintAggregateRepository:
    """
    Aggregate repository for complex complaint queries.
    
    Provides comprehensive queries combining multiple entities
    for advanced analytics and reporting.
    """

    def __init__(self, session: Session):
        """
        Initialize aggregate repository.
        
        Args:
            session: SQLAlchemy database session
        """
        self.session = session

    # ==================== Dashboard Queries ====================

    def get_dashboard_summary(
        self,
        hostel_id: Optional[str] = None,
        user_id: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Get comprehensive dashboard summary.
        
        Args:
            hostel_id: Optional hostel filter
            user_id: Optional user filter for personalization
            
        Returns:
            Dictionary with dashboard metrics
        """
        now = datetime.now(timezone.utc)
        today_start = datetime.combine(now.date(), datetime.min.time()).replace(tzinfo=timezone.utc)
        
        # Base query
        query = select(Complaint).where(Complaint.deleted_at.is_(None))
        
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        if user_id:
            query = query.where(
                or_(
                    Complaint.assigned_to == user_id,
                    Complaint.raised_by == user_id,
                )
            )
        
        result = self.session.execute(query)
        all_complaints = list(result.scalars().all())
        
        # Calculate metrics
        total = len(all_complaints)
        
        from app.models.base.enums import ComplaintStatus
        open_count = len([c for c in all_complaints if c.status == ComplaintStatus.OPEN])
        in_progress = len([c for c in all_complaints if c.status == ComplaintStatus.IN_PROGRESS])
        resolved = len([c for c in all_complaints if c.status == ComplaintStatus.RESOLVED])
        
        overdue = len([
            c for c in all_complaints
            if c.sla_due_at and c.sla_due_at < now and c.status not in [
                ComplaintStatus.RESOLVED,
                ComplaintStatus.CLOSED,
            ]
        ])
        
        escalated = len([c for c in all_complaints if c.escalated])
        
        # Today's complaints
        today_complaints = len([
            c for c in all_complaints
            if c.opened_at >= today_start
        ])
        
        # Pending assignments
        pending_assignment = len([
            c for c in all_complaints
            if c.status == ComplaintStatus.OPEN and c.assigned_to is None
        ])
        
        return {
            "total_complaints": total,
            "open_complaints": open_count,
            "in_progress_complaints": in_progress,
            "resolved_complaints": resolved,
            "overdue_complaints": overdue,
            "escalated_complaints": escalated,
            "today_complaints": today_complaints,
            "pending_assignment": pending_assignment,
        }

    def get_complaint_details_with_relations(
        self,
        complaint_id: str,
    ) -> Optional[Dict[str, Any]]:
        """
        Get complaint with all related entities.
        
        Args:
            complaint_id: Complaint identifier
            
        Returns:
            Dictionary with complaint and related data
        """
        # Load complaint with relationships
        query = (
            select(Complaint)
            .where(Complaint.id == complaint_id)
            .options(
                joinedload(Complaint.hostel),
                joinedload(Complaint.raiser),
                joinedload(Complaint.student),
                joinedload(Complaint.room),
                joinedload(Complaint.assignee),
            )
        )
        
        result = self.session.execute(query)
        complaint = result.scalar_one_or_none()
        
        if not complaint:
            return None
        
        # Get assignments
        assignments_query = (
            select(ComplaintAssignment)
            .where(ComplaintAssignment.complaint_id == complaint_id)
            .order_by(desc(ComplaintAssignment.assigned_at))
        )
        assignments_result = self.session.execute(assignments_query)
        assignments = list(assignments_result.scalars().all())
        
        # Get comments
        comments_query = (
            select(ComplaintComment)
            .where(
                and_(
                    ComplaintComment.complaint_id == complaint_id,
                    ComplaintComment.deleted_at.is_(None),
                )
            )
            .order_by(ComplaintComment.created_at.asc())
        )
        comments_result = self.session.execute(comments_query)
        comments = list(comments_result.scalars().all())
        
        # Get escalations
        escalations_query = (
            select(ComplaintEscalation)
            .where(ComplaintEscalation.complaint_id == complaint_id)
            .order_by(desc(ComplaintEscalation.escalated_at))
        )
        escalations_result = self.session.execute(escalations_query)
        escalations = list(escalations_result.scalars().all())
        
        # Get resolutions
        resolutions_query = (
            select(ComplaintResolution)
            .where(ComplaintResolution.complaint_id == complaint_id)
            .order_by(desc(ComplaintResolution.resolved_at))
        )
        resolutions_result = self.session.execute(resolutions_query)
        resolutions = list(resolutions_result.scalars().all())
        
        # Get feedback
        feedback_query = select(ComplaintFeedback).where(
            ComplaintFeedback.complaint_id == complaint_id
        )
        feedback_result = self.session.execute(feedback_query)
        feedback = feedback_result.scalar_one_or_none()
        
        return {
            "complaint": complaint,
            "assignments": assignments,
            "comments": comments,
            "escalations": escalations,
            "resolutions": resolutions,
            "feedback": feedback,
        }

    # ==================== Analytics Queries ====================

    def get_hostel_performance_comparison(
        self,
        hostel_ids: List[str],
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> List[Dict[str, Any]]:
        """
        Compare performance across multiple hostels.
        
        Args:
            hostel_ids: List of hostel identifiers
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            List of hostel performance metrics
        """
        comparison = []
        
        for hostel_id in hostel_ids:
            query = select(Complaint).where(
                and_(
                    Complaint.hostel_id == hostel_id,
                    Complaint.deleted_at.is_(None),
                )
            )
            
            if date_from:
                query = query.where(Complaint.opened_at >= date_from)
            
            if date_to:
                query = query.where(Complaint.opened_at <= date_to)
            
            result = self.session.execute(query)
            complaints = list(result.scalars().all())
            
            if complaints:
                total = len(complaints)
                resolved = len([c for c in complaints if c.resolved_at])
                sla_compliant = len([c for c in complaints if not c.sla_breach])
                
                # Average resolution time
                resolution_times = [
                    (c.resolved_at - c.opened_at).total_seconds() / 3600
                    for c in complaints if c.resolved_at
                ]
                avg_time = sum(resolution_times) / len(resolution_times) if resolution_times else None
                
                comparison.append({
                    "hostel_id": hostel_id,
                    "total_complaints": total,
                    "resolved_count": resolved,
                    "resolution_rate": (resolved / total * 100) if total > 0 else 0,
                    "sla_compliance_rate": (sla_compliant / total * 100) if total > 0 else 0,
                    "avg_resolution_time_hours": round(avg_time, 2) if avg_time else None,
                })
        
        return comparison

    def get_category_performance_trends(
        self,
        hostel_id: Optional[str] = None,
        days: int = 30,
    ) -> Dict[str, List[Dict[str, Any]]]:
        """
        Get performance trends by category.
        
        Args:
            hostel_id: Optional hostel filter
            days: Number of days to analyze
            
        Returns:
            Dictionary mapping categories to trend data
        """
        end_date = datetime.now(timezone.utc)
        start_date = end_date - timedelta(days=days)
        
        query = select(Complaint).where(
            and_(
                Complaint.opened_at >= start_date,
                Complaint.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        result = self.session.execute(query)
        complaints = list(result.scalars().all())
        
        # Group by category
        from app.models.base.enums import ComplaintCategory
        trends = {}
        
        for category in ComplaintCategory:
            category_complaints = [
                c for c in complaints
                if c.category == category
            ]
            
            if category_complaints:
                total = len(category_complaints)
                resolved = len([c for c in category_complaints if c.resolved_at])
                
                resolution_times = [
                    (c.resolved_at - c.opened_at).total_seconds() / 3600
                    for c in category_complaints if c.resolved_at
                ]
                
                trends[category.value] = {
                    "total_complaints": total,
                    "resolved_count": resolved,
                    "resolution_rate": (resolved / total * 100) if total > 0 else 0,
                    "avg_resolution_time": (
                        round(sum(resolution_times) / len(resolution_times), 2)
                        if resolution_times else None
                    ),
                }
        
        return trends

    def get_staff_workload_overview(
        self,
        hostel_id: Optional[str] = None,
    ) -> List[Dict[str, Any]]:
        """
        Get workload overview for all staff.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of staff workload metrics
        """
        from app.models.base.enums import ComplaintStatus
        
        # Get active assignments
        query = (
            select(
                ComplaintAssignment.assigned_to,
                func.count(ComplaintAssignment.id).label("active_count"),
            )
            .join(Complaint)
            .where(
                and_(
                    ComplaintAssignment.is_current == True,
                    Complaint.status.in_([
                        ComplaintStatus.ASSIGNED,
                        ComplaintStatus.IN_PROGRESS,
                    ]),
                    Complaint.deleted_at.is_(None),
                )
            )
            .group_by(ComplaintAssignment.assigned_to)
        )
        
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        result = self.session.execute(query)
        
        workload = []
        for row in result:
            # Get user details
            user_query = select(User).where(User.id == row.assigned_to)
            user_result = self.session.execute(user_query)
            user = user_result.scalar_one_or_none()
            
            if user:
                workload.append({
                    "user_id": row.assigned_to,
                    "user_name": user.full_name,
                    "active_assignments": row.active_count,
                })
        
        return sorted(workload, key=lambda x: x["active_assignments"], reverse=True)

    # ==================== Reporting Queries ====================

    def generate_executive_report(
        self,
        hostel_id: Optional[str] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, Any]:
        """
        Generate comprehensive executive report.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Dictionary with executive metrics
        """
        # Get all complaints in period
        query = select(Complaint).where(Complaint.deleted_at.is_(None))
        
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(Complaint.opened_at >= date_from)
        
        if date_to:
            query = query.where(Complaint.opened_at <= date_to)
        
        result = self.session.execute(query)
        complaints = list(result.scalars().all())
        
        if not complaints:
            return {"message": "No data for specified period"}
        
        total = len(complaints)
        
        # Resolution metrics
        resolved = [c for c in complaints if c.resolved_at]
        resolution_rate = (len(resolved) / total * 100) if total > 0 else 0
        
        resolution_times = [
            (c.resolved_at - c.opened_at).total_seconds() / 3600
            for c in resolved
        ]
        
        avg_resolution_time = (
            sum(resolution_times) / len(resolution_times)
            if resolution_times else None
        )
        
        # SLA metrics
        sla_compliant = len([c for c in complaints if not c.sla_breach])
        sla_compliance_rate = (sla_compliant / total * 100) if total > 0 else 0
        
        # Escalation metrics
        escalated = len([c for c in complaints if c.escalated])
        escalation_rate = (escalated / total * 100) if total > 0 else 0
        
        # Feedback metrics
        feedback_query = (
            select(ComplaintFeedback)
            .join(Complaint)
            .where(Complaint.id.in_([c.id for c in complaints]))
        )
        feedback_result = self.session.execute(feedback_query)
        feedbacks = list(feedback_result.scalars().all())
        
        avg_rating = (
            sum(f.rating for f in feedbacks) / len(feedbacks)
            if feedbacks else None
        )
        
        satisfaction_rate = (
            len([f for f in feedbacks if f.rating >= 4]) / len(feedbacks) * 100
            if feedbacks else None
        )
        
        # Category breakdown
        category_breakdown = {}
        for c in complaints:
            cat = c.category.value
            category_breakdown[cat] = category_breakdown.get(cat, 0) + 1
        
        # Top issues
        top_categories = sorted(
            category_breakdown.items(),
            key=lambda x: x[1],
            reverse=True
        )[:5]
        
        return {
            "summary": {
                "total_complaints": total,
                "resolution_rate": round(resolution_rate, 2),
                "avg_resolution_time_hours": round(avg_resolution_time, 2) if avg_resolution_time else None,
                "sla_compliance_rate": round(sla_compliance_rate, 2),
                "escalation_rate": round(escalation_rate, 2),
                "avg_customer_rating": round(avg_rating, 2) if avg_rating else None,
                "satisfaction_rate": round(satisfaction_rate, 2) if satisfaction_rate else None,
            },
            "top_categories": [
                {"category": cat, "count": count}
                for cat, count in top_categories
            ],
            "category_breakdown": category_breakdown,
        }




# --- File: C:\Hostel-Main\app\repositories\complaint\complaint_analytics_repository.py ---
# --- File: complaint_analytics_repository.py ---
"""
Complaint analytics repository with comprehensive metrics and insights.

Handles analytics snapshots, category metrics, and staff performance
tracking for data-driven complaint management optimization.
"""

from datetime import date, datetime, timedelta, timezone
from decimal import Decimal
from typing import Any, Dict, List, Optional

from sqlalchemy import and_, desc, func, select
from sqlalchemy.orm import Session

from app.models.complaint.complaint_analytics import (
    ComplaintAnalyticSnapshot,
    ComplaintCategoryMetric,
    ComplaintStaffPerformance,
)
from app.models.complaint.complaint import Complaint
from app.repositories.base.base_repository import BaseRepository


class ComplaintAnalyticSnapshotRepository(BaseRepository[ComplaintAnalyticSnapshot]):
    """
    Complaint analytics snapshot repository for pre-computed metrics.
    
    Provides snapshot management and historical analytics tracking
    for performance monitoring and reporting.
    """

    def __init__(self, session: Session):
        """
        Initialize analytics snapshot repository.
        
        Args:
            session: SQLAlchemy database session
        """
        super().__init__(ComplaintAnalyticSnapshot, session)

    # ==================== CRUD Operations ====================

    def create_snapshot(
        self,
        hostel_id: Optional[str],
        period_start: date,
        period_end: date,
        snapshot_type: str,
        metrics: Dict[str, Any],
    ) -> ComplaintAnalyticSnapshot:
        """
        Create a new analytics snapshot.
        
        Args:
            hostel_id: Hostel identifier (None for system-wide)
            period_start: Period start date
            period_end: Period end date
            snapshot_type: DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY
            metrics: Dictionary of calculated metrics
            
        Returns:
            Created snapshot instance
        """
        snapshot = ComplaintAnalyticSnapshot(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
            snapshot_type=snapshot_type,
            total_complaints=metrics.get("total_complaints", 0),
            open_complaints=metrics.get("open_complaints", 0),
            in_progress_complaints=metrics.get("in_progress_complaints", 0),
            resolved_complaints=metrics.get("resolved_complaints", 0),
            closed_complaints=metrics.get("closed_complaints", 0),
            avg_resolution_time_hours=metrics.get("avg_resolution_time_hours"),
            median_resolution_time_hours=metrics.get("median_resolution_time_hours"),
            min_resolution_time_hours=metrics.get("min_resolution_time_hours"),
            max_resolution_time_hours=metrics.get("max_resolution_time_hours"),
            sla_compliant_count=metrics.get("sla_compliant_count", 0),
            sla_breached_count=metrics.get("sla_breached_count", 0),
            sla_compliance_rate=metrics.get("sla_compliance_rate"),
            escalated_count=metrics.get("escalated_count", 0),
            reopened_count=metrics.get("reopened_count", 0),
            avg_rating=metrics.get("avg_rating"),
            total_feedback_count=metrics.get("total_feedback_count", 0),
            category_breakdown=metrics.get("category_breakdown", {}),
            priority_breakdown=metrics.get("priority_breakdown", {}),
            status_breakdown=metrics.get("status_breakdown", {}),
            generated_at=datetime.now(timezone.utc),
            metadata=metrics.get("metadata", {}),
        )
        
        return self.create(snapshot)

    # ==================== Query Operations ====================

    def find_by_period(
        self,
        period_start: date,
        period_end: date,
        hostel_id: Optional[str] = None,
        snapshot_type: Optional[str] = None,
    ) -> Optional[ComplaintAnalyticSnapshot]:
        """
        Find snapshot for a specific period.
        
        Args:
            period_start: Period start date
            period_end: Period end date
            hostel_id: Optional hostel filter
            snapshot_type: Optional snapshot type filter
            
        Returns:
            Snapshot or None
        """
        query = select(ComplaintAnalyticSnapshot).where(
            and_(
                ComplaintAnalyticSnapshot.period_start == period_start,
                ComplaintAnalyticSnapshot.period_end == period_end,
            )
        )
        
        if hostel_id is not None:
            query = query.where(ComplaintAnalyticSnapshot.hostel_id == hostel_id)
        else:
            query = query.where(ComplaintAnalyticSnapshot.hostel_id.is_(None))
        
        if snapshot_type:
            query = query.where(ComplaintAnalyticSnapshot.snapshot_type == snapshot_type)
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()

    def find_latest_snapshot(
        self,
        hostel_id: Optional[str] = None,
        snapshot_type: str = "DAILY",
    ) -> Optional[ComplaintAnalyticSnapshot]:
        """
        Find most recent snapshot.
        
        Args:
            hostel_id: Optional hostel filter
            snapshot_type: Snapshot type
            
        Returns:
            Latest snapshot or None
        """
        query = select(ComplaintAnalyticSnapshot).where(
            ComplaintAnalyticSnapshot.snapshot_type == snapshot_type
        )
        
        if hostel_id is not None:
            query = query.where(ComplaintAnalyticSnapshot.hostel_id == hostel_id)
        else:
            query = query.where(ComplaintAnalyticSnapshot.hostel_id.is_(None))
        
        query = query.order_by(desc(ComplaintAnalyticSnapshot.period_end))
        query = query.limit(1)
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()

    def find_snapshots_in_range(
        self,
        date_from: date,
        date_to: date,
        hostel_id: Optional[str] = None,
        snapshot_type: Optional[str] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintAnalyticSnapshot]:
        """
        Find snapshots within date range.
        
        Args:
            date_from: Start date
            date_to: End date
            hostel_id: Optional hostel filter
            snapshot_type: Optional snapshot type filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of snapshots
        """
        query = select(ComplaintAnalyticSnapshot).where(
            and_(
                ComplaintAnalyticSnapshot.period_start >= date_from,
                ComplaintAnalyticSnapshot.period_end <= date_to,
            )
        )
        
        if hostel_id is not None:
            query = query.where(ComplaintAnalyticSnapshot.hostel_id == hostel_id)
        
        if snapshot_type:
            query = query.where(ComplaintAnalyticSnapshot.snapshot_type == snapshot_type)
        
        query = query.order_by(ComplaintAnalyticSnapshot.period_start.asc())
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    # ==================== Analytics Operations ====================

    def generate_daily_snapshot(
        self,
        target_date: date,
        hostel_id: Optional[str] = None,
    ) -> ComplaintAnalyticSnapshot:
        """
        Generate daily analytics snapshot.
        
        Args:
            target_date: Date for snapshot
            hostel_id: Optional hostel filter
            
        Returns:
            Created snapshot
        """
        metrics = self._calculate_period_metrics(
            period_start=target_date,
            period_end=target_date,
            hostel_id=hostel_id,
        )
        
        return self.create_snapshot(
            hostel_id=hostel_id,
            period_start=target_date,
            period_end=target_date,
            snapshot_type="DAILY",
            metrics=metrics,
        )

    def generate_weekly_snapshot(
        self,
        week_start: date,
        hostel_id: Optional[str] = None,
    ) -> ComplaintAnalyticSnapshot:
        """
        Generate weekly analytics snapshot.
        
        Args:
            week_start: Week start date (Monday)
            hostel_id: Optional hostel filter
            
        Returns:
            Created snapshot
        """
        week_end = week_start + timedelta(days=6)
        
        metrics = self._calculate_period_metrics(
            period_start=week_start,
            period_end=week_end,
            hostel_id=hostel_id,
        )
        
        return self.create_snapshot(
            hostel_id=hostel_id,
            period_start=week_start,
            period_end=week_end,
            snapshot_type="WEEKLY",
            metrics=metrics,
        )

    def generate_monthly_snapshot(
        self,
        year: int,
        month: int,
        hostel_id: Optional[str] = None,
    ) -> ComplaintAnalyticSnapshot:
        """
        Generate monthly analytics snapshot.
        
        Args:
            year: Year
            month: Month (1-12)
            hostel_id: Optional hostel filter
            
        Returns:
            Created snapshot
        """
        from calendar import monthrange
        
        month_start = date(year, month, 1)
        last_day = monthrange(year, month)[1]
        month_end = date(year, month, last_day)
        
        metrics = self._calculate_period_metrics(
            period_start=month_start,
            period_end=month_end,
            hostel_id=hostel_id,
        )
        
        return self.create_snapshot(
            hostel_id=hostel_id,
            period_start=month_start,
            period_end=month_end,
            snapshot_type="MONTHLY",
            metrics=metrics,
        )

    def compare_periods(
        self,
        period1_start: date,
        period1_end: date,
        period2_start: date,
        period2_end: date,
        hostel_id: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Compare metrics between two periods.
        
        Args:
            period1_start: First period start
            period1_end: First period end
            period2_start: Second period start
            period2_end: Second period end
            hostel_id: Optional hostel filter
            
        Returns:
            Dictionary with comparison metrics
        """
        snapshot1 = self.find_by_period(period1_start, period1_end, hostel_id)
        snapshot2 = self.find_by_period(period2_start, period2_end, hostel_id)
        
        if not snapshot1 or not snapshot2:
            return {}
        
        def calc_change(val1, val2):
            if val2 == 0:
                return None
            return ((val1 - val2) / val2 * 100)
        
        return {
            "period1": {
                "start": period1_start.isoformat(),
                "end": period1_end.isoformat(),
                "total_complaints": snapshot1.total_complaints,
                "sla_compliance_rate": float(snapshot1.sla_compliance_rate or 0),
                "avg_resolution_time": float(snapshot1.avg_resolution_time_hours or 0),
            },
            "period2": {
                "start": period2_start.isoformat(),
                "end": period2_end.isoformat(),
                "total_complaints": snapshot2.total_complaints,
                "sla_compliance_rate": float(snapshot2.sla_compliance_rate or 0),
                "avg_resolution_time": float(snapshot2.avg_resolution_time_hours or 0),
            },
            "changes": {
                "total_complaints_change": calc_change(
                    snapshot1.total_complaints,
                    snapshot2.total_complaints,
                ),
                "sla_compliance_change": calc_change(
                    float(snapshot1.sla_compliance_rate or 0),
                    float(snapshot2.sla_compliance_rate or 0),
                ),
                "resolution_time_change": calc_change(
                    float(snapshot1.avg_resolution_time_hours or 0),
                    float(snapshot2.avg_resolution_time_hours or 0),
                ),
            },
        }

    # ==================== Helper Methods ====================

    def _calculate_period_metrics(
        self,
        period_start: date,
        period_end: date,
        hostel_id: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Calculate metrics for a specific period.
        
        Args:
            period_start: Period start date
            period_end: Period end date
            hostel_id: Optional hostel filter
            
        Returns:
            Dictionary of calculated metrics
        """
        # Convert dates to datetime for queries
        start_dt = datetime.combine(period_start, datetime.min.time()).replace(tzinfo=timezone.utc)
        end_dt = datetime.combine(period_end, datetime.max.time()).replace(tzinfo=timezone.utc)
        
        # Base query
        query = select(Complaint).where(
            and_(
                Complaint.opened_at >= start_dt,
                Complaint.opened_at <= end_dt,
            )
        )
        
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        result = self.session.execute(query)
        complaints = list(result.scalars().all())
        
        if not complaints:
            return {
                "total_complaints": 0,
                "open_complaints": 0,
                "in_progress_complaints": 0,
                "resolved_complaints": 0,
                "closed_complaints": 0,
            }
        
        # Calculate metrics
        total = len(complaints)
        
        # Status counts
        from app.models.base.enums import ComplaintStatus
        status_counts = {
            "open": len([c for c in complaints if c.status == ComplaintStatus.OPEN]),
            "in_progress": len([c for c in complaints if c.status == ComplaintStatus.IN_PROGRESS]),
            "resolved": len([c for c in complaints if c.status == ComplaintStatus.RESOLVED]),
            "closed": len([c for c in complaints if c.status == ComplaintStatus.CLOSED]),
        }
        
        # Resolution time metrics
        resolved_complaints = [
            c for c in complaints
            if c.resolved_at is not None
        ]
        
        resolution_times = []
        for c in resolved_complaints:
            hours = (c.resolved_at - c.opened_at).total_seconds() / 3600
            resolution_times.append(hours)
        
        avg_resolution_time = (
            sum(resolution_times) / len(resolution_times)
            if resolution_times else None
        )
        
        median_resolution_time = None
        if resolution_times:
            sorted_times = sorted(resolution_times)
            n = len(sorted_times)
            if n % 2 == 0:
                median_resolution_time = (sorted_times[n//2-1] + sorted_times[n//2]) / 2
            else:
                median_resolution_time = sorted_times[n//2]
        
        min_resolution_time = min(resolution_times) if resolution_times else None
        max_resolution_time = max(resolution_times) if resolution_times else None
        
        # SLA metrics
        sla_compliant = len([c for c in complaints if not c.sla_breach])
        sla_breached = len([c for c in complaints if c.sla_breach])
        sla_compliance_rate = (sla_compliant / total * 100) if total > 0 else 0
        
        # Other metrics
        escalated = len([c for c in complaints if c.escalated])
        reopened = len([c for c in complaints if c.reopened_count > 0])
        
        # Category breakdown
        category_breakdown = {}
        for c in complaints:
            cat = c.category.value
            category_breakdown[cat] = category_breakdown.get(cat, 0) + 1
        
        # Priority breakdown
        priority_breakdown = {}
        for c in complaints:
            pri = c.priority.value
            priority_breakdown[pri] = priority_breakdown.get(pri, 0) + 1
        
        # Status breakdown
        status_breakdown = {}
        for c in complaints:
            stat = c.status.value
            status_breakdown[stat] = status_breakdown.get(stat, 0) + 1
        
        return {
            "total_complaints": total,
            "open_complaints": status_counts["open"],
            "in_progress_complaints": status_counts["in_progress"],
            "resolved_complaints": status_counts["resolved"],
            "closed_complaints": status_counts["closed"],
            "avg_resolution_time_hours": Decimal(str(avg_resolution_time)) if avg_resolution_time else None,
            "median_resolution_time_hours": Decimal(str(median_resolution_time)) if median_resolution_time else None,
            "min_resolution_time_hours": Decimal(str(min_resolution_time)) if min_resolution_time else None,
            "max_resolution_time_hours": Decimal(str(max_resolution_time)) if max_resolution_time else None,
            "sla_compliant_count": sla_compliant,
            "sla_breached_count": sla_breached,
            "sla_compliance_rate": Decimal(str(sla_compliance_rate)),
            "escalated_count": escalated,
            "reopened_count": reopened,
            "category_breakdown": category_breakdown,
            "priority_breakdown": priority_breakdown,
            "status_breakdown": status_breakdown,
        }


class ComplaintCategoryMetricRepository(BaseRepository[ComplaintCategoryMetric]):
    """
    Category-wise complaint metrics repository.
    
    Provides category performance tracking and analysis.
    """

    def __init__(self, session: Session):
        """
        Initialize category metric repository.
        
        Args:
            session: SQLAlchemy database session
        """
        super().__init__(ComplaintCategoryMetric, session)

    def create_category_metric(
        self,
        hostel_id: str,
        category: str,
        period_start: date,
        period_end: date,
        metrics: Dict[str, Any],
    ) -> ComplaintCategoryMetric:
        """
        Create category metric record.
        
        Args:
            hostel_id: Hostel identifier
            category: Complaint category
            period_start: Period start date
            period_end: Period end date
            metrics: Calculated metrics
            
        Returns:
            Created metric instance
        """
        metric = ComplaintCategoryMetric(
            hostel_id=hostel_id,
            category=category,
            period_start=period_start,
            period_end=period_end,
            total_complaints=metrics.get("total_complaints", 0),
            open_complaints=metrics.get("open_complaints", 0),
            resolved_complaints=metrics.get("resolved_complaints", 0),
            avg_resolution_time_hours=metrics.get("avg_resolution_time_hours"),
            resolution_rate=metrics.get("resolution_rate"),
            avg_rating=metrics.get("avg_rating"),
            most_common_sub_category=metrics.get("most_common_sub_category"),
            metadata=metrics.get("metadata", {}),
        )
        
        return self.create(metric)

    def find_by_category(
        self,
        hostel_id: str,
        category: str,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
    ) -> List[ComplaintCategoryMetric]:
        """
        Find metrics for a specific category.
        
        Args:
            hostel_id: Hostel identifier
            category: Complaint category
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            List of category metrics
        """
        query = select(ComplaintCategoryMetric).where(
            and_(
                ComplaintCategoryMetric.hostel_id == hostel_id,
                ComplaintCategoryMetric.category == category,
            )
        )
        
        if date_from:
            query = query.where(ComplaintCategoryMetric.period_start >= date_from)
        
        if date_to:
            query = query.where(ComplaintCategoryMetric.period_end <= date_to)
        
        query = query.order_by(ComplaintCategoryMetric.period_start.asc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())


class ComplaintStaffPerformanceRepository(BaseRepository[ComplaintStaffPerformance]):
    """
    Staff performance metrics repository.
    
    Provides staff performance tracking and analytics.
    """

    def __init__(self, session: Session):
        """
        Initialize staff performance repository.
        
        Args:
            session: SQLAlchemy database session
        """
        super().__init__(ComplaintStaffPerformance, session)

    def create_performance_metric(
        self,
        staff_id: str,
        hostel_id: str,
        period_start: date,
        period_end: date,
        metrics: Dict[str, Any],
    ) -> ComplaintStaffPerformance:
        """
        Create staff performance metric.
        
        Args:
            staff_id: Staff member ID
            hostel_id: Hostel identifier
            period_start: Period start date
            period_end: Period end date
            metrics: Calculated metrics
            
        Returns:
            Created performance metric
        """
        performance = ComplaintStaffPerformance(
            staff_id=staff_id,
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
            complaints_assigned=metrics.get("complaints_assigned", 0),
            complaints_resolved=metrics.get("complaints_resolved", 0),
            complaints_pending=metrics.get("complaints_pending", 0),
            avg_resolution_time_hours=metrics.get("avg_resolution_time_hours"),
            resolution_rate=metrics.get("resolution_rate"),
            avg_rating=metrics.get("avg_rating"),
            total_feedback_count=metrics.get("total_feedback_count", 0),
            escalation_count=metrics.get("escalation_count", 0),
            reopened_count=metrics.get("reopened_count", 0),
            workload_score=metrics.get("workload_score", 0),
            performance_score=metrics.get("performance_score"),
            metadata=metrics.get("metadata", {}),
        )
        
        return self.create(performance)

    def find_by_staff(
        self,
        staff_id: str,
        hostel_id: Optional[str] = None,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
    ) -> List[ComplaintStaffPerformance]:
        """
        Find performance metrics for a staff member.
        
        Args:
            staff_id: Staff member ID
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            List of performance metrics
        """
        query = select(ComplaintStaffPerformance).where(
            ComplaintStaffPerformance.staff_id == staff_id
        )
        
        if hostel_id:
            query = query.where(ComplaintStaffPerformance.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(ComplaintStaffPerformance.period_start >= date_from)
        
        if date_to:
            query = query.where(ComplaintStaffPerformance.period_end <= date_to)
        
        query = query.order_by(ComplaintStaffPerformance.period_start.asc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def get_top_performers(
        self,
        hostel_id: str,
        period_start: date,
        period_end: date,
        limit: int = 10,
    ) -> List[ComplaintStaffPerformance]:
        """
        Get top performing staff members.
        
        Args:
            hostel_id: Hostel identifier
            period_start: Period start date
            period_end: Period end date
            limit: Maximum records to return
            
        Returns:
            List of top performers
        """
        query = (
            select(ComplaintStaffPerformance)
            .where(
                and_(
                    ComplaintStaffPerformance.hostel_id == hostel_id,
                    ComplaintStaffPerformance.period_start == period_start,
                    ComplaintStaffPerformance.period_end == period_end,
                )
            )
            .order_by(desc(ComplaintStaffPerformance.performance_score))
            .limit(limit)
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())




# --- File: C:\Hostel-Main\app\repositories\complaint\complaint_assignment_repository.py ---
# --- File: complaint_assignment_repository.py ---
"""
Complaint assignment repository with workload management and performance tracking.

Handles assignment history, workload balancing, and assignment optimization
for efficient complaint resolution.
"""

from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional, Tuple

from sqlalchemy import and_, desc, func, select
from sqlalchemy.orm import Session

from app.models.complaint.complaint_assignment import ComplaintAssignment
from app.models.complaint.complaint import Complaint
from app.repositories.base.base_repository import BaseRepository


class ComplaintAssignmentRepository(BaseRepository[ComplaintAssignment]):
    """
    Complaint assignment repository with advanced workload management.
    
    Provides assignment tracking, workload optimization, and performance
    analytics for complaint resolution staff.
    """

    def __init__(self, session: Session):
        """
        Initialize complaint assignment repository.
        
        Args:
            session: SQLAlchemy database session
        """
        super().__init__(ComplaintAssignment, session)

    # ==================== CRUD Operations ====================

    def create_assignment(
        self,
        complaint_id: str,
        assigned_to: str,
        assigned_by: str,
        assignment_type: str = "INITIAL",
        assignment_reason: Optional[str] = None,
        assignment_notes: Optional[str] = None,
        estimated_resolution_time: Optional[datetime] = None,
        workload_score: int = 0,
    ) -> ComplaintAssignment:
        """
        Create a new complaint assignment.
        
        Args:
            complaint_id: Complaint identifier
            assigned_to: User ID of assignee
            assigned_by: User ID performing assignment
            assignment_type: Type (INITIAL, REASSIGNMENT, ESCALATION)
            assignment_reason: Reason for assignment
            assignment_notes: Additional context
            estimated_resolution_time: Expected resolution time
            workload_score: Calculated workload score
            
        Returns:
            Created assignment instance
        """
        # Mark previous assignment as not current if exists
        self._deactivate_previous_assignments(complaint_id)
        
        assignment = ComplaintAssignment(
            complaint_id=complaint_id,
            assigned_to=assigned_to,
            assigned_by=assigned_by,
            assigned_at=datetime.now(timezone.utc),
            assignment_type=assignment_type,
            assignment_reason=assignment_reason,
            assignment_notes=assignment_notes,
            estimated_resolution_time=estimated_resolution_time,
            workload_score=workload_score,
            is_current=True,
        )
        
        return self.create(assignment)

    def complete_assignment(
        self,
        assignment_id: str,
    ) -> Optional[ComplaintAssignment]:
        """
        Mark assignment as completed.
        
        Args:
            assignment_id: Assignment identifier
            
        Returns:
            Updated assignment or None
        """
        assignment = self.find_by_id(assignment_id)
        if not assignment:
            return None
        
        now = datetime.now(timezone.utc)
        
        # Calculate duration
        duration_delta = now - assignment.assigned_at
        duration_hours = int(duration_delta.total_seconds() / 3600)
        
        update_data = {
            "is_current": False,
            "unassigned_at": now,
            "duration_hours": duration_hours,
        }
        
        return self.update(assignment_id, update_data)

    # ==================== Query Operations ====================

    def find_by_complaint(
        self,
        complaint_id: str,
        include_inactive: bool = True,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintAssignment]:
        """
        Find all assignments for a complaint.
        
        Args:
            complaint_id: Complaint identifier
            include_inactive: Include completed assignments
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of assignments
        """
        query = select(ComplaintAssignment).where(
            ComplaintAssignment.complaint_id == complaint_id
        )
        
        if not include_inactive:
            query = query.where(ComplaintAssignment.is_current == True)
        
        query = query.order_by(desc(ComplaintAssignment.assigned_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_current_assignment(
        self,
        complaint_id: str,
    ) -> Optional[ComplaintAssignment]:
        """
        Find current active assignment for a complaint.
        
        Args:
            complaint_id: Complaint identifier
            
        Returns:
            Current assignment or None
        """
        query = select(ComplaintAssignment).where(
            and_(
                ComplaintAssignment.complaint_id == complaint_id,
                ComplaintAssignment.is_current == True,
            )
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()

    def find_by_assignee(
        self,
        user_id: str,
        current_only: bool = True,
        assignment_type: Optional[str] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintAssignment]:
        """
        Find assignments for a specific user.
        
        Args:
            user_id: User identifier
            current_only: Only active assignments
            assignment_type: Filter by assignment type
            date_from: Start date filter
            date_to: End date filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of assignments
        """
        query = select(ComplaintAssignment).where(
            ComplaintAssignment.assigned_to == user_id
        )
        
        if current_only:
            query = query.where(ComplaintAssignment.is_current == True)
        
        if assignment_type:
            query = query.where(ComplaintAssignment.assignment_type == assignment_type)
        
        if date_from:
            query = query.where(ComplaintAssignment.assigned_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintAssignment.assigned_at <= date_to)
        
        query = query.order_by(desc(ComplaintAssignment.assigned_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_by_assigner(
        self,
        user_id: str,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintAssignment]:
        """
        Find assignments created by a specific user.
        
        Args:
            user_id: User identifier
            date_from: Start date filter
            date_to: End date filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of assignments
        """
        query = select(ComplaintAssignment).where(
            ComplaintAssignment.assigned_by == user_id
        )
        
        if date_from:
            query = query.where(ComplaintAssignment.assigned_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintAssignment.assigned_at <= date_to)
        
        query = query.order_by(desc(ComplaintAssignment.assigned_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    # ==================== Workload Management ====================

    def get_user_workload(
        self,
        user_id: str,
        hostel_id: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Calculate current workload for a user.
        
        Args:
            user_id: User identifier
            hostel_id: Optional hostel filter
            
        Returns:
            Dictionary with workload metrics
        """
        # Get active assignments
        query = (
            select(ComplaintAssignment)
            .join(Complaint)
            .where(
                and_(
                    ComplaintAssignment.assigned_to == user_id,
                    ComplaintAssignment.is_current == True,
                    Complaint.status.notin_(['RESOLVED', 'CLOSED']),
                )
            )
        )
        
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        result = self.session.execute(query)
        active_assignments = list(result.scalars().all())
        
        # Calculate metrics
        total_assignments = len(active_assignments)
        total_workload_score = sum(a.workload_score for a in active_assignments)
        
        # Count by priority
        priority_query = (
            select(
                Complaint.priority,
                func.count(ComplaintAssignment.id).label("count"),
            )
            .join(Complaint)
            .where(
                and_(
                    ComplaintAssignment.assigned_to == user_id,
                    ComplaintAssignment.is_current == True,
                    Complaint.status.notin_(['RESOLVED', 'CLOSED']),
                )
            )
            .group_by(Complaint.priority)
        )
        
        if hostel_id:
            priority_query = priority_query.where(Complaint.hostel_id == hostel_id)
        
        priority_result = self.session.execute(priority_query)
        priority_breakdown = {
            row.priority.value: row.count for row in priority_result
        }
        
        # Get overdue count
        now = datetime.now(timezone.utc)
        overdue_query = (
            select(func.count())
            .select_from(ComplaintAssignment)
            .join(Complaint)
            .where(
                and_(
                    ComplaintAssignment.assigned_to == user_id,
                    ComplaintAssignment.is_current == True,
                    Complaint.status.notin_(['RESOLVED', 'CLOSED']),
                    Complaint.sla_due_at.isnot(None),
                    Complaint.sla_due_at < now,
                )
            )
        )
        
        if hostel_id:
            overdue_query = overdue_query.where(Complaint.hostel_id == hostel_id)
        
        overdue_count = self.session.execute(overdue_query).scalar_one()
        
        return {
            "user_id": user_id,
            "total_assignments": total_assignments,
            "total_workload_score": total_workload_score,
            "priority_breakdown": priority_breakdown,
            "overdue_count": overdue_count,
            "average_workload_score": (
                total_workload_score / total_assignments
                if total_assignments > 0 else 0
            ),
        }

    def get_team_workload_distribution(
        self,
        user_ids: List[str],
        hostel_id: Optional[str] = None,
    ) -> List[Dict[str, Any]]:
        """
        Get workload distribution across a team.
        
        Args:
            user_ids: List of user identifiers
            hostel_id: Optional hostel filter
            
        Returns:
            List of workload metrics per user
        """
        workload_data = []
        
        for user_id in user_ids:
            workload = self.get_user_workload(user_id, hostel_id)
            workload_data.append(workload)
        
        # Sort by total assignments descending
        workload_data.sort(key=lambda x: x["total_assignments"], reverse=True)
        
        return workload_data

    def find_least_loaded_user(
        self,
        user_ids: List[str],
        hostel_id: Optional[str] = None,
    ) -> Optional[str]:
        """
        Find user with least workload for assignment.
        
        Args:
            user_ids: List of candidate user identifiers
            hostel_id: Optional hostel filter
            
        Returns:
            User ID with least workload or None
        """
        if not user_ids:
            return None
        
        workload_data = self.get_team_workload_distribution(user_ids, hostel_id)
        
        if not workload_data:
            return user_ids[0]
        
        # Find user with minimum workload score
        min_workload_user = min(
            workload_data,
            key=lambda x: x["total_workload_score"]
        )
        
        return min_workload_user["user_id"]

    def calculate_workload_score(
        self,
        complaint_priority: str,
        complaint_category: str,
        estimated_hours: int = 4,
    ) -> int:
        """
        Calculate workload score for a complaint.
        
        Args:
            complaint_priority: Priority level
            complaint_category: Complaint category
            estimated_hours: Estimated resolution hours
            
        Returns:
            Calculated workload score
        """
        # Base score from priority
        priority_scores = {
            "CRITICAL": 100,
            "URGENT": 75,
            "HIGH": 50,
            "MEDIUM": 25,
            "LOW": 10,
        }
        
        base_score = priority_scores.get(complaint_priority, 25)
        
        # Category complexity multiplier
        category_multipliers = {
            "MAINTENANCE": 1.2,
            "FACILITIES": 1.0,
            "CLEANLINESS": 0.8,
            "SECURITY": 1.3,
            "FOOD": 0.9,
            "INTERNET": 1.1,
            "OTHER": 1.0,
        }
        
        multiplier = category_multipliers.get(complaint_category, 1.0)
        
        # Time factor (longer estimated time = higher score)
        time_factor = min(estimated_hours / 4, 2.0)  # Cap at 2x
        
        return int(base_score * multiplier * time_factor)

    # ==================== Performance Analytics ====================

    def get_assignment_performance(
        self,
        user_id: str,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, Any]:
        """
        Get assignment performance metrics for a user.
        
        Args:
            user_id: User identifier
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            Dictionary with performance metrics
        """
        query = select(ComplaintAssignment).where(
            ComplaintAssignment.assigned_to == user_id
        )
        
        if date_from:
            query = query.where(ComplaintAssignment.assigned_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintAssignment.assigned_at <= date_to)
        
        result = self.session.execute(query)
        assignments = list(result.scalars().all())
        
        if not assignments:
            return {
                "user_id": user_id,
                "total_assignments": 0,
                "completed_assignments": 0,
                "active_assignments": 0,
                "average_duration_hours": None,
                "reassignment_rate": 0,
            }
        
        total = len(assignments)
        completed = len([a for a in assignments if not a.is_current])
        active = len([a for a in assignments if a.is_current])
        
        # Calculate average duration for completed assignments
        completed_with_duration = [
            a for a in assignments
            if a.duration_hours is not None
        ]
        
        avg_duration = (
            sum(a.duration_hours for a in completed_with_duration) / len(completed_with_duration)
            if completed_with_duration else None
        )
        
        # Count reassignments
        reassignments = len([
            a for a in assignments
            if a.assignment_type == "REASSIGNMENT"
        ])
        
        return {
            "user_id": user_id,
            "total_assignments": total,
            "completed_assignments": completed,
            "active_assignments": active,
            "average_duration_hours": avg_duration,
            "reassignment_count": reassignments,
            "reassignment_rate": (reassignments / total * 100) if total > 0 else 0,
        }

    def get_assignment_history_stats(
        self,
        complaint_id: str,
    ) -> Dict[str, Any]:
        """
        Get assignment history statistics for a complaint.
        
        Args:
            complaint_id: Complaint identifier
            
        Returns:
            Dictionary with assignment statistics
        """
        query = select(ComplaintAssignment).where(
            ComplaintAssignment.complaint_id == complaint_id
        )
        
        result = self.session.execute(query)
        assignments = list(result.scalars().all())
        
        if not assignments:
            return {
                "complaint_id": complaint_id,
                "total_assignments": 0,
                "reassignment_count": 0,
                "unique_assignees": 0,
                "total_assignment_time_hours": None,
            }
        
        total = len(assignments)
        reassignments = total - 1  # First is initial, rest are reassignments
        
        # Count unique assignees
        unique_assignees = len(set(a.assigned_to for a in assignments))
        
        # Calculate total assignment time
        completed_assignments = [
            a for a in assignments
            if a.duration_hours is not None
        ]
        
        total_time = (
            sum(a.duration_hours for a in completed_assignments)
            if completed_assignments else None
        )
        
        return {
            "complaint_id": complaint_id,
            "total_assignments": total,
            "reassignment_count": reassignments,
            "unique_assignees": unique_assignees,
            "total_assignment_time_hours": total_time,
            "average_assignment_duration_hours": (
                total_time / len(completed_assignments)
                if completed_assignments else None
            ),
        }

    # ==================== Assignment Optimization ====================

    def suggest_optimal_assignee(
        self,
        complaint_id: str,
        candidate_user_ids: List[str],
        hostel_id: Optional[str] = None,
    ) -> Optional[str]:
        """
        Suggest optimal assignee based on workload and performance.
        
        Args:
            complaint_id: Complaint being assigned
            candidate_user_ids: List of potential assignees
            hostel_id: Optional hostel context
            
        Returns:
            Recommended user ID or None
        """
        if not candidate_user_ids:
            return None
        
        # Get complaint details
        complaint_query = select(Complaint).where(Complaint.id == complaint_id)
        complaint_result = self.session.execute(complaint_query)
        complaint = complaint_result.scalar_one_or_none()
        
        if not complaint:
            return None
        
        # Calculate scores for each candidate
        candidate_scores = []
        
        for user_id in candidate_user_ids:
            workload = self.get_user_workload(user_id, hostel_id)
            performance = self.get_assignment_performance(user_id)
            
            # Calculate composite score (lower is better)
            # Factors: workload (50%), reassignment rate (30%), response time (20%)
            workload_score = workload["total_workload_score"]
            reassignment_penalty = performance["reassignment_rate"] * 10
            
            composite_score = (
                workload_score * 0.5 +
                reassignment_penalty * 0.3
            )
            
            candidate_scores.append({
                "user_id": user_id,
                "score": composite_score,
                "workload": workload_score,
                "reassignment_rate": performance["reassignment_rate"],
            })
        
        # Sort by score (ascending - lower is better)
        candidate_scores.sort(key=lambda x: x["score"])
        
        return candidate_scores[0]["user_id"] if candidate_scores else None

    def balance_workload(
        self,
        user_ids: List[str],
        hostel_id: Optional[str] = None,
        threshold_percentage: float = 30.0,
    ) -> List[Dict[str, Any]]:
        """
        Identify workload imbalances and suggest reassignments.
        
        Args:
            user_ids: List of team member IDs
            hostel_id: Optional hostel filter
            threshold_percentage: Imbalance threshold
            
        Returns:
            List of suggested reassignments
        """
        workload_data = self.get_team_workload_distribution(user_ids, hostel_id)
        
        if not workload_data:
            return []
        
        # Calculate average workload
        avg_workload = sum(w["total_workload_score"] for w in workload_data) / len(workload_data)
        
        # Identify overloaded and underloaded users
        overloaded = []
        underloaded = []
        
        for workload in workload_data:
            deviation = (workload["total_workload_score"] - avg_workload) / avg_workload * 100
            
            if deviation > threshold_percentage:
                overloaded.append(workload)
            elif deviation < -threshold_percentage:
                underloaded.append(workload)
        
        suggestions = []
        
        # Suggest reassignments from overloaded to underloaded
        for overload in overloaded:
            for underload in underloaded:
                suggestions.append({
                    "from_user": overload["user_id"],
                    "to_user": underload["user_id"],
                    "from_workload": overload["total_workload_score"],
                    "to_workload": underload["total_workload_score"],
                    "reason": "Workload balancing",
                })
        
        return suggestions

    # ==================== Helper Methods ====================

    def _deactivate_previous_assignments(self, complaint_id: str) -> None:
        """
        Mark all previous assignments for a complaint as inactive.
        
        Args:
            complaint_id: Complaint identifier
        """
        now = datetime.now(timezone.utc)
        
        # Get current active assignment
        current = self.find_current_assignment(complaint_id)
        
        if current:
            # Calculate duration
            duration_delta = now - current.assigned_at
            duration_hours = int(duration_delta.total_seconds() / 3600)
            
            # Update current assignment
            self.update(current.id, {
                "is_current": False,
                "unassigned_at": now,
                "duration_hours": duration_hours,
            })




# --- File: C:\Hostel-Main\app\repositories\complaint\complaint_comment_repository.py ---
# --- File: complaint_comment_repository.py ---
"""
Complaint comment repository with threading, mentions, and edit tracking.

Handles complaint comments, internal notes, and discussion threads with
rich features and performance optimization.
"""

from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

from sqlalchemy import and_, desc, func, or_, select
from sqlalchemy.orm import Session

from app.models.complaint.complaint_comment import ComplaintComment
from app.repositories.base.base_repository import BaseRepository


class ComplaintCommentRepository(BaseRepository[ComplaintComment]):
    """
    Complaint comment repository with advanced discussion features.
    
    Provides comment management, threading, mentions, and edit tracking
    with performance optimization.
    """

    def __init__(self, session: Session):
        """
        Initialize complaint comment repository.
        
        Args:
            session: SQLAlchemy database session
        """
        super().__init__(ComplaintComment, session)

    # ==================== CRUD Operations ====================

    def create_comment(
        self,
        complaint_id: str,
        commented_by: str,
        comment_text: str,
        is_internal: bool = False,
        attachments: Optional[List[str]] = None,
        mentioned_users: Optional[List[str]] = None,
        parent_comment_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> ComplaintComment:
        """
        Create a new comment or reply.
        
        Args:
            complaint_id: Complaint identifier
            commented_by: User creating the comment
            comment_text: Comment content
            is_internal: Internal note flag
            attachments: List of attachment URLs
            mentioned_users: List of mentioned user IDs
            parent_comment_id: Parent comment for threading
            metadata: Additional metadata
            
        Returns:
            Created comment instance
        """
        # Calculate thread depth if reply
        thread_depth = 0
        if parent_comment_id:
            parent = self.find_by_id(parent_comment_id)
            if parent:
                thread_depth = parent.thread_depth + 1
        
        comment = ComplaintComment(
            complaint_id=complaint_id,
            commented_by=commented_by,
            comment_text=comment_text,
            is_internal=is_internal,
            attachments=attachments or [],
            mentioned_users=mentioned_users or [],
            parent_comment_id=parent_comment_id,
            thread_depth=thread_depth,
            metadata=metadata or {},
        )
        
        return self.create(comment)

    def update_comment(
        self,
        comment_id: str,
        comment_text: str,
        attachments: Optional[List[str]] = None,
    ) -> Optional[ComplaintComment]:
        """
        Update comment and track edit.
        
        Args:
            comment_id: Comment identifier
            comment_text: Updated comment text
            attachments: Updated attachments list
            
        Returns:
            Updated comment or None
        """
        comment = self.find_by_id(comment_id)
        if not comment:
            return None
        
        now = datetime.now(timezone.utc)
        
        update_data = {
            "comment_text": comment_text,
            "is_edited": True,
            "edited_at": now,
            "edit_count": comment.edit_count + 1,
        }
        
        if attachments is not None:
            update_data["attachments"] = attachments
        
        return self.update(comment_id, update_data)

    # ==================== Query Operations ====================

    def find_by_complaint(
        self,
        complaint_id: str,
        include_internal: bool = True,
        include_deleted: bool = False,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintComment]:
        """
        Find all comments for a complaint.
        
        Args:
            complaint_id: Complaint identifier
            include_internal: Include internal notes
            include_deleted: Include soft-deleted comments
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of comments
        """
        query = select(ComplaintComment).where(
            ComplaintComment.complaint_id == complaint_id
        )
        
        if not include_internal:
            query = query.where(ComplaintComment.is_internal == False)
        
        if not include_deleted:
            query = query.where(ComplaintComment.deleted_at.is_(None))
        
        query = query.order_by(ComplaintComment.created_at.asc())
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_root_comments(
        self,
        complaint_id: str,
        include_internal: bool = True,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintComment]:
        """
        Find root-level comments (not replies).
        
        Args:
            complaint_id: Complaint identifier
            include_internal: Include internal notes
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of root comments
        """
        query = select(ComplaintComment).where(
            and_(
                ComplaintComment.complaint_id == complaint_id,
                ComplaintComment.parent_comment_id.is_(None),
                ComplaintComment.deleted_at.is_(None),
            )
        )
        
        if not include_internal:
            query = query.where(ComplaintComment.is_internal == False)
        
        query = query.order_by(ComplaintComment.created_at.asc())
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_replies(
        self,
        parent_comment_id: str,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintComment]:
        """
        Find all replies to a comment.
        
        Args:
            parent_comment_id: Parent comment identifier
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of reply comments
        """
        query = select(ComplaintComment).where(
            and_(
                ComplaintComment.parent_comment_id == parent_comment_id,
                ComplaintComment.deleted_at.is_(None),
            )
        )
        
        query = query.order_by(ComplaintComment.created_at.asc())
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_by_user(
        self,
        user_id: str,
        complaint_id: Optional[str] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintComment]:
        """
        Find comments by a specific user.
        
        Args:
            user_id: User identifier
            complaint_id: Optional complaint filter
            date_from: Start date filter
            date_to: End date filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of user's comments
        """
        query = select(ComplaintComment).where(
            and_(
                ComplaintComment.commented_by == user_id,
                ComplaintComment.deleted_at.is_(None),
            )
        )
        
        if complaint_id:
            query = query.where(ComplaintComment.complaint_id == complaint_id)
        
        if date_from:
            query = query.where(ComplaintComment.created_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintComment.created_at <= date_to)
        
        query = query.order_by(desc(ComplaintComment.created_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_with_mentions(
        self,
        user_id: str,
        complaint_id: Optional[str] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintComment]:
        """
        Find comments mentioning a specific user.
        
        Args:
            user_id: User identifier
            complaint_id: Optional complaint filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of comments with user mentions
        """
        query = select(ComplaintComment).where(
            and_(
                ComplaintComment.mentioned_users.contains([user_id]),
                ComplaintComment.deleted_at.is_(None),
            )
        )
        
        if complaint_id:
            query = query.where(ComplaintComment.complaint_id == complaint_id)
        
        query = query.order_by(desc(ComplaintComment.created_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_internal_notes(
        self,
        complaint_id: str,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintComment]:
        """
        Find internal notes for a complaint.
        
        Args:
            complaint_id: Complaint identifier
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of internal notes
        """
        query = select(ComplaintComment).where(
            and_(
                ComplaintComment.complaint_id == complaint_id,
                ComplaintComment.is_internal == True,
                ComplaintComment.deleted_at.is_(None),
            )
        )
        
        query = query.order_by(ComplaintComment.created_at.asc())
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    # ==================== Threading Operations ====================

    def get_comment_thread(
        self,
        comment_id: str,
        max_depth: Optional[int] = None,
    ) -> List[ComplaintComment]:
        """
        Get entire comment thread (parent and all descendants).
        
        Args:
            comment_id: Root comment identifier
            max_depth: Maximum thread depth to fetch
            
        Returns:
            List of comments in thread
        """
        thread_comments = []
        
        # Get root comment
        root = self.find_by_id(comment_id)
        if not root:
            return []
        
        thread_comments.append(root)
        
        # Recursively get all replies
        def get_replies_recursive(parent_id: str, current_depth: int):
            if max_depth and current_depth >= max_depth:
                return
            
            replies = self.find_replies(parent_id)
            for reply in replies:
                thread_comments.append(reply)
                get_replies_recursive(reply.id, current_depth + 1)
        
        get_replies_recursive(comment_id, 0)
        
        return thread_comments

    def get_thread_summary(
        self,
        comment_id: str,
    ) -> Dict[str, Any]:
        """
        Get summary statistics for a comment thread.
        
        Args:
            comment_id: Root comment identifier
            
        Returns:
            Dictionary with thread statistics
        """
        thread = self.get_comment_thread(comment_id)
        
        if not thread:
            return {
                "comment_id": comment_id,
                "total_comments": 0,
                "max_depth": 0,
                "unique_commenters": 0,
            }
        
        max_depth = max(c.thread_depth for c in thread)
        unique_commenters = len(set(c.commented_by for c in thread))
        
        return {
            "comment_id": comment_id,
            "total_comments": len(thread),
            "max_depth": max_depth,
            "unique_commenters": unique_commenters,
            "latest_comment_at": max(c.created_at for c in thread),
        }

    # ==================== Analytics ====================

    def get_comment_statistics(
        self,
        complaint_id: str,
    ) -> Dict[str, Any]:
        """
        Get comment statistics for a complaint.
        
        Args:
            complaint_id: Complaint identifier
            
        Returns:
            Dictionary with comment statistics
        """
        # Total count
        total_query = select(func.count()).where(
            and_(
                ComplaintComment.complaint_id == complaint_id,
                ComplaintComment.deleted_at.is_(None),
            )
        )
        total = self.session.execute(total_query).scalar_one()
        
        # Internal notes count
        internal_query = select(func.count()).where(
            and_(
                ComplaintComment.complaint_id == complaint_id,
                ComplaintComment.is_internal == True,
                ComplaintComment.deleted_at.is_(None),
            )
        )
        internal = self.session.execute(internal_query).scalar_one()
        
        # Public comments count
        public = total - internal
        
        # Unique commenters
        unique_query = select(func.count(func.distinct(ComplaintComment.commented_by))).where(
            and_(
                ComplaintComment.complaint_id == complaint_id,
                ComplaintComment.deleted_at.is_(None),
            )
        )
        unique_commenters = self.session.execute(unique_query).scalar_one()
        
        # Latest comment
        latest_query = (
            select(ComplaintComment.created_at)
            .where(
                and_(
                    ComplaintComment.complaint_id == complaint_id,
                    ComplaintComment.deleted_at.is_(None),
                )
            )
            .order_by(desc(ComplaintComment.created_at))
            .limit(1)
        )
        latest_result = self.session.execute(latest_query)
        latest = latest_result.scalar_one_or_none()
        
        return {
            "complaint_id": complaint_id,
            "total_comments": total,
            "public_comments": public,
            "internal_notes": internal,
            "unique_commenters": unique_commenters,
            "latest_comment_at": latest,
        }

    def get_user_comment_activity(
        self,
        user_id: str,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, Any]:
        """
        Get comment activity statistics for a user.
        
        Args:
            user_id: User identifier
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            Dictionary with activity statistics
        """
        query = select(ComplaintComment).where(
            and_(
                ComplaintComment.commented_by == user_id,
                ComplaintComment.deleted_at.is_(None),
            )
        )
        
        if date_from:
            query = query.where(ComplaintComment.created_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintComment.created_at <= date_to)
        
        result = self.session.execute(query)
        comments = list(result.scalars().all())
        
        if not comments:
            return {
                "user_id": user_id,
                "total_comments": 0,
                "internal_notes": 0,
                "public_comments": 0,
                "edited_comments": 0,
                "average_edits_per_comment": 0,
            }
        
        total = len(comments)
        internal = len([c for c in comments if c.is_internal])
        public = total - internal
        edited = len([c for c in comments if c.is_edited])
        total_edits = sum(c.edit_count for c in comments)
        
        return {
            "user_id": user_id,
            "total_comments": total,
            "internal_notes": internal,
            "public_comments": public,
            "edited_comments": edited,
            "total_edits": total_edits,
            "average_edits_per_comment": total_edits / total if total > 0 else 0,
        }

    # ==================== Search Operations ====================

    def search_comments(
        self,
        complaint_id: Optional[str] = None,
        search_term: Optional[str] = None,
        user_id: Optional[str] = None,
        is_internal: Optional[bool] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintComment]:
        """
        Advanced comment search with filters.
        
        Args:
            complaint_id: Filter by complaint
            search_term: Search in comment text
            user_id: Filter by commenter
            is_internal: Filter by internal/public
            date_from: Start date filter
            date_to: End date filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of matching comments
        """
        query = select(ComplaintComment).where(
            ComplaintComment.deleted_at.is_(None)
        )
        
        if complaint_id:
            query = query.where(ComplaintComment.complaint_id == complaint_id)
        
        if search_term:
            search_pattern = f"%{search_term}%"
            query = query.where(ComplaintComment.comment_text.ilike(search_pattern))
        
        if user_id:
            query = query.where(ComplaintComment.commented_by == user_id)
        
        if is_internal is not None:
            query = query.where(ComplaintComment.is_internal == is_internal)
        
        if date_from:
            query = query.where(ComplaintComment.created_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintComment.created_at <= date_to)
        
        query = query.order_by(desc(ComplaintComment.created_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

# --- File: C:\Hostel-Main\app\repositories\complaint\complaint_escalation_repository.py ---
# --- File: complaint_escalation_repository.py ---
"""
Complaint escalation repository with auto-escalation and escalation chain management.

Handles escalation tracking, auto-escalation rules, and escalation performance
analytics for complaint resolution optimization.
"""

from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional, Tuple

from sqlalchemy import and_, desc, func, or_, select
from sqlalchemy.orm import Session

from app.models.complaint.complaint_escalation import (
    ComplaintEscalation,
    AutoEscalationRule,
)
from app.models.complaint.complaint import Complaint
from app.models.base.enums import ComplaintStatus, Priority
from app.repositories.base.base_repository import BaseRepository


class ComplaintEscalationRepository(BaseRepository[ComplaintEscalation]):
    """
    Complaint escalation repository with intelligent escalation management.
    
    Provides escalation tracking, auto-escalation processing, and performance
    analytics for effective complaint resolution.
    """

    def __init__(self, session: Session):
        """
        Initialize complaint escalation repository.
        
        Args:
            session: SQLAlchemy database session
        """
        super().__init__(ComplaintEscalation, session)

    # ==================== CRUD Operations ====================

    def create_escalation(
        self,
        complaint_id: str,
        escalated_to: str,
        escalated_by: str,
        escalation_reason: str,
        escalation_level: int = 1,
        is_urgent: bool = False,
        status_before: str = None,
        priority_before: str = None,
        priority_after: str = None,
        auto_escalated: bool = False,
        auto_escalation_rule_id: Optional[str] = None,
    ) -> ComplaintEscalation:
        """
        Create a new escalation record.
        
        Args:
            complaint_id: Complaint identifier
            escalated_to: User to escalate to
            escalated_by: User performing escalation
            escalation_reason: Reason for escalation
            escalation_level: Escalation level (1, 2, 3, etc.)
            is_urgent: Urgent flag
            status_before: Status before escalation
            priority_before: Priority before escalation
            priority_after: Priority after escalation
            auto_escalated: Auto-escalation flag
            auto_escalation_rule_id: Auto-escalation rule ID
            
        Returns:
            Created escalation instance
        """
        escalation = ComplaintEscalation(
            complaint_id=complaint_id,
            escalated_to=escalated_to,
            escalated_by=escalated_by,
            escalated_at=datetime.now(timezone.utc),
            escalation_level=escalation_level,
            escalation_reason=escalation_reason,
            is_urgent=is_urgent,
            status_before=status_before or ComplaintStatus.OPEN.value,
            priority_before=priority_before or Priority.MEDIUM.value,
            priority_after=priority_after or priority_before or Priority.HIGH.value,
            auto_escalated=auto_escalated,
            auto_escalation_rule_id=auto_escalation_rule_id,
        )
        
        return self.create(escalation)

    def respond_to_escalation(
        self,
        escalation_id: str,
        responded_by: str,
        response_notes: str,
    ) -> Optional[ComplaintEscalation]:
        """
        Record response to an escalation.
        
        Args:
            escalation_id: Escalation identifier
            responded_by: User responding
            response_notes: Response details
            
        Returns:
            Updated escalation or None
        """
        escalation = self.find_by_id(escalation_id)
        if not escalation:
            return None
        
        now = datetime.now(timezone.utc)
        
        # Calculate resolution time
        time_delta = now - escalation.escalated_at
        resolution_hours = int(time_delta.total_seconds() / 3600)
        
        update_data = {
            "responded_at": now,
            "responded_by": responded_by,
            "response_notes": response_notes,
            "resolution_time_hours": resolution_hours,
        }
        
        return self.update(escalation_id, update_data)

    def mark_escalation_resolved(
        self,
        escalation_id: str,
        resolved_after_escalation: bool = True,
    ) -> Optional[ComplaintEscalation]:
        """
        Mark escalation as resolved.
        
        Args:
            escalation_id: Escalation identifier
            resolved_after_escalation: Whether complaint was resolved
            
        Returns:
            Updated escalation or None
        """
        update_data = {
            "resolved_at": datetime.now(timezone.utc),
            "resolved_after_escalation": resolved_after_escalation,
        }
        
        return self.update(escalation_id, update_data)

    # ==================== Query Operations ====================

    def find_by_complaint(
        self,
        complaint_id: str,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintEscalation]:
        """
        Find all escalations for a complaint.
        
        Args:
            complaint_id: Complaint identifier
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of escalations
        """
        query = select(ComplaintEscalation).where(
            ComplaintEscalation.complaint_id == complaint_id
        )
        
        query = query.order_by(desc(ComplaintEscalation.escalated_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_by_escalated_user(
        self,
        user_id: str,
        responded: Optional[bool] = None,
        resolved: Optional[bool] = None,
        is_urgent: Optional[bool] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintEscalation]:
        """
        Find escalations assigned to a user.
        
        Args:
            user_id: User identifier
            responded: Filter by response status
            resolved: Filter by resolution status
            is_urgent: Filter by urgency
            date_from: Start date filter
            date_to: End date filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of escalations
        """
        query = select(ComplaintEscalation).where(
            ComplaintEscalation.escalated_to == user_id
        )
        
        if responded is not None:
            if responded:
                query = query.where(ComplaintEscalation.responded_at.isnot(None))
            else:
                query = query.where(ComplaintEscalation.responded_at.is_(None))
        
        if resolved is not None:
            if resolved:
                query = query.where(ComplaintEscalation.resolved_at.isnot(None))
            else:
                query = query.where(ComplaintEscalation.resolved_at.is_(None))
        
        if is_urgent is not None:
            query = query.where(ComplaintEscalation.is_urgent == is_urgent)
        
        if date_from:
            query = query.where(ComplaintEscalation.escalated_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintEscalation.escalated_at <= date_to)
        
        query = query.order_by(desc(ComplaintEscalation.escalated_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_pending_escalations(
        self,
        user_id: Optional[str] = None,
        hostel_id: Optional[str] = None,
        is_urgent: Optional[bool] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintEscalation]:
        """
        Find pending (not responded) escalations.
        
        Args:
            user_id: Optional user filter
            hostel_id: Optional hostel filter
            is_urgent: Optional urgency filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of pending escalations
        """
        query = (
            select(ComplaintEscalation)
            .where(ComplaintEscalation.responded_at.is_(None))
        )
        
        if user_id:
            query = query.where(ComplaintEscalation.escalated_to == user_id)
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        if is_urgent is not None:
            query = query.where(ComplaintEscalation.is_urgent == is_urgent)
        
        query = query.order_by(
            desc(ComplaintEscalation.is_urgent),
            ComplaintEscalation.escalated_at.asc(),
        )
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_auto_escalations(
        self,
        hostel_id: Optional[str] = None,
        rule_id: Optional[str] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintEscalation]:
        """
        Find auto-generated escalations.
        
        Args:
            hostel_id: Optional hostel filter
            rule_id: Optional rule filter
            date_from: Start date filter
            date_to: End date filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of auto-escalations
        """
        query = select(ComplaintEscalation).where(
            ComplaintEscalation.auto_escalated == True
        )
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        if rule_id:
            query = query.where(ComplaintEscalation.auto_escalation_rule_id == rule_id)
        
        if date_from:
            query = query.where(ComplaintEscalation.escalated_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintEscalation.escalated_at <= date_to)
        
        query = query.order_by(desc(ComplaintEscalation.escalated_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_by_level(
        self,
        escalation_level: int,
        hostel_id: Optional[str] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintEscalation]:
        """
        Find escalations by level.
        
        Args:
            escalation_level: Escalation level
            hostel_id: Optional hostel filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of escalations at specified level
        """
        query = select(ComplaintEscalation).where(
            ComplaintEscalation.escalation_level == escalation_level
        )
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        query = query.order_by(desc(ComplaintEscalation.escalated_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    # ==================== Escalation Analytics ====================

    def get_escalation_statistics(
        self,
        hostel_id: Optional[str] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, Any]:
        """
        Get comprehensive escalation statistics.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            Dictionary with escalation statistics
        """
        query = select(ComplaintEscalation)
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(ComplaintEscalation.escalated_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintEscalation.escalated_at <= date_to)
        
        result = self.session.execute(query)
        escalations = list(result.scalars().all())
        
        if not escalations:
            return {
                "total_escalations": 0,
                "auto_escalations": 0,
                "manual_escalations": 0,
                "urgent_escalations": 0,
                "average_response_time_hours": None,
                "pending_escalations": 0,
                "resolved_after_escalation": 0,
            }
        
        total = len(escalations)
        auto = len([e for e in escalations if e.auto_escalated])
        manual = total - auto
        urgent = len([e for e in escalations if e.is_urgent])
        pending = len([e for e in escalations if e.responded_at is None])
        resolved = len([e for e in escalations if e.resolved_after_escalation])
        
        # Calculate average response time
        responded = [e for e in escalations if e.resolution_time_hours is not None]
        avg_response = (
            sum(e.resolution_time_hours for e in responded) / len(responded)
            if responded else None
        )
        
        # Level breakdown
        level_breakdown = {}
        for e in escalations:
            level = e.escalation_level
            level_breakdown[level] = level_breakdown.get(level, 0) + 1
        
        return {
            "total_escalations": total,
            "auto_escalations": auto,
            "manual_escalations": manual,
            "urgent_escalations": urgent,
            "average_response_time_hours": avg_response,
            "pending_escalations": pending,
            "resolved_after_escalation": resolved,
            "resolution_rate": (resolved / total * 100) if total > 0 else 0,
            "level_breakdown": level_breakdown,
        }

    def get_user_escalation_performance(
        self,
        user_id: str,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, Any]:
        """
        Get escalation performance metrics for a user.
        
        Args:
            user_id: User identifier
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            Dictionary with performance metrics
        """
        query = select(ComplaintEscalation).where(
            ComplaintEscalation.escalated_to == user_id
        )
        
        if date_from:
            query = query.where(ComplaintEscalation.escalated_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintEscalation.escalated_at <= date_to)
        
        result = self.session.execute(query)
        escalations = list(result.scalars().all())
        
        if not escalations:
            return {
                "user_id": user_id,
                "total_escalations": 0,
                "responded_count": 0,
                "pending_count": 0,
                "average_response_time_hours": None,
                "resolution_rate": 0,
            }
        
        total = len(escalations)
        responded = len([e for e in escalations if e.responded_at is not None])
        pending = total - responded
        resolved = len([e for e in escalations if e.resolved_after_escalation])
        
        # Calculate average response time
        responded_escalations = [
            e for e in escalations
            if e.resolution_time_hours is not None
        ]
        
        avg_response = (
            sum(e.resolution_time_hours for e in responded_escalations) / len(responded_escalations)
            if responded_escalations else None
        )
        
        return {
            "user_id": user_id,
            "total_escalations": total,
            "responded_count": responded,
            "pending_count": pending,
            "average_response_time_hours": avg_response,
            "resolution_rate": (resolved / total * 100) if total > 0 else 0,
            "response_rate": (responded / total * 100) if total > 0 else 0,
        }

    def get_escalation_trends(
        self,
        hostel_id: Optional[str] = None,
        days: int = 30,
    ) -> List[Dict[str, Any]]:
        """
        Get escalation trends over time.
        
        Args:
            hostel_id: Optional hostel filter
            days: Number of days to analyze
            
        Returns:
            List of daily escalation counts
        """
        end_date = datetime.now(timezone.utc)
        start_date = end_date - timedelta(days=days)
        
        query = (
            select(
                func.date(ComplaintEscalation.escalated_at).label("date"),
                func.count(ComplaintEscalation.id).label("count"),
                func.sum(
                    func.cast(ComplaintEscalation.is_urgent, func.Integer())
                ).label("urgent_count"),
            )
            .where(ComplaintEscalation.escalated_at >= start_date)
            .group_by(func.date(ComplaintEscalation.escalated_at))
            .order_by(func.date(ComplaintEscalation.escalated_at))
        )
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        result = self.session.execute(query)
        
        return [
            {
                "date": row.date.isoformat(),
                "total_escalations": row.count,
                "urgent_escalations": row.urgent_count or 0,
            }
            for row in result
        ]

    # ==================== Escalation Chain Management ====================

    def get_escalation_chain(
        self,
        complaint_id: str,
    ) -> List[ComplaintEscalation]:
        """
        Get complete escalation chain for a complaint.
        
        Args:
            complaint_id: Complaint identifier
            
        Returns:
            List of escalations ordered by level
        """
        query = (
            select(ComplaintEscalation)
            .where(ComplaintEscalation.complaint_id == complaint_id)
            .order_by(ComplaintEscalation.escalation_level.asc())
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def get_next_escalation_level(
        self,
        complaint_id: str,
    ) -> int:
        """
        Get next escalation level for a complaint.
        
        Args:
            complaint_id: Complaint identifier
            
        Returns:
            Next escalation level number
        """
        query = (
            select(func.max(ComplaintEscalation.escalation_level))
            .where(ComplaintEscalation.complaint_id == complaint_id)
        )
        
        result = self.session.execute(query)
        max_level = result.scalar_one_or_none()
        
        return (max_level or 0) + 1

    def check_escalation_eligibility(
        self,
        complaint_id: str,
        max_level: int = 3,
    ) -> Tuple[bool, Optional[str]]:
        """
        Check if complaint can be escalated further.
        
        Args:
            complaint_id: Complaint identifier
            max_level: Maximum allowed escalation level
            
        Returns:
            Tuple of (eligible, reason)
        """
        chain = self.get_escalation_chain(complaint_id)
        
        if not chain:
            return True, None
        
        current_level = max(e.escalation_level for e in chain)
        
        if current_level >= max_level:
            return False, f"Maximum escalation level ({max_level}) reached"
        
        # Check if last escalation is pending
        latest = chain[-1]
        if latest.responded_at is None:
            return False, "Previous escalation pending response"
        
        return True, None


class AutoEscalationRuleRepository(BaseRepository[AutoEscalationRule]):
    """
    Auto-escalation rule repository for managing escalation automation.
    
    Provides rule management and auto-escalation processing capabilities.
    """

    def __init__(self, session: Session):
        """
        Initialize auto-escalation rule repository.
        
        Args:
            session: SQLAlchemy database session
        """
        super().__init__(AutoEscalationRule, session)

    # ==================== CRUD Operations ====================

    def create_rule(
        self,
        hostel_id: str,
        rule_name: str,
        first_escalation_to: str,
        escalate_after_hours: int = 24,
        escalate_on_sla_breach: bool = True,
        urgent_escalation_hours: int = 4,
        high_escalation_hours: int = 12,
        medium_escalation_hours: int = 24,
        low_escalation_hours: int = 48,
        second_escalation_to: Optional[str] = None,
        third_escalation_to: Optional[str] = None,
        priority: int = 100,
        is_active: bool = True,
        conditions: Optional[Dict[str, Any]] = None,
    ) -> AutoEscalationRule:
        """
        Create a new auto-escalation rule.
        
        Args:
            hostel_id: Hostel identifier
            rule_name: Rule name
            first_escalation_to: First level escalation user
            escalate_after_hours: Default escalation hours
            escalate_on_sla_breach: Auto-escalate on SLA breach
            urgent_escalation_hours: Hours for urgent priority
            high_escalation_hours: Hours for high priority
            medium_escalation_hours: Hours for medium priority
            low_escalation_hours: Hours for low priority
            second_escalation_to: Second level user
            third_escalation_to: Third level user
            priority: Rule priority
            is_active: Active status
            conditions: Additional conditions
            
        Returns:
            Created rule instance
        """
        rule = AutoEscalationRule(
            hostel_id=hostel_id,
            rule_name=rule_name,
            first_escalation_to=first_escalation_to,
            escalate_after_hours=escalate_after_hours,
            escalate_on_sla_breach=escalate_on_sla_breach,
            urgent_escalation_hours=urgent_escalation_hours,
            high_escalation_hours=high_escalation_hours,
            medium_escalation_hours=medium_escalation_hours,
            low_escalation_hours=low_escalation_hours,
            second_escalation_to=second_escalation_to,
            third_escalation_to=third_escalation_to,
            priority=priority,
            is_active=is_active,
            conditions=conditions or {},
        )
        
        return self.create(rule)

    # ==================== Query Operations ====================

    def find_active_rules(
        self,
        hostel_id: Optional[str] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[AutoEscalationRule]:
        """
        Find active auto-escalation rules.
        
        Args:
            hostel_id: Optional hostel filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of active rules
        """
        query = select(AutoEscalationRule).where(
            AutoEscalationRule.is_active == True
        )
        
        if hostel_id:
            query = query.where(AutoEscalationRule.hostel_id == hostel_id)
        
        query = query.order_by(AutoEscalationRule.priority.asc())
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_by_hostel(
        self,
        hostel_id: str,
        active_only: bool = False,
        skip: int = 0,
        limit: int = 100,
    ) -> List[AutoEscalationRule]:
        """
        Find rules for a specific hostel.
        
        Args:
            hostel_id: Hostel identifier
            active_only: Only active rules
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of rules
        """
        query = select(AutoEscalationRule).where(
            AutoEscalationRule.hostel_id == hostel_id
        )
        
        if active_only:
            query = query.where(AutoEscalationRule.is_active == True)
        
        query = query.order_by(AutoEscalationRule.priority.asc())
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_applicable_rule(
        self,
        hostel_id: str,
        complaint_priority: str,
        complaint_age_hours: int,
        sla_breached: bool = False,
    ) -> Optional[AutoEscalationRule]:
        """
        Find applicable auto-escalation rule for a complaint.
        
        Args:
            hostel_id: Hostel identifier
            complaint_priority: Complaint priority level
            complaint_age_hours: Complaint age in hours
            sla_breached: SLA breach status
            
        Returns:
            Applicable rule or None
        """
        rules = self.find_active_rules(hostel_id)
        
        for rule in rules:
            # Check SLA breach condition
            if sla_breached and rule.escalate_on_sla_breach:
                return rule
            
            # Check age threshold based on priority
            threshold = rule.get_threshold_for_priority(complaint_priority)
            
            if complaint_age_hours >= threshold:
                return rule
        
        return None

    def get_escalation_targets(
        self,
        rule_id: str,
        level: int = 1,
    ) -> Optional[str]:
        """
        Get escalation target user for a specific level.
        
        Args:
            rule_id: Rule identifier
            level: Escalation level
            
        Returns:
            User ID for escalation target or None
        """
        rule = self.find_by_id(rule_id)
        if not rule:
            return None
        
        if level == 1:
            return rule.first_escalation_to
        elif level == 2:
            return rule.second_escalation_to
        elif level == 3:
            return rule.third_escalation_to
        
        return None

    # ==================== Rule Management ====================

    def activate_rule(
        self,
        rule_id: str,
    ) -> Optional[AutoEscalationRule]:
        """
        Activate an auto-escalation rule.
        
        Args:
            rule_id: Rule identifier
            
        Returns:
            Updated rule or None
        """
        return self.update(rule_id, {"is_active": True})

    def deactivate_rule(
        self,
        rule_id: str,
    ) -> Optional[AutoEscalationRule]:
        """
        Deactivate an auto-escalation rule.
        
        Args:
            rule_id: Rule identifier
            
        Returns:
            Updated rule or None
        """
        return self.update(rule_id, {"is_active": False})

    def update_escalation_targets(
        self,
        rule_id: str,
        first_escalation_to: Optional[str] = None,
        second_escalation_to: Optional[str] = None,
        third_escalation_to: Optional[str] = None,
    ) -> Optional[AutoEscalationRule]:
        """
        Update escalation targets for a rule.
        
        Args:
            rule_id: Rule identifier
            first_escalation_to: First level target
            second_escalation_to: Second level target
            third_escalation_to: Third level target
            
        Returns:
            Updated rule or None
        """
        update_data = {}
        
        if first_escalation_to:
            update_data["first_escalation_to"] = first_escalation_to
        
        if second_escalation_to:
            update_data["second_escalation_to"] = second_escalation_to
        
        if third_escalation_to:
            update_data["third_escalation_to"] = third_escalation_to
        
        if not update_data:
            return None
        
        return self.update(rule_id, update_data)

    def update_thresholds(
        self,
        rule_id: str,
        urgent_hours: Optional[int] = None,
        high_hours: Optional[int] = None,
        medium_hours: Optional[int] = None,
        low_hours: Optional[int] = None,
    ) -> Optional[AutoEscalationRule]:
        """
        Update escalation time thresholds.
        
        Args:
            rule_id: Rule identifier
            urgent_hours: Urgent priority threshold
            high_hours: High priority threshold
            medium_hours: Medium priority threshold
            low_hours: Low priority threshold
            
        Returns:
            Updated rule or None
        """
        update_data = {}
        
        if urgent_hours is not None:
            update_data["urgent_escalation_hours"] = urgent_hours
        
        if high_hours is not None:
            update_data["high_escalation_hours"] = high_hours
        
        if medium_hours is not None:
            update_data["medium_escalation_hours"] = medium_hours
        
        if low_hours is not None:
            update_data["low_escalation_hours"] = low_hours
        
        if not update_data:
            return None
        
        return self.update(rule_id, update_data)

    # ==================== Analytics ====================

    def get_rule_effectiveness(
        self,
        rule_id: str,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, Any]:
        """
        Analyze effectiveness of an auto-escalation rule.
        
        Args:
            rule_id: Rule identifier
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            Dictionary with effectiveness metrics
        """
        query = select(ComplaintEscalation).where(
            ComplaintEscalation.auto_escalation_rule_id == rule_id
        )
        
        if date_from:
            query = query.where(ComplaintEscalation.escalated_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintEscalation.escalated_at <= date_to)
        
        result = self.session.execute(query)
        escalations = list(result.scalars().all())
        
        if not escalations:
            return {
                "rule_id": rule_id,
                "total_auto_escalations": 0,
                "resolved_count": 0,
                "resolution_rate": 0,
                "average_resolution_time_hours": None,
            }
        
        total = len(escalations)
        resolved = len([e for e in escalations if e.resolved_after_escalation])
        
        # Calculate average resolution time
        resolved_escalations = [
            e for e in escalations
            if e.resolution_time_hours is not None
        ]
        
        avg_resolution = (
            sum(e.resolution_time_hours for e in resolved_escalations) / len(resolved_escalations)
            if resolved_escalations else None
        )
        
        return {
            "rule_id": rule_id,
            "total_auto_escalations": total,
            "resolved_count": resolved,
            "resolution_rate": (resolved / total * 100) if total > 0 else 0,
            "average_resolution_time_hours": avg_resolution,
        }




# --- File: C:\Hostel-Main\app\repositories\complaint\complaint_feedback_repository.py ---
# --- File: complaint_feedback_repository.py ---
"""
Complaint feedback repository with satisfaction tracking and sentiment analysis.

Handles feedback collection, rating analysis, and satisfaction metrics
for complaint resolution quality monitoring.
"""

from datetime import datetime, timezone
from typing import Any, Dict, List, Optional, Tuple

from sqlalchemy import and_, desc, func, select
from sqlalchemy.orm import Session

from app.models.complaint.complaint_feedback import ComplaintFeedback
from app.models.complaint.complaint import Complaint
from app.repositories.base.base_repository import BaseRepository


class ComplaintFeedbackRepository(BaseRepository[ComplaintFeedback]):
    """
    Complaint feedback repository with satisfaction analytics.
    
    Provides feedback management, rating analysis, and sentiment tracking
    for service quality improvement.
    """

    def __init__(self, session: Session):
        """
        Initialize complaint feedback repository.
        
        Args:
            session: SQLAlchemy database session
        """
        super().__init__(ComplaintFeedback, session)

    # ==================== CRUD Operations ====================

    def create_feedback(
        self,
        complaint_id: str,
        submitted_by: str,
        rating: int,
        issue_resolved_satisfactorily: bool,
        response_time_satisfactory: bool,
        staff_helpful: bool,
        feedback_text: Optional[str] = None,
        would_recommend: Optional[bool] = None,
        resolution_quality_rating: Optional[int] = None,
        communication_rating: Optional[int] = None,
        professionalism_rating: Optional[int] = None,
        improvement_suggestions: Optional[str] = None,
        positive_aspects: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> ComplaintFeedback:
        """
        Create new complaint feedback.
        
        Args:
            complaint_id: Complaint identifier
            submitted_by: User submitting feedback
            rating: Overall rating (1-5)
            issue_resolved_satisfactorily: Resolution satisfaction
            response_time_satisfactory: Response time satisfaction
            staff_helpful: Staff helpfulness
            feedback_text: Detailed feedback
            would_recommend: Recommendation flag
            resolution_quality_rating: Resolution quality (1-5)
            communication_rating: Communication quality (1-5)
            professionalism_rating: Professionalism (1-5)
            improvement_suggestions: Improvement suggestions
            positive_aspects: Positive feedback
            metadata: Additional metadata
            
        Returns:
            Created feedback instance
        """
        feedback = ComplaintFeedback(
            complaint_id=complaint_id,
            submitted_by=submitted_by,
            submitted_at=datetime.now(timezone.utc),
            rating=rating,
            feedback_text=feedback_text,
            issue_resolved_satisfactorily=issue_resolved_satisfactorily,
            response_time_satisfactory=response_time_satisfactory,
            staff_helpful=staff_helpful,
            would_recommend=would_recommend,
            resolution_quality_rating=resolution_quality_rating,
            communication_rating=communication_rating,
            professionalism_rating=professionalism_rating,
            improvement_suggestions=improvement_suggestions,
            positive_aspects=positive_aspects,
            metadata=metadata or {},
        )
        
        # Calculate sentiment (simplified)
        sentiment_score, sentiment_label = self._calculate_sentiment(
            rating=rating,
            feedback_text=feedback_text,
            satisfaction_flags=[
                issue_resolved_satisfactorily,
                response_time_satisfactory,
                staff_helpful,
            ],
        )
        
        feedback.sentiment_score = sentiment_score
        feedback.sentiment_label = sentiment_label
        
        # Check if follow-up needed
        feedback.follow_up_required = self._check_follow_up_needed(
            rating=rating,
            issue_resolved_satisfactorily=issue_resolved_satisfactorily,
            sentiment_label=sentiment_label,
        )
        
        return self.create(feedback)

    def verify_feedback(
        self,
        feedback_id: str,
        verified_by: str,
    ) -> Optional[ComplaintFeedback]:
        """
        Verify feedback as authentic.
        
        Args:
            feedback_id: Feedback identifier
            verified_by: User verifying feedback
            
        Returns:
            Updated feedback or None
        """
        update_data = {
            "is_verified": True,
            "verified_at": datetime.now(timezone.utc),
            "verified_by": verified_by,
        }
        
        return self.update(feedback_id, update_data)

    # ==================== Query Operations ====================

    def find_by_complaint(
        self,
        complaint_id: str,
    ) -> Optional[ComplaintFeedback]:
        """
        Find feedback for a specific complaint.
        
        Args:
            complaint_id: Complaint identifier
            
        Returns:
            Feedback instance or None
        """
        query = select(ComplaintFeedback).where(
            ComplaintFeedback.complaint_id == complaint_id
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()

    def find_by_hostel(
        self,
        hostel_id: str,
        verified_only: bool = False,
        min_rating: Optional[int] = None,
        max_rating: Optional[int] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintFeedback]:
        """
        Find feedback for hostel complaints.
        
        Args:
            hostel_id: Hostel identifier
            verified_only: Only verified feedback
            min_rating: Minimum rating filter
            max_rating: Maximum rating filter
            date_from: Start date filter
            date_to: End date filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of feedback records
        """
        query = (
            select(ComplaintFeedback)
            .join(Complaint)
            .where(Complaint.hostel_id == hostel_id)
        )
        
        if verified_only:
            query = query.where(ComplaintFeedback.is_verified == True)
        
        if min_rating is not None:
            query = query.where(ComplaintFeedback.rating >= min_rating)
        
        if max_rating is not None:
            query = query.where(ComplaintFeedback.rating <= max_rating)
        
        if date_from:
            query = query.where(ComplaintFeedback.submitted_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintFeedback.submitted_at <= date_to)
        
        query = query.order_by(desc(ComplaintFeedback.submitted_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_by_sentiment(
        self,
        sentiment_label: str,
        hostel_id: Optional[str] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintFeedback]:
        """
        Find feedback by sentiment classification.
        
        Args:
            sentiment_label: Sentiment (POSITIVE, NEGATIVE, NEUTRAL)
            hostel_id: Optional hostel filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of feedback with matching sentiment
        """
        query = select(ComplaintFeedback).where(
            ComplaintFeedback.sentiment_label == sentiment_label
        )
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        query = query.order_by(desc(ComplaintFeedback.submitted_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_requiring_follow_up(
        self,
        hostel_id: Optional[str] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintFeedback]:
        """
        Find feedback requiring follow-up action.
        
        Args:
            hostel_id: Optional hostel filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of feedback needing follow-up
        """
        query = select(ComplaintFeedback).where(
            ComplaintFeedback.follow_up_required == True
        )
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        query = query.order_by(desc(ComplaintFeedback.submitted_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    # ==================== Analytics ====================

    def get_satisfaction_metrics(
        self,
        hostel_id: Optional[str] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, Any]:
        """
        Calculate satisfaction metrics.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            Dictionary with satisfaction metrics
        """
        query = select(ComplaintFeedback)
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(ComplaintFeedback.submitted_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintFeedback.submitted_at <= date_to)
        
        result = self.session.execute(query)
        feedbacks = list(result.scalars().all())
        
        if not feedbacks:
            return {
                "total_feedback": 0,
                "average_rating": None,
                "satisfaction_rate": 0,
                "nps_score": None,
            }
        
        total = len(feedbacks)
        
        # Average rating
        avg_rating = sum(f.rating for f in feedbacks) / total
        
        # Satisfaction rate (ratings 4-5)
        satisfied = len([f for f in feedbacks if f.rating >= 4])
        satisfaction_rate = (satisfied / total * 100)
        
        # NPS calculation
        promoters = len([f for f in feedbacks if f.would_recommend is True])
        detractors = len([f for f in feedbacks if f.would_recommend is False])
        nps_responses = promoters + detractors
        nps_score = (
            ((promoters - detractors) / nps_responses * 100)
            if nps_responses > 0 else None
        )
        
        # Satisfaction breakdown
        satisfaction_breakdown = {
            "issue_resolved": len([f for f in feedbacks if f.issue_resolved_satisfactorily]) / total * 100,
            "response_time": len([f for f in feedbacks if f.response_time_satisfactory]) / total * 100,
            "staff_helpful": len([f for f in feedbacks if f.staff_helpful]) / total * 100,
        }
        
        # Rating distribution
        rating_dist = {}
        for i in range(1, 6):
            rating_dist[i] = len([f for f in feedbacks if f.rating == i])
        
        # Sentiment distribution
        sentiment_dist = {
            "POSITIVE": len([f for f in feedbacks if f.sentiment_label == "POSITIVE"]),
            "NEGATIVE": len([f for f in feedbacks if f.sentiment_label == "NEGATIVE"]),
            "NEUTRAL": len([f for f in feedbacks if f.sentiment_label == "NEUTRAL"]),
        }
        
        return {
            "total_feedback": total,
            "average_rating": round(avg_rating, 2),
            "satisfaction_rate": round(satisfaction_rate, 2),
            "nps_score": round(nps_score, 2) if nps_score is not None else None,
            "satisfaction_breakdown": satisfaction_breakdown,
            "rating_distribution": rating_dist,
            "sentiment_distribution": sentiment_dist,
        }

    def get_detailed_ratings(
        self,
        hostel_id: Optional[str] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, float]:
        """
        Get average detailed ratings.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            Dictionary with average detailed ratings
        """
        query = select(ComplaintFeedback)
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(ComplaintFeedback.submitted_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintFeedback.submitted_at <= date_to)
        
        result = self.session.execute(query)
        feedbacks = list(result.scalars().all())
        
        # Filter feedbacks with detailed ratings
        resolution_ratings = [
            f.resolution_quality_rating for f in feedbacks
            if f.resolution_quality_rating is not None
        ]
        
        communication_ratings = [
            f.communication_rating for f in feedbacks
            if f.communication_rating is not None
        ]
        
        professionalism_ratings = [
            f.professionalism_rating for f in feedbacks
            if f.professionalism_rating is not None
        ]
        
        return {
            "resolution_quality": (
                round(sum(resolution_ratings) / len(resolution_ratings), 2)
                if resolution_ratings else None
            ),
            "communication": (
                round(sum(communication_ratings) / len(communication_ratings), 2)
                if communication_ratings else None
            ),
            "professionalism": (
                round(sum(professionalism_ratings) / len(professionalism_ratings), 2)
                if professionalism_ratings else None
            ),
        }

    def get_feedback_trends(
        self,
        hostel_id: Optional[str] = None,
        days: int = 30,
    ) -> List[Dict[str, Any]]:
        """
        Get feedback trends over time.
        
        Args:
            hostel_id: Optional hostel filter
            days: Number of days to analyze
            
        Returns:
            List of daily feedback metrics
        """
        end_date = datetime.now(timezone.utc)
        start_date = end_date - timedelta(days=days)
        
        query = (
            select(
                func.date(ComplaintFeedback.submitted_at).label("date"),
                func.count(ComplaintFeedback.id).label("count"),
                func.avg(ComplaintFeedback.rating).label("avg_rating"),
            )
            .where(ComplaintFeedback.submitted_at >= start_date)
            .group_by(func.date(ComplaintFeedback.submitted_at))
            .order_by(func.date(ComplaintFeedback.submitted_at))
        )
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        result = self.session.execute(query)
        
        return [
            {
                "date": row.date.isoformat(),
                "total_feedback": row.count,
                "average_rating": round(float(row.avg_rating), 2),
            }
            for row in result
        ]

    # ==================== Helper Methods ====================

    def _calculate_sentiment(
        self,
        rating: int,
        feedback_text: Optional[str],
        satisfaction_flags: List[bool],
    ) -> Tuple[float, str]:
        """
        Calculate sentiment score and label.
        
        Args:
            rating: Overall rating
            feedback_text: Feedback text
            satisfaction_flags: List of satisfaction booleans
            
        Returns:
            Tuple of (sentiment_score, sentiment_label)
        """
        # Rating-based score (-1 to 1)
        rating_score = (rating - 3) / 2  # Maps 1->-1, 3->0, 5->1
        
        # Satisfaction flags score
        satisfaction_score = (
            (sum(satisfaction_flags) / len(satisfaction_flags) - 0.5) * 2
            if satisfaction_flags else 0
        )
        
        # Combined score (weighted average)
        sentiment_score = (rating_score * 0.6 + satisfaction_score * 0.4)
        
        # Classify sentiment
        if sentiment_score > 0.3:
            sentiment_label = "POSITIVE"
        elif sentiment_score < -0.3:
            sentiment_label = "NEGATIVE"
        else:
            sentiment_label = "NEUTRAL"
        
        return round(sentiment_score, 2), sentiment_label

    def _check_follow_up_needed(
        self,
        rating: int,
        issue_resolved_satisfactorily: bool,
        sentiment_label: str,
    ) -> bool:
        """
        Determine if follow-up is needed.
        
        Args:
            rating: Overall rating
            issue_resolved_satisfactorily: Resolution satisfaction
            sentiment_label: Sentiment classification
            
        Returns:
            True if follow-up needed
        """
        # Low rating requires follow-up
        if rating <= 2:
            return True
        
        # Issue not resolved satisfactorily
        if not issue_resolved_satisfactorily:
            return True
        
        # Negative sentiment
        if sentiment_label == "NEGATIVE":
            return True
        
        return False

# --- File: C:\Hostel-Main\app\repositories\complaint\complaint_repository.py ---
# --- File: complaint_repository.py ---
"""
Core complaint repository with advanced querying, lifecycle management, and analytics.

Handles all complaint-related data operations including creation, updates, 
status transitions, assignments, and complex search queries.
"""

from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional, Tuple

from sqlalchemy import and_, case, desc, func, or_, select, text
from sqlalchemy.orm import joinedload, selectinload, Session

from app.models.complaint.complaint import Complaint
from app.models.base.enums import ComplaintCategory, ComplaintStatus, Priority
from app.repositories.base.base_repository import BaseRepository
from app.repositories.base.query_builder import QueryBuilder
from app.repositories.base.specifications import Specification


class ComplaintRepository(BaseRepository[Complaint]):
    """
    Core complaint repository with comprehensive data access operations.
    
    Provides advanced querying, filtering, aggregation, and lifecycle
    management for complaints with performance optimization.
    """

    def __init__(self, session: Session):
        """
        Initialize complaint repository.
        
        Args:
            session: SQLAlchemy database session
        """
        super().__init__(Complaint, session)

    # ==================== CRUD Operations ====================

    def create_complaint(
        self,
        hostel_id: str,
        raised_by: str,
        title: str,
        description: str,
        category: ComplaintCategory,
        priority: Priority = Priority.MEDIUM,
        student_id: Optional[str] = None,
        room_id: Optional[str] = None,
        location_details: Optional[str] = None,
        attachments: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Complaint:
        """
        Create a new complaint with auto-generated complaint number.
        
        Args:
            hostel_id: Associated hostel identifier
            raised_by: User ID who raised the complaint
            title: Brief complaint summary
            description: Detailed complaint description
            category: Complaint category
            priority: Priority level
            student_id: Optional student identifier
            room_id: Optional room identifier
            location_details: Detailed location information
            attachments: List of attachment URLs
            metadata: Additional metadata
            
        Returns:
            Created complaint instance
        """
        # Generate unique complaint number
        complaint_number = self._generate_complaint_number(hostel_id)
        
        # Calculate SLA due date based on priority
        sla_due_at = self._calculate_sla_due_date(priority)
        
        complaint = Complaint(
            complaint_number=complaint_number,
            hostel_id=hostel_id,
            raised_by=raised_by,
            student_id=student_id,
            title=title,
            description=description,
            category=category,
            priority=priority,
            room_id=room_id,
            location_details=location_details,
            attachments=attachments or [],
            status=ComplaintStatus.OPEN,
            sla_due_at=sla_due_at,
            opened_at=datetime.now(timezone.utc),
            metadata=metadata or {},
        )
        
        return self.create(complaint)

    def update_complaint(
        self,
        complaint_id: str,
        **update_data: Any,
    ) -> Optional[Complaint]:
        """
        Update complaint with validation and audit tracking.
        
        Args:
            complaint_id: Complaint identifier
            **update_data: Fields to update
            
        Returns:
            Updated complaint or None if not found
        """
        complaint = self.find_by_id(complaint_id)
        if not complaint:
            return None
        
        # Track specific updates
        if "status" in update_data:
            self._handle_status_change(complaint, update_data["status"])
        
        if "priority" in update_data:
            self._handle_priority_change(complaint, update_data["priority"])
        
        return self.update(complaint_id, update_data)

    # ==================== Query Operations ====================

    def find_by_complaint_number(
        self,
        complaint_number: str,
        include_deleted: bool = False,
    ) -> Optional[Complaint]:
        """
        Find complaint by unique complaint number.
        
        Args:
            complaint_number: Unique complaint reference number
            include_deleted: Include soft-deleted records
            
        Returns:
            Complaint instance or None
        """
        query = select(Complaint).where(
            Complaint.complaint_number == complaint_number
        )
        
        if not include_deleted:
            query = query.where(Complaint.deleted_at.is_(None))
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()

    def find_by_hostel(
        self,
        hostel_id: str,
        status: Optional[ComplaintStatus] = None,
        category: Optional[ComplaintCategory] = None,
        priority: Optional[Priority] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
        include_deleted: bool = False,
        skip: int = 0,
        limit: int = 100,
    ) -> List[Complaint]:
        """
        Find complaints by hostel with optional filters.
        
        Args:
            hostel_id: Hostel identifier
            status: Filter by status
            category: Filter by category
            priority: Filter by priority
            date_from: Start date filter
            date_to: End date filter
            include_deleted: Include soft-deleted records
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of matching complaints
        """
        query = select(Complaint).where(Complaint.hostel_id == hostel_id)
        
        if not include_deleted:
            query = query.where(Complaint.deleted_at.is_(None))
        
        if status:
            query = query.where(Complaint.status == status)
        
        if category:
            query = query.where(Complaint.category == category)
        
        if priority:
            query = query.where(Complaint.priority == priority)
        
        if date_from:
            query = query.where(Complaint.opened_at >= date_from)
        
        if date_to:
            query = query.where(Complaint.opened_at <= date_to)
        
        query = query.order_by(desc(Complaint.opened_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_by_student(
        self,
        student_id: str,
        status: Optional[ComplaintStatus] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[Complaint]:
        """
        Find all complaints raised by a student.
        
        Args:
            student_id: Student identifier
            status: Optional status filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of student's complaints
        """
        query = select(Complaint).where(
            and_(
                Complaint.student_id == student_id,
                Complaint.deleted_at.is_(None),
            )
        )
        
        if status:
            query = query.where(Complaint.status == status)
        
        query = query.order_by(desc(Complaint.opened_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_assigned_to_user(
        self,
        user_id: str,
        status: Optional[ComplaintStatus] = None,
        priority: Optional[Priority] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[Complaint]:
        """
        Find complaints assigned to a specific user.
        
        Args:
            user_id: User identifier
            status: Optional status filter
            priority: Optional priority filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of assigned complaints
        """
        query = select(Complaint).where(
            and_(
                Complaint.assigned_to == user_id,
                Complaint.deleted_at.is_(None),
            )
        )
        
        if status:
            query = query.where(Complaint.status == status)
        
        if priority:
            query = query.where(Complaint.priority == priority)
        
        query = query.order_by(
            desc(Complaint.priority),
            Complaint.sla_due_at.asc(),
        )
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_overdue_complaints(
        self,
        hostel_id: Optional[str] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[Complaint]:
        """
        Find complaints that are overdue based on SLA.
        
        Args:
            hostel_id: Optional hostel filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of overdue complaints
        """
        now = datetime.now(timezone.utc)
        
        query = select(Complaint).where(
            and_(
                Complaint.deleted_at.is_(None),
                Complaint.status.in_([
                    ComplaintStatus.OPEN,
                    ComplaintStatus.ASSIGNED,
                    ComplaintStatus.IN_PROGRESS,
                    ComplaintStatus.REOPENED,
                ]),
                Complaint.sla_due_at.isnot(None),
                Complaint.sla_due_at < now,
            )
        )
        
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        query = query.order_by(Complaint.sla_due_at.asc())
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_escalated_complaints(
        self,
        hostel_id: Optional[str] = None,
        escalated_to: Optional[str] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[Complaint]:
        """
        Find escalated complaints.
        
        Args:
            hostel_id: Optional hostel filter
            escalated_to: Optional user filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of escalated complaints
        """
        query = select(Complaint).where(
            and_(
                Complaint.deleted_at.is_(None),
                Complaint.escalated == True,
                Complaint.status.in_([
                    ComplaintStatus.OPEN,
                    ComplaintStatus.ASSIGNED,
                    ComplaintStatus.IN_PROGRESS,
                    ComplaintStatus.REOPENED,
                ]),
            )
        )
        
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        if escalated_to:
            query = query.where(Complaint.escalated_to == escalated_to)
        
        query = query.order_by(desc(Complaint.escalated_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_by_room(
        self,
        room_id: str,
        status: Optional[ComplaintStatus] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[Complaint]:
        """
        Find complaints related to a specific room.
        
        Args:
            room_id: Room identifier
            status: Optional status filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of room-related complaints
        """
        query = select(Complaint).where(
            and_(
                Complaint.room_id == room_id,
                Complaint.deleted_at.is_(None),
            )
        )
        
        if status:
            query = query.where(Complaint.status == status)
        
        query = query.order_by(desc(Complaint.opened_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def search_complaints(
        self,
        hostel_id: Optional[str] = None,
        search_term: Optional[str] = None,
        status: Optional[List[ComplaintStatus]] = None,
        category: Optional[List[ComplaintCategory]] = None,
        priority: Optional[List[Priority]] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
        assigned_to: Optional[str] = None,
        raised_by: Optional[str] = None,
        student_id: Optional[str] = None,
        room_id: Optional[str] = None,
        escalated_only: bool = False,
        sla_breach_only: bool = False,
        skip: int = 0,
        limit: int = 100,
    ) -> Tuple[List[Complaint], int]:
        """
        Advanced complaint search with multiple filters.
        
        Args:
            hostel_id: Filter by hostel
            search_term: Search in title and description
            status: Filter by status list
            category: Filter by category list
            priority: Filter by priority list
            date_from: Start date filter
            date_to: End date filter
            assigned_to: Filter by assignee
            raised_by: Filter by raiser
            student_id: Filter by student
            room_id: Filter by room
            escalated_only: Show only escalated complaints
            sla_breach_only: Show only SLA breached complaints
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            Tuple of (complaints list, total count)
        """
        # Build base query
        query = select(Complaint).where(Complaint.deleted_at.is_(None))
        
        # Apply filters
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        if search_term:
            search_pattern = f"%{search_term}%"
            query = query.where(
                or_(
                    Complaint.title.ilike(search_pattern),
                    Complaint.description.ilike(search_pattern),
                    Complaint.complaint_number.ilike(search_pattern),
                )
            )
        
        if status:
            query = query.where(Complaint.status.in_(status))
        
        if category:
            query = query.where(Complaint.category.in_(category))
        
        if priority:
            query = query.where(Complaint.priority.in_(priority))
        
        if date_from:
            query = query.where(Complaint.opened_at >= date_from)
        
        if date_to:
            query = query.where(Complaint.opened_at <= date_to)
        
        if assigned_to:
            query = query.where(Complaint.assigned_to == assigned_to)
        
        if raised_by:
            query = query.where(Complaint.raised_by == raised_by)
        
        if student_id:
            query = query.where(Complaint.student_id == student_id)
        
        if room_id:
            query = query.where(Complaint.room_id == room_id)
        
        if escalated_only:
            query = query.where(Complaint.escalated == True)
        
        if sla_breach_only:
            query = query.where(Complaint.sla_breach == True)
        
        # Get total count
        count_query = select(func.count()).select_from(query.subquery())
        total_count = self.session.execute(count_query).scalar_one()
        
        # Apply ordering and pagination
        query = query.order_by(
            desc(Complaint.priority),
            Complaint.sla_due_at.asc(),
            desc(Complaint.opened_at),
        )
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        complaints = list(result.scalars().all())
        
        return complaints, total_count

    # ==================== Status Management ====================

    def assign_complaint(
        self,
        complaint_id: str,
        assigned_to: str,
        assigned_by: str,
        notes: Optional[str] = None,
    ) -> Optional[Complaint]:
        """
        Assign complaint to a user.
        
        Args:
            complaint_id: Complaint identifier
            assigned_to: User ID to assign to
            assigned_by: User ID performing assignment
            notes: Optional assignment notes
            
        Returns:
            Updated complaint or None
        """
        complaint = self.find_by_id(complaint_id)
        if not complaint:
            return None
        
        # Update assignment count if reassigning
        if complaint.assigned_to and complaint.assigned_to != assigned_to:
            complaint.reassigned_count += 1
        
        update_data = {
            "assigned_to": assigned_to,
            "assigned_by": assigned_by,
            "assigned_at": datetime.now(timezone.utc),
            "status": ComplaintStatus.ASSIGNED,
            "reassigned_count": complaint.reassigned_count,
        }
        
        return self.update(complaint_id, update_data)

    def mark_in_progress(
        self,
        complaint_id: str,
        user_id: str,
    ) -> Optional[Complaint]:
        """
        Mark complaint as in progress.
        
        Args:
            complaint_id: Complaint identifier
            user_id: User marking as in progress
            
        Returns:
            Updated complaint or None
        """
        complaint = self.find_by_id(complaint_id)
        if not complaint:
            return None
        
        update_data = {
            "status": ComplaintStatus.IN_PROGRESS,
            "in_progress_at": datetime.now(timezone.utc),
        }
        
        return self.update(complaint_id, update_data)

    def mark_resolved(
        self,
        complaint_id: str,
        resolved_by: str,
        resolution_notes: str,
        resolution_attachments: Optional[List[str]] = None,
    ) -> Optional[Complaint]:
        """
        Mark complaint as resolved.
        
        Args:
            complaint_id: Complaint identifier
            resolved_by: User resolving the complaint
            resolution_notes: Resolution description
            resolution_attachments: Optional proof attachments
            
        Returns:
            Updated complaint or None
        """
        complaint = self.find_by_id(complaint_id)
        if not complaint:
            return None
        
        now = datetime.now(timezone.utc)
        
        update_data = {
            "status": ComplaintStatus.RESOLVED,
            "resolved_at": now,
            "resolution_notes": resolution_notes,
            "resolution_attachments": resolution_attachments or [],
            "actual_resolution_time": now,
        }
        
        return self.update(complaint_id, update_data)

    def reopen_complaint(
        self,
        complaint_id: str,
        reopened_by: str,
        reopen_reason: str,
    ) -> Optional[Complaint]:
        """
        Reopen a resolved complaint.
        
        Args:
            complaint_id: Complaint identifier
            reopened_by: User reopening the complaint
            reopen_reason: Reason for reopening
            
        Returns:
            Updated complaint or None
        """
        complaint = self.find_by_id(complaint_id)
        if not complaint:
            return None
        
        update_data = {
            "status": ComplaintStatus.REOPENED,
            "reopened_count": complaint.reopened_count + 1,
            "resolved_at": None,
            "resolution_notes": None,
        }
        
        return self.update(complaint_id, update_data)

    def close_complaint(
        self,
        complaint_id: str,
        closed_by: str,
    ) -> Optional[Complaint]:
        """
        Close a resolved complaint.
        
        Args:
            complaint_id: Complaint identifier
            closed_by: User closing the complaint
            
        Returns:
            Updated complaint or None
        """
        complaint = self.find_by_id(complaint_id)
        if not complaint:
            return None
        
        if complaint.status != ComplaintStatus.RESOLVED:
            return None
        
        update_data = {
            "status": ComplaintStatus.CLOSED,
            "closed_at": datetime.now(timezone.utc),
            "closed_by": closed_by,
        }
        
        return self.update(complaint_id, update_data)

    # ==================== Escalation Management ====================

    def escalate_complaint(
        self,
        complaint_id: str,
        escalated_to: str,
        escalated_by: str,
        escalation_reason: str,
        new_priority: Optional[Priority] = None,
    ) -> Optional[Complaint]:
        """
        Escalate a complaint.
        
        Args:
            complaint_id: Complaint identifier
            escalated_to: User to escalate to
            escalated_by: User performing escalation
            escalation_reason: Reason for escalation
            new_priority: Optional new priority level
            
        Returns:
            Updated complaint or None
        """
        complaint = self.find_by_id(complaint_id)
        if not complaint:
            return None
        
        update_data = {
            "escalated": True,
            "escalated_to": escalated_to,
            "escalated_at": datetime.now(timezone.utc),
            "escalation_reason": escalation_reason,
        }
        
        if new_priority:
            update_data["priority"] = new_priority
        
        return self.update(complaint_id, update_data)

    # ==================== SLA Management ====================

    def mark_sla_breach(
        self,
        complaint_id: str,
        breach_reason: str,
    ) -> Optional[Complaint]:
        """
        Mark complaint as SLA breached.
        
        Args:
            complaint_id: Complaint identifier
            breach_reason: Reason for SLA breach
            
        Returns:
            Updated complaint or None
        """
        update_data = {
            "sla_breach": True,
            "sla_breach_reason": breach_reason,
        }
        
        return self.update(complaint_id, update_data)

    def find_sla_at_risk(
        self,
        hostel_id: Optional[str] = None,
        hours_threshold: int = 2,
        skip: int = 0,
        limit: int = 100,
    ) -> List[Complaint]:
        """
        Find complaints at risk of SLA breach.
        
        Args:
            hostel_id: Optional hostel filter
            hours_threshold: Hours before SLA breach
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of at-risk complaints
        """
        threshold_time = datetime.now(timezone.utc) + timedelta(hours=hours_threshold)
        
        query = select(Complaint).where(
            and_(
                Complaint.deleted_at.is_(None),
                Complaint.sla_breach == False,
                Complaint.status.in_([
                    ComplaintStatus.OPEN,
                    ComplaintStatus.ASSIGNED,
                    ComplaintStatus.IN_PROGRESS,
                    ComplaintStatus.REOPENED,
                ]),
                Complaint.sla_due_at.isnot(None),
                Complaint.sla_due_at <= threshold_time,
            )
        )
        
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        query = query.order_by(Complaint.sla_due_at.asc())
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    # ==================== Analytics & Reporting ====================

    def get_complaint_statistics(
        self,
        hostel_id: Optional[str] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, Any]:
        """
        Get comprehensive complaint statistics.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            Dictionary with complaint statistics
        """
        query = select(Complaint).where(Complaint.deleted_at.is_(None))
        
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(Complaint.opened_at >= date_from)
        
        if date_to:
            query = query.where(Complaint.opened_at <= date_to)
        
        # Status breakdown
        status_query = (
            select(
                Complaint.status,
                func.count(Complaint.id).label("count"),
            )
            .where(Complaint.deleted_at.is_(None))
            .group_by(Complaint.status)
        )
        
        if hostel_id:
            status_query = status_query.where(Complaint.hostel_id == hostel_id)
        
        status_result = self.session.execute(status_query)
        status_breakdown = {
            row.status.value: row.count for row in status_result
        }
        
        # Category breakdown
        category_query = (
            select(
                Complaint.category,
                func.count(Complaint.id).label("count"),
            )
            .where(Complaint.deleted_at.is_(None))
            .group_by(Complaint.category)
        )
        
        if hostel_id:
            category_query = category_query.where(Complaint.hostel_id == hostel_id)
        
        category_result = self.session.execute(category_query)
        category_breakdown = {
            row.category.value: row.count for row in category_result
        }
        
        # Priority breakdown
        priority_query = (
            select(
                Complaint.priority,
                func.count(Complaint.id).label("count"),
            )
            .where(Complaint.deleted_at.is_(None))
            .group_by(Complaint.priority)
        )
        
        if hostel_id:
            priority_query = priority_query.where(Complaint.hostel_id == hostel_id)
        
        priority_result = self.session.execute(priority_query)
        priority_breakdown = {
            row.priority.value: row.count for row in priority_result
        }
        
        # Total count
        count_query = select(func.count()).select_from(query.subquery())
        total_count = self.session.execute(count_query).scalar_one()
        
        # SLA metrics
        sla_breach_query = query.where(Complaint.sla_breach == True)
        sla_breach_count_query = select(func.count()).select_from(sla_breach_query.subquery())
        sla_breach_count = self.session.execute(sla_breach_count_query).scalar_one()
        
        # Escalation metrics
        escalated_query = query.where(Complaint.escalated == True)
        escalated_count_query = select(func.count()).select_from(escalated_query.subquery())
        escalated_count = self.session.execute(escalated_count_query).scalar_one()
        
        return {
            "total_complaints": total_count,
            "status_breakdown": status_breakdown,
            "category_breakdown": category_breakdown,
            "priority_breakdown": priority_breakdown,
            "sla_breach_count": sla_breach_count,
            "sla_compliance_rate": (
                ((total_count - sla_breach_count) / total_count * 100)
                if total_count > 0 else 0
            ),
            "escalated_count": escalated_count,
            "escalation_rate": (
                (escalated_count / total_count * 100)
                if total_count > 0 else 0
            ),
        }

    def get_average_resolution_time(
        self,
        hostel_id: Optional[str] = None,
        category: Optional[ComplaintCategory] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Optional[float]:
        """
        Calculate average resolution time in hours.
        
        Args:
            hostel_id: Optional hostel filter
            category: Optional category filter
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            Average resolution time in hours or None
        """
        query = select(
            func.avg(
                func.extract(
                    "epoch",
                    Complaint.resolved_at - Complaint.opened_at
                ) / 3600
            )
        ).where(
            and_(
                Complaint.deleted_at.is_(None),
                Complaint.resolved_at.isnot(None),
            )
        )
        
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        if category:
            query = query.where(Complaint.category == category)
        
        if date_from:
            query = query.where(Complaint.resolved_at >= date_from)
        
        if date_to:
            query = query.where(Complaint.resolved_at <= date_to)
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()

    def get_top_categories(
        self,
        hostel_id: Optional[str] = None,
        limit: int = 10,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> List[Dict[str, Any]]:
        """
        Get top complaint categories by count.
        
        Args:
            hostel_id: Optional hostel filter
            limit: Maximum categories to return
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            List of categories with counts
        """
        query = (
            select(
                Complaint.category,
                func.count(Complaint.id).label("count"),
            )
            .where(Complaint.deleted_at.is_(None))
            .group_by(Complaint.category)
            .order_by(desc("count"))
            .limit(limit)
        )
        
        if hostel_id:
            query = query.where(Complaint.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(Complaint.opened_at >= date_from)
        
        if date_to:
            query = query.where(Complaint.opened_at <= date_to)
        
        result = self.session.execute(query)
        return [
            {"category": row.category.value, "count": row.count}
            for row in result
        ]

    # ==================== Bulk Operations ====================

    def bulk_assign(
        self,
        complaint_ids: List[str],
        assigned_to: str,
        assigned_by: str,
    ) -> int:
        """
        Bulk assign multiple complaints.
        
        Args:
            complaint_ids: List of complaint identifiers
            assigned_to: User ID to assign to
            assigned_by: User ID performing assignment
            
        Returns:
            Number of complaints updated
        """
        now = datetime.now(timezone.utc)
        
        stmt = (
            self.model.__table__.update()
            .where(
                and_(
                    self.model.id.in_(complaint_ids),
                    self.model.deleted_at.is_(None),
                )
            )
            .values(
                assigned_to=assigned_to,
                assigned_by=assigned_by,
                assigned_at=now,
                status=ComplaintStatus.ASSIGNED,
                updated_at=now,
            )
        )
        
        result = self.session.execute(stmt)
        self.session.commit()
        
        return result.rowcount

    def bulk_update_priority(
        self,
        complaint_ids: List[str],
        priority: Priority,
    ) -> int:
        """
        Bulk update priority for multiple complaints.
        
        Args:
            complaint_ids: List of complaint identifiers
            priority: New priority level
            
        Returns:
            Number of complaints updated
        """
        now = datetime.now(timezone.utc)
        
        stmt = (
            self.model.__table__.update()
            .where(
                and_(
                    self.model.id.in_(complaint_ids),
                    self.model.deleted_at.is_(None),
                )
            )
            .values(
                priority=priority,
                updated_at=now,
            )
        )
        
        result = self.session.execute(stmt)
        self.session.commit()
        
        return result.rowcount

    # ==================== Helper Methods ====================

    def _generate_complaint_number(self, hostel_id: str) -> str:
        """
        Generate unique complaint number.
        
        Args:
            hostel_id: Hostel identifier
            
        Returns:
            Unique complaint number (e.g., CMP-2024-001)
        """
        year = datetime.now().year
        
        # Get count of complaints this year for this hostel
        query = select(func.count()).where(
            and_(
                Complaint.hostel_id == hostel_id,
                func.extract("year", Complaint.created_at) == year,
            )
        )
        
        count = self.session.execute(query).scalar_one()
        sequence = count + 1
        
        return f"CMP-{year}-{sequence:05d}"

    def _calculate_sla_due_date(self, priority: Priority) -> datetime:
        """
        Calculate SLA due date based on priority.
        
        Args:
            priority: Complaint priority
            
        Returns:
            SLA due datetime
        """
        now = datetime.now(timezone.utc)
        
        # SLA hours based on priority
        sla_hours = {
            Priority.CRITICAL: 4,
            Priority.URGENT: 8,
            Priority.HIGH: 24,
            Priority.MEDIUM: 48,
            Priority.LOW: 72,
        }
        
        hours = sla_hours.get(priority, 48)
        return now + timedelta(hours=hours)

    def _handle_status_change(
        self,
        complaint: Complaint,
        new_status: ComplaintStatus,
    ) -> None:
        """
        Handle status-specific updates.
        
        Args:
            complaint: Complaint instance
            new_status: New status
        """
        now = datetime.now(timezone.utc)
        
        if new_status == ComplaintStatus.IN_PROGRESS and not complaint.in_progress_at:
            complaint.in_progress_at = now
        
        elif new_status == ComplaintStatus.RESOLVED and not complaint.resolved_at:
            complaint.resolved_at = now
        
        elif new_status == ComplaintStatus.CLOSED and not complaint.closed_at:
            complaint.closed_at = now

    def _handle_priority_change(
        self,
        complaint: Complaint,
        new_priority: Priority,
    ) -> None:
        """
        Handle priority change and recalculate SLA.
        
        Args:
            complaint: Complaint instance
            new_priority: New priority level
        """
        if complaint.priority != new_priority:
            # Recalculate SLA due date if not breached
            if not complaint.sla_breach and complaint.status in [
                ComplaintStatus.OPEN,
                ComplaintStatus.ASSIGNED,
                ComplaintStatus.IN_PROGRESS,
            ]:
                complaint.sla_due_at = self._calculate_sla_due_date(new_priority)

# --- File: C:\Hostel-Main\app\repositories\complaint\complaint_resolution_repository.py ---
# --- File: complaint_resolution_repository.py ---
"""
Complaint resolution repository with quality tracking and follow-up management.

Handles resolution documentation, quality control, and follow-up scheduling
for comprehensive complaint closure management.
"""

from datetime import date, datetime, timedelta, timezone
from typing import Any, Dict, List, Optional, Tuple

from sqlalchemy import and_, desc, func, select
from sqlalchemy.orm import Session

from app.models.complaint.complaint_resolution import ComplaintResolution
from app.models.complaint.complaint import Complaint
from app.repositories.base.base_repository import BaseRepository


class ComplaintResolutionRepository(BaseRepository[ComplaintResolution]):
    """
    Complaint resolution repository with quality management.
    
    Provides resolution tracking, quality control, follow-up management,
    and performance analytics for complaint resolution.
    """

    def __init__(self, session: Session):
        """
        Initialize complaint resolution repository.
        
        Args:
            session: SQLAlchemy database session
        """
        super().__init__(ComplaintResolution, session)

    # ==================== CRUD Operations ====================

    def create_resolution(
        self,
        complaint_id: str,
        resolved_by: str,
        resolution_notes: str,
        resolution_attachments: Optional[List[str]] = None,
        actions_taken: Optional[List[str]] = None,
        materials_used: Optional[str] = None,
        actual_resolution_time: Optional[datetime] = None,
        follow_up_required: bool = False,
        follow_up_date: Optional[date] = None,
        follow_up_notes: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> ComplaintResolution:
        """
        Create a new resolution record.
        
        Args:
            complaint_id: Complaint identifier
            resolved_by: User resolving the complaint
            resolution_notes: Resolution description
            resolution_attachments: Proof attachments
            actions_taken: List of actions performed
            materials_used: Materials/parts used
            actual_resolution_time: Actual completion time
            follow_up_required: Follow-up flag
            follow_up_date: Scheduled follow-up date
            follow_up_notes: Follow-up instructions
            metadata: Additional metadata
            
        Returns:
            Created resolution instance
        """
        # Mark previous resolutions as not final
        self._mark_previous_as_non_final(complaint_id)
        
        now = datetime.now(timezone.utc)
        
        # Get complaint to calculate resolution time
        complaint_query = select(Complaint).where(Complaint.id == complaint_id)
        complaint_result = self.session.execute(complaint_query)
        complaint = complaint_result.scalar_one_or_none()
        
        time_to_resolve = None
        if complaint:
            time_delta = now - complaint.opened_at
            time_to_resolve = int(time_delta.total_seconds() / 3600)
        
        resolution = ComplaintResolution(
            complaint_id=complaint_id,
            resolved_by=resolved_by,
            resolved_at=now,
            resolution_notes=resolution_notes,
            resolution_attachments=resolution_attachments or [],
            actions_taken=actions_taken or [],
            materials_used=materials_used,
            actual_resolution_time=actual_resolution_time or now,
            time_to_resolve_hours=time_to_resolve,
            follow_up_required=follow_up_required,
            follow_up_date=follow_up_date,
            follow_up_notes=follow_up_notes,
            is_final_resolution=True,
            metadata=metadata or {},
        )
        
        return self.create(resolution)

    def perform_quality_check(
        self,
        resolution_id: str,
        quality_checked_by: str,
        quality_score: int,
        quality_notes: Optional[str] = None,
    ) -> Optional[ComplaintResolution]:
        """
        Perform quality check on resolution.
        
        Args:
            resolution_id: Resolution identifier
            quality_checked_by: User performing quality check
            quality_score: Quality score (1-10)
            quality_notes: Quality check notes
            
        Returns:
            Updated resolution or None
        """
        update_data = {
            "quality_checked": True,
            "quality_checked_by": quality_checked_by,
            "quality_checked_at": datetime.now(timezone.utc),
            "quality_score": quality_score,
            "quality_notes": quality_notes,
        }
        
        return self.update(resolution_id, update_data)

    def complete_follow_up(
        self,
        resolution_id: str,
    ) -> Optional[ComplaintResolution]:
        """
        Mark follow-up as completed.
        
        Args:
            resolution_id: Resolution identifier
            
        Returns:
            Updated resolution or None
        """
        update_data = {
            "follow_up_completed": True,
            "follow_up_completed_at": datetime.now(timezone.utc),
        }
        
        return self.update(resolution_id, update_data)

    def reopen_resolution(
        self,
        resolution_id: str,
        reopen_reason: str,
    ) -> Optional[ComplaintResolution]:
        """
        Mark resolution as reopened.
        
        Args:
            resolution_id: Resolution identifier
            reopen_reason: Reason for reopening
            
        Returns:
            Updated resolution or None
        """
        update_data = {
            "reopened": True,
            "reopened_at": datetime.now(timezone.utc),
            "reopen_reason": reopen_reason,
            "is_final_resolution": False,
        }
        
        return self.update(resolution_id, update_data)

    # ==================== Query Operations ====================

    def find_by_complaint(
        self,
        complaint_id: str,
        final_only: bool = False,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintResolution]:
        """
        Find all resolutions for a complaint.
        
        Args:
            complaint_id: Complaint identifier
            final_only: Only final resolution
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of resolutions
        """
        query = select(ComplaintResolution).where(
            ComplaintResolution.complaint_id == complaint_id
        )
        
        if final_only:
            query = query.where(ComplaintResolution.is_final_resolution == True)
        
        query = query.order_by(desc(ComplaintResolution.resolved_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_final_resolution(
        self,
        complaint_id: str,
    ) -> Optional[ComplaintResolution]:
        """
        Find final resolution for a complaint.
        
        Args:
            complaint_id: Complaint identifier
            
        Returns:
            Final resolution or None
        """
        query = select(ComplaintResolution).where(
            and_(
                ComplaintResolution.complaint_id == complaint_id,
                ComplaintResolution.is_final_resolution == True,
            )
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()

    def find_by_resolver(
        self,
        user_id: str,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
        reopened_only: bool = False,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintResolution]:
        """
        Find resolutions by a specific user.
        
        Args:
            user_id: User identifier
            date_from: Start date filter
            date_to: End date filter
            reopened_only: Only reopened resolutions
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of resolutions
        """
        query = select(ComplaintResolution).where(
            ComplaintResolution.resolved_by == user_id
        )
        
        if date_from:
            query = query.where(ComplaintResolution.resolved_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintResolution.resolved_at <= date_to)
        
        if reopened_only:
            query = query.where(ComplaintResolution.reopened == True)
        
        query = query.order_by(desc(ComplaintResolution.resolved_at))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_pending_follow_ups(
        self,
        hostel_id: Optional[str] = None,
        overdue_only: bool = False,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintResolution]:
        """
        Find resolutions with pending follow-ups.
        
        Args:
            hostel_id: Optional hostel filter
            overdue_only: Only overdue follow-ups
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of resolutions needing follow-up
        """
        query = select(ComplaintResolution).where(
            and_(
                ComplaintResolution.follow_up_required == True,
                ComplaintResolution.follow_up_completed == False,
            )
        )
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        if overdue_only:
            today = date.today()
            query = query.where(
                and_(
                    ComplaintResolution.follow_up_date.isnot(None),
                    ComplaintResolution.follow_up_date < today,
                )
            )
        
        query = query.order_by(ComplaintResolution.follow_up_date.asc())
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_pending_quality_checks(
        self,
        hostel_id: Optional[str] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintResolution]:
        """
        Find resolutions pending quality check.
        
        Args:
            hostel_id: Optional hostel filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of resolutions needing quality check
        """
        query = select(ComplaintResolution).where(
            and_(
                ComplaintResolution.quality_checked == False,
                ComplaintResolution.is_final_resolution == True,
            )
        )
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        query = query.order_by(ComplaintResolution.resolved_at.asc())
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    def find_by_quality_score(
        self,
        min_score: Optional[int] = None,
        max_score: Optional[int] = None,
        hostel_id: Optional[str] = None,
        skip: int = 0,
        limit: int = 100,
    ) -> List[ComplaintResolution]:
        """
        Find resolutions by quality score range.
        
        Args:
            min_score: Minimum quality score
            max_score: Maximum quality score
            hostel_id: Optional hostel filter
            skip: Number of records to skip
            limit: Maximum records to return
            
        Returns:
            List of resolutions in score range
        """
        query = select(ComplaintResolution).where(
            ComplaintResolution.quality_checked == True
        )
        
        if min_score is not None:
            query = query.where(ComplaintResolution.quality_score >= min_score)
        
        if max_score is not None:
            query = query.where(ComplaintResolution.quality_score <= max_score)
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        query = query.order_by(desc(ComplaintResolution.quality_score))
        query = query.offset(skip).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())

    # ==================== Analytics ====================

    def get_resolution_statistics(
        self,
        hostel_id: Optional[str] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, Any]:
        """
        Get comprehensive resolution statistics.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            Dictionary with resolution statistics
        """
        query = select(ComplaintResolution)
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(ComplaintResolution.resolved_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintResolution.resolved_at <= date_to)
        
        result = self.session.execute(query)
        resolutions = list(result.scalars().all())
        
        if not resolutions:
            return {
                "total_resolutions": 0,
                "average_resolution_time_hours": None,
                "reopened_count": 0,
                "reopen_rate": 0,
                "quality_checked_count": 0,
                "average_quality_score": None,
            }
        
        total = len(resolutions)
        reopened = len([r for r in resolutions if r.reopened])
        quality_checked = len([r for r in resolutions if r.quality_checked])
        
        # Average resolution time
        resolutions_with_time = [
            r for r in resolutions
            if r.time_to_resolve_hours is not None
        ]
        avg_time = (
            sum(r.time_to_resolve_hours for r in resolutions_with_time) / len(resolutions_with_time)
            if resolutions_with_time else None
        )
        
        # Average quality score
        quality_scored = [
            r for r in resolutions
            if r.quality_score is not None
        ]
        avg_quality = (
            sum(r.quality_score for r in quality_scored) / len(quality_scored)
            if quality_scored else None
        )
        
        # Follow-up metrics
        follow_up_required = len([r for r in resolutions if r.follow_up_required])
        follow_up_completed = len([r for r in resolutions if r.follow_up_completed])
        
        return {
            "total_resolutions": total,
            "average_resolution_time_hours": round(avg_time, 2) if avg_time else None,
            "median_resolution_time_hours": self._calculate_median_resolution_time(resolutions),
            "reopened_count": reopened,
            "reopen_rate": round(reopened / total * 100, 2) if total > 0 else 0,
            "quality_checked_count": quality_checked,
            "quality_check_rate": round(quality_checked / total * 100, 2) if total > 0 else 0,
            "average_quality_score": round(avg_quality, 2) if avg_quality else None,
            "follow_up_required_count": follow_up_required,
            "follow_up_completed_count": follow_up_completed,
            "follow_up_completion_rate": (
                round(follow_up_completed / follow_up_required * 100, 2)
                if follow_up_required > 0 else 0
            ),
        }

    def get_resolver_performance(
        self,
        user_id: str,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, Any]:
        """
        Get resolution performance metrics for a user.
        
        Args:
            user_id: User identifier
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            Dictionary with performance metrics
        """
        query = select(ComplaintResolution).where(
            ComplaintResolution.resolved_by == user_id
        )
        
        if date_from:
            query = query.where(ComplaintResolution.resolved_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintResolution.resolved_at <= date_to)
        
        result = self.session.execute(query)
        resolutions = list(result.scalars().all())
        
        if not resolutions:
            return {
                "user_id": user_id,
                "total_resolutions": 0,
                "average_resolution_time_hours": None,
                "reopen_rate": 0,
                "average_quality_score": None,
            }
        
        total = len(resolutions)
        reopened = len([r for r in resolutions if r.reopened])
        
        # Average resolution time
        resolutions_with_time = [
            r for r in resolutions
            if r.time_to_resolve_hours is not None
        ]
        avg_time = (
            sum(r.time_to_resolve_hours for r in resolutions_with_time) / len(resolutions_with_time)
            if resolutions_with_time else None
        )
        
        # Average quality score
        quality_scored = [
            r for r in resolutions
            if r.quality_score is not None
        ]
        avg_quality = (
            sum(r.quality_score for r in quality_scored) / len(quality_scored)
            if quality_scored else None
        )
        
        # Efficiency rating
        efficiency_rating = self._calculate_efficiency_rating(avg_time)
        
        return {
            "user_id": user_id,
            "total_resolutions": total,
            "average_resolution_time_hours": round(avg_time, 2) if avg_time else None,
            "reopen_count": reopened,
            "reopen_rate": round(reopened / total * 100, 2) if total > 0 else 0,
            "quality_checked_count": len(quality_scored),
            "average_quality_score": round(avg_quality, 2) if avg_quality else None,
            "efficiency_rating": efficiency_rating,
        }

    def get_quality_distribution(
        self,
        hostel_id: Optional[str] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[int, int]:
        """
        Get distribution of quality scores.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Start date filter
            date_to: End date filter
            
        Returns:
            Dictionary mapping quality scores to counts
        """
        query = select(ComplaintResolution).where(
            ComplaintResolution.quality_checked == True
        )
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(ComplaintResolution.resolved_at >= date_from)
        
        if date_to:
            query = query.where(ComplaintResolution.resolved_at <= date_to)
        
        result = self.session.execute(query)
        resolutions = list(result.scalars().all())
        
        distribution = {}
        for i in range(1, 11):
            distribution[i] = len([
                r for r in resolutions
                if r.quality_score == i
            ])
        
        return distribution

    def get_resolution_trends(
        self,
        hostel_id: Optional[str] = None,
        days: int = 30,
    ) -> List[Dict[str, Any]]:
        """
        Get resolution trends over time.
        
        Args:
            hostel_id: Optional hostel filter
            days: Number of days to analyze
            
        Returns:
            List of daily resolution metrics
        """
        end_date = datetime.now(timezone.utc)
        start_date = end_date - timedelta(days=days)
        
        query = (
            select(
                func.date(ComplaintResolution.resolved_at).label("date"),
                func.count(ComplaintResolution.id).label("count"),
                func.avg(ComplaintResolution.time_to_resolve_hours).label("avg_time"),
                func.avg(ComplaintResolution.quality_score).label("avg_quality"),
            )
            .where(ComplaintResolution.resolved_at >= start_date)
            .group_by(func.date(ComplaintResolution.resolved_at))
            .order_by(func.date(ComplaintResolution.resolved_at))
        )
        
        if hostel_id:
            query = query.join(Complaint).where(Complaint.hostel_id == hostel_id)
        
        result = self.session.execute(query)
        
        return [
            {
                "date": row.date.isoformat(),
                "total_resolutions": row.count,
                "average_resolution_time_hours": round(float(row.avg_time), 2) if row.avg_time else None,
                "average_quality_score": round(float(row.avg_quality), 2) if row.avg_quality else None,
            }
            for row in result
        ]

    # ==================== Helper Methods ====================

    def _mark_previous_as_non_final(self, complaint_id: str) -> None:
        """
        Mark all previous resolutions as non-final.
        
        Args:
            complaint_id: Complaint identifier
        """
        stmt = (
            ComplaintResolution.__table__.update()
            .where(
                and_(
                    ComplaintResolution.complaint_id == complaint_id,
                    ComplaintResolution.is_final_resolution == True,
                )
            )
            .values(is_final_resolution=False)
        )
        
        self.session.execute(stmt)

    def _calculate_median_resolution_time(
        self,
        resolutions: List[ComplaintResolution],
    ) -> Optional[float]:
        """
        Calculate median resolution time.
        
        Args:
            resolutions: List of resolution instances
            
        Returns:
            Median time in hours or None
        """
        times = [
            r.time_to_resolve_hours for r in resolutions
            if r.time_to_resolve_hours is not None
        ]
        
        if not times:
            return None
        
        times.sort()
        n = len(times)
        
        if n % 2 == 0:
            return (times[n//2 - 1] + times[n//2]) / 2.0
        else:
            return float(times[n//2])

    def _calculate_efficiency_rating(
        self,
        avg_resolution_time: Optional[float],
    ) -> Optional[str]:
        """
        Calculate efficiency rating based on resolution time.
        
        Args:
            avg_resolution_time: Average resolution time in hours
            
        Returns:
            Efficiency rating or None
        """
        if avg_resolution_time is None:
            return None
        
        if avg_resolution_time <= 6:
            return "EXCELLENT"
        elif avg_resolution_time <= 12:
            return "GOOD"
        elif avg_resolution_time <= 24:
            return "AVERAGE"
        else:
            return "POOR"




# --- File: C:\Hostel-Main\app\repositories\complaint\__init__.py ---
# --- File: __init__.py ---
"""
Complaint repositories package.

Provides comprehensive data access layer for complaint management
with advanced querying, analytics, and aggregation capabilities.

Repositories:
    - ComplaintRepository: Core complaint CRUD and queries
    - ComplaintAssignmentRepository: Assignment management
    - ComplaintCommentRepository: Comment and discussion management
    - ComplaintEscalationRepository: Escalation tracking
    - ComplaintFeedbackRepository: Feedback and satisfaction tracking
    - ComplaintResolutionRepository: Resolution management
    - ComplaintAnalyticSnapshotRepository: Pre-computed analytics
    - ComplaintCategoryMetricRepository: Category performance metrics
    - ComplaintStaffPerformanceRepository: Staff performance tracking
    - ComplaintAggregateRepository: Complex multi-entity queries

Example:
    from app.repositories.complaint import ComplaintRepository
    
    repo = ComplaintRepository(session)
    
    # Create complaint
    complaint = repo.create_complaint(
        hostel_id=hostel_id,
        raised_by=user_id,
        title="Water leakage",
        description="...",
        category=ComplaintCategory.MAINTENANCE,
        priority=Priority.HIGH,
    )
    
    # Search complaints
    complaints, total = repo.search_complaints(
        hostel_id=hostel_id,
        status=[ComplaintStatus.OPEN, ComplaintStatus.IN_PROGRESS],
        priority=[Priority.HIGH, Priority.CRITICAL],
        skip=0,
        limit=20,
    )
"""

from app.repositories.complaint.complaint_repository import ComplaintRepository
from app.repositories.complaint.complaint_assignment_repository import (
    ComplaintAssignmentRepository,
)
from app.repositories.complaint.complaint_comment_repository import (
    ComplaintCommentRepository,
)
from app.repositories.complaint.complaint_escalation_repository import (
    ComplaintEscalationRepository,
    AutoEscalationRuleRepository,
)
from app.repositories.complaint.complaint_feedback_repository import (
    ComplaintFeedbackRepository,
)
from app.repositories.complaint.complaint_resolution_repository import (
    ComplaintResolutionRepository,
)
from app.repositories.complaint.complaint_analytics_repository import (
    ComplaintAnalyticSnapshotRepository,
    ComplaintCategoryMetricRepository,
    ComplaintStaffPerformanceRepository,
)
from app.repositories.complaint.complaint_aggregate_repository import (
    ComplaintAggregateRepository,
)

__all__ = [
    # Core repositories
    "ComplaintRepository",
    "ComplaintAssignmentRepository",
    "ComplaintCommentRepository",
    "ComplaintEscalationRepository",
    "ComplaintFeedbackRepository",
    "ComplaintResolutionRepository",
    # Analytics repositories
    "ComplaintAnalyticSnapshotRepository",
    "ComplaintCategoryMetricRepository",
    "ComplaintStaffPerformanceRepository",
    # Specialized repositories
    "AutoEscalationRuleRepository",
    "ComplaintAggregateRepository",
]
