### Combined Content from Folder: C:\Hostel-Main\app\repositories\fee_structure ###



# ===== Folder: C:\Hostel-Main\app\repositories\fee_structure =====

# --- File: C:\Hostel-Main\app\repositories\fee_structure\charge_component_repository.py ---
# --- File: C:\Hostel-Main\app\repositories\fee_structure\charge_component_repository.py ---
"""
Charge Component Repository

Manages charge components, charge rules, and discount configurations
with advanced querying, validation, business logic, and analytics capabilities.
"""

from datetime import date as Date, datetime
from decimal import Decimal
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID
import json

from sqlalchemy import and_, or_, func, case, select, desc, asc
from sqlalchemy.orm import Session, joinedload, selectinload

from app.models.fee_structure.charge_component import (
    ChargeComponent,
    ChargeRule,
    DiscountConfiguration,
)
from app.repositories.base.base_repository import BaseRepository
from app.core.exceptions import (
    NotFoundException,
    ValidationException,
    ConflictException,
)


class ChargeComponentRepository(BaseRepository[ChargeComponent]):
    """
    Charge Component Repository
    
    Manages individual charge components within fee structures,
    including component lifecycle, rules, calculations, and analytics.
    """
    
    def __init__(self, session: Session):
        super().__init__(ChargeComponent, session)
    
    # ============================================================
    # Core CRUD Operations
    # ============================================================
    
    def create_charge_component(
        self,
        fee_structure_id: UUID,
        component_name: str,
        component_type: str,
        amount: Decimal,
        audit_context: Dict[str, Any],
        **kwargs
    ) -> ChargeComponent:
        """
        Create a new charge component with validation.
        
        Args:
            fee_structure_id: Parent fee structure ID
            component_name: Name of the component
            component_type: Type of charge (rent, deposit, mess, etc.)
            amount: Component amount
            audit_context: Audit information (user_id, ip_address, etc.)
            **kwargs: Additional component attributes
            
        Returns:
            Created ChargeComponent instance
            
        Raises:
            ValidationException: If validation fails
            ConflictException: If duplicate component name exists
        """
        # Validate component data
        self._validate_component(component_type, amount, kwargs)
        
        # Check for duplicate component names within same fee structure
        self._check_duplicate_component(fee_structure_id, component_name, None)
        
        # Set defaults
        component_data = {
            'fee_structure_id': fee_structure_id,
            'component_name': component_name,
            'component_type': component_type,
            'amount': amount,
            'is_mandatory': kwargs.pop('is_mandatory', True),
            'is_refundable': kwargs.pop('is_refundable', False),
            'is_recurring': kwargs.pop('is_recurring', True),
            'calculation_method': kwargs.pop('calculation_method', 'fixed'),
            'is_taxable': kwargs.pop('is_taxable', False),
            'tax_percentage': kwargs.pop('tax_percentage', Decimal('0.00')),
            'display_order': kwargs.pop('display_order', 0),
            'is_visible_to_student': kwargs.pop('is_visible_to_student', True),
            'proration_allowed': kwargs.pop('proration_allowed', False),
        }
        
        # Add remaining kwargs
        component_data.update(kwargs)
        
        component = ChargeComponent(**component_data)
        
        self._apply_audit(component, audit_context)
        self.session.add(component)
        self.session.flush()
        
        return component
    
    def update_charge_component(
        self,
        component_id: UUID,
        update_data: Dict[str, Any],
        audit_context: Dict[str, Any]
    ) -> ChargeComponent:
        """
        Update an existing charge component.
        
        Args:
            component_id: Component identifier
            update_data: Fields to update
            audit_context: Audit information
            
        Returns:
            Updated ChargeComponent instance
            
        Raises:
            NotFoundException: If component not found
            ValidationException: If validation fails
            ConflictException: If duplicate name
        """
        component = self.find_by_id(component_id)
        if not component:
            raise NotFoundException(f"Charge component {component_id} not found")
        
        # Validate updates
        if 'amount' in update_data or 'component_type' in update_data:
            self._validate_component(
                update_data.get('component_type', component.component_type),
                update_data.get('amount', component.amount),
                update_data
            )
        
        # Check for duplicate names if name is being changed
        if 'component_name' in update_data and update_data['component_name'] != component.component_name:
            self._check_duplicate_component(
                component.fee_structure_id,
                update_data['component_name'],
                component_id
            )
        
        # Apply updates
        for key, value in update_data.items():
            if hasattr(component, key) and key not in ['id', 'created_at', 'created_by']:
                setattr(component, key, value)
        
        self._apply_audit(component, audit_context, is_update=True)
        self.session.flush()
        
        return component
    
    def delete_charge_component(
        self,
        component_id: UUID,
        audit_context: Dict[str, Any],
        hard_delete: bool = False
    ) -> bool:
        """
        Delete a charge component (soft or hard delete).
        
        Args:
            component_id: Component identifier
            audit_context: Audit information
            hard_delete: If True, permanently delete; otherwise soft delete
            
        Returns:
            True if deleted successfully
            
        Raises:
            NotFoundException: If component not found
        """
        component = self.find_by_id(component_id)
        if not component:
            raise NotFoundException(f"Charge component {component_id} not found")
        
        if hard_delete:
            self.session.delete(component)
        else:
            component.deleted_at = datetime.utcnow()
            component.deleted_by = audit_context.get('user_id')
        
        self.session.flush()
        return True
    
    # ============================================================
    # Query Operations - Basic
    # ============================================================
    
    def find_by_fee_structure(
        self,
        fee_structure_id: UUID,
        component_type: Optional[str] = None,
        is_mandatory: Optional[bool] = None,
        is_recurring: Optional[bool] = None,
        include_deleted: bool = False,
        order_by_display: bool = True
    ) -> List[ChargeComponent]:
        """
        Find all charge components for a fee structure.
        
        Args:
            fee_structure_id: Fee structure identifier
            component_type: Optional component type filter
            is_mandatory: Optional mandatory filter
            is_recurring: Optional recurring filter
            include_deleted: Include soft-deleted components
            order_by_display: Order by display_order
            
        Returns:
            List of ChargeComponent instances
        """
        query = self.session.query(ChargeComponent).filter(
            ChargeComponent.fee_structure_id == fee_structure_id
        )
        
        if not include_deleted:
            query = query.filter(ChargeComponent.deleted_at.is_(None))
        
        if component_type:
            query = query.filter(ChargeComponent.component_type == component_type)
        
        if is_mandatory is not None:
            query = query.filter(ChargeComponent.is_mandatory == is_mandatory)
        
        if is_recurring is not None:
            query = query.filter(ChargeComponent.is_recurring == is_recurring)
        
        if order_by_display:
            query = query.order_by(ChargeComponent.display_order.asc())
        
        return query.all()
    
    def find_by_type(
        self,
        component_type: str,
        fee_structure_ids: Optional[List[UUID]] = None,
        as_of_date: Optional[Date] = None,
        is_active_only: bool = True
    ) -> List[ChargeComponent]:
        """
        Find charge components by type across fee structures.
        
        Args:
            component_type: Component type to search
            fee_structure_ids: Optional list of fee structure IDs
            as_of_date: Find components applicable as of this date
            is_active_only: Only return active components
            
        Returns:
            List of ChargeComponent instances
        """
        query = self.session.query(ChargeComponent).filter(
            ChargeComponent.component_type == component_type,
            ChargeComponent.deleted_at.is_(None)
        )
        
        if fee_structure_ids:
            query = query.filter(ChargeComponent.fee_structure_id.in_(fee_structure_ids))
        
        if as_of_date:
            query = query.filter(
                or_(
                    ChargeComponent.applies_from_date.is_(None),
                    ChargeComponent.applies_from_date <= as_of_date
                ),
                or_(
                    ChargeComponent.applies_to_date.is_(None),
                    ChargeComponent.applies_to_date >= as_of_date
                )
            )
        
        return query.order_by(ChargeComponent.component_name).all()
    
    def find_by_id_with_relations(
        self,
        component_id: UUID
    ) -> Optional[ChargeComponent]:
        """
        Get charge component with all related entities loaded.
        
        Args:
            component_id: Component identifier
            
        Returns:
            ChargeComponent with relations or None
        """
        return self.session.query(ChargeComponent).options(
            selectinload(ChargeComponent.charge_rules),
            joinedload(ChargeComponent.fee_structure)
        ).filter(
            ChargeComponent.id == component_id,
            ChargeComponent.deleted_at.is_(None)
        ).first()
    
    def get_component_with_rules(
        self,
        component_id: UUID,
        active_rules_only: bool = True
    ) -> Optional[ChargeComponent]:
        """
        Get charge component with associated rules.
        
        Args:
            component_id: Component identifier
            active_rules_only: Only load active rules
            
        Returns:
            ChargeComponent with rules loaded or None
        """
        query = self.session.query(ChargeComponent).options(
            selectinload(ChargeComponent.charge_rules)
        ).filter(
            ChargeComponent.id == component_id,
            ChargeComponent.deleted_at.is_(None)
        )
        
        component = query.first()
        
        if component and active_rules_only:
            component.charge_rules = [r for r in component.charge_rules if r.is_active]
        
        return component
    
    # ============================================================
    # Query Operations - Advanced
    # ============================================================
    
    def find_applicable_components(
        self,
        fee_structure_id: UUID,
        room_types: Optional[List[str]] = None,
        check_date: Optional[Date] = None,
        include_optional: bool = True
    ) -> List[ChargeComponent]:
        """
        Find components applicable to specific room types and date.
        
        Args:
            fee_structure_id: Fee structure identifier
            room_types: List of room types to check
            check_date: Date to check applicability
            include_optional: Include non-mandatory components
            
        Returns:
            List of applicable ChargeComponent instances
        """
        check_date = check_date or Date.today()
        
        query = self.session.query(ChargeComponent).filter(
            ChargeComponent.fee_structure_id == fee_structure_id,
            ChargeComponent.deleted_at.is_(None),
            or_(
                ChargeComponent.applies_from_date.is_(None),
                ChargeComponent.applies_from_date <= check_date
            ),
            or_(
                ChargeComponent.applies_to_date.is_(None),
                ChargeComponent.applies_to_date >= check_date
            )
        )
        
        # Filter by mandatory if specified
        if not include_optional:
            query = query.filter(ChargeComponent.is_mandatory == True)
        
        # Filter by room types
        if room_types:
            conditions = [ChargeComponent.applies_to_room_types.is_(None)]
            for room_type in room_types:
                conditions.append(ChargeComponent.applies_to_room_types.like(f'%{room_type}%'))
            query = query.filter(or_(*conditions))
        
        return query.order_by(ChargeComponent.display_order).all()
    
    def find_taxable_components(
        self,
        fee_structure_id: UUID,
        min_tax_rate: Optional[Decimal] = None
    ) -> List[ChargeComponent]:
        """
        Find all taxable components for a fee structure.
        
        Args:
            fee_structure_id: Fee structure identifier
            min_tax_rate: Optional minimum tax rate filter
            
        Returns:
            List of taxable ChargeComponent instances
        """
        query = self.session.query(ChargeComponent).filter(
            ChargeComponent.fee_structure_id == fee_structure_id,
            ChargeComponent.is_taxable == True,
            ChargeComponent.deleted_at.is_(None)
        )
        
        if min_tax_rate:
            query = query.filter(ChargeComponent.tax_percentage >= min_tax_rate)
        
        return query.order_by(ChargeComponent.display_order).all()
    
    def find_recurring_components(
        self,
        fee_structure_id: UUID,
        visible_only: bool = True
    ) -> List[ChargeComponent]:
        """
        Find all recurring charge components.
        
        Args:
            fee_structure_id: Fee structure identifier
            visible_only: Only return components visible to students
            
        Returns:
            List of recurring ChargeComponent instances
        """
        query = self.session.query(ChargeComponent).filter(
            ChargeComponent.fee_structure_id == fee_structure_id,
            ChargeComponent.is_recurring == True,
            ChargeComponent.deleted_at.is_(None)
        )
        
        if visible_only:
            query = query.filter(ChargeComponent.is_visible_to_student == True)
        
        return query.order_by(ChargeComponent.display_order).all()
    
    def find_refundable_components(
        self,
        fee_structure_id: UUID,
        min_amount: Optional[Decimal] = None
    ) -> List[ChargeComponent]:
        """
        Find all refundable charge components.
        
        Args:
            fee_structure_id: Fee structure identifier
            min_amount: Optional minimum amount filter
            
        Returns:
            List of refundable ChargeComponent instances
        """
        query = self.session.query(ChargeComponent).filter(
            ChargeComponent.fee_structure_id == fee_structure_id,
            ChargeComponent.is_refundable == True,
            ChargeComponent.deleted_at.is_(None)
        )
        
        if min_amount:
            query = query.filter(ChargeComponent.amount >= min_amount)
        
        return query.order_by(ChargeComponent.display_order).all()
    
    def find_one_time_components(
        self,
        fee_structure_id: UUID
    ) -> List[ChargeComponent]:
        """
        Find all one-time (non-recurring) charge components.
        
        Args:
            fee_structure_id: Fee structure identifier
            
        Returns:
            List of one-time ChargeComponent instances
        """
        return self.session.query(ChargeComponent).filter(
            ChargeComponent.fee_structure_id == fee_structure_id,
            ChargeComponent.is_recurring == False,
            ChargeComponent.deleted_at.is_(None)
        ).order_by(ChargeComponent.display_order).all()
    
    def find_variable_components(
        self,
        fee_structure_id: UUID
    ) -> List[ChargeComponent]:
        """
        Find components with variable calculation method.
        
        Args:
            fee_structure_id: Fee structure identifier
            
        Returns:
            List of variable ChargeComponent instances
        """
        return self.session.query(ChargeComponent).filter(
            ChargeComponent.fee_structure_id == fee_structure_id,
            ChargeComponent.calculation_method.in_(['variable', 'percentage', 'tiered', 'actual']),
            ChargeComponent.deleted_at.is_(None)
        ).order_by(ChargeComponent.display_order).all()
    
    def find_proratable_components(
        self,
        fee_structure_id: UUID
    ) -> List[ChargeComponent]:
        """
        Find components that allow proration.
        
        Args:
            fee_structure_id: Fee structure identifier
            
        Returns:
            List of proratable ChargeComponent instances
        """
        return self.session.query(ChargeComponent).filter(
            ChargeComponent.fee_structure_id == fee_structure_id,
            ChargeComponent.proration_allowed == True,
            ChargeComponent.deleted_at.is_(None)
        ).order_by(ChargeComponent.display_order).all()
    
    def find_by_calculation_method(
        self,
        calculation_method: str,
        fee_structure_ids: Optional[List[UUID]] = None
    ) -> List[ChargeComponent]:
        """
        Find components by calculation method.
        
        Args:
            calculation_method: Calculation method to filter
            fee_structure_ids: Optional fee structure filter
            
        Returns:
            List of ChargeComponent instances
        """
        query = self.session.query(ChargeComponent).filter(
            ChargeComponent.calculation_method == calculation_method,
            ChargeComponent.deleted_at.is_(None)
        )
        
        if fee_structure_ids:
            query = query.filter(ChargeComponent.fee_structure_id.in_(fee_structure_ids))
        
        return query.all()
    
    def find_expiring_components(
        self,
        days_ahead: int = 30
    ) -> List[ChargeComponent]:
        """
        Find components expiring within specified days.
        
        Args:
            days_ahead: Number of days to look ahead
            
        Returns:
            List of expiring ChargeComponent instances
        """
        today = Date.today()
        future_date = Date.fromordinal(today.toordinal() + days_ahead)
        
        return self.session.query(ChargeComponent).filter(
            ChargeComponent.applies_to_date.isnot(None),
            ChargeComponent.applies_to_date > today,
            ChargeComponent.applies_to_date <= future_date,
            ChargeComponent.deleted_at.is_(None)
        ).order_by(ChargeComponent.applies_to_date).all()
    
    # ============================================================
    # Calculation and Analytics
    # ============================================================
    
    def calculate_total_components(
        self,
        fee_structure_id: UUID,
        include_tax: bool = True,
        component_types: Optional[List[str]] = None,
        mandatory_only: bool = False,
        recurring_only: bool = False
    ) -> Decimal:
        """
        Calculate total of components with various filters.
        
        Args:
            fee_structure_id: Fee structure identifier
            include_tax: Whether to include tax in calculation
            component_types: Optional list of component types to include
            mandatory_only: Only include mandatory components
            recurring_only: Only include recurring components
            
        Returns:
            Total amount as Decimal
        """
        query = self.session.query(
            func.sum(ChargeComponent.amount).label('total_amount'),
            func.sum(ChargeComponent.amount * ChargeComponent.tax_percentage / 100).label('total_tax')
        ).filter(
            ChargeComponent.fee_structure_id == fee_structure_id,
            ChargeComponent.deleted_at.is_(None)
        )
        
        if component_types:
            query = query.filter(ChargeComponent.component_type.in_(component_types))
        
        if mandatory_only:
            query = query.filter(ChargeComponent.is_mandatory == True)
        
        if recurring_only:
            query = query.filter(ChargeComponent.is_recurring == True)
        
        result = query.first()
        
        total = result.total_amount or Decimal('0.00')
        
        if include_tax:
            total += (result.total_tax or Decimal('0.00'))
        
        return total.quantize(Decimal('0.01'))
    
    def calculate_monthly_recurring_total(
        self,
        fee_structure_id: UUID,
        include_tax: bool = True
    ) -> Decimal:
        """
        Calculate total monthly recurring charges.
        
        Args:
            fee_structure_id: Fee structure identifier
            include_tax: Include tax in calculation
            
        Returns:
            Monthly recurring total as Decimal
        """
        return self.calculate_total_components(
            fee_structure_id=fee_structure_id,
            include_tax=include_tax,
            recurring_only=True
        )
    
    def calculate_one_time_total(
        self,
        fee_structure_id: UUID,
        include_tax: bool = True
    ) -> Decimal:
        """
        Calculate total one-time charges.
        
        Args:
            fee_structure_id: Fee structure identifier
            include_tax: Include tax in calculation
            
        Returns:
            One-time total as Decimal
        """
        query = self.session.query(
            func.sum(ChargeComponent.amount).label('total_amount'),
            func.sum(ChargeComponent.amount * ChargeComponent.tax_percentage / 100).label('total_tax')
        ).filter(
            ChargeComponent.fee_structure_id == fee_structure_id,
            ChargeComponent.is_recurring == False,
            ChargeComponent.deleted_at.is_(None)
        )
        
        result = query.first()
        
        total = result.total_amount or Decimal('0.00')
        
        if include_tax:
            total += (result.total_tax or Decimal('0.00'))
        
        return total.quantize(Decimal('0.01'))
    
    def calculate_tax_breakdown(
        self,
        fee_structure_id: UUID
    ) -> Dict[str, Any]:
        """
        Calculate detailed tax breakdown.
        
        Args:
            fee_structure_id: Fee structure identifier
            
        Returns:
            Dictionary with tax breakdown
        """
        components = self.find_taxable_components(fee_structure_id)
        
        tax_breakdown = {
            'total_taxable_components': len(components),
            'total_base_amount': Decimal('0.00'),
            'total_tax_amount': Decimal('0.00'),
            'by_tax_rate': {},
            'by_component_type': {}
        }
        
        for component in components:
            base_amount = component.amount
            tax_amount = component.tax_amount
            tax_rate = str(component.tax_percentage)
            comp_type = component.component_type
            
            # Accumulate totals
            tax_breakdown['total_base_amount'] += base_amount
            tax_breakdown['total_tax_amount'] += tax_amount
            
            # Group by tax rate
            if tax_rate not in tax_breakdown['by_tax_rate']:
                tax_breakdown['by_tax_rate'][tax_rate] = {
                    'count': 0,
                    'base_amount': Decimal('0.00'),
                    'tax_amount': Decimal('0.00')
                }
            tax_breakdown['by_tax_rate'][tax_rate]['count'] += 1
            tax_breakdown['by_tax_rate'][tax_rate]['base_amount'] += base_amount
            tax_breakdown['by_tax_rate'][tax_rate]['tax_amount'] += tax_amount
            
            # Group by component type
            if comp_type not in tax_breakdown['by_component_type']:
                tax_breakdown['by_component_type'][comp_type] = {
                    'count': 0,
                    'base_amount': Decimal('0.00'),
                    'tax_amount': Decimal('0.00')
                }
            tax_breakdown['by_component_type'][comp_type]['count'] += 1
            tax_breakdown['by_component_type'][comp_type]['base_amount'] += base_amount
            tax_breakdown['by_component_type'][comp_type]['tax_amount'] += tax_amount
        
        # Convert Decimals to float for JSON serialization
        tax_breakdown['total_base_amount'] = float(tax_breakdown['total_base_amount'])
        tax_breakdown['total_tax_amount'] = float(tax_breakdown['total_tax_amount'])
        
        for rate_data in tax_breakdown['by_tax_rate'].values():
            rate_data['base_amount'] = float(rate_data['base_amount'])
            rate_data['tax_amount'] = float(rate_data['tax_amount'])
        
        for type_data in tax_breakdown['by_component_type'].values():
            type_data['base_amount'] = float(type_data['base_amount'])
            type_data['tax_amount'] = float(type_data['tax_amount'])
        
        return tax_breakdown
    
    def get_component_breakdown(
        self,
        fee_structure_id: UUID,
        include_hidden: bool = False
    ) -> Dict[str, Any]:
        """
        Get detailed breakdown of all components.
        
        Args:
            fee_structure_id: Fee structure identifier
            include_hidden: Include components not visible to students
            
        Returns:
            Dictionary with component breakdown
        """
        query = self.session.query(ChargeComponent).filter(
            ChargeComponent.fee_structure_id == fee_structure_id,
            ChargeComponent.deleted_at.is_(None)
        )
        
        if not include_hidden:
            query = query.filter(ChargeComponent.is_visible_to_student == True)
        
        components = query.all()
        
        breakdown = {
            'total_components': len(components),
            'mandatory_count': sum(1 for c in components if c.is_mandatory),
            'optional_count': sum(1 for c in components if not c.is_mandatory),
            'recurring_count': sum(1 for c in components if c.is_recurring),
            'one_time_count': sum(1 for c in components if not c.is_recurring),
            'taxable_count': sum(1 for c in components if c.is_taxable),
            'refundable_count': sum(1 for c in components if c.is_refundable),
            'proratable_count': sum(1 for c in components if c.proration_allowed),
            'total_amount': sum(c.amount for c in components),
            'total_tax': sum(c.tax_amount for c in components),
            'total_with_tax': sum(c.total_amount_with_tax for c in components),
            'by_type': {},
            'by_calculation_method': {},
            'by_mandatory_status': {
                'mandatory': {'count': 0, 'total_amount': Decimal('0.00')},
                'optional': {'count': 0, 'total_amount': Decimal('0.00')}
            },
            'by_recurring_status': {
                'recurring': {'count': 0, 'total_amount': Decimal('0.00')},
                'one_time': {'count': 0, 'total_amount': Decimal('0.00')}
            }
        }
        
        # Group by type
        for component in components:
            comp_type = component.component_type
            if comp_type not in breakdown['by_type']:
                breakdown['by_type'][comp_type] = {
                    'count': 0,
                    'total_amount': Decimal('0.00'),
                    'taxable_count': 0,
                    'mandatory_count': 0
                }
            breakdown['by_type'][comp_type]['count'] += 1
            breakdown['by_type'][comp_type]['total_amount'] += component.amount
            if component.is_taxable:
                breakdown['by_type'][comp_type]['taxable_count'] += 1
            if component.is_mandatory:
                breakdown['by_type'][comp_type]['mandatory_count'] += 1
        
        # Group by calculation method
        for component in components:
            method = component.calculation_method
            if method not in breakdown['by_calculation_method']:
                breakdown['by_calculation_method'][method] = {
                    'count': 0,
                    'total_amount': Decimal('0.00')
                }
            breakdown['by_calculation_method'][method]['count'] += 1
            breakdown['by_calculation_method'][method]['total_amount'] += component.amount
        
        # Group by mandatory status
        for component in components:
            key = 'mandatory' if component.is_mandatory else 'optional'
            breakdown['by_mandatory_status'][key]['count'] += 1
            breakdown['by_mandatory_status'][key]['total_amount'] += component.amount
        
        # Group by recurring status
        for component in components:
            key = 'recurring' if component.is_recurring else 'one_time'
            breakdown['by_recurring_status'][key]['count'] += 1
            breakdown['by_recurring_status'][key]['total_amount'] += component.amount
        
        # Convert Decimals to float
        breakdown['total_amount'] = float(breakdown['total_amount'])
        breakdown['total_tax'] = float(breakdown['total_tax'])
        breakdown['total_with_tax'] = float(breakdown['total_with_tax'])
        
        for type_data in breakdown['by_type'].values():
            type_data['total_amount'] = float(type_data['total_amount'])
        
        for method_data in breakdown['by_calculation_method'].values():
            method_data['total_amount'] = float(method_data['total_amount'])
        
        for status_data in breakdown['by_mandatory_status'].values():
            status_data['total_amount'] = float(status_data['total_amount'])
        
        for status_data in breakdown['by_recurring_status'].values():
            status_data['total_amount'] = float(status_data['total_amount'])
        
        return breakdown
    
    def get_component_statistics(
        self,
        component_type: str,
        fee_structure_ids: Optional[List[UUID]] = None
    ) -> Dict[str, Any]:
        """
        Get statistical information about components of a specific type.
        
        Args:
            component_type: Component type to analyze
            fee_structure_ids: Optional list of fee structure IDs
            
        Returns:
            Dictionary with statistical data
        """
        query = self.session.query(
            func.count(ChargeComponent.id).label('count'),
            func.avg(ChargeComponent.amount).label('avg_amount'),
            func.min(ChargeComponent.amount).label('min_amount'),
            func.max(ChargeComponent.amount).label('max_amount'),
            func.sum(ChargeComponent.amount).label('total_amount'),
            func.avg(ChargeComponent.tax_percentage).label('avg_tax_rate'),
            func.sum(case(
                (ChargeComponent.is_mandatory == True, 1),
                else_=0
            )).label('mandatory_count'),
            func.sum(case(
                (ChargeComponent.is_recurring == True, 1),
                else_=0
            )).label('recurring_count'),
            func.sum(case(
                (ChargeComponent.is_taxable == True, 1),
                else_=0
            )).label('taxable_count')
        ).filter(
            ChargeComponent.component_type == component_type,
            ChargeComponent.deleted_at.is_(None)
        )
        
        if fee_structure_ids:
            query = query.filter(ChargeComponent.fee_structure_id.in_(fee_structure_ids))
        
        result = query.first()
        
        total_count = result.count or 0
        
        return {
            'component_type': component_type,
            'count': total_count,
            'average_amount': float(result.avg_amount or 0),
            'minimum_amount': float(result.min_amount or 0),
            'maximum_amount': float(result.max_amount or 0),
            'total_amount': float(result.total_amount or 0),
            'average_tax_rate': float(result.avg_tax_rate or 0),
            'mandatory_count': result.mandatory_count or 0,
            'mandatory_percentage': (result.mandatory_count / total_count * 100) if total_count else 0,
            'recurring_count': result.recurring_count or 0,
            'recurring_percentage': (result.recurring_count / total_count * 100) if total_count else 0,
            'taxable_count': result.taxable_count or 0,
            'taxable_percentage': (result.taxable_count / total_count * 100) if total_count else 0
        }
    
    def compare_component_costs(
        self,
        component_type: str,
        fee_structure_ids: List[UUID]
    ) -> List[Dict[str, Any]]:
        """
        Compare costs of same component type across fee structures.
        
        Args:
            component_type: Component type to compare
            fee_structure_ids: Fee structure IDs to compare
            
        Returns:
            List of comparison data
        """
        results = self.session.query(
            ChargeComponent.fee_structure_id,
            ChargeComponent.amount,
            ChargeComponent.tax_percentage,
            ChargeComponent.is_mandatory,
            ChargeComponent.is_recurring
        ).filter(
            ChargeComponent.component_type == component_type,
            ChargeComponent.fee_structure_id.in_(fee_structure_ids),
            ChargeComponent.deleted_at.is_(None)
        ).all()
        
        return [
            {
                'fee_structure_id': str(r.fee_structure_id),
                'amount': float(r.amount),
                'tax_percentage': float(r.tax_percentage),
                'amount_with_tax': float(r.amount * (1 + r.tax_percentage / 100)),
                'is_mandatory': r.is_mandatory,
                'is_recurring': r.is_recurring
            }
            for r in results
        ]
    
    # ============================================================
    # Bulk Operations
    # ============================================================
    
    def bulk_create_components(
        self,
        fee_structure_id: UUID,
        components_data: List[Dict[str, Any]],
        audit_context: Dict[str, Any]
    ) -> List[ChargeComponent]:
        """
        Create multiple charge components in bulk.
        
        Args:
            fee_structure_id: Parent fee structure ID
            components_data: List of component data dictionaries
            audit_context: Audit information
            
        Returns:
            List of created ChargeComponent instances
            
        Raises:
            ValidationException: If any component fails validation
        """
        created_components = []
        
        for idx, comp_data in enumerate(components_data):
            # Validate each component
            self._validate_component(
                comp_data.get('component_type'),
                comp_data.get('amount'),
                comp_data
            )
            
            component = ChargeComponent(
                fee_structure_id=fee_structure_id,
                component_name=comp_data['component_name'],
                component_type=comp_data['component_type'],
                amount=comp_data['amount'],
                display_order=comp_data.get('display_order', idx),
                is_mandatory=comp_data.get('is_mandatory', True),
                is_refundable=comp_data.get('is_refundable', False),
                is_recurring=comp_data.get('is_recurring', True),
                calculation_method=comp_data.get('calculation_method', 'fixed'),
                is_taxable=comp_data.get('is_taxable', False),
                tax_percentage=comp_data.get('tax_percentage', Decimal('0.00')),
                is_visible_to_student=comp_data.get('is_visible_to_student', True),
                proration_allowed=comp_data.get('proration_allowed', False),
                description=comp_data.get('description'),
                calculation_basis=comp_data.get('calculation_basis'),
                applies_to_room_types=comp_data.get('applies_to_room_types'),
                applies_from_date=comp_data.get('applies_from_date'),
                applies_to_date=comp_data.get('applies_to_date')
            )
            
            self._apply_audit(component, audit_context)
            created_components.append(component)
        
        self.session.bulk_save_objects(created_components, return_defaults=True)
        self.session.flush()
        
        return created_components
    
    def bulk_update_amounts(
        self,
        component_ids: List[UUID],
        amount_updates: Dict[UUID, Decimal],
        audit_context: Dict[str, Any]
    ) -> int:
        """
        Bulk update amounts for multiple components.
        
        Args:
            component_ids: List of component IDs
            amount_updates: Dictionary mapping component_id to new amount
            audit_context: Audit information
            
        Returns:
            Number of components updated
        """
        updated = 0
        
        for component_id, new_amount in amount_updates.items():
            if component_id in component_ids:
                result = self.session.query(ChargeComponent).filter(
                    ChargeComponent.id == component_id,
                    ChargeComponent.deleted_at.is_(None)
                ).update(
                    {
                        'amount': new_amount,
                        'updated_at': datetime.utcnow(),
                        'updated_by': audit_context.get('user_id')
                    },
                    synchronize_session=False
                )
                updated += result
        
        self.session.flush()
        return updated
    
    def bulk_update_display_order(
        self,
        component_orders: Dict[UUID, int],
        audit_context: Dict[str, Any]
    ) -> int:
        """
        Bulk update display order for components.
        
        Args:
            component_orders: Dictionary mapping component_id to display_order
            audit_context: Audit information
            
        Returns:
            Number of components updated
        """
        updated = 0
        
        for component_id, display_order in component_orders.items():
            result = self.session.query(ChargeComponent).filter(
                ChargeComponent.id == component_id,
                ChargeComponent.deleted_at.is_(None)
            ).update(
                {
                    'display_order': display_order,
                    'updated_at': datetime.utcnow(),
                    'updated_by': audit_context.get('user_id')
                },
                synchronize_session=False
            )
            updated += result
        
        self.session.flush()
        return updated
    
    def bulk_update_tax_rates(
        self,
        component_ids: List[UUID],
        tax_percentage: Decimal,
        audit_context: Dict[str, Any]
    ) -> int:
        """
        Bulk update tax rates for multiple components.
        
        Args:
            component_ids: List of component IDs
            tax_percentage: New tax percentage
            audit_context: Audit information
            
        Returns:
            Number of components updated
        """
        if tax_percentage < Decimal('0') or tax_percentage > Decimal('100'):
            raise ValidationException("Tax percentage must be between 0 and 100")
        
        updated = self.session.query(ChargeComponent).filter(
            ChargeComponent.id.in_(component_ids),
            ChargeComponent.deleted_at.is_(None)
        ).update(
            {
                'tax_percentage': tax_percentage,
                'is_taxable': tax_percentage > Decimal('0'),
                'updated_at': datetime.utcnow(),
                'updated_by': audit_context.get('user_id')
            },
            synchronize_session=False
        )
        
        self.session.flush()
        return updated
    
    def clone_components_to_structure(
        self,
        source_fee_structure_id: UUID,
        target_fee_structure_id: UUID,
        audit_context: Dict[str, Any],
        include_rules: bool = False
    ) -> List[ChargeComponent]:
        """
        Clone all components from one fee structure to another.
        
        Args:
            source_fee_structure_id: Source fee structure ID
            target_fee_structure_id: Target fee structure ID
            audit_context: Audit information
            include_rules: Also clone associated charge rules
            
        Returns:
            List of cloned ChargeComponent instances
        """
        source_components = self.find_by_fee_structure(source_fee_structure_id)
        
        cloned_components = []
        for source in source_components:
            cloned = ChargeComponent(
                fee_structure_id=target_fee_structure_id,
                component_name=source.component_name,
                component_type=source.component_type,
                amount=source.amount,
                is_mandatory=source.is_mandatory,
                is_refundable=source.is_refundable,
                is_recurring=source.is_recurring,
                calculation_method=source.calculation_method,
                calculation_basis=source.calculation_basis,
                proration_allowed=source.proration_allowed,
                is_taxable=source.is_taxable,
                tax_percentage=source.tax_percentage,
                description=source.description,
                display_order=source.display_order,
                is_visible_to_student=source.is_visible_to_student,
                applies_to_room_types=source.applies_to_room_types,
                applies_from_date=source.applies_from_date,
                applies_to_date=source.applies_to_date
            )
            self._apply_audit(cloned, audit_context)
            cloned_components.append(cloned)
        
        self.session.bulk_save_objects(cloned_components, return_defaults=True)
        self.session.flush()
        
        # Clone rules if requested
        if include_rules:
            for original, cloned in zip(source_components, cloned_components):
                if original.charge_rules:
                    for rule in original.charge_rules:
                        cloned_rule = ChargeRule(
                            charge_component_id=cloned.id,
                            rule_name=rule.rule_name,
                            rule_type=rule.rule_type,
                            rule_condition=rule.rule_condition,
                            rule_action=rule.rule_action,
                            priority=rule.priority,
                            is_active=rule.is_active
                        )
                        self.session.add(cloned_rule)
            self.session.flush()
        
        return cloned_components
    
    def reorder_components(
        self,
        fee_structure_id: UUID,
        component_id_order: List[UUID],
        audit_context: Dict[str, Any]
    ) -> int:
        """
        Reorder components based on provided list.
        
        Args:
            fee_structure_id: Fee structure identifier
            component_id_order: Ordered list of component IDs
            audit_context: Audit information
            
        Returns:
            Number of components reordered
        """
        order_map = {comp_id: idx for idx, comp_id in enumerate(component_id_order)}
        return self.bulk_update_display_order(order_map, audit_context)
    
    # ============================================================
    # Search and Filtering
    # ============================================================
    
    def search_components(
        self,
        search_term: str,
        fee_structure_ids: Optional[List[UUID]] = None,
        component_types: Optional[List[str]] = None,
        limit: int = 50
    ) -> List[ChargeComponent]:
        """
        Search components by name or description.
        
        Args:
            search_term: Term to search for
            fee_structure_ids: Optional fee structure filter
            component_types: Optional component type filter
            limit: Maximum results to return
            
        Returns:
            List of matching ChargeComponent instances
        """
        search_pattern = f"%{search_term}%"
        
        query = self.session.query(ChargeComponent).filter(
            or_(
                ChargeComponent.component_name.ilike(search_pattern),
                ChargeComponent.description.ilike(search_pattern)
            ),
            ChargeComponent.deleted_at.is_(None)
        )
        
        if fee_structure_ids:
            query = query.filter(ChargeComponent.fee_structure_id.in_(fee_structure_ids))
        
        if component_types:
            query = query.filter(ChargeComponent.component_type.in_(component_types))
        
        return query.limit(limit).all()
    
    def filter_components(
        self,
        filters: Dict[str, Any]
    ) -> List[ChargeComponent]:
        """
        Filter components based on dynamic criteria.
        
        Args:
            filters: Dictionary of filter criteria
            
        Returns:
            List of filtered ChargeComponent instances
        """
        query = self.session.query(ChargeComponent).filter(
            ChargeComponent.deleted_at.is_(None)
        )
        
        if 'fee_structure_id' in filters:
            query = query.filter(ChargeComponent.fee_structure_id == filters['fee_structure_id'])
        
        if 'component_type' in filters:
            query = query.filter(ChargeComponent.component_type == filters['component_type'])
        
        if 'is_mandatory' in filters:
            query = query.filter(ChargeComponent.is_mandatory == filters['is_mandatory'])
        
        if 'is_recurring' in filters:
            query = query.filter(ChargeComponent.is_recurring == filters['is_recurring'])
        
        if 'is_taxable' in filters:
            query = query.filter(ChargeComponent.is_taxable == filters['is_taxable'])
        
        if 'is_refundable' in filters:
            query = query.filter(ChargeComponent.is_refundable == filters['is_refundable'])
        
        if 'min_amount' in filters:
            query = query.filter(ChargeComponent.amount >= filters['min_amount'])
        
        if 'max_amount' in filters:
            query = query.filter(ChargeComponent.amount <= filters['max_amount'])
        
        if 'calculation_method' in filters:
            query = query.filter(ChargeComponent.calculation_method == filters['calculation_method'])
        
        if 'proration_allowed' in filters:
            query = query.filter(ChargeComponent.proration_allowed == filters['proration_allowed'])
        
        return query.order_by(ChargeComponent.display_order).all()
    
    # ============================================================
    # Validation Helpers
    # ============================================================
    
    def _validate_component(
        self,
        component_type: str,
        amount: Decimal,
        additional_data: Dict[str, Any]
    ) -> None:
        """
validate component data."""
        valid_types = ['rent', 'deposit', 'mess', 'electricity', 'water', 'maintenance', 'amenity', 'other']
        if component_type not in valid_types:
            raise ValidationException(f"Invalid component_type. Must be one of: {', '.join(valid_types)}")
        
        if amount < Decimal('0'):
            raise ValidationException("Component amount cannot be negative")
        
        tax_percentage = additional_data.get('tax_percentage', Decimal('0'))
        if tax_percentage < Decimal('0') or tax_percentage > Decimal('100'):
            raise ValidationException("Tax percentage must be between 0 and 100")
        
        calculation_method = additional_data.get('calculation_method', 'fixed')
        valid_methods = ['fixed', 'variable', 'percentage', 'tiered', 'actual']
        if calculation_method not in valid_methods:
            raise ValidationException(
                f"Invalid calculation_method. Must be one of: {', '.join(valid_methods)}"
            )
        
        # Validate date range if provided
        applies_from = additional_data.get('applies_from_date')
        applies_to = additional_data.get('applies_to_date')
        if applies_from and applies_to and applies_to <= applies_from:
            raise ValidationException("applies_to_date must be after applies_from_date")
    
    def _check_duplicate_component(
        self,
        fee_structure_id: UUID,
        component_name: str,
        exclude_id: Optional[UUID]
    ) -> None:
        """Check for duplicate component names in the same fee structure."""
        query = self.session.query(ChargeComponent).filter(
            ChargeComponent.fee_structure_id == fee_structure_id,
            ChargeComponent.component_name == component_name,
            ChargeComponent.deleted_at.is_(None)
        )
        
        if exclude_id:
            query = query.filter(ChargeComponent.id != exclude_id)
        
        if query.first():
            raise ConflictException(
                f"Component with name '{component_name}' already exists in this fee structure"
            )
    
    def _apply_audit(
        self,
        entity: ChargeComponent,
        audit_context: Dict[str, Any],
        is_update: bool = False
    ) -> None:
        """Apply audit information to entity."""
        user_id = audit_context.get('user_id')
        
        if is_update:
            entity.updated_by = user_id
            entity.updated_at = datetime.utcnow()
        else:
            entity.created_by = user_id
            entity.created_at = datetime.utcnow()


class ChargeRuleRepository(BaseRepository[ChargeRule]):
    """
    Charge Rule Repository
    
    Manages business rules associated with charge components including
    discounts, surcharges, waivers, proration, and conditional logic.
    """
    
    def __init__(self, session: Session):
        super().__init__(ChargeRule, session)
    
    # ============================================================
    # Core CRUD Operations
    # ============================================================
    
    def create_charge_rule(
        self,
        charge_component_id: UUID,
        rule_name: str,
        rule_type: str,
        rule_condition: str,
        rule_action: str,
        audit_context: Dict[str, Any],
        **kwargs
    ) -> ChargeRule:
        """
        Create a new charge rule.
        
        Args:
            charge_component_id: Parent component ID
            rule_name: Name of the rule
            rule_type: Type of rule (discount, surcharge, waiver, etc.)
            rule_condition: Condition expression (JSON or string)
            rule_action: Action expression (JSON or string)
            audit_context: Audit information
            **kwargs: Additional rule attributes
            
        Returns:
            Created ChargeRule instance
            
        Raises:
            ValidationException: If validation fails
        """
        self._validate_rule(rule_type, rule_condition, rule_action)
        
        rule = ChargeRule(
            charge_component_id=charge_component_id,
            rule_name=rule_name,
            rule_type=rule_type,
            rule_condition=rule_condition,
            rule_action=rule_action,
            priority=kwargs.pop('priority', 0),
            is_active=kwargs.pop('is_active', True),
            **kwargs
        )
        
        self._apply_audit(rule, audit_context)
        self.session.add(rule)
        self.session.flush()
        
        return rule
    
    def update_charge_rule(
        self,
        rule_id: UUID,
        update_data: Dict[str, Any],
        audit_context: Dict[str, Any]
    ) -> ChargeRule:
        """
        Update an existing charge rule.
        
        Args:
            rule_id: Rule identifier
            update_data: Fields to update
            audit_context: Audit information
            
        Returns:
            Updated ChargeRule instance
        """
        rule = self.find_by_id(rule_id)
        if not rule:
            raise NotFoundException(f"Charge rule {rule_id} not found")
        
        # Validate if rule type, condition, or action is being updated
        if any(k in update_data for k in ['rule_type', 'rule_condition', 'rule_action']):
            self._validate_rule(
                update_data.get('rule_type', rule.rule_type),
                update_data.get('rule_condition', rule.rule_condition),
                update_data.get('rule_action', rule.rule_action)
            )
        
        # Apply updates
        for key, value in update_data.items():
            if hasattr(rule, key) and key not in ['id', 'created_at']:
                setattr(rule, key, value)
        
        self._apply_audit(rule, audit_context, is_update=True)
        self.session.flush()
        
        return rule
    
    def activate_rule(
        self,
        rule_id: UUID,
        audit_context: Dict[str, Any]
    ) -> ChargeRule:
        """
        Activate a charge rule.
        
        Args:
            rule_id: Rule identifier
            audit_context: Audit information
            
        Returns:
            Activated ChargeRule instance
        """
        return self.update_charge_rule(
            rule_id,
            {'is_active': True},
            audit_context
        )
    
    def deactivate_rule(
        self,
        rule_id: UUID,
        audit_context: Dict[str, Any]
    ) -> ChargeRule:
        """
        Deactivate a charge rule.
        
        Args:
            rule_id: Rule identifier
            audit_context: Audit information
            
        Returns:
            Deactivated ChargeRule instance
        """
        return self.update_charge_rule(
            rule_id,
            {'is_active': False},
            audit_context
        )
    
    # ============================================================
    # Query Operations
    # ============================================================
    
    def find_by_component(
        self,
        charge_component_id: UUID,
        rule_type: Optional[str] = None,
        is_active: Optional[bool] = True
    ) -> List[ChargeRule]:
        """
        Find rules for a specific charge component.
        
        Args:
            charge_component_id: Component identifier
            rule_type: Optional rule type filter
            is_active: Filter by active status (None for all)
            
        Returns:
            List of ChargeRule instances ordered by priority
        """
        query = self.session.query(ChargeRule).filter(
            ChargeRule.charge_component_id == charge_component_id
        )
        
        if rule_type:
            query = query.filter(ChargeRule.rule_type == rule_type)
        
        if is_active is not None:
            query = query.filter(ChargeRule.is_active == is_active)
        
        return query.order_by(ChargeRule.priority.desc()).all()
    
    def find_by_type(
        self,
        rule_type: str,
        is_active: bool = True,
        component_ids: Optional[List[UUID]] = None
    ) -> List[ChargeRule]:
        """
        Find all rules of a specific type.
        
        Args:
            rule_type: Rule type to search
            is_active: Filter by active status
            component_ids: Optional component filter
            
        Returns:
            List of ChargeRule instances
        """
        query = self.session.query(ChargeRule).filter(
            ChargeRule.rule_type == rule_type
        )
        
        if is_active:
            query = query.filter(ChargeRule.is_active == True)
        
        if component_ids:
            query = query.filter(ChargeRule.charge_component_id.in_(component_ids))
        
        return query.order_by(ChargeRule.priority.desc()).all()
    
    def get_highest_priority_rules(
        self,
        charge_component_id: UUID,
        limit: int = 5,
        is_active: bool = True
    ) -> List[ChargeRule]:
        """
        Get highest priority rules for a component.
        
        Args:
            charge_component_id: Component identifier
            limit: Maximum number of rules to return
            is_active: Only return active rules
            
        Returns:
            List of highest priority ChargeRule instances
        """
        query = self.session.query(ChargeRule).filter(
            ChargeRule.charge_component_id == charge_component_id
        )
        
        if is_active:
            query = query.filter(ChargeRule.is_active == True)
        
        return query.order_by(ChargeRule.priority.desc()).limit(limit).all()
    
    def find_discount_rules(
        self,
        component_ids: Optional[List[UUID]] = None,
        is_active: bool = True
    ) -> List[ChargeRule]:
        """
        Find all discount rules.
        
        Args:
            component_ids: Optional component filter
            is_active: Filter by active status
            
        Returns:
            List of discount ChargeRule instances
        """
        return self.find_by_type('discount', is_active, component_ids)
    
    def find_surcharge_rules(
        self,
        component_ids: Optional[List[UUID]] = None,
        is_active: bool = True
    ) -> List[ChargeRule]:
        """
        Find all surcharge rules.
        
        Args:
            component_ids: Optional component filter
            is_active: Filter by active status
            
        Returns:
            List of surcharge ChargeRule instances
        """
        return self.find_by_type('surcharge', is_active, component_ids)
    
    def find_waiver_rules(
        self,
        component_ids: Optional[List[UUID]] = None,
        is_active: bool = True
    ) -> List[ChargeRule]:
        """
        Find all waiver rules.
        
        Args:
            component_ids: Optional component filter
            is_active: Filter by active status
            
        Returns:
            List of waiver ChargeRule instances
        """
        return self.find_by_type('waiver', is_active, component_ids)
    
    def find_proration_rules(
        self,
        component_ids: Optional[List[UUID]] = None,
        is_active: bool = True
    ) -> List[ChargeRule]:
        """
        Find all proration rules.
        
        Args:
            component_ids: Optional component filter
            is_active: Filter by active status
            
        Returns:
            List of proration ChargeRule instances
        """
        return self.find_by_type('proration', is_active, component_ids)
    
    def find_conditional_rules(
        self,
        component_ids: Optional[List[UUID]] = None,
        is_active: bool = True
    ) -> List[ChargeRule]:
        """
        Find all conditional rules.
        
        Args:
            component_ids: Optional component filter
            is_active: Filter by active status
            
        Returns:
            List of conditional ChargeRule instances
        """
        return self.find_by_type('conditional', is_active, component_ids)
    
    # ============================================================
    # Analytics
    # ============================================================
    
    def get_rule_statistics(
        self,
        charge_component_id: Optional[UUID] = None
    ) -> Dict[str, Any]:
        """
        Get statistics on charge rules.
        
        Args:
            charge_component_id: Optional component filter
            
        Returns:
            Dictionary with rule statistics
        """
        query = self.session.query(
            func.count(ChargeRule.id).label('total_rules'),
            func.sum(case((ChargeRule.is_active == True, 1), else_=0)).label('active_rules'),
            func.sum(case((ChargeRule.rule_type == 'discount', 1), else_=0)).label('discount_rules'),
            func.sum(case((ChargeRule.rule_type == 'surcharge', 1), else_=0)).label('surcharge_rules'),
            func.sum(case((ChargeRule.rule_type == 'waiver', 1), else_=0)).label('waiver_rules'),
            func.sum(case((ChargeRule.rule_type == 'proration', 1), else_=0)).label('proration_rules'),
            func.sum(case((ChargeRule.rule_type == 'conditional', 1), else_=0)).label('conditional_rules'),
            func.avg(ChargeRule.priority).label('avg_priority')
        )
        
        if charge_component_id:
            query = query.filter(ChargeRule.charge_component_id == charge_component_id)
        
        result = query.first()
        
        total = result.total_rules or 0
        
        return {
            'total_rules': total,
            'active_rules': result.active_rules or 0,
            'inactive_rules': total - (result.active_rules or 0),
            'active_percentage': (result.active_rules / total * 100) if total else 0,
            'by_type': {
                'discount': result.discount_rules or 0,
                'surcharge': result.surcharge_rules or 0,
                'waiver': result.waiver_rules or 0,
                'proration': result.proration_rules or 0,
                'conditional': result.conditional_rules or 0
            },
            'average_priority': float(result.avg_priority or 0)
        }
    
    # ============================================================
    # Bulk Operations
    # ============================================================
    
    def bulk_activate_rules(
        self,
        rule_ids: List[UUID],
        audit_context: Dict[str, Any]
    ) -> int:
        """
        Bulk activate multiple rules.
        
        Args:
            rule_ids: List of rule IDs
            audit_context: Audit information
            
        Returns:
            Number of rules activated
        """
        updated = self.session.query(ChargeRule).filter(
            ChargeRule.id.in_(rule_ids)
        ).update(
            {
                'is_active': True,
                'updated_at': datetime.utcnow(),
                'updated_by': audit_context.get('user_id')
            },
            synchronize_session=False
        )
        
        self.session.flush()
        return updated
    
    def bulk_deactivate_rules(
        self,
        rule_ids: List[UUID],
        audit_context: Dict[str, Any]
    ) -> int:
        """
        Bulk deactivate multiple rules.
        
        Args:
            rule_ids: List of rule IDs
            audit_context: Audit information
            
        Returns:
            Number of rules deactivated
        """
        updated = self.session.query(ChargeRule).filter(
            ChargeRule.id.in_(rule_ids)
        ).update(
            {
                'is_active': False,
                'updated_at': datetime.utcnow(),
                'updated_by': audit_context.get('user_id')
            },
            synchronize_session=False
        )
        
        self.session.flush()
        return updated
    
    def bulk_update_priority(
        self,
        priority_updates: Dict[UUID, int],
        audit_context: Dict[str, Any]
    ) -> int:
        """
        Bulk update priorities for rules.
        
        Args:
            priority_updates: Dictionary mapping rule_id to priority
            audit_context: Audit information
            
        Returns:
            Number of rules updated
        """
        updated = 0
        
        for rule_id, priority in priority_updates.items():
            result = self.session.query(ChargeRule).filter(
                ChargeRule.id == rule_id
            ).update(
                {
                    'priority': priority,
                    'updated_at': datetime.utcnow(),
                    'updated_by': audit_context.get('user_id')
                },
                synchronize_session=False
            )
            updated += result
        
        self.session.flush()
        return updated
    
    # ============================================================
    # Validation Helpers
    # ============================================================
    
    def _validate_rule(
        self,
        rule_type: str,
        rule_condition: str,
        rule_action: str
    ) -> None:
        """Validate rule data."""
        valid_types = ['discount', 'surcharge', 'waiver', 'proration', 'conditional']
        if rule_type not in valid_types:
            raise ValidationException(
                f"Invalid rule_type. Must be one of: {', '.join(valid_types)}"
            )
        
        # Validate JSON if it appears to be JSON
        if rule_condition.strip().startswith('{'):
            try:
                json.loads(rule_condition)
            except json.JSONDecodeError:
                raise ValidationException("rule_condition must be valid JSON")
        
        if rule_action.strip().startswith('{'):
            try:
                json.loads(rule_action)
            except json.JSONDecodeError:
                raise ValidationException("rule_action must be valid JSON")
    
    def _apply_audit(
        self,
        entity: ChargeRule,
        audit_context: Dict[str, Any],
        is_update: bool = False
    ) -> None:
        """Apply audit information to entity."""
        user_id = audit_context.get('user_id')
        
        if is_update:
            entity.updated_by = user_id
            entity.updated_at = datetime.utcnow()
        else:
            entity.created_by = user_id
            entity.created_at = datetime.utcnow()


class DiscountConfigurationRepository(BaseRepository[DiscountConfiguration]):
    """
    Discount Configuration Repository
    
    Manages discount configurations with validation, usage tracking,
    applicability checking, and comprehensive analytics.
    """
    
    def __init__(self, session: Session):
        super().__init__(DiscountConfiguration, session)
    
    # ============================================================
    # Core CRUD Operations
    # ============================================================
    
    def create_discount(
        self,
        discount_name: str,
        discount_type: str,
        applies_to: str,
        audit_context: Dict[str, Any],
        **kwargs
    ) -> DiscountConfiguration:
        """
        Create a new discount configuration.
        
        Args:
            discount_name: Name of the discount
            discount_type: Type of discount (percentage, fixed_amount, waiver)
            applies_to: What the discount applies to
            audit_context: Audit information
            **kwargs: Additional discount attributes
            
        Returns:
            Created DiscountConfiguration instance
            
        Raises:
            ValidationException: If validation fails
            ConflictException: If duplicate code
        """
        # Validate discount configuration
        self._validate_discount(discount_type, applies_to, kwargs)
        
        # Check for duplicate discount codes
        if 'discount_code' in kwargs and kwargs['discount_code']:
            self._check_duplicate_code(kwargs['discount_code'], None)
        
        discount = DiscountConfiguration(
            discount_name=discount_name,
            discount_type=discount_type,
            applies_to=applies_to,
            is_active=kwargs.pop('is_active', True),
            current_usage_count=0,
            **kwargs
        )
        
        self._apply_audit(discount, audit_context)
        self.session.add(discount)
        self.session.flush()
        
        return discount
    
    def update_discount(
        self,
        discount_id: UUID,
        update_data: Dict[str, Any],
        audit_context: Dict[str, Any]
    ) -> DiscountConfiguration:
        """
        Update an existing discount configuration.
        
        Args:
            discount_id: Discount identifier
            update_data: Fields to update
            audit_context: Audit information
            
        Returns:
            Updated DiscountConfiguration instance
            
        Raises:
            NotFoundException: If discount not found
            ValidationException: If validation fails
        """
        discount = self.find_by_id(discount_id)
        if not discount:
            raise NotFoundException(f"Discount configuration {discount_id} not found")
        
        # Validate updates
        self._validate_discount(
            update_data.get('discount_type', discount.discount_type),
            update_data.get('applies_to', discount.applies_to),
            update_data
        )
        
        # Check for duplicate codes if code is being changed
        if 'discount_code' in update_data and update_data['discount_code'] != discount.discount_code:
            self._check_duplicate_code(update_data['discount_code'], discount_id)
        
        # Apply updates
        for key, value in update_data.items():
            if hasattr(discount, key) and key not in ['id', 'created_at', 'current_usage_count']:
                setattr(discount, key, value)
        
        self._apply_audit(discount, audit_context, is_update=True)
        self.session.flush()
        
        return discount
    
    def activate_discount(
        self,
        discount_id: UUID,
        audit_context: Dict[str, Any]
    ) -> DiscountConfiguration:
        """
        Activate a discount.
        
        Args:
            discount_id: Discount identifier
            audit_context: Audit information
            
        Returns:
            Activated DiscountConfiguration
        """
        return self.update_discount(
            discount_id,
            {'is_active': True},
            audit_context
        )
    
    def deactivate_discount(
        self,
        discount_id: UUID,
        audit_context: Dict[str, Any]
    ) -> DiscountConfiguration:
        """
        Deactivate a discount.
        
        Args:
            discount_id: Discount identifier
            audit_context: Audit information
            
        Returns:
            Deactivated DiscountConfiguration
        """
        return self.update_discount(
            discount_id,
            {'is_active': False},
            audit_context
        )
    
    # ============================================================
    # Query Operations
    # ============================================================
    
    def find_active_discounts(
        self,
        applies_to: Optional[str] = None,
        hostel_id: Optional[UUID] = None,
        room_type: Optional[str] = None,
        as_of_date: Optional[Date] = None,
        new_students_only: Optional[bool] = None
    ) -> List[DiscountConfiguration]:
        """
        Find active discounts with comprehensive filters.
        
        Args:
            applies_to: What the discount applies to
            hostel_id: Optional hostel filter
            room_type: Optional room type filter
            as_of_date: Date to check validity
            new_students_only: Filter for new student discounts
            
        Returns:
            List of active DiscountConfiguration instances
        """
        check_date = as_of_date or Date.today()
        
        query = self.session.query(DiscountConfiguration).filter(
            DiscountConfiguration.is_active == True,
            DiscountConfiguration.deleted_at.is_(None),
            or_(
                DiscountConfiguration.valid_from.is_(None),
                DiscountConfiguration.valid_from <= check_date
            ),
            or_(
                DiscountConfiguration.valid_to.is_(None),
                DiscountConfiguration.valid_to >= check_date
            )
        )
        
        if applies_to:
            query = query.filter(DiscountConfiguration.applies_to == applies_to)
        
        if hostel_id:
            query = query.filter(
                or_(
                    DiscountConfiguration.hostel_ids.is_(None),
                    DiscountConfiguration.hostel_ids.like(f'%{hostel_id}%')
                )
            )
        
        if room_type:
            query = query.filter(
                or_(
                    DiscountConfiguration.room_types.is_(None),
                    DiscountConfiguration.room_types.like(f'%{room_type}%')
                )
            )
        
        if new_students_only is not None:
            query = query.filter(DiscountConfiguration.valid_for_new_students_only == new_students_only)
        
        # Filter by usage limit
        query = query.filter(
            or_(
                DiscountConfiguration.max_usage_count.is_(None),
                DiscountConfiguration.current_usage_count < DiscountConfiguration.max_usage_count
            )
        )
        
        return query.order_by(DiscountConfiguration.discount_name).all()
    
    def find_by_code(
        self,
        discount_code: str,
        validate_active: bool = True,
        check_date: Optional[Date] = None
    ) -> Optional[DiscountConfiguration]:
        """
        Find discount by code with validation.
        
        Args:
            discount_code: Discount code to search
            validate_active: Whether to check if discount is currently active
            check_date: Date to validate against
            
        Returns:
            DiscountConfiguration instance or None
        """
        query = self.session.query(DiscountConfiguration).filter(
            DiscountConfiguration.discount_code == discount_code,
            DiscountConfiguration.deleted_at.is_(None)
        )
        
        if validate_active:
            today = check_date or Date.today()
            query = query.filter(
                DiscountConfiguration.is_active == True,
                or_(
                    DiscountConfiguration.valid_from.is_(None),
                    DiscountConfiguration.valid_from <= today
                ),
                or_(
                    DiscountConfiguration.valid_to.is_(None),
                    DiscountConfiguration.valid_to >= today
                ),
                or_(
                    DiscountConfiguration.max_usage_count.is_(None),
                    DiscountConfiguration.current_usage_count < DiscountConfiguration.max_usage_count
                )
            )
        
        return query.first()
    
    def find_expiring_soon(
        self,
        days_ahead: int = 7,
        hostel_id: Optional[UUID] = None
    ) -> List[DiscountConfiguration]:
        """
        Find discounts expiring within specified days.
        
        Args:
            days_ahead: Number of days to look ahead
            hostel_id: Optional hostel filter
            
        Returns:
            List of expiring DiscountConfiguration instances
        """
        today = Date.today()
        future_date = Date.fromordinal(today.toordinal() + days_ahead)
        
        query = self.session.query(DiscountConfiguration).filter(
            DiscountConfiguration.is_active == True,
            DiscountConfiguration.valid_to.isnot(None),
            DiscountConfiguration.valid_to > today,
            DiscountConfiguration.valid_to <= future_date,
            DiscountConfiguration.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.filter(
                or_(
                    DiscountConfiguration.hostel_ids.is_(None),
                    DiscountConfiguration.hostel_ids.like(f'%{hostel_id}%')
                )
            )
        
        return query.order_by(DiscountConfiguration.valid_to).all()
    
    def find_by_hostel(
        self,
        hostel_id: UUID,
        include_inactive: bool = False,
        as_of_date: Optional[Date] = None
    ) -> List[DiscountConfiguration]:
        """
        Find all discounts applicable to a specific hostel.
        
        Args:
            hostel_id: Hostel identifier
            include_inactive: Include inactive discounts
            as_of_date: Date to check validity
            
        Returns:
            List of DiscountConfiguration instances
        """
        query = self.session.query(DiscountConfiguration).filter(
            or_(
                DiscountConfiguration.hostel_ids.is_(None),
                DiscountConfiguration.hostel_ids.like(f'%{hostel_id}%')
            ),
            DiscountConfiguration.deleted_at.is_(None)
        )
        
        if not include_inactive:
            query = query.filter(DiscountConfiguration.is_active == True)
            
            if as_of_date:
                query = query.filter(
                    or_(
                        DiscountConfiguration.valid_from.is_(None),
                        DiscountConfiguration.valid_from <= as_of_date
                    ),
                    or_(
                        DiscountConfiguration.valid_to.is_(None),
                        DiscountConfiguration.valid_to >= as_of_date
                    )
                )
        
        return query.order_by(DiscountConfiguration.discount_name).all()
    
    def find_nearly_exhausted(
        self,
        threshold_percentage: float = 0.9,
        include_unlimited: bool = False
    ) -> List[DiscountConfiguration]:
        """
        Find discounts nearly exhausted (used close to max limit).
        
        Args:
            threshold_percentage: Threshold percentage (0.0 to 1.0)
            include_unlimited: Include discounts with no usage limit
            
        Returns:
            List of nearly exhausted DiscountConfiguration instances
        """
        query = self.session.query(DiscountConfiguration).filter(
            DiscountConfiguration.is_active == True,
            DiscountConfiguration.deleted_at.is_(None)
        )
        
        if not include_unlimited:
            query = query.filter(DiscountConfiguration.max_usage_count.isnot(None))
        
        query = query.filter(
            DiscountConfiguration.current_usage_count >= (
                DiscountConfiguration.max_usage_count * threshold_percentage
            )
        )
        
        return query.order_by(
            (DiscountConfiguration.current_usage_count / DiscountConfiguration.max_usage_count).desc()
        ).all()
    
    def find_by_type(
        self,
        discount_type: str,
        is_active: bool = True
    ) -> List[DiscountConfiguration]:
        """
        Find discounts by type.
        
        Args:
            discount_type: Type of discount
            is_active: Filter by active status
            
        Returns:
            List of DiscountConfiguration instances
        """
        query = self.session.query(DiscountConfiguration).filter(
            DiscountConfiguration.discount_type == discount_type,
            DiscountConfiguration.deleted_at.is_(None)
        )
        
        if is_active:
            query = query.filter(DiscountConfiguration.is_active == True)
        
        return query.all()
    
    def find_for_new_students(
        self,
        hostel_id: Optional[UUID] = None,
        room_type: Optional[str] = None,
        as_of_date: Optional[Date] = None
    ) -> List[DiscountConfiguration]:
        """
        Find discounts applicable to new students.
        
        Args:
            hostel_id: Optional hostel filter
            room_type: Optional room type filter
            as_of_date: Date to check validity
            
        Returns:
            List of DiscountConfiguration instances for new students
        """
        return self.find_active_discounts(
            hostel_id=hostel_id,
            room_type=room_type,
            as_of_date=as_of_date,
            new_students_only=True
        )
    
    # ============================================================
    # Usage Tracking
    # ============================================================
    
    def increment_usage(
        self,
        discount_id: UUID
    ) -> DiscountConfiguration:
        """
        Increment usage count for a discount.
        
        Args:
            discount_id: Discount identifier
            
        Returns:
            Updated DiscountConfiguration instance
            
        Raises:
            NotFoundException: If discount not found
            ValidationException: If max usage exceeded
        """
        discount = self.find_by_id(discount_id)
        if not discount:
            raise NotFoundException(f"Discount {discount_id} not found")
        
        if discount.max_usage_count and discount.current_usage_count >= discount.max_usage_count:
            raise ValidationException("Discount has reached maximum usage limit")
        
        discount.current_usage_count += 1
        discount.updated_at = datetime.utcnow()
        
        self.session.flush()
        return discount
    
    def decrement_usage(
        self,
        discount_id: UUID
    ) -> DiscountConfiguration:
        """
        Decrement usage count for a discount (e.g., on cancellation).
        
        Args:
            discount_id: Discount identifier
            
        Returns:
            Updated DiscountConfiguration instance
            
        Raises:
            NotFoundException: If discount not found
        """
        discount = self.find_by_id(discount_id)
        if not discount:
            raise NotFoundException(f"Discount {discount_id} not found")
        
        if discount.current_usage_count > 0:
            discount.current_usage_count -= 1
            discount.updated_at = datetime.utcnow()
            self.session.flush()
        
        return discount
    
    def reset_usage_count(
        self,
        discount_id: UUID,
        audit_context: Dict[str, Any]
    ) -> DiscountConfiguration:
        """
        Reset usage count to zero.
        
        Args:
            discount_id: Discount identifier
            audit_context: Audit information
            
        Returns:
            Updated DiscountConfiguration instance
        """
        return self.update_discount(
            discount_id,
            {'current_usage_count': 0},
            audit_context
        )
    
    def get_usage_statistics(
        self,
        discount_id: UUID
    ) -> Dict[str, Any]:
        """
        Get detailed usage statistics for a discount.
        
        Args:
            discount_id: Discount identifier
            
        Returns:
            Dictionary with usage statistics
            
        Raises:
            NotFoundException: If discount not found
        """
        discount = self.find_by_id(discount_id)
        if not discount:
            raise NotFoundException(f"Discount {discount_id} not found")
        
        usage_percentage = None
        if discount.max_usage_count:
            usage_percentage = (
                discount.current_usage_count / discount.max_usage_count * 100
            )
        
        days_until_expiry = None
        if discount.valid_to:
            days_until_expiry = (discount.valid_to - Date.today()).days
        
        return {
            'discount_id': str(discount.id),
            'discount_name': discount.discount_name,
            'discount_code': discount.discount_code,
            'current_usage': discount.current_usage_count,
            'max_usage': discount.max_usage_count,
            'remaining_usage': discount.remaining_usage_count,
            'usage_percentage': float(usage_percentage) if usage_percentage else None,
            'is_exhausted': discount.max_usage_count and 
                          discount.current_usage_count >= discount.max_usage_count,
            'is_active': discount.is_active,
            'is_currently_valid': discount.is_currently_valid,
            'valid_from': discount.valid_from.isoformat() if discount.valid_from else None,
            'valid_to': discount.valid_to.isoformat() if discount.valid_to else None,
            'days_until_expiry': days_until_expiry
        }
    
    # ============================================================
    # Validation and Applicability
    # ============================================================
    
    def validate_discount_applicability(
        self,
        discount_id: UUID,
        hostel_id: UUID,
        room_type: str,
        is_new_student: bool = False,
        stay_months: Optional[int] = None,
        check_date: Optional[Date] = None
    ) -> Tuple[bool, Optional[str]]:
        """
        Comprehensive validation of discount applicability.
        
        Args:
            discount_id: Discount identifier
            hostel_id: Hostel identifier
            room_type: Room type
            is_new_student: Whether student is new
            stay_months: Length of stay in months
            check_date: Date to validate against
            
        Returns:
            Tuple of (is_valid, error_message)
        """
        discount = self.find_by_id(discount_id)
        if not discount:
            return False, "Discount not found"
        
        check_date = check_date or Date.today()
        
        # Check if discount is active
        if not discount.is_active:
            return False, "Discount is not active"
        
        # Check date validity
        if discount.valid_from and check_date < discount.valid_from:
            return False, f"Discount not valid until {discount.valid_from.isoformat()}"
        
        if discount.valid_to and check_date > discount.valid_to:
            return False, f"Discount expired on {discount.valid_to.isoformat()}"
        
        # Check usage limit
        if discount.max_usage_count and discount.current_usage_count >= discount.max_usage_count:
            return False, "Discount has reached maximum usage limit"
        
        # Check hostel applicability
        if discount.hostel_ids:
            if str(hostel_id) not in discount.hostel_ids:
                return False, "Discount not applicable to this hostel"
        
        # Check room type applicability
        if discount.room_types:
            if room_type not in discount.room_types:
                return False, "Discount not applicable to this room type"
        
        # Check new student requirement
        if discount.valid_for_new_students_only and not is_new_student:
            return False, "Discount only valid for new students"
        
        # Check minimum stay requirement
        if discount.minimum_stay_months and stay_months:
            if stay_months < discount.minimum_stay_months:
                return False, f"Minimum stay of {discount.minimum_stay_months} months required"
        
        return True, None
    
    def calculate_discount_amount(
        self,
        discount_id: UUID,
        base_amount: Decimal
    ) -> Decimal:
        """
        Calculate discount amount based on configuration.
        
        Args:
            discount_id: Discount identifier
            base_amount: Base amount to apply discount to
            
        Returns:
            Calculated discount amount
            
        Raises:
            NotFoundException: If discount not found
        """
        discount = self.find_by_id(discount_id)
        if not discount:
            raise NotFoundException(f"Discount {discount_id} not found")
        
        if discount.discount_type == 'percentage':
            return (base_amount * discount.discount_percentage / 100).quantize(Decimal('0.01'))
        elif discount.discount_type == 'fixed_amount':
            return min(discount.discount_amount, base_amount)
        elif discount.discount_type == 'waiver':
            return base_amount
        
        return Decimal('0.00')
    
    def get_best_applicable_discount(
        self,
        hostel_id: UUID,
        room_type: str,
        base_amount: Decimal,
        is_new_student: bool = False,
        stay_months: Optional[int] = None,
        check_date: Optional[Date] = None
    ) -> Optional[Tuple[DiscountConfiguration, Decimal]]:
        """
        Find the best applicable discount for given criteria.
        
        Args:
            hostel_id: Hostel identifier
            room_type: Room type
            base_amount: Base amount to calculate discount
            is_new_student: Whether student is new
            stay_months: Length of stay
            check_date: Date to check
            
        Returns:
            Tuple of (DiscountConfiguration, discount_amount) or None
        """
        applicable_discounts = self.find_active_discounts(
            hostel_id=hostel_id,
            room_type=room_type,
            as_of_date=check_date,
            new_students_only=is_new_student if is_new_student else None
        )
        
        best_discount = None
        best_amount = Decimal('0.00')
        
        for discount in applicable_discounts:
            # Validate applicability
            is_valid, _ = self.validate_discount_applicability(
                discount.id,
                hostel_id,
                room_type,
                is_new_student,
                stay_months,
                check_date
            )
            
            if is_valid:
                discount_amount = self.calculate_discount_amount(discount.id, base_amount)
                if discount_amount > best_amount:
                    best_amount = discount_amount
                    best_discount = discount
        
        if best_discount:
            return (best_discount, best_amount)
        
        return None
    
    # ============================================================
    # Analytics
    # ============================================================
    
    def get_discount_analytics(
        self,
        start_date: Optional[Date] = None,
        end_date: Optional[Date] = None,
        hostel_id: Optional[UUID] = None
    ) -> Dict[str, Any]:
        """
        Get comprehensive discount analytics.
        
        Args:
            start_date: Optional start date for analysis
            end_date: Optional end date for analysis
            hostel_id: Optional hostel filter
            
        Returns:
            Dictionary with discount analytics
        """
        query = self.session.query(
            func.count(DiscountConfiguration.id).label('total_discounts'),
            func.sum(case(
                (DiscountConfiguration.is_active == True, 1),
                else_=0
            )).label('active_discounts'),
            func.sum(DiscountConfiguration.current_usage_count).label('total_usage'),
            func.avg(DiscountConfiguration.current_usage_count).label('avg_usage'),
            func.avg(DiscountConfiguration.discount_percentage).label('avg_percentage'),
            func.avg(DiscountConfiguration.discount_amount).label('avg_fixed_amount'),
            func.sum(case(
                (DiscountConfiguration.discount_type == 'percentage', 1),
                else_=0
            )).label('percentage_based'),
            func.sum(case(
                (DiscountConfiguration.discount_type == 'fixed_amount', 1),
                else_=0
            )).label('fixed_amount_based'),
            func.sum(case(
                (DiscountConfiguration.discount_type == 'waiver', 1),
                else_=0
            )).label('waiver_based'),
            func.sum(case(
                (DiscountConfiguration.valid_for_new_students_only == True, 1),
                else_=0
            )).label('new_student_only')
        ).filter(
            DiscountConfiguration.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.filter(
                or_(
                    DiscountConfiguration.hostel_ids.is_(None),
                    DiscountConfiguration.hostel_ids.like(f'%{hostel_id}%')
                )
            )
        
        if start_date:
            query = query.filter(
                or_(
                    DiscountConfiguration.valid_from.is_(None),
                    DiscountConfiguration.valid_from >= start_date
                )
            )
        
        if end_date:
            query = query.filter(
                or_(
                    DiscountConfiguration.valid_to.is_(None),
                    DiscountConfiguration.valid_to <= end_date
                )
            )
        
        result = query.first()
        
        total = result.total_discounts or 0
        
        return {
            'total_discounts': total,
            'active_discounts': result.active_discounts or 0,
            'inactive_discounts': total - (result.active_discounts or 0),
            'active_percentage': (result.active_discounts / total * 100) if total else 0,
            'total_usage': result.total_usage or 0,
            'average_usage': float(result.avg_usage or 0),
            'average_discount_percentage': float(result.avg_percentage or 0),
            'average_fixed_amount': float(result.avg_fixed_amount or 0),
            'by_type': {
                'percentage': result.percentage_based or 0,
                'fixed_amount': result.fixed_amount_based or 0,
                'waiver': result.waiver_based or 0
            },
            'new_student_only_count': result.new_student_only or 0,
            'period': {
                'start_date': start_date.isoformat() if start_date else None,
                'end_date': end_date.isoformat() if end_date else None
            }
        }
    
    def get_discount_performance(
        self,
        discount_id: UUID
    ) -> Dict[str, Any]:
        """
        Get performance metrics for a specific discount.
        
        Args:
            discount_id: Discount identifier
            
        Returns:
            Dictionary with performance metrics
        """
        discount = self.find_by_id(discount_id)
        if not discount:
            raise NotFoundException(f"Discount {discount_id} not found")
        
        usage_stats = self.get_usage_statistics(discount_id)
        
        days_active = None
        if discount.valid_from:
            days_active = (Date.today() - discount.valid_from).days
        
        usage_rate = None
        if discount.max_usage_count and days_active:
            usage_rate = discount.current_usage_count / days_active
        
        return {
            **usage_stats,
            'days_active': days_active,
            'daily_usage_rate': float(usage_rate) if usage_rate else None,
            'discount_type': discount.discount_type,
            'applies_to': discount.applies_to,
            'value': {
                'percentage': float(discount.discount_percentage) if discount.discount_percentage else None,
                'fixed_amount': float(discount.discount_amount) if discount.discount_amount else None
            }
        }
    
    def compare_discount_effectiveness(
        self,
        discount_ids: List[UUID]
    ) -> List[Dict[str, Any]]:
        """
        Compare effectiveness of multiple discounts.
        
        Args:
            discount_ids: List of discount IDs to compare
            
        Returns:
            List of comparison data
        """
        comparisons = []
        
        for discount_id in discount_ids:
            try:
                performance = self.get_discount_performance(discount_id)
                comparisons.append(performance)
            except NotFoundException:
                continue
        
        # Sort by usage count descending
        comparisons.sort(key=lambda x: x['current_usage'], reverse=True)
        
        return comparisons
    
    # ============================================================
    # Bulk Operations
    # ============================================================
    
    def bulk_activate_discounts(
        self,
        discount_ids: List[UUID],
        audit_context: Dict[str, Any]
    ) -> int:
        """
        Bulk activate multiple discounts.
        
        Args:
            discount_ids: List of discount IDs
            audit_context: Audit information
            
        Returns:
            Number of discounts activated
        """
        updated = self.session.query(DiscountConfiguration).filter(
            DiscountConfiguration.id.in_(discount_ids),
            DiscountConfiguration.deleted_at.is_(None)
        ).update(
            {
                'is_active': True,
                'updated_at': datetime.utcnow(),
                'updated_by': audit_context.get('user_id')
            },
            synchronize_session=False
        )
        
        self.session.flush()
        return updated
    
    def bulk_deactivate_discounts(
        self,
        discount_ids: List[UUID],
        audit_context: Dict[str, Any]
    ) -> int:
        """
        Bulk deactivate multiple discounts.
        
        Args:
            discount_ids: List of discount IDs
            audit_context: Audit information
            
        Returns:
            Number of discounts deactivated
        """
        updated = self.session.query(DiscountConfiguration).filter(
            DiscountConfiguration.id.in_(discount_ids),
            DiscountConfiguration.deleted_at.is_(None)
        ).update(
            {
                'is_active': False,
                'updated_at': datetime.utcnow(),
                'updated_by': audit_context.get('user_id')
            },
            synchronize_session=False
        )
        
        self.session.flush()
        return updated
    
    def expire_discounts(
        self,
        expiry_date: Optional[Date] = None,
        audit_context: Optional[Dict[str, Any]] = None
    ) -> int:
        """
        Expire discounts that have passed their valid_to date.
        
        Args:
            expiry_date: Date to check (defaults to today)
            audit_context: Optional audit information
            
        Returns:
            Number of discounts expired
        """
        check_date = expiry_date or Date.today()
        
        update_data = {
            'is_active': False,
            'updated_at': datetime.utcnow()
        }
        
        if audit_context:
            update_data['updated_by'] = audit_context.get('user_id')
        
        expired = self.session.query(DiscountConfiguration).filter(
            DiscountConfiguration.is_active == True,
            DiscountConfiguration.valid_to.isnot(None),
            DiscountConfiguration.valid_to < check_date,
            DiscountConfiguration.deleted_at.is_(None)
        ).update(update_data, synchronize_session=False)
        
        self.session.flush()
        return expired
    
    # ============================================================
    # Validation Helpers
    # ============================================================
    
    def _validate_discount(
        self,
        discount_type: str,
        applies_to: str,
        data: Dict[str, Any]
    ) -> None:
        """Validate discount configuration."""
        valid_types = ['percentage', 'fixed_amount', 'waiver']
        if discount_type not in valid_types:
            raise ValidationException(
                f"Invalid discount_type. Must be one of: {', '.join(valid_types)}"
            )
        
        valid_applies_to = ['base_rent', 'mess_charges', 'total', 'security_deposit']
        if applies_to not in valid_applies_to:
            raise ValidationException(
                f"Invalid applies_to. Must be one of: {', '.join(valid_applies_to)}"
            )
        
        # Validate discount value
        discount_percentage = data.get('discount_percentage')
        discount_amount = data.get('discount_amount')
        
        if discount_type == 'percentage':
            if not discount_percentage:
                raise ValidationException("discount_percentage required for percentage type")
            if discount_percentage < Decimal('0') or discount_percentage > Decimal('100'):
                raise ValidationException("discount_percentage must be between 0 and 100")
            if discount_amount:
                raise ValidationException("Cannot specify both discount_percentage and discount_amount")
        
        elif discount_type == 'fixed_amount':
            if not discount_amount:
                raise ValidationException("discount_amount required for fixed_amount type")
            if discount_amount < Decimal('0'):
                raise ValidationException("discount_amount cannot be negative")
            if discount_percentage:
                raise ValidationException("Cannot specify both discount_percentage and discount_amount")
        
        # Validate date range
        valid_from = data.get('valid_from')
        valid_to = data.get('valid_to')
        if valid_from and valid_to and valid_to <= valid_from:
            raise ValidationException("valid_to must be after valid_from")
        
        # Validate usage limits
        max_usage = data.get('max_usage_count')
        if max_usage is not None and max_usage <= 0:
            raise ValidationException("max_usage_count must be positive")
        
        # Validate minimum stay
        min_stay = data.get('minimum_stay_months')
        if min_stay is not None and min_stay < 1:
            raise ValidationException("minimum_stay_months must be at least 1")
    
    def _check_duplicate_code(
        self,
        discount_code: str,
        exclude_id: Optional[UUID]
    ) -> None:
        """Check for duplicate discount codes."""
        query = self.session.query(DiscountConfiguration).filter(
            DiscountConfiguration.discount_code == discount_code,
            DiscountConfiguration.deleted_at.is_(None)
        )
        
        if exclude_id:
            query = query.filter(DiscountConfiguration.id != exclude_id)
        
        if query.first():
            raise ConflictException(f"Discount code '{discount_code}' already exists")
    
    def _apply_audit(
        self,
        entity: DiscountConfiguration,
        audit_context: Dict[str, Any],
        is_update: bool = False
    ) -> None:
        """Apply audit information to entity."""
        user_id = audit_context.get('user_id')
        
        if is_update:
            entity.updated_by = user_id
            entity.updated_at = datetime.utcnow()
        else:
            entity.created_by = user_id
            entity.created_at = datetime.utcnow()

# --- File: C:\Hostel-Main\app\repositories\fee_structure\fee_aggregate_repository.py ---
# --- File: C:\Hostel-Main\app\repositories\fee_structure\fee_aggregate_repository.py ---
"""
Fee Aggregate Repository

Provides aggregated queries and analytics across all fee structure entities.
Combines data from fee structures, components, calculations, and discounts.
"""

from datetime import date as Date, datetime
from decimal import Decimal
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID

from sqlalchemy import and_, or_, func, case, select, desc, distinct
from sqlalchemy.orm import Session, joinedload

from app.models.fee_structure.fee_structure import FeeStructure
from app.models.fee_structure.charge_component import (
    ChargeComponent,
    DiscountConfiguration,
)
from app.models.fee_structure.fee_calculation import FeeCalculation
from app.models.base.enums import RoomType, FeeType
from app.repositories.base.base_repository import BaseRepository


class FeeAggregateRepository:
    """
    Fee Aggregate Repository
    
    Provides complex aggregated queries and analytics that span
    multiple fee structure entities.
    """
    
    def __init__(self, session: Session):
        self.session = session
    
    # ============================================================
    # Comprehensive Fee Structure Analytics
    # ============================================================
    
    def get_hostel_fee_summary(
        self,
        hostel_id: UUID,
        as_of_date: Optional[Date] = None
    ) -> Dict[str, Any]:
        """
        Get comprehensive fee summary for a hostel.
        
        Args:
            hostel_id: Hostel identifier
            as_of_date: Date to check (defaults to today)
            
        Returns:
            Dictionary with comprehensive fee summary
        """
        check_date = as_of_date or Date.today()
        
        # Get fee structures
        fee_structures = self.session.query(FeeStructure).filter(
            FeeStructure.hostel_id == hostel_id,
            FeeStructure.is_active == True,
            FeeStructure.effective_from <= check_date,
            or_(
                FeeStructure.effective_to.is_(None),
                FeeStructure.effective_to >= check_date
            ),
            FeeStructure.deleted_at.is_(None)
        ).all()
        
        # Calculate statistics
        by_room_type = {}
        for fs in fee_structures:
            room_type = fs.room_type.value
            if room_type not in by_room_type:
                by_room_type[room_type] = []
            
            # Get component count
            component_count = self.session.query(func.count(ChargeComponent.id)).filter(
                ChargeComponent.fee_structure_id == fs.id,
                ChargeComponent.deleted_at.is_(None)
            ).scalar()
            
            by_room_type[room_type].append({
                'fee_structure_id': str(fs.id),
                'fee_type': fs.fee_type.value,
                'amount': float(fs.amount),
                'security_deposit': float(fs.security_deposit),
                'monthly_minimum': float(fs.monthly_total_minimum),
                'includes_mess': fs.includes_mess,
                'component_count': component_count,
                'effective_from': fs.effective_from.isoformat(),
                'effective_to': fs.effective_to.isoformat() if fs.effective_to else None
            })
        
        return {
            'hostel_id': str(hostel_id),
            'as_of_date': check_date.isoformat(),
            'total_fee_structures': len(fee_structures),
            'by_room_type': by_room_type,
            'room_types_available': list(by_room_type.keys())
        }
    
    def get_pricing_analytics(
        self,
        hostel_ids: Optional[List[UUID]] = None,
        room_type: Optional[RoomType] = None,
        as_of_date: Optional[Date] = None
    ) -> Dict[str, Any]:
        """
        Get comprehensive pricing analytics.
        
        Args:
            hostel_ids: Optional list of hostel IDs
            room_type: Optional room type filter
            as_of_date: Date to check
            
        Returns:
            Dictionary with pricing analytics
        """
        check_date = as_of_date or Date.today()
        
        query = self.session.query(
            func.count(distinct(FeeStructure.hostel_id)).label('hostel_count'),
            func.count(FeeStructure.id).label('structure_count'),
            func.avg(FeeStructure.amount).label('avg_amount'),
            func.min(FeeStructure.amount).label('min_amount'),
            func.max(FeeStructure.amount).label('max_amount'),
            func.avg(FeeStructure.security_deposit).label('avg_deposit'),
            func.avg(FeeStructure.mess_charges_monthly).label('avg_mess'),
            func.sum(case(
                (FeeStructure.includes_mess == True, 1),
                else_=0
            )).label('includes_mess_count'),
            func.sum(case(
                (FeeStructure.electricity_charges == 'INCLUDED', 1),
                else_=0
            )).label('electricity_included_count'),
            func.sum(case(
                (FeeStructure.water_charges == 'INCLUDED', 1),
                else_=0
            )).label('water_included_count')
        ).filter(
            FeeStructure.is_active == True,
            FeeStructure.effective_from <= check_date,
            or_(
                FeeStructure.effective_to.is_(None),
                FeeStructure.effective_to >= check_date
            ),
            FeeStructure.deleted_at.is_(None)
        )
        
        if hostel_ids:
            query = query.filter(FeeStructure.hostel_id.in_(hostel_ids))
        
        if room_type:
            query = query.filter(FeeStructure.room_type == room_type)
        
        result = query.first()
        
        return {
            'hostel_count': result.hostel_count or 0,
            'fee_structure_count': result.structure_count or 0,
            'average_rent': float(result.avg_amount or 0),
            'minimum_rent': float(result.min_amount or 0),
            'maximum_rent': float(result.max_amount or 0),
            'average_security_deposit': float(result.avg_deposit or 0),
            'average_mess_charges': float(result.avg_mess or 0),
            'includes_mess_count': result.includes_mess_count or 0,
            'electricity_included_count': result.electricity_included_count or 0,
            'water_included_count': result.water_included_count or 0,
            'as_of_date': check_date.isoformat()
        }
    
    def get_component_analytics(
        self,
        hostel_id: Optional[UUID] = None,
        component_type: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Get analytics on charge components.
        
        Args:
            hostel_id: Optional hostel filter
            component_type: Optional component type filter
            
        Returns:
            Dictionary with component analytics
        """
        query = self.session.query(
            ChargeComponent.component_type,
            func.count(ChargeComponent.id).label('count'),
            func.avg(ChargeComponent.amount).label('avg_amount'),
            func.sum(ChargeComponent.amount).label('total_amount'),
            func.sum(case(
                (ChargeComponent.is_mandatory == True, 1),
                else_=0
            )).label('mandatory_count'),
            func.sum(case(
                (ChargeComponent.is_taxable == True, 1),
                else_=0
            )).label('taxable_count'),
            func.avg(ChargeComponent.tax_percentage).label('avg_tax_rate')
        ).filter(
            ChargeComponent.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.join(FeeStructure).filter(
                FeeStructure.hostel_id == hostel_id
            )
        
        if component_type:
            query = query.filter(ChargeComponent.component_type == component_type)
        
        query = query.group_by(ChargeComponent.component_type)
        
        results = query.all()
        
        by_type = {}
        total_components = 0
        total_amount = Decimal('0')
        
        for r in results:
            by_type[r.component_type] = {
                'count': r.count,
                'average_amount': float(r.avg_amount or 0),
                'total_amount': float(r.total_amount or 0),
                'mandatory_count': r.mandatory_count or 0,
                'taxable_count': r.taxable_count or 0,
                'average_tax_rate': float(r.avg_tax_rate or 0)
            }
            total_components += r.count
            total_amount += (r.total_amount or Decimal('0'))
        
        return {
            'total_components': total_components,
            'total_amount': float(total_amount),
            'by_type': by_type,
            'unique_types': len(by_type)
        }
    
    def get_discount_analytics(
        self,
        hostel_id: Optional[UUID] = None,
        start_date: Optional[Date] = None,
        end_date: Optional[Date] = None
    ) -> Dict[str, Any]:
        """
        Get comprehensive discount analytics.
        
        Args:
            hostel_id: Optional hostel filter
            start_date: Optional start date
            end_date: Optional end date
            
        Returns:
            Dictionary with discount analytics
        """
        # Discount configuration stats
        discount_query = self.session.query(
            func.count(DiscountConfiguration.id).label('total_discounts'),
            func.sum(case(
                (DiscountConfiguration.is_active == True, 1),
                else_=0
            )).label('active_discounts'),
            func.sum(DiscountConfiguration.current_usage_count).label('total_usage'),
            func.avg(DiscountConfiguration.discount_percentage).label('avg_percentage'),
            func.sum(case(
                (DiscountConfiguration.discount_type == 'percentage', 1),
                else_=0
            )).label('percentage_type_count'),
            func.sum(case(
                (DiscountConfiguration.discount_type == 'fixed_amount', 1),
                else_=0
            )).label('fixed_type_count')
        ).filter(
            DiscountConfiguration.deleted_at.is_(None)
        )
        
        if hostel_id:
            discount_query = discount_query.filter(
                or_(
                    DiscountConfiguration.hostel_ids.is_(None),
                    DiscountConfiguration.hostel_ids.like(f'%{hostel_id}%')
                )
            )
        
        discount_result = discount_query.first()
        
        # Calculation discount stats
        calc_query = self.session.query(
            func.count(FeeCalculation.id).label('total_calculations'),
            func.sum(case(
                (FeeCalculation.discount_applied > 0, 1),
                else_=0
            )).label('calculations_with_discount'),
            func.sum(FeeCalculation.discount_applied).label('total_discount_amount'),
            func.avg(FeeCalculation.discount_applied).label('avg_discount_amount')
        )
        
        if start_date:
            calc_query = calc_query.filter(FeeCalculation.calculation_date >= start_date)
        
        if end_date:
            calc_query = calc_query.filter(FeeCalculation.calculation_date <= end_date)
        
        calc_result = calc_query.first()
        
        return {
            'discount_configurations': {
                'total': discount_result.total_discounts or 0,
                'active': discount_result.active_discounts or 0,
                'total_usage': discount_result.total_usage or 0,
                'average_percentage': float(discount_result.avg_percentage or 0),
                'percentage_type_count': discount_result.percentage_type_count or 0,
                'fixed_type_count': discount_result.fixed_type_count or 0
            },
            'discount_application': {
                'total_calculations': calc_result.total_calculations or 0,
                'calculations_with_discount': calc_result.calculations_with_discount or 0,
                'usage_rate': (calc_result.calculations_with_discount / calc_result.total_calculations * 100)
                            if calc_result.total_calculations else 0,
                'total_discount_given': float(calc_result.total_discount_amount or 0),
                'average_discount': float(calc_result.avg_discount_amount or 0)
            }
        }
    
    # ============================================================
    # Revenue and Financial Analytics
    # ============================================================
    
    def get_revenue_summary(
        self,
        hostel_id: Optional[UUID] = None,
        start_date: Optional[Date] = None,
        end_date: Optional[Date] = None
    ) -> Dict[str, Any]:
        """
        Get comprehensive revenue summary from calculations.
        
        Args:
            hostel_id: Optional hostel filter
            start_date: Optional start date
            end_date: Optional end date
            
        Returns:
            Dictionary with revenue summary
        """
        query = self.session.query(
            func.count(FeeCalculation.id).label('total_calculations'),
            func.sum(FeeCalculation.total_payable).label('total_revenue'),
            func.sum(FeeCalculation.security_deposit).label('total_deposits'),
            func.sum(FeeCalculation.monthly_recurring).label('total_recurring'),
            func.sum(FeeCalculation.discount_applied).label('total_discounts'),
            func.sum(FeeCalculation.tax_amount).label('total_tax'),
            func.avg(FeeCalculation.total_payable).label('avg_revenue'),
            func.sum(case(
                (FeeCalculation.is_approved == True, FeeCalculation.total_payable),
                else_=0
            )).label('approved_revenue')
        )
        
        if hostel_id:
            query = query.join(FeeStructure).filter(
                FeeStructure.hostel_id == hostel_id
            )
        
        if start_date:
            query = query.filter(FeeCalculation.calculation_date >= start_date)
        
        if end_date:
            query = query.filter(FeeCalculation.calculation_date <= end_date)
        
        result = query.first()
        
        total_revenue = float(result.total_revenue or 0)
        total_discounts = float(result.total_discounts or 0)
        
        return {
            'total_calculations': result.total_calculations or 0,
            'total_revenue': total_revenue,
            'total_deposits_collected': float(result.total_deposits or 0),
            'total_recurring_revenue': float(result.total_recurring or 0),
            'total_discounts_given': total_discounts,
            'total_tax_collected': float(result.total_tax or 0),
            'average_revenue_per_calculation': float(result.avg_revenue or 0),
            'approved_revenue': float(result.approved_revenue or 0),
            'discount_percentage_of_revenue': (total_discounts / total_revenue * 100) 
                                             if total_revenue else 0,
            'period': {
                'start_date': start_date.isoformat() if start_date else None,
                'end_date': end_date.isoformat() if end_date else None
            }
        }
    
    def get_revenue_by_room_type(
        self,
        hostel_id: Optional[UUID] = None,
        start_date: Optional[Date] = None,
        end_date: Optional[Date] = None
    ) -> Dict[str, Any]:
        """
        Get revenue breakdown by room type.
        
        Args:
            hostel_id: Optional hostel filter
            start_date: Optional start date
            end_date: Optional end date
            
        Returns:
            Dictionary with revenue by room type
        """
        query = self.session.query(
            FeeCalculation.room_type,
            func.count(FeeCalculation.id).label('count'),
            func.sum(FeeCalculation.total_payable).label('total_revenue'),
            func.avg(FeeCalculation.total_payable).label('avg_revenue'),
            func.sum(FeeCalculation.discount_applied).label('total_discount')
        )
        
        if hostel_id:
            query = query.join(FeeStructure).filter(
                FeeStructure.hostel_id == hostel_id
            )
        
        if start_date:
            query = query.filter(FeeCalculation.calculation_date >= start_date)
        
        if end_date:
            query = query.filter(FeeCalculation.calculation_date <= end_date)
        
        query = query.group_by(FeeCalculation.room_type)
        
        results = query.all()
        
        by_room_type = {}
        total_revenue = Decimal('0')
        
        for r in results:
            revenue = float(r.total_revenue or 0)
            by_room_type[r.room_type] = {
                'calculation_count': r.count,
                'total_revenue': revenue,
                'average_revenue': float(r.avg_revenue or 0),
                'total_discount': float(r.total_discount or 0)
            }
            total_revenue += (r.total_revenue or Decimal('0'))
        
        # Calculate percentages
        for room_type, data in by_room_type.items():
            data['revenue_percentage'] = (data['total_revenue'] / float(total_revenue) * 100) \
                                        if total_revenue else 0
        
        return {
            'total_revenue': float(total_revenue),
            'by_room_type': by_room_type,
            'room_types': list(by_room_type.keys())
        }
    
    def get_monthly_revenue_trend(
        self,
        hostel_id: Optional[UUID] = None,
        months: int = 12
    ) -> List[Dict[str, Any]]:
        """
        Get monthly revenue trends.
        
        Args:
            hostel_id: Optional hostel filter
            months: Number of months to analyze
            
        Returns:
            List of monthly revenue data
        """
        start_date = Date.fromordinal(Date.today().toordinal() - (months * 30))
        
        query = self.session.query(
            func.date_trunc('month', FeeCalculation.calculation_date).label('month'),
            func.count(FeeCalculation.id).label('count'),
            func.sum(FeeCalculation.total_payable).label('revenue'),
            func.sum(FeeCalculation.discount_applied).label('discount'),
            func.avg(FeeCalculation.total_payable).label('avg_revenue')
        ).filter(
            FeeCalculation.calculation_date >= start_date
        )
        
        if hostel_id:
            query = query.join(FeeStructure).filter(
                FeeStructure.hostel_id == hostel_id
            )
        
        query = query.group_by(
            func.date_trunc('month', FeeCalculation.calculation_date)
        ).order_by(
            func.date_trunc('month', FeeCalculation.calculation_date)
        )
        
        results = query.all()
        
        return [
            {
                'month': r.month.isoformat() if r.month else None,
                'calculation_count': r.count,
                'total_revenue': float(r.revenue or 0),
                'total_discount': float(r.discount or 0),
                'average_revenue': float(r.avg_revenue or 0),
                'net_revenue': float((r.revenue or 0) - (r.discount or 0))
            }
            for r in results
        ]
    
    # ============================================================
    # Comparative Analytics
    # ============================================================
    
    def compare_fee_structures(
        self,
        fee_structure_ids: List[UUID]
    ) -> List[Dict[str, Any]]:
        """
        Compare multiple fee structures.
        
        Args:
            fee_structure_ids: List of fee structure IDs to compare
            
        Returns:
            List of fee structure comparisons
        """
        fee_structures = self.session.query(FeeStructure).filter(
            FeeStructure.id.in_(fee_structure_ids),
            FeeStructure.deleted_at.is_(None)
        ).all()
        
        comparisons = []
        
        for fs in fee_structures:
            # Get component count and total
            component_stats = self.session.query(
                func.count(ChargeComponent.id).label('count'),
                func.sum(ChargeComponent.amount).label('total')
            ).filter(
                ChargeComponent.fee_structure_id == fs.id,
                ChargeComponent.deleted_at.is_(None)
            ).first()
            
            # Get calculation stats
            calc_stats = self.session.query(
                func.count(FeeCalculation.id).label('count'),
                func.avg(FeeCalculation.total_payable).label('avg_total')
            ).filter(
                FeeCalculation.fee_structure_id == fs.id
            ).first()
            
            comparisons.append({
                'fee_structure_id': str(fs.id),
                'hostel_id': str(fs.hostel_id),
                'room_type': fs.room_type.value,
                'fee_type': fs.fee_type.value,
                'base_amount': float(fs.amount),
                'security_deposit': float(fs.security_deposit),
                'monthly_minimum': float(fs.monthly_total_minimum),
                'includes_mess': fs.includes_mess,
                'all_inclusive': fs.is_all_inclusive,
                'component_count': component_stats.count or 0,
                'component_total': float(component_stats.total or 0),
                'calculation_count': calc_stats.count or 0,
                'average_total_payable': float(calc_stats.avg_total or 0),
                'effective_from': fs.effective_from.isoformat(),
                'is_active': fs.is_active
            })
        
        return comparisons
    
    def get_market_positioning(
        self,
        hostel_id: UUID,
        room_type: RoomType
    ) -> Dict[str, Any]:
        """
        Analyze market positioning for a hostel's room type.
        
        Args:
            hostel_id: Hostel identifier
            room_type: Room type to analyze
            
        Returns:
            Dictionary with market positioning analysis
        """
        # Get hostel's pricing
        hostel_fs = self.session.query(FeeStructure).filter(
            FeeStructure.hostel_id == hostel_id,
            FeeStructure.room_type == room_type,
            FeeStructure.is_active == True,
            FeeStructure.deleted_at.is_(None)
        ).first()
        
        if not hostel_fs:
            return {'error': 'No active fee structure found'}
        
        # Get market statistics
        market_stats = self.session.query(
            func.count(FeeStructure.id).label('competitor_count'),
            func.avg(FeeStructure.amount).label('market_avg'),
            func.min(FeeStructure.amount).label('market_min'),
            func.max(FeeStructure.amount).label('market_max'),
            func.percentile_cont(0.25).within_group(FeeStructure.amount).label('percentile_25'),
            func.percentile_cont(0.50).within_group(FeeStructure.amount).label('percentile_50'),
            func.percentile_cont(0.75).within_group(FeeStructure.amount).label('percentile_75')
        ).filter(
            FeeStructure.room_type == room_type,
            FeeStructure.is_active == True,
            FeeStructure.deleted_at.is_(None),
            FeeStructure.hostel_id != hostel_id  # Exclude self
        ).first()
        
        hostel_amount = float(hostel_fs.amount)
        market_avg = float(market_stats.market_avg or 0)
        
        return {
            'hostel_id': str(hostel_id),
            'room_type': room_type.value,
            'hostel_amount': hostel_amount,
            'market_statistics': {
                'competitor_count': market_stats.competitor_count or 0,
                'average': market_avg,
                'minimum': float(market_stats.market_min or 0),
                'maximum': float(market_stats.market_max or 0),
                'percentile_25': float(market_stats.percentile_25 or 0),
                'percentile_50': float(market_stats.percentile_50 or 0),
                'percentile_75': float(market_stats.percentile_75 or 0)
            },
            'positioning': {
                'difference_from_average': hostel_amount - market_avg,
                'percentage_of_average': (hostel_amount / market_avg * 100) if market_avg else 0,
                'is_below_market': hostel_amount < market_avg,
                'is_above_market': hostel_amount > market_avg,
                'percentile_position': self._calculate_percentile_position(
                    hostel_amount,
                    float(market_stats.percentile_25 or 0),
                    float(market_stats.percentile_50 or 0),
                    float(market_stats.percentile_75 or 0)
                )
            }
        }
    
    # ============================================================
    # Helper Methods
    # ============================================================
    
    def _calculate_percentile_position(
        self,
        value: float,
        p25: float,
        p50: float,
        p75: float
    ) -> str:
        """Calculate which percentile range a value falls into."""
        if value < p25:
            return 'bottom_quartile'
        elif value < p50:
            return 'below_median'
        elif value < p75:
            return 'above_median'
        else:
            return 'top_quartile'

# --- File: C:\Hostel-Main\app\repositories\fee_structure\fee_calculation_repository.py ---
# --- File: C:\Hostel-Main\app\repositories\fee_structure\fee_calculation_repository.py ---
"""
Fee Calculation Repository

Manages fee calculations, estimates, and projections with comprehensive
calculation logic and historical tracking.
"""

from datetime import date as Date, datetime
from decimal import Decimal
from typing import List, Optional, Dict, Any
from uuid import UUID

from sqlalchemy import and_, or_, func, case, select, desc
from sqlalchemy.orm import Session, joinedload, selectinload

from app.models.fee_structure.fee_calculation import FeeCalculation, FeeProjection
from app.models.base.enums import RoomType, FeeType
from app.repositories.base.base_repository import BaseRepository
from app.core.exceptions import (
    NotFoundException,
    ValidationException,
)


class FeeCalculationRepository(BaseRepository[FeeCalculation]):
    """
    Fee Calculation Repository
    
    Manages fee calculations with comprehensive querying,
    analytics, and historical tracking capabilities.
    """
    
    def __init__(self, session: Session):
        super().__init__(FeeCalculation, session)
    
    # ============================================================
    # Core CRUD Operations
    # ============================================================
    
    def create_fee_calculation(
        self,
        fee_structure_id: UUID,
        calculation_type: str,
        room_type: RoomType,
        fee_type: FeeType,
        stay_duration_months: int,
        move_in_date: Date,
        monthly_rent: Decimal,
        security_deposit: Decimal,
        audit_context: Dict[str, Any],
        **kwargs
    ) -> FeeCalculation:
        """
        Create a new fee calculation.
        
        Args:
            fee_structure_id: Fee structure identifier
            calculation_type: Type of calculation
            room_type: Room type
            fee_type: Fee type
            stay_duration_months: Duration in months
            move_in_date: Move-in date
            monthly_rent: Monthly rent amount
            security_deposit: Security deposit amount
            audit_context: Audit information
            **kwargs: Additional calculation attributes
            
        Returns:
            Created FeeCalculation instance
        """
        self._validate_calculation(
            calculation_type,
            stay_duration_months,
            monthly_rent,
            security_deposit,
            kwargs
        )
        
        # Calculate totals
        subtotal, total_payable, first_month_total, monthly_recurring = self._calculate_totals(
            monthly_rent=monthly_rent,
            security_deposit=security_deposit,
            stay_duration_months=stay_duration_months,
            mess_charges=kwargs.get('mess_charges_total', Decimal('0')),
            utility_charges=kwargs.get('utility_charges_estimated', Decimal('0')),
            other_charges=kwargs.get('other_charges', Decimal('0')),
            discount=kwargs.get('discount_applied', Decimal('0')),
            tax_percentage=kwargs.get('tax_percentage', Decimal('0'))
        )
        
        calculation = FeeCalculation(
            fee_structure_id=fee_structure_id,
            calculation_type=calculation_type,
            room_type=room_type,
            fee_type=fee_type,
            stay_duration_months=stay_duration_months,
            move_in_date=move_in_date,
            monthly_rent=monthly_rent,
            security_deposit=security_deposit,
            subtotal=subtotal,
            total_payable=total_payable,
            first_month_total=first_month_total,
            monthly_recurring=monthly_recurring,
            calculation_date=Date.today(),
            **kwargs
        )
        
        self._apply_audit(calculation, audit_context)
        self.session.add(calculation)
        self.session.flush()
        
        return calculation
    
    # ============================================================
    # Query Operations
    # ============================================================
    
    def find_by_student(
        self,
        student_id: UUID,
        calculation_type: Optional[str] = None,
        start_date: Optional[Date] = None,
        end_date: Optional[Date] = None
    ) -> List[FeeCalculation]:
        """
        Find all fee calculations for a student.
        
        Args:
            student_id: Student identifier
            calculation_type: Optional calculation type filter
            start_date: Optional start date filter
            end_date: Optional end date filter
            
        Returns:
            List of FeeCalculation instances
        """
        query = self.session.query(FeeCalculation).filter(
            FeeCalculation.student_id == student_id
        )
        
        if calculation_type:
            query = query.filter(FeeCalculation.calculation_type == calculation_type)
        
        if start_date:
            query = query.filter(FeeCalculation.calculation_date >= start_date)
        
        if end_date:
            query = query.filter(FeeCalculation.calculation_date <= end_date)
        
        return query.order_by(FeeCalculation.calculation_date.desc()).all()
    
    def find_by_booking(
        self,
        booking_id: UUID
    ) -> List[FeeCalculation]:
        """
        Find all fee calculations for a booking.
        
        Args:
            booking_id: Booking identifier
            
        Returns:
            List of FeeCalculation instances
        """
        return self.session.query(FeeCalculation).filter(
            FeeCalculation.booking_id == booking_id
        ).order_by(FeeCalculation.calculation_date.desc()).all()
    
    def find_by_fee_structure(
        self,
        fee_structure_id: UUID,
        calculation_type: Optional[str] = None,
        limit: Optional[int] = None
    ) -> List[FeeCalculation]:
        """
        Find calculations for a specific fee structure.
        
        Args:
            fee_structure_id: Fee structure identifier
            calculation_type: Optional calculation type filter
            limit: Optional result limit
            
        Returns:
            List of FeeCalculation instances
        """
        query = self.session.query(FeeCalculation).filter(
            FeeCalculation.fee_structure_id == fee_structure_id
        )
        
        if calculation_type:
            query = query.filter(FeeCalculation.calculation_type == calculation_type)
        
        query = query.order_by(FeeCalculation.calculation_date.desc())
        
        if limit:
            query = query.limit(limit)
        
        return query.all()
    
    def get_latest_calculation(
        self,
        student_id: Optional[UUID] = None,
        booking_id: Optional[UUID] = None
    ) -> Optional[FeeCalculation]:
        """
        Get the most recent calculation for a student or booking.
        
        Args:
            student_id: Optional student identifier
            booking_id: Optional booking identifier
            
        Returns:
            Latest FeeCalculation instance or None
        """
        query = self.session.query(FeeCalculation)
        
        if student_id:
            query = query.filter(FeeCalculation.student_id == student_id)
        elif booking_id:
            query = query.filter(FeeCalculation.booking_id == booking_id)
        else:
            return None
        
        return query.order_by(FeeCalculation.calculation_date.desc()).first()
    
    def find_pending_approval(
        self,
        fee_structure_id: Optional[UUID] = None
    ) -> List[FeeCalculation]:
        """
        Find calculations pending approval.
        
        Args:
            fee_structure_id: Optional fee structure filter
            
        Returns:
            List of pending FeeCalculation instances
        """
        query = self.session.query(FeeCalculation).filter(
            FeeCalculation.is_approved == False
        )
        
        if fee_structure_id:
            query = query.filter(FeeCalculation.fee_structure_id == fee_structure_id)
        
        return query.order_by(FeeCalculation.calculation_date.desc()).all()
    
    def find_approved_calculations(
        self,
        start_date: Optional[Date] = None,
        end_date: Optional[Date] = None,
        approved_by_id: Optional[UUID] = None
    ) -> List[FeeCalculation]:
        """
        Find approved calculations within date range.
        
        Args:
            start_date: Optional start date
            end_date: Optional end date
            approved_by_id: Optional approver filter
            
        Returns:
            List of approved FeeCalculation instances
        """
        query = self.session.query(FeeCalculation).filter(
            FeeCalculation.is_approved == True
        )
        
        if start_date:
            query = query.filter(FeeCalculation.approved_at >= start_date)
        
        if end_date:
            query = query.filter(FeeCalculation.approved_at <= end_date)
        
        if approved_by_id:
            query = query.filter(FeeCalculation.approved_by_id == approved_by_id)
        
        return query.order_by(FeeCalculation.approved_at.desc()).all()
    
    def find_prorated_calculations(
        self,
        fee_structure_id: Optional[UUID] = None
    ) -> List[FeeCalculation]:
        """
        Find all prorated fee calculations.
        
        Args:
            fee_structure_id: Optional fee structure filter
            
        Returns:
            List of prorated FeeCalculation instances
        """
        query = self.session.query(FeeCalculation).filter(
            FeeCalculation.is_prorated == True
        )
        
        if fee_structure_id:
            query = query.filter(FeeCalculation.fee_structure_id == fee_structure_id)
        
        return query.order_by(FeeCalculation.calculation_date.desc()).all()
    
    def get_calculation_with_details(
        self,
        calculation_id: UUID
    ) -> Optional[FeeCalculation]:
        """
        Get calculation with all related entities loaded.
        
        Args:
            calculation_id: Calculation identifier
            
        Returns:
            FeeCalculation with related data or None
        """
        return self.session.query(FeeCalculation).options(
            joinedload(FeeCalculation.fee_structure),
            joinedload(FeeCalculation.student),
            joinedload(FeeCalculation.booking),
            joinedload(FeeCalculation.discount_config)
        ).filter(
            FeeCalculation.id == calculation_id
        ).first()
    
    # ============================================================
    # Approval Operations
    # ============================================================
    
    def approve_calculation(
        self,
        calculation_id: UUID,
        approved_by_id: UUID
    ) -> FeeCalculation:
        """
        Approve a fee calculation.
        
        Args:
            calculation_id: Calculation identifier
            approved_by_id: User approving the calculation
            
        Returns:
            Approved FeeCalculation instance
        """
        calculation = self.find_by_id(calculation_id)
        if not calculation:
            raise NotFoundException(f"Fee calculation {calculation_id} not found")
        
        calculation.is_approved = True
        calculation.approved_by_id = approved_by_id
        calculation.approved_at = datetime.utcnow()
        calculation.updated_at = datetime.utcnow()
        
        self.session.flush()
        return calculation
    
    def bulk_approve_calculations(
        self,
        calculation_ids: List[UUID],
        approved_by_id: UUID
    ) -> int:
        """
        Bulk approve multiple calculations.
        
        Args:
            calculation_ids: List of calculation IDs
            approved_by_id: User approving the calculations
            
        Returns:
            Number of calculations approved
        """
        approved = self.session.query(FeeCalculation).filter(
            FeeCalculation.id.in_(calculation_ids),
            FeeCalculation.is_approved == False
        ).update(
            {
                'is_approved': True,
                'approved_by_id': approved_by_id,
                'approved_at': datetime.utcnow(),
                'updated_at': datetime.utcnow()
            },
            synchronize_session=False
        )
        
        self.session.flush()
        return approved
    
    # ============================================================
    # Analytics and Reporting
    # ============================================================
    
    def get_calculation_statistics(
        self,
        fee_structure_id: Optional[UUID] = None,
        calculation_type: Optional[str] = None,
        start_date: Optional[Date] = None,
        end_date: Optional[Date] = None
    ) -> Dict[str, Any]:
        """
        Get statistical summary of calculations.
        
        Args:
            fee_structure_id: Optional fee structure filter
            calculation_type: Optional calculation type filter
            start_date: Optional start date
            end_date: Optional end date
            
        Returns:
            Dictionary with calculation statistics
        """
        query = self.session.query(
            func.count(FeeCalculation.id).label('total_calculations'),
            func.avg(FeeCalculation.total_payable).label('avg_total'),
            func.min(FeeCalculation.total_payable).label('min_total'),
            func.max(FeeCalculation.total_payable).label('max_total'),
            func.sum(FeeCalculation.total_payable).label('sum_total'),
            func.avg(FeeCalculation.discount_applied).label('avg_discount'),
            func.sum(FeeCalculation.discount_applied).label('total_discount'),
            func.sum(case(
                (FeeCalculation.is_approved == True, 1),
                else_=0
            )).label('approved_count'),
            func.sum(case(
                (FeeCalculation.is_prorated == True, 1),
                else_=0
            )).label('prorated_count')
        )
        
        if fee_structure_id:
            query = query.filter(FeeCalculation.fee_structure_id == fee_structure_id)
        
        if calculation_type:
            query = query.filter(FeeCalculation.calculation_type == calculation_type)
        
        if start_date:
            query = query.filter(FeeCalculation.calculation_date >= start_date)
        
        if end_date:
            query = query.filter(FeeCalculation.calculation_date <= end_date)
        
        result = query.first()
        
        return {
            'total_calculations': result.total_calculations or 0,
            'average_total': float(result.avg_total or 0),
            'minimum_total': float(result.min_total or 0),
            'maximum_total': float(result.max_total or 0),
            'sum_total': float(result.sum_total or 0),
            'average_discount': float(result.avg_discount or 0),
            'total_discount': float(result.total_discount or 0),
            'approved_count': result.approved_count or 0,
            'prorated_count': result.prorated_count or 0,
            'approval_rate': (result.approved_count / result.total_calculations * 100) 
                           if result.total_calculations else 0
        }
    
    def get_revenue_projection(
        self,
        fee_structure_id: UUID,
        months_ahead: int = 12
    ) -> Dict[str, Any]:
        """
        Calculate revenue projection based on calculations.
        
        Args:
            fee_structure_id: Fee structure identifier
            months_ahead: Number of months to project
            
        Returns:
            Dictionary with revenue projections
        """
        # Get recent calculations
        recent = self.session.query(
            func.avg(FeeCalculation.monthly_recurring).label('avg_monthly'),
            func.count(FeeCalculation.id).label('calc_count')
        ).filter(
            FeeCalculation.fee_structure_id == fee_structure_id,
            FeeCalculation.calculation_date >= Date.fromordinal(
                Date.today().toordinal() - 90
            )  # Last 90 days
        ).first()
        
        avg_monthly = float(recent.avg_monthly or 0)
        
        return {
            'fee_structure_id': str(fee_structure_id),
            'projection_months': months_ahead,
            'average_monthly_recurring': avg_monthly,
            'projected_monthly_revenue': avg_monthly * (recent.calc_count or 0),
            'projected_total_revenue': avg_monthly * (recent.calc_count or 0) * months_ahead,
            'calculation_sample_size': recent.calc_count or 0
        }
    
    def get_discount_impact_analysis(
        self,
        start_date: Optional[Date] = None,
        end_date: Optional[Date] = None
    ) -> Dict[str, Any]:
        """
        Analyze impact of discounts on calculations.
        
        Args:
            start_date: Optional start date
            end_date: Optional end date
            
        Returns:
            Dictionary with discount impact analysis
        """
        query = self.session.query(
            func.count(FeeCalculation.id).label('total_calculations'),
            func.sum(case(
                (FeeCalculation.discount_applied > 0, 1),
                else_=0
            )).label('calculations_with_discount'),
            func.sum(FeeCalculation.discount_applied).label('total_discount'),
            func.sum(FeeCalculation.subtotal).label('total_before_discount'),
            func.avg(FeeCalculation.discount_applied).label('avg_discount')
        )
        
        if start_date:
            query = query.filter(FeeCalculation.calculation_date >= start_date)
        
        if end_date:
            query = query.filter(FeeCalculation.calculation_date <= end_date)
        
        result = query.first()
        
        total_calc = result.total_calculations or 0
        calc_with_discount = result.calculations_with_discount or 0
        total_discount = float(result.total_discount or 0)
        total_before = float(result.total_before_discount or 0)
        
        return {
            'total_calculations': total_calc,
            'calculations_with_discount': calc_with_discount,
            'discount_usage_rate': (calc_with_discount / total_calc * 100) if total_calc else 0,
            'total_discount_given': total_discount,
            'average_discount': float(result.avg_discount or 0),
            'discount_percentage_of_revenue': (total_discount / total_before * 100) if total_before else 0,
            'total_revenue_before_discount': total_before,
            'total_revenue_after_discount': total_before - total_discount
        }
    
    def get_calculation_trends(
        self,
        fee_structure_id: UUID,
        months: int = 6
    ) -> List[Dict[str, Any]]:
        """
        Get monthly calculation trends.
        
        Args:
            fee_structure_id: Fee structure identifier
            months: Number of months to analyze
            
        Returns:
            List of monthly trend data
        """
        start_date = Date.fromordinal(
            Date.today().toordinal() - (months * 30)
        )
        
        results = self.session.query(
            func.date_trunc('month', FeeCalculation.calculation_date).label('month'),
            func.count(FeeCalculation.id).label('count'),
            func.avg(FeeCalculation.total_payable).label('avg_total'),
            func.sum(FeeCalculation.total_payable).label('sum_total')
        ).filter(
            FeeCalculation.fee_structure_id == fee_structure_id,
            FeeCalculation.calculation_date >= start_date
        ).group_by(
            func.date_trunc('month', FeeCalculation.calculation_date)
        ).order_by(
            func.date_trunc('month', FeeCalculation.calculation_date)
        ).all()
        
        return [
            {
                'month': r.month.isoformat() if r.month else None,
                'calculation_count': r.count,
                'average_total': float(r.avg_total or 0),
                'total_revenue': float(r.sum_total or 0)
            }
            for r in results
        ]
    
    # ============================================================
    # Calculation Helpers
    # ============================================================
    
    def _calculate_totals(
        self,
        monthly_rent: Decimal,
        security_deposit: Decimal,
        stay_duration_months: int,
        mess_charges: Decimal,
        utility_charges: Decimal,
        other_charges: Decimal,
        discount: Decimal,
        tax_percentage: Decimal
    ) -> Tuple[Decimal, Decimal, Decimal, Decimal]:
        """
        Calculate total amounts for fee calculation.
        
        Returns:
            Tuple of (subtotal, total_payable, first_month_total, monthly_recurring)
        """
        # Monthly recurring charges
        monthly_recurring = monthly_rent + mess_charges + utility_charges
        
        # Total for stay duration
        total_for_duration = monthly_recurring * stay_duration_months
        
        # Subtotal before discount and tax
        subtotal = total_for_duration + security_deposit + other_charges
        
        # Apply discount
        amount_after_discount = subtotal - discount
        
        # Calculate tax
        tax_amount = (amount_after_discount * tax_percentage / 100).quantize(Decimal('0.01'))
        
        # Total payable
        total_payable = (amount_after_discount + tax_amount).quantize(Decimal('0.01'))
        
        # First month total (includes security deposit and one-time charges)
        first_month_total = (
            monthly_recurring + security_deposit + other_charges - discount + tax_amount
        ).quantize(Decimal('0.01'))
        
        return (
            subtotal.quantize(Decimal('0.01')),
            total_payable,
            first_month_total,
            monthly_recurring.quantize(Decimal('0.01'))
        )
    
    def _validate_calculation(
        self,
        calculation_type: str,
        stay_duration_months: int,
        monthly_rent: Decimal,
        security_deposit: Decimal,
        data: Dict[str, Any]
    ) -> None:
        """Validate calculation data."""
        valid_types = ['estimate', 'booking', 'student', 'renewal', 'modification']
        if calculation_type not in valid_types:
            raise ValidationException(
                f"Invalid calculation_type. Must be one of: {', '.join(valid_types)}"
            )
        
        if stay_duration_months < 1:
            raise ValidationException("stay_duration_months must be at least 1")
        
        if monthly_rent < Decimal('0'):
            raise ValidationException("monthly_rent cannot be negative")
        
        if security_deposit < Decimal('0'):
            raise ValidationException("security_deposit cannot be negative")
        
        move_in = data.get('move_in_date')
        move_out = data.get('move_out_date')
        if move_in and move_out and move_out <= move_in:
            raise ValidationException("move_out_date must be after move_in_date")
    
    def _apply_audit(
        self,
        entity: FeeCalculation,
        audit_context: Dict[str, Any],
        is_update: bool = False
    ) -> None:
        """Apply audit information to entity."""
        user_id = audit_context.get('user_id')
        
        if is_update:
            entity.updated_by = user_id
            entity.updated_at = datetime.utcnow()
        else:
            entity.calculated_by_id = user_id
            entity.created_at = datetime.utcnow()


class FeeProjectionRepository(BaseRepository[FeeProjection]):
    """
    Fee Projection Repository
    
    Manages fee projections and forecasting for future periods.
    """
    
    def __init__(self, session: Session):
        super().__init__(FeeProjection, session)
    
    # ============================================================
    # Core CRUD Operations
    # ============================================================
    
    def create_projection(
        self,
        fee_structure_id: UUID,
        projection_date: Date,
        projection_period_months: int,
        projected_revenue: Decimal,
        projected_occupancy: Decimal,
        projected_bookings: int,
        projection_model: str,
        audit_context: Dict[str, Any],
        **kwargs
    ) -> FeeProjection:
        """
        Create a new fee projection.
        
        Args:
            fee_structure_id: Fee structure identifier
            projection_date: Date of projection
            projection_period_months: Projection period
            projected_revenue: Projected revenue amount
            projected_occupancy: Projected occupancy percentage
            projected_bookings: Projected number of bookings
            projection_model: Model used for projection
            audit_context: Audit information
            **kwargs: Additional projection attributes
            
        Returns:
            Created FeeProjection instance
        """
        self._validate_projection(
            projection_period_months,
            projected_revenue,
            projected_occupancy,
            projected_bookings,
            kwargs
        )
        
        projection = FeeProjection(
            fee_structure_id=fee_structure_id,
            projection_date=projection_date,
            projection_period_months=projection_period_months,
            projected_revenue=projected_revenue,
            projected_occupancy=projected_occupancy,
            projected_bookings=projected_bookings,
            projection_model=projection_model,
            **kwargs
        )
        
        self._apply_audit(projection, audit_context)
        self.session.add(projection)
        self.session.flush()
        
        return projection
    
    # ============================================================
    # Query Operations
    # ============================================================
    
    def find_by_fee_structure(
        self,
        fee_structure_id: UUID,
        start_date: Optional[Date] = None,
        end_date: Optional[Date] = None
    ) -> List[FeeProjection]:
        """
        Find projections for a fee structure.
        
        Args:
            fee_structure_id: Fee structure identifier
            start_date: Optional start date filter
            end_date: Optional end date filter
            
        Returns:
            List of FeeProjection instances
        """
        query = self.session.query(FeeProjection).filter(
            FeeProjection.fee_structure_id == fee_structure_id
        )
        
        if start_date:
            query = query.filter(FeeProjection.projection_date >= start_date)
        
        if end_date:
            query = query.filter(FeeProjection.projection_date <= end_date)
        
        return query.order_by(FeeProjection.projection_date.desc()).all()
    
    def get_latest_projection(
        self,
        fee_structure_id: UUID
    ) -> Optional[FeeProjection]:
        """
        Get most recent projection for a fee structure.
        
        Args:
            fee_structure_id: Fee structure identifier
            
        Returns:
            Latest FeeProjection instance or None
        """
        return self.session.query(FeeProjection).filter(
            FeeProjection.fee_structure_id == fee_structure_id
        ).order_by(FeeProjection.projection_date.desc()).first()
    
    def find_by_period(
        self,
        projection_period_months: int,
        start_date: Optional[Date] = None
    ) -> List[FeeProjection]:
        """
        Find projections by period length.
        
        Args:
            projection_period_months: Period in months
            start_date: Optional start date filter
            
        Returns:
            List of FeeProjection instances
        """
        query = self.session.query(FeeProjection).filter(
            FeeProjection.projection_period_months == projection_period_months
        )
        
        if start_date:
            query = query.filter(FeeProjection.projection_date >= start_date)
        
        return query.order_by(FeeProjection.projection_date.desc()).all()
    
    # ============================================================
    # Analytics
    # ============================================================
    
    def get_projection_accuracy(
        self,
        fee_structure_id: UUID,
        actual_revenue: Decimal,
        actual_occupancy: Decimal,
        projection_date: Date
    ) -> Dict[str, Any]:
        """
        Calculate accuracy of projections vs actuals.
        
        Args:
            fee_structure_id: Fee structure identifier
            actual_revenue: Actual revenue achieved
            actual_occupancy: Actual occupancy achieved
            projection_date: Date to compare
            
        Returns:
            Dictionary with accuracy metrics
        """
        projection = self.session.query(FeeProjection).filter(
            FeeProjection.fee_structure_id == fee_structure_id,
            FeeProjection.projection_date == projection_date
        ).first()
        
        if not projection:
            return {'error': 'No projection found for comparison'}
        
        revenue_variance = float(actual_revenue - projection.projected_revenue)
        revenue_variance_pct = (revenue_variance / float(projection.projected_revenue) * 100) \
                             if projection.projected_revenue > 0 else 0
        
        occupancy_variance = float(actual_occupancy - projection.projected_occupancy)
        
        return {
            'projection_date': projection_date.isoformat(),
            'projected_revenue': float(projection.projected_revenue),
            'actual_revenue': float(actual_revenue),
            'revenue_variance': revenue_variance,
            'revenue_variance_percentage': revenue_variance_pct,
            'projected_occupancy': float(projection.projected_occupancy),
            'actual_occupancy': float(actual_occupancy),
            'occupancy_variance': occupancy_variance,
            'projection_model': projection.projection_model,
            'confidence_level': float(projection.confidence_level) if projection.confidence_level else None
        }
    
    # ============================================================
    # Validation Helpers
    # ============================================================
    
    def _validate_projection(
        self,
        projection_period_months: int,
        projected_revenue: Decimal,
        projected_occupancy: Decimal,
        projected_bookings: int,
        data: Dict[str, Any]
    ) -> None:
        """Validate projection data."""
        if projection_period_months < 1:
            raise ValidationException("projection_period_months must be at least 1")
        
        if projected_revenue < Decimal('0'):
            raise ValidationException("projected_revenue cannot be negative")
        
        if projected_occupancy < Decimal('0') or projected_occupancy > Decimal('100'):
            raise ValidationException("projected_occupancy must be between 0 and 100")
        
        if projected_bookings < 0:
            raise ValidationException("projected_bookings cannot be negative")
        
        confidence = data.get('confidence_level')
        if confidence is not None:
            if confidence < Decimal('0') or confidence > Decimal('100'):
                raise ValidationException("confidence_level must be between 0 and 100")
    
    def _apply_audit(
        self,
        entity: FeeProjection,
        audit_context: Dict[str, Any]
    ) -> None:
        """Apply audit information to entity."""
        entity.created_at = datetime.utcnow()

# --- File: C:\Hostel-Main\app\repositories\fee_structure\fee_structure_repository.py ---
# --- File: C:\Hostel-Main\app\repositories\fee_structure\fee_structure_repository.py ---
"""
Fee Structure Repository

Manages fee structure CRUD operations, versioning, approval workflows,
and complex queries for pricing management.
"""

from datetime import date as Date, datetime
from decimal import Decimal
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID

from sqlalchemy import and_, or_, func, case, exists, select
from sqlalchemy.orm import Session, joinedload, selectinload

from app.models.fee_structure.fee_structure import FeeStructure, FeeApproval
from app.models.base.enums import RoomType, FeeType, ChargeType
from app.repositories.base.base_repository import BaseRepository
from app.repositories.base.specifications import Specification
from app.core.exceptions import (
    NotFoundException,
    ValidationException,
    ConflictException,
)


class FeeStructureRepository(BaseRepository[FeeStructure]):
    """
    Fee Structure Repository
    
    Provides comprehensive fee structure management with versioning,
    validation, and complex querying capabilities.
    """
    
    def __init__(self, session: Session):
        super().__init__(FeeStructure, session)
    
    # ============================================================
    # Core CRUD Operations with Business Logic
    # ============================================================
    
    def create_fee_structure(
        self,
        hostel_id: UUID,
        room_type: RoomType,
        fee_type: FeeType,
        amount: Decimal,
        security_deposit: Decimal,
        effective_from: Date,
        audit_context: Dict[str, Any],
        **kwargs
    ) -> FeeStructure:
        """
        Create new fee structure with validation and conflict checking.
        
        Args:
            hostel_id: Hostel identifier
            room_type: Room type enum
            fee_type: Fee type enum
            amount: Base fee amount
            security_deposit: Security deposit amount
            effective_from: Effective start date
            audit_context: Audit information
            **kwargs: Additional fee structure attributes
            
        Returns:
            Created FeeStructure instance
            
        Raises:
            ValidationException: If validation fails
            ConflictException: If overlapping active fee structure exists
        """
        # Validate amounts
        self._validate_amounts(amount, security_deposit, kwargs)
        
        # Check for overlapping fee structures
        self._check_for_overlaps(
            hostel_id=hostel_id,
            room_type=room_type,
            fee_type=fee_type,
            effective_from=effective_from,
            effective_to=kwargs.get('effective_to'),
            exclude_id=None
        )
        
        # Auto-deactivate previous fee structures
        self._deactivate_previous_structures(
            hostel_id=hostel_id,
            room_type=room_type,
            fee_type=fee_type,
            effective_from=effective_from
        )
        
        # Create fee structure
        fee_structure = FeeStructure(
            hostel_id=hostel_id,
            room_type=room_type,
            fee_type=fee_type,
            amount=amount,
            security_deposit=security_deposit,
            effective_from=effective_from,
            is_active=True,
            version=1,
            **kwargs
        )
        
        # Apply audit context
        self._apply_audit(fee_structure, audit_context)
        
        self.session.add(fee_structure)
        self.session.flush()
        
        return fee_structure
    
    def update_fee_structure(
        self,
        fee_structure_id: UUID,
        update_data: Dict[str, Any],
        audit_context: Dict[str, Any],
        create_new_version: bool = True
    ) -> FeeStructure:
        """
        Update fee structure with versioning support.
        
        Args:
            fee_structure_id: Fee structure to update
            update_data: Fields to update
            audit_context: Audit information
            create_new_version: Whether to create new version or update in-place
            
        Returns:
            Updated or new FeeStructure instance
            
        Raises:
            NotFoundException: If fee structure not found
            ValidationException: If validation fails
        """
        fee_structure = self.find_by_id(fee_structure_id)
        if not fee_structure:
            raise NotFoundException(f"Fee structure {fee_structure_id} not found")
        
        # Validate update data
        if 'amount' in update_data or 'security_deposit' in update_data:
            self._validate_amounts(
                update_data.get('amount', fee_structure.amount),
                update_data.get('security_deposit', fee_structure.security_deposit),
                update_data
            )
        
        if create_new_version:
            # Create new version
            new_version = self._create_new_version(fee_structure, update_data, audit_context)
            return new_version
        else:
            # Update in-place
            for key, value in update_data.items():
                if hasattr(fee_structure, key):
                    setattr(fee_structure, key, value)
            
            self._apply_audit(fee_structure, audit_context, is_update=True)
            self.session.flush()
            
            return fee_structure
    
    # ============================================================
    # Query Operations
    # ============================================================
    
    def find_by_hostel_and_room_type(
        self,
        hostel_id: UUID,
        room_type: RoomType,
        fee_type: Optional[FeeType] = None,
        include_inactive: bool = False,
        as_of_date: Optional[Date] = None
    ) -> List[FeeStructure]:
        """
        Find fee structures for specific hostel and room type.
        
        Args:
            hostel_id: Hostel identifier
            room_type: Room type
            fee_type: Optional fee type filter
            include_inactive: Include inactive structures
            as_of_date: Find structures effective as of this date
            
        Returns:
            List of matching FeeStructure instances
        """
        query = self.session.query(FeeStructure).filter(
            FeeStructure.hostel_id == hostel_id,
            FeeStructure.room_type == room_type,
            FeeStructure.deleted_at.is_(None)
        )
        
        if fee_type:
            query = query.filter(FeeStructure.fee_type == fee_type)
        
        if not include_inactive:
            query = query.filter(FeeStructure.is_active == True)
        
        if as_of_date:
            query = query.filter(
                FeeStructure.effective_from <= as_of_date,
                or_(
                    FeeStructure.effective_to.is_(None),
                    FeeStructure.effective_to >= as_of_date
                )
            )
        
        return query.all()
    
    def get_current_fee_structure(
        self,
        hostel_id: UUID,
        room_type: RoomType,
        fee_type: FeeType,
        as_of_date: Optional[Date] = None
    ) -> Optional[FeeStructure]:
        """
        Get currently effective fee structure.
        
        Args:
            hostel_id: Hostel identifier
            room_type: Room type
            fee_type: Fee type
            as_of_date: Date to check (defaults to today)
            
        Returns:
            Current FeeStructure or None
        """
        check_date = as_of_date or Date.today()
        
        return self.session.query(FeeStructure).filter(
            FeeStructure.hostel_id == hostel_id,
            FeeStructure.room_type == room_type,
            FeeStructure.fee_type == fee_type,
            FeeStructure.is_active == True,
            FeeStructure.effective_from <= check_date,
            or_(
                FeeStructure.effective_to.is_(None),
                FeeStructure.effective_to >= check_date
            ),
            FeeStructure.deleted_at.is_(None)
        ).order_by(
            FeeStructure.effective_from.desc(),
            FeeStructure.version.desc()
        ).first()
    
    def find_by_date_range(
        self,
        hostel_id: UUID,
        start_date: Date,
        end_date: Date,
        room_type: Optional[RoomType] = None,
        fee_type: Optional[FeeType] = None
    ) -> List[FeeStructure]:
        """
        Find fee structures effective within date range.
        
        Args:
            hostel_id: Hostel identifier
            start_date: Range start date
            end_date: Range end date
            room_type: Optional room type filter
            fee_type: Optional fee type filter
            
        Returns:
            List of FeeStructure instances
        """
        query = self.session.query(FeeStructure).filter(
            FeeStructure.hostel_id == hostel_id,
            FeeStructure.deleted_at.is_(None),
            # Overlaps with date range
            FeeStructure.effective_from <= end_date,
            or_(
                FeeStructure.effective_to.is_(None),
                FeeStructure.effective_to >= start_date
            )
        )
        
        if room_type:
            query = query.filter(FeeStructure.room_type == room_type)
        
        if fee_type:
            query = query.filter(FeeStructure.fee_type == fee_type)
        
        return query.order_by(
            FeeStructure.effective_from,
            FeeStructure.room_type
        ).all()
    
    def get_fee_structure_with_components(
        self,
        fee_structure_id: UUID
    ) -> Optional[FeeStructure]:
        """
        Get fee structure with all related components loaded.
        
        Args:
            fee_structure_id: Fee structure identifier
            
        Returns:
            FeeStructure with components or None
        """
        return self.session.query(FeeStructure).options(
            selectinload(FeeStructure.charge_components),
            selectinload(FeeStructure.approvals)
        ).filter(
            FeeStructure.id == fee_structure_id,
            FeeStructure.deleted_at.is_(None)
        ).first()
    
    def find_pending_approval(
        self,
        hostel_id: Optional[UUID] = None
    ) -> List[FeeStructure]:
        """
        Find fee structures pending approval.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of FeeStructure instances pending approval
        """
        subquery = self.session.query(FeeApproval.fee_structure_id).filter(
            FeeApproval.approval_status == 'approved'
        ).subquery()
        
        query = self.session.query(FeeStructure).filter(
            FeeStructure.deleted_at.is_(None),
            ~FeeStructure.id.in_(subquery)
        )
        
        if hostel_id:
            query = query.filter(FeeStructure.hostel_id == hostel_id)
        
        return query.order_by(FeeStructure.created_at.desc()).all()
    
    def get_version_history(
        self,
        hostel_id: UUID,
        room_type: RoomType,
        fee_type: FeeType
    ) -> List[FeeStructure]:
        """
        Get complete version history for a fee structure configuration.
        
        Args:
            hostel_id: Hostel identifier
            room_type: Room type
            fee_type: Fee type
            
        Returns:
            List of all versions ordered by version number
        """
        return self.session.query(FeeStructure).filter(
            FeeStructure.hostel_id == hostel_id,
            FeeStructure.room_type == room_type,
            FeeStructure.fee_type == fee_type,
            FeeStructure.deleted_at.is_(None)
        ).order_by(FeeStructure.version.desc()).all()
    
    # ============================================================
    # Analytics and Reporting
    # ============================================================
    
    def get_fee_summary_by_hostel(
        self,
        hostel_id: UUID,
        as_of_date: Optional[Date] = None
    ) -> List[Dict[str, Any]]:
        """
        Get summary of current fee structures for a hostel.
        
        Args:
            hostel_id: Hostel identifier
            as_of_date: Date to check (defaults to today)
            
        Returns:
            List of fee summaries by room type
        """
        check_date = as_of_date or Date.today()
        
        results = self.session.query(
            FeeStructure.room_type,
            FeeStructure.fee_type,
            FeeStructure.amount,
            FeeStructure.security_deposit,
            FeeStructure.mess_charges_monthly,
            FeeStructure.includes_mess,
            FeeStructure.effective_from,
            FeeStructure.effective_to
        ).filter(
            FeeStructure.hostel_id == hostel_id,
            FeeStructure.is_active == True,
            FeeStructure.effective_from <= check_date,
            or_(
                FeeStructure.effective_to.is_(None),
                FeeStructure.effective_to >= check_date
            ),
            FeeStructure.deleted_at.is_(None)
        ).order_by(
            FeeStructure.room_type,
            FeeStructure.fee_type
        ).all()
        
        return [
            {
                'room_type': r.room_type.value,
                'fee_type': r.fee_type.value,
                'amount': float(r.amount),
                'security_deposit': float(r.security_deposit),
                'mess_charges_monthly': float(r.mess_charges_monthly),
                'includes_mess': r.includes_mess,
                'effective_from': r.effective_from.isoformat(),
                'effective_to': r.effective_to.isoformat() if r.effective_to else None
            }
            for r in results
        ]
    
    def get_pricing_comparison(
        self,
        hostel_ids: List[UUID],
        room_type: RoomType,
        fee_type: FeeType,
        as_of_date: Optional[Date] = None
    ) -> List[Dict[str, Any]]:
        """
        Compare pricing across multiple hostels.
        
        Args:
            hostel_ids: List of hostel identifiers
            room_type: Room type to compare
            fee_type: Fee type to compare
            as_of_date: Date to check (defaults to today)
            
        Returns:
            List of pricing comparisons
        """
        check_date = as_of_date or Date.today()
        
        results = self.session.query(
            FeeStructure.hostel_id,
            FeeStructure.amount,
            FeeStructure.security_deposit,
            FeeStructure.mess_charges_monthly
        ).filter(
            FeeStructure.hostel_id.in_(hostel_ids),
            FeeStructure.room_type == room_type,
            FeeStructure.fee_type == fee_type,
            FeeStructure.is_active == True,
            FeeStructure.effective_from <= check_date,
            or_(
                FeeStructure.effective_to.is_(None),
                FeeStructure.effective_to >= check_date
            ),
            FeeStructure.deleted_at.is_(None)
        ).all()
        
        return [
            {
                'hostel_id': str(r.hostel_id),
                'amount': float(r.amount),
                'security_deposit': float(r.security_deposit),
                'mess_charges_monthly': float(r.mess_charges_monthly),
                'total_first_month': float(r.amount + r.security_deposit + r.mess_charges_monthly)
            }
            for r in results
        ]
    
    def calculate_average_pricing(
        self,
        hostel_id: Optional[UUID] = None,
        room_type: Optional[RoomType] = None,
        as_of_date: Optional[Date] = None
    ) -> Dict[str, Decimal]:
        """
        Calculate average pricing statistics.
        
        Args:
            hostel_id: Optional hostel filter
            room_type: Optional room type filter
            as_of_date: Date to check (defaults to today)
            
        Returns:
            Dictionary with average pricing metrics
        """
        check_date = as_of_date or Date.today()
        
        query = self.session.query(
            func.avg(FeeStructure.amount).label('avg_amount'),
            func.min(FeeStructure.amount).label('min_amount'),
            func.max(FeeStructure.amount).label('max_amount'),
            func.avg(FeeStructure.security_deposit).label('avg_deposit'),
            func.count(FeeStructure.id).label('count')
        ).filter(
            FeeStructure.is_active == True,
            FeeStructure.effective_from <= check_date,
            or_(
                FeeStructure.effective_to.is_(None),
                FeeStructure.effective_to >= check_date
            ),
            FeeStructure.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.filter(FeeStructure.hostel_id == hostel_id)
        
        if room_type:
            query = query.filter(FeeStructure.room_type == room_type)
        
        result = query.first()
        
        return {
            'average_amount': result.avg_amount or Decimal('0'),
            'minimum_amount': result.min_amount or Decimal('0'),
            'maximum_amount': result.max_amount or Decimal('0'),
            'average_deposit': result.avg_deposit or Decimal('0'),
            'structure_count': result.count or 0
        }
    
    def get_upcoming_changes(
        self,
        hostel_id: Optional[UUID] = None,
        days_ahead: int = 30
    ) -> List[FeeStructure]:
        """
        Get fee structures with upcoming effective dates.
        
        Args:
            hostel_id: Optional hostel filter
            days_ahead: Number of days to look ahead
            
        Returns:
            List of upcoming FeeStructure instances
        """
        today = Date.today()
        future_date = Date.fromordinal(today.toordinal() + days_ahead)
        
        query = self.session.query(FeeStructure).filter(
            FeeStructure.effective_from > today,
            FeeStructure.effective_from <= future_date,
            FeeStructure.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.filter(FeeStructure.hostel_id == hostel_id)
        
        return query.order_by(FeeStructure.effective_from).all()
    
    def get_expiring_structures(
        self,
        hostel_id: Optional[UUID] = None,
        days_ahead: int = 30
    ) -> List[FeeStructure]:
        """
        Get fee structures expiring soon.
        
        Args:
            hostel_id: Optional hostel filter
            days_ahead: Number of days to look ahead
            
        Returns:
            List of expiring FeeStructure instances
        """
        today = Date.today()
        future_date = Date.fromordinal(today.toordinal() + days_ahead)
        
        query = self.session.query(FeeStructure).filter(
            FeeStructure.effective_to.isnot(None),
            FeeStructure.effective_to > today,
            FeeStructure.effective_to <= future_date,
            FeeStructure.is_active == True,
            FeeStructure.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.filter(FeeStructure.hostel_id == hostel_id)
        
        return query.order_by(FeeStructure.effective_to).all()
    
    # ============================================================
    # Bulk Operations
    # ============================================================
    
    def bulk_update_effective_dates(
        self,
        fee_structure_ids: List[UUID],
        new_effective_to: Date,
        audit_context: Dict[str, Any]
    ) -> int:
        """
        Bulk update effective_to dates for multiple fee structures.
        
        Args:
            fee_structure_ids: List of fee structure IDs
            new_effective_to: New effective_to date
            audit_context: Audit information
            
        Returns:
            Number of records updated
        """
        updated = self.session.query(FeeStructure).filter(
            FeeStructure.id.in_(fee_structure_ids),
            FeeStructure.deleted_at.is_(None)
        ).update(
            {
                'effective_to': new_effective_to,
                'updated_at': datetime.utcnow(),
                'updated_by': audit_context.get('user_id')
            },
            synchronize_session=False
        )
        
        self.session.flush()
        return updated
    
    def bulk_deactivate(
        self,
        hostel_id: UUID,
        room_type: Optional[RoomType] = None,
        before_date: Optional[Date] = None,
        audit_context: Optional[Dict[str, Any]] = None
    ) -> int:
        """
        Bulk deactivate fee structures.
        
        Args:
            hostel_id: Hostel identifier
            room_type: Optional room type filter
            before_date: Deactivate structures effective before this date
            audit_context: Audit information
            
        Returns:
            Number of records deactivated
        """
        query = self.session.query(FeeStructure).filter(
            FeeStructure.hostel_id == hostel_id,
            FeeStructure.is_active == True,
            FeeStructure.deleted_at.is_(None)
        )
        
        if room_type:
            query = query.filter(FeeStructure.room_type == room_type)
        
        if before_date:
            query = query.filter(FeeStructure.effective_from < before_date)
        
        update_data = {
            'is_active': False,
            'updated_at': datetime.utcnow()
        }
        
        if audit_context:
            update_data['updated_by'] = audit_context.get('user_id')
        
        updated = query.update(update_data, synchronize_session=False)
        self.session.flush()
        
        return updated
    
    # ============================================================
    # Validation and Helper Methods
    # ============================================================
    
    def _validate_amounts(
        self,
        amount: Decimal,
        security_deposit: Decimal,
        additional_data: Dict[str, Any]
    ) -> None:
        """Validate fee amounts and related fields."""
        if amount < Decimal('500.00') or amount > Decimal('100000.00'):
            raise ValidationException(
                "Amount must be between 500.00 and 100000.00"
            )
        
        if security_deposit < Decimal('0'):
            raise ValidationException("Security deposit cannot be negative")
        
        if security_deposit > (amount * 3):
            raise ValidationException(
                "Security deposit cannot exceed 3 times the monthly amount"
            )
        
        mess_charges = additional_data.get('mess_charges_monthly', Decimal('0'))
        includes_mess = additional_data.get('includes_mess', False)
        
        if includes_mess and mess_charges > Decimal('0'):
            raise ValidationException(
                "Cannot have both includes_mess=True and mess_charges_monthly > 0"
            )
        
        if mess_charges > Decimal('10000.00'):
            raise ValidationException(
                "Mess charges cannot exceed 10000.00"
            )
    
    def _check_for_overlaps(
        self,
        hostel_id: UUID,
        room_type: RoomType,
        fee_type: FeeType,
        effective_from: Date,
        effective_to: Optional[Date],
        exclude_id: Optional[UUID]
    ) -> None:
        """Check for overlapping fee structures."""
        query = self.session.query(FeeStructure).filter(
            FeeStructure.hostel_id == hostel_id,
            FeeStructure.room_type == room_type,
            FeeStructure.fee_type == fee_type,
            FeeStructure.is_active == True,
            FeeStructure.deleted_at.is_(None)
        )
        
        if exclude_id:
            query = query.filter(FeeStructure.id != exclude_id)
        
        # Check for date overlap
        if effective_to:
            query = query.filter(
                or_(
                    and_(
                        FeeStructure.effective_from <= effective_from,
                        or_(
                            FeeStructure.effective_to.is_(None),
                            FeeStructure.effective_to >= effective_from
                        )
                    ),
                    and_(
                        FeeStructure.effective_from <= effective_to,
                        or_(
                            FeeStructure.effective_to.is_(None),
                            FeeStructure.effective_to >= effective_to
                        )
                    ),
                    and_(
                        FeeStructure.effective_from >= effective_from,
                        FeeStructure.effective_from <= effective_to
                    )
                )
            )
        else:
            query = query.filter(
                or_(
                    FeeStructure.effective_to.is_(None),
                    FeeStructure.effective_to >= effective_from
                )
            )
        
        if query.first():
            raise ConflictException(
                f"Overlapping fee structure exists for {hostel_id}/{room_type.value}/{fee_type.value}"
            )
    
    def _deactivate_previous_structures(
        self,
        hostel_id: UUID,
        room_type: RoomType,
        fee_type: FeeType,
        effective_from: Date
    ) -> None:
        """Automatically deactivate previous fee structures."""
        previous_date = Date.fromordinal(effective_from.toordinal() - 1)
        
        self.session.query(FeeStructure).filter(
            FeeStructure.hostel_id == hostel_id,
            FeeStructure.room_type == room_type,
            FeeStructure.fee_type == fee_type,
            FeeStructure.is_active == True,
            FeeStructure.effective_to.is_(None),
            FeeStructure.deleted_at.is_(None)
        ).update(
            {
                'effective_to': previous_date,
                'updated_at': datetime.utcnow()
            },
            synchronize_session=False
        )
    
    def _create_new_version(
        self,
        original: FeeStructure,
        update_data: Dict[str, Any],
        audit_context: Dict[str, Any]
    ) -> FeeStructure:
        """Create a new version of fee structure."""
        # Set end date on original
        original.effective_to = update_data.get(
            'effective_from',
            Date.today()
        ) - Date.resolution
        original.is_active = False
        
        # Create new version
        new_version_data = {
            'hostel_id': original.hostel_id,
            'room_type': original.room_type,
            'fee_type': original.fee_type,
            'amount': original.amount,
            'security_deposit': original.security_deposit,
            'includes_mess': original.includes_mess,
            'mess_charges_monthly': original.mess_charges_monthly,
            'electricity_charges': original.electricity_charges,
            'electricity_fixed_amount': original.electricity_fixed_amount,
            'water_charges': original.water_charges,
            'water_fixed_amount': original.water_fixed_amount,
            'effective_from': update_data.get('effective_from', Date.today()),
            'is_active': True,
            'version': original.version + 1,
            'replaced_by_id': None,
            'description': original.description
        }
        
        # Apply updates
        new_version_data.update(update_data)
        
        new_version = FeeStructure(**new_version_data)
        self._apply_audit(new_version, audit_context)
        
        # Link versions
        original.replaced_by_id = new_version.id
        
        self.session.add(new_version)
        self.session.flush()
        
        return new_version
    
    def _apply_audit(
        self,
        entity: FeeStructure,
        audit_context: Dict[str, Any],
        is_update: bool = False
    ) -> None:
        """Apply audit information to entity."""
        user_id = audit_context.get('user_id')
        
        if is_update:
            entity.updated_by = user_id
            entity.updated_at = datetime.utcnow()
        else:
            entity.created_by = user_id
            entity.created_at = datetime.utcnow()

# --- File: C:\Hostel-Main\app\repositories\fee_structure\__init__.py ---
# --- File: C:\Hostel-Main\app\repositories\fee_structure\__init__.py ---
"""
Fee Structure Repositories Package

This module exports all fee structure-related repositories.
"""

from app.repositories.fee_structure.fee_structure_repository import (
    FeeStructureRepository,
)
from app.repositories.fee_structure.charge_component_repository import (
    ChargeComponentRepository,
    ChargeRuleRepository,
    DiscountConfigurationRepository,
)
from app.repositories.fee_structure.fee_calculation_repository import (
    FeeCalculationRepository,
    FeeProjectionRepository,
)
from app.repositories.fee_structure.fee_aggregate_repository import (
    FeeAggregateRepository,
)

__all__ = [
    # Fee Structure
    "FeeStructureRepository",
    # Charge Components
    "ChargeComponentRepository",
    "ChargeRuleRepository",
    "DiscountConfigurationRepository",
    # Calculations
    "FeeCalculationRepository",
    "FeeProjectionRepository",
    # Aggregates
    "FeeAggregateRepository",
]
