### Combined Content from Folder: C:\Hostel-Main\app\repositories\booking ###



# ===== Folder: C:\Hostel-Main\app\repositories\booking =====

# --- File: C:\Hostel-Main\app\repositories\booking\booking_aggregate_repository.py ---
# app/repositories/booking/booking_aggregate_repository.py
"""
Booking aggregate repository for complex cross-model queries.

Provides aggregated views, complex analytics, dashboard data,
and business intelligence queries across booking-related models.
"""

from datetime import date, datetime, timedelta
from decimal import Decimal
from typing import Dict, List, Optional, Tuple
from uuid import UUID

from sqlalchemy import and_, func, or_, select, case
from sqlalchemy.orm import Session, joinedload

from app.models.booking.booking import Booking
from app.models.booking.booking_approval import BookingApproval
from app.models.booking.booking_assignment import BookingAssignment
from app.models.booking.booking_cancellation import BookingCancellation
from app.models.booking.booking_conversion import BookingConversion
from app.models.booking.booking_modification import BookingModification
from app.models.booking.booking_waitlist import BookingWaitlist
from app.models.base.enums import BookingStatus, WaitlistStatus
from app.repositories.base.base_repository import BaseRepository


class BookingAggregateRepository:
    """
    Aggregate repository for complex booking queries.
    
    Provides:
    - Dashboard metrics and KPIs
    - Cross-model analytics
    - Business intelligence queries
    - Funnel analysis
    - Performance metrics
    """
    
    def __init__(self, session: Session):
        """Initialize aggregate repository."""
        self.session = session
    
    # ==================== DASHBOARD METRICS ====================
    
    def get_booking_funnel_metrics(
        self,
        hostel_id: UUID,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, any]:
        """
        Get booking funnel conversion metrics.
        
        Args:
            hostel_id: Hostel UUID
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Funnel metrics dictionary
        """
        query = select(Booking).where(
            and_(
                Booking.hostel_id == hostel_id,
                Booking.deleted_at.is_(None),
            )
        )
        
        if date_from:
            query = query.where(Booking.booking_date >= date_from)
        
        if date_to:
            query = query.where(Booking.booking_date <= date_to)
        
        bookings = self.session.execute(query).scalars().all()
        
        total_requests = len(bookings)
        pending = sum(1 for b in bookings if b.booking_status == BookingStatus.PENDING)
        approved = sum(1 for b in bookings if b.booking_status == BookingStatus.APPROVED)
        confirmed = sum(1 for b in bookings if b.booking_status == BookingStatus.CONFIRMED)
        checked_in = sum(1 for b in bookings if b.booking_status == BookingStatus.CHECKED_IN)
        completed = sum(1 for b in bookings if b.booking_status == BookingStatus.COMPLETED)
        
        rejected = sum(1 for b in bookings if b.booking_status == BookingStatus.REJECTED)
        cancelled = sum(1 for b in bookings if b.booking_status == BookingStatus.CANCELLED)
        
        return {
            "total_requests": total_requests,
            "pending": pending,
            "approved": approved,
            "confirmed": confirmed,
            "checked_in": checked_in,
            "completed": completed,
            "rejected": rejected,
            "cancelled": cancelled,
            # Conversion rates
            "approval_rate": (approved / total_requests * 100) if total_requests > 0 else 0,
            "confirmation_rate": (confirmed / approved * 100) if approved > 0 else 0,
            "checkin_rate": (checked_in / confirmed * 100) if confirmed > 0 else 0,
            "completion_rate": (completed / checked_in * 100) if checked_in > 0 else 0,
            # Drop-off rates
            "rejection_rate": (rejected / total_requests * 100) if total_requests > 0 else 0,
            "cancellation_rate": (cancelled / total_requests * 100) if total_requests > 0 else 0,
        }
    
    def get_hostel_performance_dashboard(
        self,
        hostel_id: UUID,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, any]:
        """
        Get comprehensive hostel performance dashboard data.
        
        Args:
            hostel_id: Hostel UUID
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Dashboard data dictionary
        """
        # Booking metrics
        funnel_metrics = self.get_booking_funnel_metrics(hostel_id, date_from, date_to)
        
        # Revenue metrics
        revenue_query = select(
            func.sum(Booking.total_amount).label('total_revenue'),
            func.sum(
                case(
                    (Booking.advance_paid == True, Booking.advance_amount),
                    else_=0
                )
            ).label('advance_collected'),
            func.avg(Booking.total_amount).label('avg_booking_value'),
        ).where(
            and_(
                Booking.hostel_id == hostel_id,
                Booking.booking_status.in_([
                    BookingStatus.CONFIRMED,
                    BookingStatus.CHECKED_IN,
                    BookingStatus.COMPLETED,
                ]),
                Booking.deleted_at.is_(None),
            )
        )
        
        if date_from:
            revenue_query = revenue_query.where(Booking.booking_date >= date_from)
        
        if date_to:
            revenue_query = revenue_query.where(Booking.booking_date <= date_to)
        
        revenue_result = self.session.execute(revenue_query).first()
        
        # Conversion metrics
        conversion_count = self.session.execute(
            select(func.count(BookingConversion.id)).join(
                Booking,
                BookingConversion.booking_id == Booking.id
            ).where(
                and_(
                    Booking.hostel_id == hostel_id,
                    BookingConversion.is_successful == True,
                    BookingConversion.deleted_at.is_(None),
                )
            )
        ).scalar_one()
        
        # Cancellation metrics
        cancellation_query = select(
            func.count(BookingCancellation.id).label('total_cancellations'),
            func.sum(BookingCancellation.refundable_amount).label('total_refunds'),
            func.avg(BookingCancellation.cancellation_charge_percentage).label('avg_charge_pct'),
        ).join(
            Booking,
            BookingCancellation.booking_id == Booking.id
        ).where(
            and_(
                Booking.hostel_id == hostel_id,
                BookingCancellation.deleted_at.is_(None),
            )
        )
        
        cancellation_result = self.session.execute(cancellation_query).first()
        
        # Waitlist metrics
        waitlist_query = select(
            func.count(BookingWaitlist.id).label('total_waitlist'),
            func.count(
                case(
                    (BookingWaitlist.status == WaitlistStatus.WAITING, 1),
                )
            ).label('active_waitlist'),
            func.count(
                case(
                    (BookingWaitlist.converted_to_booking == True, 1),
                )
            ).label('converted_from_waitlist'),
        ).where(
            and_(
                BookingWaitlist.hostel_id == hostel_id,
                BookingWaitlist.deleted_at.is_(None),
            )
        )
        
        waitlist_result = self.session.execute(waitlist_query).first()
        
        return {
            "funnel_metrics": funnel_metrics,
            "revenue_metrics": {
                "total_revenue": revenue_result.total_revenue or Decimal("0.00"),
                "advance_collected": revenue_result.advance_collected or Decimal("0.00"),
                "average_booking_value": revenue_result.avg_booking_value or Decimal("0.00"),
            },
            "conversion_metrics": {
                "total_conversions": conversion_count,
                "conversion_rate": (
                    conversion_count / funnel_metrics["confirmed"] * 100
                    if funnel_metrics["confirmed"] > 0 else 0
                ),
            },
            "cancellation_metrics": {
                "total_cancellations": cancellation_result.total_cancellations or 0,
                "total_refunds": cancellation_result.total_refunds or Decimal("0.00"),
                "average_charge_percentage": cancellation_result.avg_charge_pct or Decimal("0.00"),
            },
            "waitlist_metrics": {
                "total_entries": waitlist_result.total_waitlist or 0,
                "active_entries": waitlist_result.active_waitlist or 0,
                "converted_entries": waitlist_result.converted_from_waitlist or 0,
                "conversion_rate": (
                    waitlist_result.converted_from_waitlist / waitlist_result.total_waitlist * 100
                    if waitlist_result.total_waitlist > 0 else 0
                ),
            },
        }
    
    def get_time_series_bookings(
        self,
        hostel_id: UUID,
        date_from: datetime,
        date_to: datetime,
        granularity: str = 'day',
    ) -> List[Dict]:
        """
        Get time series booking data.
        
        Args:
            hostel_id: Hostel UUID
            date_from: Start date
            date_to: End date
            granularity: 'day', 'week', or 'month'
            
        Returns:
            List of time series data points
        """
        # This would typically use date_trunc function for PostgreSQL
        # Simplified implementation
        query = select(
            func.date(Booking.booking_date).label('date'),
            func.count(Booking.id).label('count'),
            func.sum(Booking.total_amount).label('revenue'),
        ).where(
            and_(
                Booking.hostel_id == hostel_id,
                Booking.booking_date >= date_from,
                Booking.booking_date <= date_to,
                Booking.deleted_at.is_(None),
            )
        ).group_by(
            func.date(Booking.booking_date)
        ).order_by(
            func.date(Booking.booking_date)
        )
        
        results = self.session.execute(query).all()
        
        return [
            {
                "date": str(row.date),
                "bookings": row.count,
                "revenue": row.revenue or Decimal("0.00"),
            }
            for row in results
        ]
    
    def get_pending_actions_summary(
        self,
        hostel_id: UUID,
    ) -> Dict[str, any]:
        """
        Get summary of pending actions requiring attention.
        
        Args:
            hostel_id: Hostel UUID
            
        Returns:
            Pending actions summary
        """
        # Pending approvals
        pending_approvals = self.session.execute(
            select(func.count(Booking.id)).where(
                and_(
                    Booking.hostel_id == hostel_id,
                    Booking.booking_status == BookingStatus.PENDING,
                    Booking.deleted_at.is_(None),
                )
            )
        ).scalar_one()
        
        # Expiring bookings
        expiring_bookings = self.session.execute(
            select(func.count(Booking.id)).where(
                and_(
                    Booking.hostel_id == hostel_id,
                    Booking.booking_status == BookingStatus.PENDING,
                    Booking.expires_at.isnot(None),
                    Booking.expires_at <= datetime.utcnow() + timedelta(hours=24),
                    Booking.deleted_at.is_(None),
                )
            )
        ).scalar_one()
        
        # Pending payments
        pending_payments = self.session.execute(
            select(func.count(BookingApproval.id)).join(
                Booking,
                BookingApproval.booking_id == Booking.id
            ).where(
                and_(
                    Booking.hostel_id == hostel_id,
                    BookingApproval.advance_payment_required == True,
                    Booking.advance_paid == False,
                    Booking.booking_status == BookingStatus.APPROVED,
                    BookingApproval.deleted_at.is_(None),
                )
            )
        ).scalar_one()
        
        # Pending modifications
        pending_modifications = self.session.execute(
            select(func.count(BookingModification.id)).join(
                Booking,
                BookingModification.booking_id == Booking.id
            ).where(
                and_(
                    Booking.hostel_id == hostel_id,
                    BookingModification.modification_status == 'pending',
                    BookingModification.deleted_at.is_(None),
                )
            )
        ).scalar_one()
        
        # Pending conversions
        pending_conversions = self.session.execute(
            select(func.count(BookingConversion.id)).join(
                Booking,
                BookingConversion.booking_id == Booking.id
            ).where(
                and_(
                    Booking.hostel_id == hostel_id,
                    BookingConversion.is_successful == True,
                    BookingConversion.deleted_at.is_(None),
                )
            )
        ).scalar_one()
        
        # Active waitlist
        active_waitlist = self.session.execute(
            select(func.count(BookingWaitlist.id)).where(
                and_(
                    BookingWaitlist.hostel_id == hostel_id,
                    BookingWaitlist.status == WaitlistStatus.WAITING,
                    BookingWaitlist.deleted_at.is_(None),
                )
            )
        ).scalar_one()
        
        return {
            "pending_approvals": pending_approvals,
            "expiring_bookings": expiring_bookings,
            "pending_payments": pending_payments,
            "pending_modifications": pending_modifications,
            "pending_conversions": pending_conversions,
            "active_waitlist": active_waitlist,
            "total_pending_actions": (
                pending_approvals +
                expiring_bookings +
                pending_payments +
                pending_modifications
            ),
        }




# --- File: C:\Hostel-Main\app\repositories\booking\booking_approval_repository.py ---
# app/repositories/booking/booking_approval_repository.py
"""
Booking approval repository for approval workflow management.

Provides approval decision tracking, settings management, rejection handling,
and auto-approval logic.
"""

from datetime import datetime, timedelta
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from sqlalchemy import and_, func, or_, select
from sqlalchemy.orm import Session, joinedload

from app.core.exceptions import EntityNotFoundError, ValidationError
from app.models.booking.booking_approval import (
    ApprovalSettings,
    BookingApproval,
    RejectionRecord,
)
from app.models.booking.booking import Booking
from app.models.base.enums import BookingStatus
from app.repositories.base.base_repository import (
    AuditContext,
    BaseRepository,
    QueryOptions,
)


class BookingApprovalRepository(BaseRepository[BookingApproval]):
    """
    Repository for booking approval operations.
    
    Provides:
    - Approval workflow management
    - Auto-approval logic
    - Rejection tracking
    - Approval settings configuration
    - Payment requirement calculation
    """
    
    def __init__(self, session: Session):
        """Initialize approval repository."""
        super().__init__(session, BookingApproval)
    
    # ==================== APPROVAL OPERATIONS ====================
    
    def create_approval_record(
        self,
        booking_id: UUID,
        approval_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingApproval:
        """
        Create approval record for a booking.
        
        Args:
            booking_id: Booking UUID
            approval_data: Approval information
            audit_context: Audit context
            
        Returns:
            Created approval record
        """
        # Calculate advance payment amount if not provided
        if 'advance_payment_amount' not in approval_data:
            total_amount = approval_data.get('total_amount', Decimal("0.00"))
            percentage = approval_data.get('advance_payment_percentage', Decimal("20.00"))
            approval_data['advance_payment_amount'] = (total_amount * percentage / 100).quantize(
                Decimal("0.01")
            )
        
        approval = BookingApproval(
            booking_id=booking_id,
            approved_by=audit_context.user_id if audit_context else None,
            approved_at=datetime.utcnow(),
            **approval_data,
        )
        
        return self.create(approval, audit_context)
    
    def find_by_booking(self, booking_id: UUID) -> Optional[BookingApproval]:
        """
        Find approval record for a booking.
        
        Args:
            booking_id: Booking UUID
            
        Returns:
            Approval record if found
        """
        query = select(BookingApproval).where(
            BookingApproval.booking_id == booking_id
        ).where(
            BookingApproval.deleted_at.is_(None)
        ).options(
            joinedload(BookingApproval.booking),
            joinedload(BookingApproval.approver),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def update_pricing(
        self,
        booking_id: UUID,
        pricing_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingApproval:
        """
        Update pricing in approval record.
        
        Args:
            booking_id: Booking UUID
            pricing_data: Updated pricing information
            audit_context: Audit context
            
        Returns:
            Updated approval record
        """
        approval = self.find_by_booking(booking_id)
        if not approval:
            raise EntityNotFoundError(f"Approval for booking {booking_id} not found")
        
        # Recalculate advance amount if percentage changed
        if 'advance_payment_percentage' in pricing_data or 'total_amount' in pricing_data:
            total = pricing_data.get('total_amount', approval.total_amount)
            percentage = pricing_data.get(
                'advance_payment_percentage',
                approval.advance_payment_percentage
            )
            pricing_data['advance_payment_amount'] = (total * percentage / 100).quantize(
                Decimal("0.01")
            )
        
        # Update fields
        for key, value in pricing_data.items():
            if hasattr(approval, key):
                setattr(approval, key, value)
        
        self.session.flush()
        self.session.refresh(approval)
        
        return approval
    
    def set_payment_deadline(
        self,
        booking_id: UUID,
        deadline_hours: int = 72,
    ) -> BookingApproval:
        """
        Set advance payment deadline.
        
        Args:
            booking_id: Booking UUID
            deadline_hours: Hours from now for deadline
            
        Returns:
            Updated approval record
        """
        approval = self.find_by_booking(booking_id)
        if not approval:
            raise EntityNotFoundError(f"Approval for booking {booking_id} not found")
        
        approval.advance_payment_deadline = datetime.utcnow() + timedelta(hours=deadline_hours)
        
        self.session.flush()
        self.session.refresh(approval)
        
        return approval
    
    def mark_notification_sent(
        self,
        booking_id: UUID,
    ) -> BookingApproval:
        """
        Mark approval notification as sent.
        
        Args:
            booking_id: Booking UUID
            
        Returns:
            Updated approval record
        """
        approval = self.find_by_booking(booking_id)
        if not approval:
            raise EntityNotFoundError(f"Approval for booking {booking_id} not found")
        
        approval.send_approval_notification()
        
        self.session.flush()
        self.session.refresh(approval)
        
        return approval
    
    def find_pending_payment(
        self,
        hostel_id: Optional[UUID] = None,
        overdue_only: bool = False,
    ) -> List[BookingApproval]:
        """
        Find approvals with pending advance payment.
        
        Args:
            hostel_id: Optional hostel filter
            overdue_only: If True, only return overdue payments
            
        Returns:
            List of approvals with pending payment
        """
        query = select(BookingApproval).join(
            Booking,
            BookingApproval.booking_id == Booking.id
        ).where(
            and_(
                BookingApproval.advance_payment_required == True,
                Booking.advance_paid == False,
                Booking.booking_status == BookingStatus.APPROVED,
                BookingApproval.deleted_at.is_(None),
                Booking.deleted_at.is_(None),
            )
        )
        
        if overdue_only:
            query = query.where(
                and_(
                    BookingApproval.advance_payment_deadline.isnot(None),
                    BookingApproval.advance_payment_deadline < datetime.utcnow()
                )
            )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.order_by(BookingApproval.advance_payment_deadline.asc()).options(
            joinedload(BookingApproval.booking),
            joinedload(BookingApproval.approver),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_payment_expiring_soon(
        self,
        within_hours: int = 24,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingApproval]:
        """
        Find approvals with payment deadline expiring soon.
        
        Args:
            within_hours: Hours threshold
            hostel_id: Optional hostel filter
            
        Returns:
            List of approvals with expiring deadlines
        """
        expiry_threshold = datetime.utcnow() + timedelta(hours=within_hours)
        
        query = select(BookingApproval).join(
            Booking,
            BookingApproval.booking_id == Booking.id
        ).where(
            and_(
                BookingApproval.advance_payment_required == True,
                Booking.advance_paid == False,
                BookingApproval.advance_payment_deadline.isnot(None),
                BookingApproval.advance_payment_deadline > datetime.utcnow(),
                BookingApproval.advance_payment_deadline <= expiry_threshold,
                BookingApproval.deleted_at.is_(None),
                Booking.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.order_by(BookingApproval.advance_payment_deadline.asc()).options(
            joinedload(BookingApproval.booking),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_auto_approved(
        self,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> List[BookingApproval]:
        """
        Find auto-approved bookings.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            List of auto-approved bookings
        """
        query = select(BookingApproval).join(
            Booking,
            BookingApproval.booking_id == Booking.id
        ).where(
            and_(
                BookingApproval.auto_approved == True,
                BookingApproval.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(BookingApproval.approved_at >= date_from)
        
        if date_to:
            query = query.where(BookingApproval.approved_at <= date_to)
        
        query = query.order_by(BookingApproval.approved_at.desc()).options(
            joinedload(BookingApproval.booking),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def get_approval_statistics(
        self,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, any]:
        """
        Get approval statistics.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Statistics dictionary
        """
        query = select(BookingApproval).join(
            Booking,
            BookingApproval.booking_id == Booking.id
        ).where(
            BookingApproval.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(BookingApproval.approved_at >= date_from)
        
        if date_to:
            query = query.where(BookingApproval.approved_at <= date_to)
        
        approvals = self.session.execute(query).scalars().all()
        
        total_approvals = len(approvals)
        auto_approved = sum(1 for a in approvals if a.auto_approved)
        manual_approved = total_approvals - auto_approved
        
        payment_required = sum(1 for a in approvals if a.advance_payment_required)
        
        total_revenue = sum(a.total_amount for a in approvals)
        avg_booking_value = total_revenue / total_approvals if total_approvals > 0 else Decimal("0.00")
        
        avg_advance_percentage = (
            sum(a.advance_payment_percentage for a in approvals) / total_approvals
            if total_approvals > 0 else Decimal("0.00")
        )
        
        return {
            "total_approvals": total_approvals,
            "auto_approved": auto_approved,
            "manual_approved": manual_approved,
            "auto_approval_rate": (auto_approved / total_approvals * 100) if total_approvals > 0 else 0,
            "payment_required_count": payment_required,
            "total_revenue": total_revenue,
            "average_booking_value": avg_booking_value,
            "average_advance_percentage": avg_advance_percentage,
        }


class ApprovalSettingsRepository(BaseRepository[ApprovalSettings]):
    """Repository for approval settings management."""
    
    def __init__(self, session: Session):
        """Initialize approval settings repository."""
        super().__init__(session, ApprovalSettings)
    
    def find_by_hostel(self, hostel_id: UUID) -> Optional[ApprovalSettings]:
        """
        Find approval settings for a hostel.
        
        Args:
            hostel_id: Hostel UUID
            
        Returns:
            Approval settings if found
        """
        query = select(ApprovalSettings).where(
            ApprovalSettings.hostel_id == hostel_id
        ).where(
            ApprovalSettings.deleted_at.is_(None)
        ).options(
            joinedload(ApprovalSettings.hostel),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def create_or_update_settings(
        self,
        hostel_id: UUID,
        settings_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> ApprovalSettings:
        """
        Create or update approval settings for a hostel.
        
        Args:
            hostel_id: Hostel UUID
            settings_data: Settings data
            audit_context: Audit context
            
        Returns:
            Created or updated settings
        """
        existing = self.find_by_hostel(hostel_id)
        
        if existing:
            # Update existing
            for key, value in settings_data.items():
                if hasattr(existing, key):
                    setattr(existing, key, value)
            
            if audit_context:
                existing.last_updated_by = audit_context.user_id
            
            self.session.flush()
            self.session.refresh(existing)
            return existing
        else:
            # Create new
            settings = ApprovalSettings(
                hostel_id=hostel_id,
                last_updated_by=audit_context.user_id if audit_context else None,
                **settings_data,
            )
            return self.create(settings, audit_context)
    
    def check_auto_approval_criteria(
        self,
        hostel_id: UUID,
        booking_data: Dict,
    ) -> Tuple[bool, Optional[Dict]]:
        """
        Check if booking meets auto-approval criteria.
        
        Args:
            hostel_id: Hostel UUID
            booking_data: Booking information to check
            
        Returns:
            Tuple of (should_auto_approve, criteria_met)
        """
        settings = self.find_by_hostel(hostel_id)
        
        if not settings or not settings.auto_approve_enabled:
            return False, None
        
        if not settings.auto_approve_conditions:
            return False, None
        
        conditions = settings.auto_approve_conditions
        criteria_met = {}
        
        # Check each condition
        for condition_key, condition_value in conditions.items():
            if condition_key == "max_booking_amount":
                booking_amount = booking_data.get("total_amount", Decimal("0.00"))
                meets_criteria = booking_amount <= Decimal(str(condition_value))
                criteria_met[condition_key] = meets_criteria
                if not meets_criteria:
                    return False, criteria_met
            
            elif condition_key == "min_stay_duration":
                duration = booking_data.get("stay_duration_months", 0)
                meets_criteria = duration >= condition_value
                criteria_met[condition_key] = meets_criteria
                if not meets_criteria:
                    return False, criteria_met
            
            elif condition_key == "allowed_room_types":
                room_type = booking_data.get("room_type_requested")
                meets_criteria = str(room_type) in condition_value
                criteria_met[condition_key] = meets_criteria
                if not meets_criteria:
                    return False, criteria_met
            
            elif condition_key == "require_advance_payment":
                meets_criteria = condition_value is True
                criteria_met[condition_key] = meets_criteria
        
        return True, criteria_met
    
    def find_hostels_with_auto_approval(self) -> List[ApprovalSettings]:
        """
        Find all hostels with auto-approval enabled.
        
        Returns:
            List of approval settings with auto-approval enabled
        """
        query = select(ApprovalSettings).where(
            and_(
                ApprovalSettings.auto_approve_enabled == True,
                ApprovalSettings.deleted_at.is_(None),
            )
        ).options(
            joinedload(ApprovalSettings.hostel),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())


class RejectionRecordRepository(BaseRepository[RejectionRecord]):
    """Repository for booking rejection tracking."""
    
    def __init__(self, session: Session):
        """Initialize rejection record repository."""
        super().__init__(session, RejectionRecord)
    
    def create_rejection_record(
        self,
        booking_id: UUID,
        rejection_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> RejectionRecord:
        """
        Create rejection record for a booking.
        
        Args:
            booking_id: Booking UUID
            rejection_data: Rejection information
            audit_context: Audit context
            
        Returns:
            Created rejection record
        """
        record = RejectionRecord(
            booking_id=booking_id,
            rejected_by=audit_context.user_id if audit_context else None,
            rejected_at=datetime.utcnow(),
            **rejection_data,
        )
        
        return self.create(record, audit_context)
    
    def find_by_booking(self, booking_id: UUID) -> Optional[RejectionRecord]:
        """
        Find rejection record for a booking.
        
        Args:
            booking_id: Booking UUID
            
        Returns:
            Rejection record if found
        """
        query = select(RejectionRecord).where(
            RejectionRecord.booking_id == booking_id
        ).where(
            RejectionRecord.deleted_at.is_(None)
        ).options(
            joinedload(RejectionRecord.booking),
            joinedload(RejectionRecord.rejecter),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def mark_notification_sent(self, booking_id: UUID) -> RejectionRecord:
        """
        Mark rejection notification as sent.
        
        Args:
            booking_id: Booking UUID
            
        Returns:
            Updated rejection record
        """
        record = self.find_by_booking(booking_id)
        if not record:
            raise EntityNotFoundError(f"Rejection record for booking {booking_id} not found")
        
        record.send_rejection_notification()
        
        self.session.flush()
        self.session.refresh(record)
        
        return record
    
    def find_with_alternatives_suggested(
        self,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> List[RejectionRecord]:
        """
        Find rejections where alternatives were suggested.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            List of rejection records with alternatives
        """
        query = select(RejectionRecord).join(
            Booking,
            RejectionRecord.booking_id == Booking.id
        ).where(
            and_(
                or_(
                    RejectionRecord.suggest_alternative_dates == True,
                    RejectionRecord.suggest_alternative_room_types == True,
                ),
                RejectionRecord.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(RejectionRecord.rejected_at >= date_from)
        
        if date_to:
            query = query.where(RejectionRecord.rejected_at <= date_to)
        
        query = query.order_by(RejectionRecord.rejected_at.desc()).options(
            joinedload(RejectionRecord.booking),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def get_rejection_statistics(
        self,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, any]:
        """
        Get rejection statistics.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Statistics dictionary
        """
        query = select(RejectionRecord).join(
            Booking,
            RejectionRecord.booking_id == Booking.id
        ).where(
            RejectionRecord.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(RejectionRecord.rejected_at >= date_from)
        
        if date_to:
            query = query.where(RejectionRecord.rejected_at <= date_to)
        
        rejections = self.session.execute(query).scalars().all()
        
        total_rejections = len(rejections)
        
        with_date_alternatives = sum(
            1 for r in rejections if r.suggest_alternative_dates
        )
        with_room_alternatives = sum(
            1 for r in rejections if r.suggest_alternative_room_types
        )
        notifications_sent = sum(
            1 for r in rejections if r.rejection_notification_sent
        )
        
        # Group by rejection reason (first 50 chars)
        reason_groups = {}
        for rejection in rejections:
            reason_key = rejection.rejection_reason[:50] if rejection.rejection_reason else "Unknown"
            reason_groups[reason_key] = reason_groups.get(reason_key, 0) + 1
        
        return {
            "total_rejections": total_rejections,
            "with_date_alternatives": with_date_alternatives,
            "with_room_alternatives": with_room_alternatives,
            "alternatives_suggested_rate": (
                (with_date_alternatives + with_room_alternatives) / total_rejections * 100
                if total_rejections > 0 else 0
            ),
            "notifications_sent": notifications_sent,
            "notification_rate": (
                notifications_sent / total_rejections * 100
                if total_rejections > 0 else 0
            ),
            "top_rejection_reasons": sorted(
                reason_groups.items(),
                key=lambda x: x[1],
                reverse=True
            )[:5],
        }

# --- File: C:\Hostel-Main\app\repositories\booking\booking_assignment_repository.py ---
# app/repositories/booking/booking_assignment_repository.py
"""
Booking assignment repository for room and bed assignment management.

Provides intelligent assignment operations, conflict resolution,
assignment tracking, and optimization.
"""

from datetime import datetime
from typing import Dict, List, Optional, Tuple
from uuid import UUID

from sqlalchemy import and_, func, or_, select
from sqlalchemy.orm import Session, joinedload

from app.core.exceptions import EntityNotFoundError, ValidationError
from app.models.booking.booking_assignment import (
    AssignmentHistory,
    BookingAssignment,
)
from app.models.booking.booking import Booking
from app.models.room.room import Room
from app.models.room.bed import Bed
from app.models.base.enums import BedStatus, RoomStatus
from app.repositories.base.base_repository import (
    AuditContext,
    BaseRepository,
    QueryOptions,
)


class BookingAssignmentRepository(BaseRepository[BookingAssignment]):
    """
    Repository for booking assignment operations.
    
    Provides:
    - Room and bed assignment
    - Assignment conflict detection
    - Assignment optimization
    - Assignment history tracking
    - Availability checking
    """
    
    def __init__(self, session: Session):
        """Initialize assignment repository."""
        super().__init__(session, BookingAssignment)
    
    # ==================== ASSIGNMENT OPERATIONS ====================
    
    def create_assignment(
        self,
        assignment_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingAssignment:
        """
        Create new booking assignment.
        
        Args:
            assignment_data: Assignment information
            audit_context: Audit context
            
        Returns:
            Created assignment
            
        Raises:
            ValidationError: If assignment conflicts or validation fails
        """
        booking_id = assignment_data.get('booking_id')
        room_id = assignment_data.get('room_id')
        bed_id = assignment_data.get('bed_id')
        
        # Validate no existing active assignment for booking
        existing = self.find_active_by_booking(booking_id)
        if existing:
            raise ValidationError(
                f"Booking {booking_id} already has an active assignment"
            )
        
        # Validate bed belongs to room
        bed = self.session.get(Bed, bed_id)
        if not bed or bed.room_id != room_id:
            raise ValidationError("Bed does not belong to the specified room")
        
        # Validate bed is available
        if bed.status != BedStatus.AVAILABLE:
            raise ValidationError(f"Bed {bed_id} is not available for assignment")
        
        # Create assignment
        assignment = BookingAssignment(
            assigned_by=audit_context.user_id if audit_context else None,
            assigned_at=datetime.utcnow(),
            **assignment_data,
        )
        
        created = self.create(assignment, audit_context)
        
        # Create history entry
        self._create_assignment_history(
            assignment_id=created.id,
            booking_id=booking_id,
            to_room_id=room_id,
            to_bed_id=bed_id,
            change_type="initial",
            changed_by=audit_context.user_id if audit_context else None,
            change_reason="Initial assignment",
        )
        
        # Update bed status
        bed.status = BedStatus.RESERVED
        self.session.flush()
        
        return created
    
    def find_by_booking(self, booking_id: UUID) -> Optional[BookingAssignment]:
        """
        Find assignment for a booking (including inactive).
        
        Args:
            booking_id: Booking UUID
            
        Returns:
            Assignment if found
        """
        query = select(BookingAssignment).where(
            BookingAssignment.booking_id == booking_id
        ).where(
            BookingAssignment.deleted_at.is_(None)
        ).options(
            joinedload(BookingAssignment.booking),
            joinedload(BookingAssignment.room),
            joinedload(BookingAssignment.bed),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def find_active_by_booking(self, booking_id: UUID) -> Optional[BookingAssignment]:
        """
        Find active assignment for a booking.
        
        Args:
            booking_id: Booking UUID
            
        Returns:
            Active assignment if found
        """
        query = select(BookingAssignment).where(
            and_(
                BookingAssignment.booking_id == booking_id,
                BookingAssignment.is_active == True,
                BookingAssignment.deleted_at.is_(None),
            )
        ).options(
            joinedload(BookingAssignment.booking),
            joinedload(BookingAssignment.room),
            joinedload(BookingAssignment.bed),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def find_by_room(
        self,
        room_id: UUID,
        active_only: bool = True,
    ) -> List[BookingAssignment]:
        """
        Find assignments for a room.
        
        Args:
            room_id: Room UUID
            active_only: If True, only return active assignments
            
        Returns:
            List of assignments
        """
        query = select(BookingAssignment).where(
            and_(
                BookingAssignment.room_id == room_id,
                BookingAssignment.deleted_at.is_(None),
            )
        )
        
        if active_only:
            query = query.where(BookingAssignment.is_active == True)
        
        query = query.options(
            joinedload(BookingAssignment.booking),
            joinedload(BookingAssignment.bed),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_by_bed(
        self,
        bed_id: UUID,
        active_only: bool = True,
    ) -> List[BookingAssignment]:
        """
        Find assignments for a bed.
        
        Args:
            bed_id: Bed UUID
            active_only: If True, only return active assignments
            
        Returns:
            List of assignments
        """
        query = select(BookingAssignment).where(
            and_(
                BookingAssignment.bed_id == bed_id,
                BookingAssignment.deleted_at.is_(None),
            )
        )
        
        if active_only:
            query = query.where(BookingAssignment.is_active == True)
        
        query = query.options(
            joinedload(BookingAssignment.booking),
            joinedload(BookingAssignment.room),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def reassign_booking(
        self,
        booking_id: UUID,
        new_room_id: UUID,
        new_bed_id: UUID,
        reason: str,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingAssignment:
        """
        Reassign booking to different room/bed.
        
        Args:
            booking_id: Booking UUID
            new_room_id: New room UUID
            new_bed_id: New bed UUID
            reason: Reassignment reason
            audit_context: Audit context
            
        Returns:
            Updated assignment
            
        Raises:
            EntityNotFoundError: If assignment not found
            ValidationError: If reassignment validation fails
        """
        assignment = self.find_active_by_booking(booking_id)
        if not assignment:
            raise EntityNotFoundError(
                f"Active assignment for booking {booking_id} not found"
            )
        
        # Validate new bed belongs to new room
        new_bed = self.session.get(Bed, new_bed_id)
        if not new_bed or new_bed.room_id != new_room_id:
            raise ValidationError("Bed does not belong to the specified room")
        
        # Validate new bed is available
        if new_bed.status not in [BedStatus.AVAILABLE, BedStatus.RESERVED]:
            raise ValidationError(f"Bed {new_bed_id} is not available")
        
        # Store old assignment info
        old_room_id = assignment.room_id
        old_bed_id = assignment.bed_id
        old_bed = self.session.get(Bed, old_bed_id)
        
        # Update assignment
        assignment.room_id = new_room_id
        assignment.bed_id = new_bed_id
        
        self.session.flush()
        
        # Create history entry
        self._create_assignment_history(
            assignment_id=assignment.id,
            booking_id=booking_id,
            from_room_id=old_room_id,
            from_bed_id=old_bed_id,
            to_room_id=new_room_id,
            to_bed_id=new_bed_id,
            change_type="reassignment",
            changed_by=audit_context.user_id if audit_context else None,
            change_reason=reason,
        )
        
        # Update bed statuses
        if old_bed:
            old_bed.status = BedStatus.AVAILABLE
        new_bed.status = BedStatus.RESERVED
        
        self.session.flush()
        self.session.refresh(assignment)
        
        return assignment
    
    def deactivate_assignment(
        self,
        booking_id: UUID,
        reason: str,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingAssignment:
        """
        Deactivate booking assignment.
        
        Args:
            booking_id: Booking UUID
            reason: Deactivation reason
            audit_context: Audit context
            
        Returns:
            Deactivated assignment
        """
        assignment = self.find_active_by_booking(booking_id)
        if not assignment:
            raise EntityNotFoundError(
                f"Active assignment for booking {booking_id} not found"
            )
        
        # Deactivate
        assignment.deactivate(
            deactivated_by=audit_context.user_id if audit_context else None,
            reason=reason,
        )
        
        # Update bed status
        bed = self.session.get(Bed, assignment.bed_id)
        if bed:
            bed.status = BedStatus.AVAILABLE
        
        self.session.flush()
        self.session.refresh(assignment)
        
        return assignment
    
    def reactivate_assignment(
        self,
        booking_id: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingAssignment:
        """
        Reactivate deactivated assignment.
        
        Args:
            booking_id: Booking UUID
            audit_context: Audit context
            
        Returns:
            Reactivated assignment
        """
        assignment = self.find_by_booking(booking_id)
        if not assignment:
            raise EntityNotFoundError(f"Assignment for booking {booking_id} not found")
        
        if assignment.is_active:
            raise ValidationError("Assignment is already active")
        
        # Validate bed is available
        bed = self.session.get(Bed, assignment.bed_id)
        if not bed or bed.status not in [BedStatus.AVAILABLE, BedStatus.RESERVED]:
            raise ValidationError("Bed is no longer available")
        
        # Reactivate
        assignment.reactivate()
        
        # Update bed status
        bed.status = BedStatus.RESERVED
        
        self.session.flush()
        self.session.refresh(assignment)
        
        return assignment
    
    # ==================== ASSIGNMENT HISTORY ====================
    
    def _create_assignment_history(
        self,
        assignment_id: UUID,
        booking_id: UUID,
        to_room_id: UUID,
        to_bed_id: UUID,
        change_type: str,
        changed_by: Optional[UUID],
        change_reason: str,
        from_room_id: Optional[UUID] = None,
        from_bed_id: Optional[UUID] = None,
    ) -> AssignmentHistory:
        """Create assignment history entry."""
        history = AssignmentHistory(
            assignment_id=assignment_id,
            booking_id=booking_id,
            from_room_id=from_room_id,
            from_bed_id=from_bed_id,
            to_room_id=to_room_id,
            to_bed_id=to_bed_id,
            change_type=change_type,
            changed_by=changed_by,
            change_reason=change_reason,
            changed_at=datetime.utcnow(),
        )
        
        self.session.add(history)
        self.session.flush()
        
        return history
    
    def get_assignment_history(self, booking_id: UUID) -> List[AssignmentHistory]:
        """
        Get assignment history for a booking.
        
        Args:
            booking_id: Booking UUID
            
        Returns:
            List of assignment changes
        """
        query = select(AssignmentHistory).where(
            AssignmentHistory.booking_id == booking_id
        ).order_by(
            AssignmentHistory.changed_at.desc()
        ).options(
            joinedload(AssignmentHistory.from_room),
            joinedload(AssignmentHistory.from_bed),
            joinedload(AssignmentHistory.to_room),
            joinedload(AssignmentHistory.to_bed),
            joinedload(AssignmentHistory.changer),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    # ==================== AVAILABILITY & OPTIMIZATION ====================
    
    def find_available_beds_for_booking(
        self,
        hostel_id: UUID,
        room_type: str,
        gender_preference: Optional[str] = None,
        limit: Optional[int] = None,
    ) -> List[Bed]:
        """
        Find available beds suitable for a booking.
        
        Args:
            hostel_id: Hostel UUID
            room_type: Requested room type
            gender_preference: Optional gender preference
            limit: Optional result limit
            
        Returns:
            List of available beds
        """
        query = select(Bed).join(
            Room,
            Bed.room_id == Room.id
        ).where(
            and_(
                Room.hostel_id == hostel_id,
                Room.room_type == room_type,
                Bed.status == BedStatus.AVAILABLE,
                Room.status == RoomStatus.AVAILABLE,
                Bed.deleted_at.is_(None),
                Room.deleted_at.is_(None),
            )
        )
        
        if gender_preference:
            query = query.where(Room.gender_type == gender_preference)
        
        query = query.options(
            joinedload(Bed.room)
        ).order_by(
            Room.floor_number.asc(),
            Room.room_number.asc(),
            Bed.bed_number.asc(),
        )
        
        if limit:
            query = query.limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def get_room_assignment_statistics(
        self,
        room_id: UUID,
    ) -> Dict[str, any]:
        """
        Get assignment statistics for a room.
        
        Args:
            room_id: Room UUID
            
        Returns:
            Statistics dictionary
        """
        assignments = self.find_by_room(room_id, active_only=True)
        
        room = self.session.get(Room, room_id)
        if not room:
            raise EntityNotFoundError(f"Room {room_id} not found")
        
        total_beds = room.capacity
        assigned_beds = len(assignments)
        available_beds = total_beds - assigned_beds
        occupancy_rate = (assigned_beds / total_beds * 100) if total_beds > 0 else 0
        
        return {
            "room_id": room_id,
            "total_beds": total_beds,
            "assigned_beds": assigned_beds,
            "available_beds": available_beds,
            "occupancy_rate": occupancy_rate,
            "assignments": assignments,
        }
    
    def find_auto_assigned(
        self,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> List[BookingAssignment]:
        """
        Find auto-assigned bookings.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            List of auto-assigned bookings
        """
        query = select(BookingAssignment).join(
            Booking,
            BookingAssignment.booking_id == Booking.id
        ).where(
            and_(
                BookingAssignment.auto_assigned == True,
                BookingAssignment.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(BookingAssignment.assigned_at >= date_from)
        
        if date_to:
            query = query.where(BookingAssignment.assigned_at <= date_to)
        
        query = query.order_by(BookingAssignment.assigned_at.desc()).options(
            joinedload(BookingAssignment.booking),
            joinedload(BookingAssignment.room),
            joinedload(BookingAssignment.bed),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())

# --- File: C:\Hostel-Main\app\repositories\booking\booking_calendar_repository.py ---
# app/repositories/booking/booking_calendar_repository.py
"""
Booking calendar repository for calendar management and availability tracking.

Provides calendar event management, availability calculations, blocking,
and visual calendar data generation.
"""

from datetime import date, datetime, timedelta
from typing import Dict, List, Optional, Tuple
from uuid import UUID

from sqlalchemy import and_, func, or_, select
from sqlalchemy.orm import Session, joinedload

from app.core.exceptions import EntityNotFoundError, ValidationError
from app.models.booking.booking_calendar import (
    BookingCalendarEvent,
    CalendarBlock,
    DayAvailability,
)
from app.models.booking.booking import Booking
from app.models.room.room import Room
from app.models.room.bed import Bed
from app.models.base.enums import BookingStatus, BedStatus
from app.repositories.base.base_repository import (
    AuditContext,
    BaseRepository,
    QueryOptions,
)


class BookingCalendarEventRepository(BaseRepository[BookingCalendarEvent]):
    """
    Repository for booking calendar events.
    
    Provides:
    - Calendar event management
    - Event visualization
    - Event filtering and search
    - Priority event tracking
    """
    
    def __init__(self, session: Session):
        """Initialize calendar event repository."""
        super().__init__(session, BookingCalendarEvent)
    
    # ==================== EVENT OPERATIONS ====================
    
    def create_event_from_booking(
        self,
        booking: Booking,
        event_type: str,
        event_date: date,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingCalendarEvent:
        """
        Create calendar event from booking.
        
        Args:
            booking: Booking instance
            event_type: Type of event
            event_date: Event date
            audit_context: Audit context
            
        Returns:
            Created event
        """
        # Determine color based on event type
        color_map = {
            "check_in": "#4CAF50",  # Green
            "check_out": "#F44336",  # Red
            "booking_request": "#2196F3",  # Blue
            "payment_due": "#FF9800",  # Orange
        }
        
        # Generate event title
        guest_name = None
        if booking.guest_info:
            guest_name = booking.guest_info.guest_name
        
        title_map = {
            "check_in": f"Check-in: {guest_name or 'Guest'}",
            "check_out": f"Check-out: {guest_name or 'Guest'}",
            "booking_request": f"New Booking: {booking.booking_reference}",
            "payment_due": f"Payment Due: {booking.booking_reference}",
        }
        
        event = BookingCalendarEvent(
            hostel_id=booking.hostel_id,
            booking_id=booking.id,
            room_id=booking.assignment.room_id if booking.assignment else None,
            event_type=event_type,
            event_date=event_date,
            event_title=title_map.get(event_type, event_type),
            guest_name=guest_name,
            room_type=str(booking.room_type_requested),
            booking_status=booking.booking_status,
            color_code=color_map.get(event_type, "#9E9E9E"),
        )
        
        return self.create(event, audit_context)
    
    def find_events_for_date_range(
        self,
        hostel_id: UUID,
        start_date: date,
        end_date: date,
        event_types: Optional[List[str]] = None,
    ) -> List[BookingCalendarEvent]:
        """
        Find calendar events for a date range.
        
        Args:
            hostel_id: Hostel UUID
            start_date: Range start date
            end_date: Range end date
            event_types: Optional event type filter
            
        Returns:
            List of calendar events
        """
        query = select(BookingCalendarEvent).where(
            and_(
                BookingCalendarEvent.hostel_id == hostel_id,
                BookingCalendarEvent.event_date >= start_date,
                BookingCalendarEvent.event_date <= end_date,
                BookingCalendarEvent.deleted_at.is_(None),
            )
        )
        
        if event_types:
            query = query.where(BookingCalendarEvent.event_type.in_(event_types))
        
        query = query.order_by(
            BookingCalendarEvent.event_date.asc(),
            BookingCalendarEvent.event_type.asc()
        ).options(
            joinedload(BookingCalendarEvent.booking),
            joinedload(BookingCalendarEvent.room),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_events_for_month(
        self,
        hostel_id: UUID,
        year: int,
        month: int,
    ) -> List[BookingCalendarEvent]:
        """
        Find all events for a specific month.
        
        Args:
            hostel_id: Hostel UUID
            year: Year
            month: Month (1-12)
            
        Returns:
            List of calendar events
        """
        from calendar import monthrange
        
        start_date = date(year, month, 1)
        last_day = monthrange(year, month)[1]
        end_date = date(year, month, last_day)
        
        return self.find_events_for_date_range(hostel_id, start_date, end_date)
    
    def find_high_priority_events(
        self,
        hostel_id: UUID,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
    ) -> List[BookingCalendarEvent]:
        """
        Find high priority events.
        
        Args:
            hostel_id: Hostel UUID
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            List of high priority events
        """
        query = select(BookingCalendarEvent).where(
            and_(
                BookingCalendarEvent.hostel_id == hostel_id,
                BookingCalendarEvent.is_high_priority == True,
                BookingCalendarEvent.deleted_at.is_(None),
            )
        )
        
        if date_from:
            query = query.where(BookingCalendarEvent.event_date >= date_from)
        
        if date_to:
            query = query.where(BookingCalendarEvent.event_date <= date_to)
        
        query = query.order_by(BookingCalendarEvent.event_date.asc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_events_requiring_action(
        self,
        hostel_id: UUID,
    ) -> List[BookingCalendarEvent]:
        """
        Find events that require admin action.
        
        Args:
            hostel_id: Hostel UUID
            
        Returns:
            List of events requiring action
        """
        query = select(BookingCalendarEvent).where(
            and_(
                BookingCalendarEvent.hostel_id == hostel_id,
                BookingCalendarEvent.requires_action == True,
                BookingCalendarEvent.deleted_at.is_(None),
            )
        ).order_by(
            BookingCalendarEvent.event_date.asc()
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def mark_action_completed(
        self,
        event_id: UUID,
    ) -> BookingCalendarEvent:
        """
        Mark event action as completed.
        
        Args:
            event_id: Event UUID
            
        Returns:
            Updated event
        """
        event = self.find_by_id(event_id)
        if not event:
            raise EntityNotFoundError(f"Calendar event {event_id} not found")
        
        event.clear_action_required()
        
        self.session.flush()
        self.session.refresh(event)
        
        return event


class DayAvailabilityRepository(BaseRepository[DayAvailability]):
    """
    Repository for day-by-day availability tracking.
    
    Provides:
    - Availability calculation and caching
    - Occupancy tracking
    - Availability forecasting
    """
    
    def __init__(self, session: Session):
        """Initialize day availability repository."""
        super().__init__(session, DayAvailability)
    
    # ==================== AVAILABILITY OPERATIONS ====================
    
    def find_or_create_for_date(
        self,
        hostel_id: UUID,
        availability_date: date,
        room_id: Optional[UUID] = None,
    ) -> DayAvailability:
        """
        Find or create availability record for a specific date.
        
        Args:
            hostel_id: Hostel UUID
            availability_date: Date
            room_id: Optional room UUID for room-specific availability
            
        Returns:
            Day availability record
        """
        query = select(DayAvailability).where(
            and_(
                DayAvailability.hostel_id == hostel_id,
                DayAvailability.availability_date == availability_date,
            )
        )
        
        if room_id:
            query = query.where(DayAvailability.room_id == room_id)
        else:
            query = query.where(DayAvailability.room_id.is_(None))
        
        result = self.session.execute(query)
        availability = result.scalar_one_or_none()
        
        if not availability:
            # Create new record
            availability = DayAvailability(
                hostel_id=hostel_id,
                room_id=room_id,
                availability_date=availability_date,
            )
            self.session.add(availability)
            self.session.flush()
        
        return availability
    
    def calculate_and_update_availability(
        self,
        hostel_id: UUID,
        availability_date: date,
        room_id: Optional[UUID] = None,
    ) -> DayAvailability:
        """
        Calculate and update availability for a date.
        
        Args:
            hostel_id: Hostel UUID
            availability_date: Date to calculate
            room_id: Optional room UUID
            
        Returns:
            Updated availability record
        """
        availability = self.find_or_create_for_date(hostel_id, availability_date, room_id)
        
        # Query total beds
        bed_query = select(func.count(Bed.id)).join(
            Room,
            Bed.room_id == Room.id
        ).where(
            and_(
                Room.hostel_id == hostel_id,
                Bed.deleted_at.is_(None),
                Room.deleted_at.is_(None),
            )
        )
        
        if room_id:
            bed_query = bed_query.where(Room.id == room_id)
        
        availability.total_beds = self.session.execute(bed_query).scalar_one()
        
        # Count beds by status
        for status in [BedStatus.OCCUPIED, BedStatus.RESERVED, BedStatus.MAINTENANCE, BedStatus.BLOCKED]:
            status_query = select(func.count(Bed.id)).join(
                Room,
                Bed.room_id == Room.id
            ).where(
                and_(
                    Room.hostel_id == hostel_id,
                    Bed.status == status,
                    Bed.deleted_at.is_(None),
                    Room.deleted_at.is_(None),
                )
            )
            
            if room_id:
                status_query = status_query.where(Room.id == room_id)
            
            count = self.session.execute(status_query).scalar_one()
            
            if status == BedStatus.OCCUPIED:
                availability.occupied_beds = count
            elif status == BedStatus.RESERVED:
                availability.reserved_beds = count
            elif status == BedStatus.MAINTENANCE:
                availability.maintenance_beds = count
            elif status == BedStatus.BLOCKED:
                availability.blocked_beds = count
        
        # Calculate availability
        availability.calculate_availability()
        
        self.session.flush()
        self.session.refresh(availability)
        
        return availability
    
    def get_availability_for_date_range(
        self,
        hostel_id: UUID,
        start_date: date,
        end_date: date,
        room_id: Optional[UUID] = None,
    ) -> List[DayAvailability]:
        """
        Get availability records for a date range.
        
        Args:
            hostel_id: Hostel UUID
            start_date: Range start
            end_date: Range end
            room_id: Optional room filter
            
        Returns:
            List of availability records
        """
        query = select(DayAvailability).where(
            and_(
                DayAvailability.hostel_id == hostel_id,
                DayAvailability.availability_date >= start_date,
                DayAvailability.availability_date <= end_date,
            )
        )
        
        if room_id:
            query = query.where(DayAvailability.room_id == room_id)
        else:
            query = query.where(DayAvailability.room_id.is_(None))
        
        query = query.order_by(DayAvailability.availability_date.asc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_fully_booked_dates(
        self,
        hostel_id: UUID,
        date_from: date,
        date_to: date,
    ) -> List[date]:
        """
        Find dates when hostel is fully booked.
        
        Args:
            hostel_id: Hostel UUID
            date_from: Range start
            date_to: Range end
            
        Returns:
            List of fully booked dates
        """
        query = select(DayAvailability.availability_date).where(
            and_(
                DayAvailability.hostel_id == hostel_id,
                DayAvailability.is_fully_booked == True,
                DayAvailability.availability_date >= date_from,
                DayAvailability.availability_date <= date_to,
            )
        ).order_by(DayAvailability.availability_date.asc())
        
        result = self.session.execute(query)
        return [row[0] for row in result.all()]
    
    def get_occupancy_trend(
        self,
        hostel_id: UUID,
        days: int = 30,
    ) -> List[Dict]:
        """
        Get occupancy trend for recent days.
        
        Args:
            hostel_id: Hostel UUID
            days: Number of days to look back
            
        Returns:
            List of occupancy data points
        """
        end_date = date.today()
        start_date = end_date - timedelta(days=days)
        
        availabilities = self.get_availability_for_date_range(
            hostel_id,
            start_date,
            end_date
        )
        
        return [
            {
                "date": avail.availability_date,
                "total_beds": avail.total_beds,
                "occupied_beds": avail.occupied_beds,
                "available_beds": avail.available_beds,
                "occupancy_rate": avail.occupancy_rate,
            }
            for avail in availabilities
        ]


class CalendarBlockRepository(BaseRepository[CalendarBlock]):
    """
    Repository for calendar blocking management.
    
    Provides:
    - Block creation and management
    - Conflict detection
    - Block impact analysis
    - Completion tracking
    """
    
    def __init__(self, session: Session):
        """Initialize calendar block repository."""
        super().__init__(session, CalendarBlock)
    
    # ==================== BLOCK OPERATIONS ====================
    
    def create_block(
        self,
        block_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> CalendarBlock:
        """
        Create calendar block.
        
        Args:
            block_data: Block information
            audit_context: Audit context
            
        Returns:
            Created block
            
        Raises:
            ValidationError: If validation fails
        """
        # Validate dates
        start_date = block_data.get('start_date')
        end_date = block_data.get('end_date')
        
        if end_date < start_date:
            raise ValidationError("End date must be after or equal to start date")
        
        block = CalendarBlock(
            blocked_by=audit_context.user_id if audit_context else None,
            **block_data,
        )
        
        created = self.create(block, audit_context)
        
        # Calculate affected bookings if needed
        if created.affects_bookings:
            affected_count = self._count_affected_bookings(created)
            created.affected_booking_count = affected_count
            self.session.flush()
        
        return created
    
    def _count_affected_bookings(self, block: CalendarBlock) -> int:
        """Count bookings affected by a block."""
        query = select(func.count(Booking.id)).where(
            and_(
                Booking.hostel_id == block.hostel_id,
                Booking.booking_status.in_([
                    BookingStatus.APPROVED,
                    BookingStatus.CONFIRMED,
                ]),
                Booking.preferred_check_in_date <= block.end_date,
                func.date(
                    Booking.preferred_check_in_date +
                    func.cast(Booking.stay_duration_months * 30, func.text('interval day'))
                ) >= block.start_date,
                Booking.deleted_at.is_(None),
            )
        )
        
        if block.room_id:
            # Check assignments
            from app.models.booking.booking_assignment import BookingAssignment
            query = query.join(
                BookingAssignment,
                Booking.id == BookingAssignment.booking_id
            ).where(
                BookingAssignment.room_id == block.room_id
            )
        
        return self.session.execute(query).scalar_one()
    
    def find_active_blocks(
        self,
        hostel_id: UUID,
        as_of_date: Optional[date] = None,
    ) -> List[CalendarBlock]:
        """
        Find active blocks for a hostel.
        
        Args:
            hostel_id: Hostel UUID
            as_of_date: Optional date to check (default: today)
            
        Returns:
            List of active blocks
        """
        check_date = as_of_date or date.today()
        
        query = select(CalendarBlock).where(
            and_(
                CalendarBlock.hostel_id == hostel_id,
                CalendarBlock.is_active == True,
                CalendarBlock.start_date <= check_date,
                CalendarBlock.end_date >= check_date,
                CalendarBlock.deleted_at.is_(None),
            )
        ).options(
            joinedload(CalendarBlock.room),
            joinedload(CalendarBlock.bed),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_blocks_for_date_range(
        self,
        hostel_id: UUID,
        start_date: date,
        end_date: date,
        room_id: Optional[UUID] = None,
    ) -> List[CalendarBlock]:
        """
        Find blocks overlapping with a date range.
        
        Args:
            hostel_id: Hostel UUID
            start_date: Range start
            end_date: Range end
            room_id: Optional room filter
            
        Returns:
            List of overlapping blocks
        """
        query = select(CalendarBlock).where(
            and_(
                CalendarBlock.hostel_id == hostel_id,
                CalendarBlock.is_active == True,
                or_(
                    # Block starts during range
                    and_(
                        CalendarBlock.start_date >= start_date,
                        CalendarBlock.start_date <= end_date,
                    ),
                    # Block ends during range
                    and_(
                        CalendarBlock.end_date >= start_date,
                        CalendarBlock.end_date <= end_date,
                    ),
                    # Block completely contains range
                    and_(
                        CalendarBlock.start_date <= start_date,
                        CalendarBlock.end_date >= end_date,
                    )
                ),
                CalendarBlock.deleted_at.is_(None),
            )
        )
        
        if room_id:
            query = query.where(
                or_(
                    CalendarBlock.room_id == room_id,
                    CalendarBlock.room_id.is_(None),  # Hostel-wide blocks
                )
            )
        
        query = query.order_by(CalendarBlock.start_date.asc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_upcoming_blocks(
        self,
        hostel_id: UUID,
        days_ahead: int = 30,
    ) -> List[CalendarBlock]:
        """
        Find upcoming blocks.
        
        Args:
            hostel_id: Hostel UUID
            days_ahead: Days to look ahead
            
        Returns:
            List of upcoming blocks
        """
        today = date.today()
        end_date = today + timedelta(days=days_ahead)
        
        query = select(CalendarBlock).where(
            and_(
                CalendarBlock.hostel_id == hostel_id,
                CalendarBlock.is_active == True,
                CalendarBlock.start_date > today,
                CalendarBlock.start_date <= end_date,
                CalendarBlock.deleted_at.is_(None),
            )
        ).order_by(CalendarBlock.start_date.asc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def mark_completed(
        self,
        block_id: UUID,
        completion_notes: Optional[str] = None,
    ) -> CalendarBlock:
        """
        Mark block as completed.
        
        Args:
            block_id: Block UUID
            completion_notes: Optional completion notes
            
        Returns:
            Updated block
        """
        block = self.find_by_id(block_id)
        if not block:
            raise EntityNotFoundError(f"Calendar block {block_id} not found")
        
        block.mark_completed(completion_notes)
        
        self.session.flush()
        self.session.refresh(block)
        
        return block
    
    def send_notification(
        self,
        block_id: UUID,
    ) -> CalendarBlock:
        """
        Mark notification as sent for a block.
        
        Args:
            block_id: Block UUID
            
        Returns:
            Updated block
        """
        block = self.find_by_id(block_id)
        if not block:
            raise EntityNotFoundError(f"Calendar block {block_id} not found")
        
        block.send_notification()
        
        self.session.flush()
        self.session.refresh(block)
        
        return block
    
    def get_block_statistics(
        self,
        hostel_id: UUID,
        date_from: Optional[date] = None,
        date_to: Optional[date] = None,
    ) -> Dict[str, any]:
        """
        Get statistics about calendar blocks.
        
        Args:
            hostel_id: Hostel UUID
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Statistics dictionary
        """
        query = select(CalendarBlock).where(
            and_(
                CalendarBlock.hostel_id == hostel_id,
                CalendarBlock.deleted_at.is_(None),
            )
        )
        
        if date_from:
            query = query.where(CalendarBlock.start_date >= date_from)
        
        if date_to:
            query = query.where(CalendarBlock.end_date <= date_to)
        
        blocks = self.session.execute(query).scalars().all()
        
        total_blocks = len(blocks)
        active_blocks = sum(1 for b in blocks if b.is_active)
        completed_blocks = sum(1 for b in blocks if b.is_completed)
        
        # Group by type
        by_type = {}
        for block in blocks:
            by_type[block.block_type] = by_type.get(block.block_type, 0) + 1
        
        # Total affected bookings
        total_affected = sum(b.affected_booking_count for b in blocks)
        
        # Average duration
        total_days = sum(b.duration_days for b in blocks)
        avg_duration = total_days / total_blocks if total_blocks > 0 else 0
        
        return {
            "total_blocks": total_blocks,
            "active_blocks": active_blocks,
            "completed_blocks": completed_blocks,
            "completion_rate": (completed_blocks / total_blocks * 100) if total_blocks > 0 else 0,
            "blocks_by_type": by_type,
            "total_affected_bookings": total_affected,
            "average_duration_days": avg_duration,
        }

# --- File: C:\Hostel-Main\app\repositories\booking\booking_cancellation_repository.py ---
# app/repositories/booking/booking_cancellation_repository.py
"""
Booking cancellation repository for cancellation and refund management.

Provides cancellation tracking, refund calculations, policy management,
and refund processing workflows.
"""

from datetime import date, datetime, timedelta
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from sqlalchemy import and_, func, or_, select
from sqlalchemy.orm import Session, joinedload

from app.core.exceptions import EntityNotFoundError, ValidationError
from app.models.booking.booking_cancellation import (
    BookingCancellation,
    CancellationPolicy,
    RefundTransaction,
)
from app.models.booking.booking import Booking
from app.models.base.enums import PaymentStatus
from app.repositories.base.base_repository import (
    AuditContext,
    BaseRepository,
    QueryOptions,
)


class BookingCancellationRepository(BaseRepository[BookingCancellation]):
    """
    Repository for booking cancellation operations.
    
    Provides:
    - Cancellation record management
    - Refund calculation and tracking
    - Refund status management
    - Cancellation analytics
    """
    
    def __init__(self, session: Session):
        """Initialize cancellation repository."""
        super().__init__(session, BookingCancellation)
    
    # ==================== CANCELLATION OPERATIONS ====================
    
    def create_cancellation(
        self,
        booking_id: UUID,
        cancellation_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingCancellation:
        """
        Create cancellation record for a booking.
        
        Args:
            booking_id: Booking UUID
            cancellation_data: Cancellation information
            audit_context: Audit context
            
        Returns:
            Created cancellation record
        """
        cancellation = BookingCancellation(
            booking_id=booking_id,
            cancelled_by=audit_context.user_id if audit_context else None,
            cancelled_at=datetime.utcnow(),
            **cancellation_data,
        )
        
        return self.create(cancellation, audit_context)
    
    def find_by_booking(self, booking_id: UUID) -> Optional[BookingCancellation]:
        """
        Find cancellation record for a booking.
        
        Args:
            booking_id: Booking UUID
            
        Returns:
            Cancellation record if found
        """
        query = select(BookingCancellation).where(
            BookingCancellation.booking_id == booking_id
        ).where(
            BookingCancellation.deleted_at.is_(None)
        ).options(
            joinedload(BookingCancellation.booking),
            joinedload(BookingCancellation.canceller),
            joinedload(BookingCancellation.refund_transaction),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def calculate_refund_amount(
        self,
        booking: Booking,
        cancellation_policy: Optional[CancellationPolicy] = None,
    ) -> Tuple[Decimal, Decimal, Decimal]:
        """
        Calculate refund amount based on policy.
        
        Args:
            booking: Booking instance
            cancellation_policy: Optional specific policy (otherwise use hostel's)
            
        Returns:
            Tuple of (cancellation_charge, cancellation_charge_percentage, refundable_amount)
        """
        advance_paid = booking.advance_amount if booking.advance_paid else Decimal("0.00")
        
        if not cancellation_policy:
            # Get default policy for hostel
            policy_repo = CancellationPolicyRepository(self.session)
            cancellation_policy = policy_repo.find_active_by_hostel(booking.hostel_id)
        
        if not cancellation_policy:
            # No policy: full refund
            return Decimal("0.00"), Decimal("0.00"), advance_paid
        
        # Calculate days before check-in
        days_before = (booking.preferred_check_in_date - date.today()).days
        
        # Calculate cancellation charge
        charge = cancellation_policy.calculate_cancellation_charge(
            days_before,
            advance_paid
        )
        
        # Calculate percentage
        charge_percentage = (charge / advance_paid * 100).quantize(Decimal("0.01")) if advance_paid > 0 else Decimal("0.00")
        
        # Calculate refundable amount
        refundable = (advance_paid - charge).quantize(Decimal("0.01"))
        
        return charge, charge_percentage, refundable
    
    def initiate_refund(
        self,
        cancellation_id: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingCancellation:
        """
        Initiate refund processing.
        
        Args:
            cancellation_id: Cancellation UUID
            audit_context: Audit context
            
        Returns:
            Updated cancellation
        """
        cancellation = self.find_by_id(cancellation_id)
        if not cancellation:
            raise EntityNotFoundError(f"Cancellation {cancellation_id} not found")
        
        cancellation.initiate_refund()
        
        self.session.flush()
        self.session.refresh(cancellation)
        
        return cancellation
    
    def complete_refund(
        self,
        cancellation_id: UUID,
        transaction_id: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingCancellation:
        """
        Mark refund as completed.
        
        Args:
            cancellation_id: Cancellation UUID
            transaction_id: Refund transaction UUID
            audit_context: Audit context
            
        Returns:
            Updated cancellation
        """
        cancellation = self.find_by_id(cancellation_id)
        if not cancellation:
            raise EntityNotFoundError(f"Cancellation {cancellation_id} not found")
        
        cancellation.complete_refund(transaction_id)
        
        self.session.flush()
        self.session.refresh(cancellation)
        
        return cancellation
    
    def fail_refund(
        self,
        cancellation_id: UUID,
        reason: str,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingCancellation:
        """
        Mark refund as failed.
        
        Args:
            cancellation_id: Cancellation UUID
            reason: Failure reason
            audit_context: Audit context
            
        Returns:
            Updated cancellation
        """
        cancellation = self.find_by_id(cancellation_id)
        if not cancellation:
            raise EntityNotFoundError(f"Cancellation {cancellation_id} not found")
        
        cancellation.fail_refund(reason)
        
        self.session.flush()
        self.session.refresh(cancellation)
        
        return cancellation
    
    def find_pending_refunds(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingCancellation]:
        """
        Find cancellations with pending refunds.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of cancellations with pending refunds
        """
        query = select(BookingCancellation).join(
            Booking,
            BookingCancellation.booking_id == Booking.id
        ).where(
            and_(
                BookingCancellation.request_refund == True,
                BookingCancellation.refund_status == PaymentStatus.PENDING,
                BookingCancellation.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.order_by(BookingCancellation.cancelled_at.asc()).options(
            joinedload(BookingCancellation.booking),
            joinedload(BookingCancellation.canceller),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_processing_refunds(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingCancellation]:
        """
        Find refunds currently being processed.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of refunds in processing
        """
        query = select(BookingCancellation).join(
            Booking,
            BookingCancellation.booking_id == Booking.id
        ).where(
            and_(
                BookingCancellation.refund_status == PaymentStatus.PROCESSING,
                BookingCancellation.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.order_by(BookingCancellation.refund_initiated_at.asc()).options(
            joinedload(BookingCancellation.booking),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_overdue_refunds(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingCancellation]:
        """
        Find refunds that are overdue (past expected completion date).
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of overdue refunds
        """
        query = select(BookingCancellation).join(
            Booking,
            BookingCancellation.booking_id == Booking.id
        ).where(
            and_(
                BookingCancellation.refund_status == PaymentStatus.PROCESSING,
                BookingCancellation.refund_initiated_at.isnot(None),
                BookingCancellation.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        # Filter for overdue (processing time exceeded)
        cancellations = self.session.execute(query).scalars().all()
        
        overdue = [
            c for c in cancellations
            if c.expected_refund_date and c.expected_refund_date < datetime.utcnow()
        ]
        
        return overdue
    
    def get_cancellation_statistics(
        self,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, any]:
        """
        Get cancellation statistics.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Statistics dictionary
        """
        query = select(BookingCancellation).join(
            Booking,
            BookingCancellation.booking_id == Booking.id
        ).where(
            BookingCancellation.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(BookingCancellation.cancelled_at >= date_from)
        
        if date_to:
            query = query.where(BookingCancellation.cancelled_at <= date_to)
        
        cancellations = self.session.execute(query).scalars().all()
        
        total_cancellations = len(cancellations)
        
        # Refund statistics
        refund_requested = sum(1 for c in cancellations if c.request_refund)
        refunds_pending = sum(
            1 for c in cancellations
            if c.refund_status == PaymentStatus.PENDING
        )
        refunds_processing = sum(
            1 for c in cancellations
            if c.refund_status == PaymentStatus.PROCESSING
        )
        refunds_completed = sum(
            1 for c in cancellations
            if c.refund_status == PaymentStatus.COMPLETED
        )
        refunds_failed = sum(
            1 for c in cancellations
            if c.refund_status == PaymentStatus.FAILED
        )
        
        # Financial statistics
        total_advance_paid = sum(c.advance_paid for c in cancellations)
        total_charges = sum(c.cancellation_charge for c in cancellations)
        total_refundable = sum(c.refundable_amount for c in cancellations)
        
        avg_charge_percentage = (
            sum(c.cancellation_charge_percentage for c in cancellations) / total_cancellations
            if total_cancellations > 0 else Decimal("0.00")
        )
        
        # Group by canceller role
        by_role = {}
        for cancellation in cancellations:
            role = cancellation.cancelled_by_role
            by_role[role] = by_role.get(role, 0) + 1
        
        # Average days since cancellation
        avg_days_since = (
            sum(c.days_since_cancellation for c in cancellations) / total_cancellations
            if total_cancellations > 0 else 0
        )
        
        return {
            "total_cancellations": total_cancellations,
            "refund_requested": refund_requested,
            "refund_request_rate": (refund_requested / total_cancellations * 100) if total_cancellations > 0 else 0,
            "refunds_pending": refunds_pending,
            "refunds_processing": refunds_processing,
            "refunds_completed": refunds_completed,
            "refunds_failed": refunds_failed,
            "refund_completion_rate": (refunds_completed / refund_requested * 100) if refund_requested > 0 else 0,
            "total_advance_paid": total_advance_paid,
            "total_cancellation_charges": total_charges,
            "total_refundable_amount": total_refundable,
            "average_charge_percentage": avg_charge_percentage,
            "cancellations_by_role": by_role,
            "average_days_since_cancellation": avg_days_since,
        }


class CancellationPolicyRepository(BaseRepository[CancellationPolicy]):
    """Repository for cancellation policy management."""
    
    def __init__(self, session: Session):
        """Initialize policy repository."""
        super().__init__(session, CancellationPolicy)
    
    def find_by_hostel(
        self,
        hostel_id: UUID,
        include_inactive: bool = False,
    ) -> List[CancellationPolicy]:
        """
        Find cancellation policies for a hostel.
        
        Args:
            hostel_id: Hostel UUID
            include_inactive: Whether to include inactive policies
            
        Returns:
            List of policies
        """
        query = select(CancellationPolicy).where(
            and_(
                CancellationPolicy.hostel_id == hostel_id,
                CancellationPolicy.deleted_at.is_(None),
            )
        )
        
        if not include_inactive:
            query = query.where(CancellationPolicy.is_active == True)
        
        query = query.order_by(CancellationPolicy.effective_from.desc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_active_by_hostel(
        self,
        hostel_id: UUID,
        as_of_date: Optional[datetime] = None,
    ) -> Optional[CancellationPolicy]:
        """
        Find currently active cancellation policy for a hostel.
        
        Args:
            hostel_id: Hostel UUID
            as_of_date: Optional date to check (default: now)
            
        Returns:
            Active policy if found
        """
        check_date = as_of_date or datetime.utcnow()
        
        query = select(CancellationPolicy).where(
            and_(
                CancellationPolicy.hostel_id == hostel_id,
                CancellationPolicy.is_active == True,
                CancellationPolicy.effective_from <= check_date,
                or_(
                    CancellationPolicy.effective_until.is_(None),
                    CancellationPolicy.effective_until >= check_date,
                ),
                CancellationPolicy.deleted_at.is_(None),
            )
        ).order_by(CancellationPolicy.effective_from.desc())
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def create_or_update_policy(
        self,
        hostel_id: UUID,
        policy_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> CancellationPolicy:
        """
        Create new policy or update existing.
        
        Args:
            hostel_id: Hostel UUID
            policy_data: Policy data
            audit_context: Audit context
            
        Returns:
            Created or updated policy
        """
        # Deactivate existing active policies
        existing_policies = self.find_active_by_hostel(hostel_id)
        if existing_policies:
            existing_policies.is_active = False
            existing_policies.effective_until = datetime.utcnow()
        
        # Create new policy
        policy = CancellationPolicy(
            hostel_id=hostel_id,
            **policy_data,
        )
        
        return self.create(policy, audit_context)


class RefundTransactionRepository(BaseRepository[RefundTransaction]):
    """Repository for refund transaction tracking."""
    
    def __init__(self, session: Session):
        """Initialize refund transaction repository."""
        super().__init__(session, RefundTransaction)
    
    def create_refund_transaction(
        self,
        transaction_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> RefundTransaction:
        """
        Create refund transaction record.
        
        Args:
            transaction_data: Transaction data
            audit_context: Audit context
            
        Returns:
            Created transaction
        """
        transaction = RefundTransaction(**transaction_data)
        return self.create(transaction, audit_context)
    
    def find_by_cancellation(
        self,
        cancellation_id: UUID,
    ) -> List[RefundTransaction]:
        """
        Find refund transactions for a cancellation.
        
        Args:
            cancellation_id: Cancellation UUID
            
        Returns:
            List of refund transactions
        """
        query = select(RefundTransaction).where(
            RefundTransaction.cancellation_id == cancellation_id
        ).order_by(RefundTransaction.initiated_at.desc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_by_gateway_id(
        self,
        gateway_transaction_id: str,
    ) -> Optional[RefundTransaction]:
        """
        Find refund transaction by gateway transaction ID.
        
        Args:
            gateway_transaction_id: Gateway transaction ID
            
        Returns:
            Refund transaction if found
        """
        query = select(RefundTransaction).where(
            RefundTransaction.gateway_transaction_id == gateway_transaction_id
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()

# --- File: C:\Hostel-Main\app\repositories\booking\booking_conversion_repository.py ---
# app/repositories/booking/booking_conversion_repository.py
"""
Booking conversion repository for student conversion management.

Provides conversion workflow management, checklist tracking, document verification,
and conversion analytics.
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional, Tuple
from uuid import UUID

from sqlalchemy import and_, func, or_, select
from sqlalchemy.orm import Session, joinedload, selectinload

from app.core.exceptions import EntityNotFoundError, ValidationError
from app.models.booking.booking_conversion import (
    BookingConversion,
    ChecklistItem,
    ConversionChecklist,
)
from app.models.booking.booking import Booking
from app.models.base.enums import BookingStatus
from app.repositories.base.base_repository import (
    AuditContext,
    BaseRepository,
    QueryOptions,
)


class BookingConversionRepository(BaseRepository[BookingConversion]):
    """
    Repository for booking conversion operations.
    
    Provides:
    - Conversion record management
    - Conversion workflow tracking
    - Document verification
    - Payment tracking
    - Conversion analytics
    """
    
    def __init__(self, session: Session):
        """Initialize conversion repository."""
        super().__init__(session, BookingConversion)
    
    # ==================== CONVERSION OPERATIONS ====================
    
    def create_conversion(
        self,
        conversion_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingConversion:
        """
        Create conversion record for a booking.
        
        Args:
            conversion_data: Conversion information
            audit_context: Audit context
            
        Returns:
            Created conversion record
            
        Raises:
            ValidationError: If conversion validation fails
        """
        booking_id = conversion_data.get('booking_id')
        
        # Validate booking exists and is in correct status
        booking = self.session.get(Booking, booking_id)
        if not booking:
            raise EntityNotFoundError(f"Booking {booking_id} not found")
        
        if booking.booking_status != BookingStatus.CONFIRMED:
            raise ValidationError("Only confirmed bookings can be converted")
        
        # Validate no existing conversion
        existing = self.find_by_booking(booking_id)
        if existing:
            raise ValidationError(f"Booking {booking_id} already has a conversion record")
        
        conversion = BookingConversion(
            converted_by=audit_context.user_id if audit_context else None,
            converted_at=datetime.utcnow(),
            **conversion_data,
        )
        
        created = self.create(conversion, audit_context)
        
        # Create checklist
        self._create_default_checklist(created, audit_context)
        
        return created
    
    def _create_default_checklist(
        self,
        conversion: BookingConversion,
        audit_context: Optional[AuditContext] = None,
    ) -> ConversionChecklist:
        """Create default conversion checklist."""
        checklist_repo = ConversionChecklistRepository(self.session)
        
        checklist = checklist_repo.create_checklist(
            conversion_id=conversion.id,
            booking_id=conversion.booking_id,
            audit_context=audit_context,
        )
        
        # Add default checklist items
        default_items = [
            {
                "item_name": "Security Deposit Paid",
                "item_description": "Verify security deposit payment has been received",
                "item_category": "financial",
                "is_required": True,
                "item_order": 1,
            },
            {
                "item_name": "First Month Rent Paid",
                "item_description": "Verify first month's rent payment has been received",
                "item_category": "financial",
                "is_required": True,
                "item_order": 2,
            },
            {
                "item_name": "ID Proof Uploaded",
                "item_description": "Valid ID proof document uploaded and verified",
                "item_category": "documents",
                "is_required": True,
                "item_order": 3,
            },
            {
                "item_name": "Photo Uploaded",
                "item_description": "Student photo uploaded for records",
                "item_category": "documents",
                "is_required": True,
                "item_order": 4,
            },
            {
                "item_name": "Profile Information Complete",
                "item_description": "All required profile fields completed",
                "item_category": "profile",
                "is_required": True,
                "item_order": 5,
            },
            {
                "item_name": "Guardian Information Verified",
                "item_description": "Guardian contact information verified",
                "item_category": "verification",
                "is_required": True,
                "item_order": 6,
            },
            {
                "item_name": "Room Assignment Confirmed",
                "item_description": "Room and bed assignment confirmed",
                "item_category": "assignment",
                "is_required": True,
                "item_order": 7,
            },
        ]
        
        for item_data in default_items:
            checklist_repo.add_checklist_item(
                checklist.id,
                item_data,
                audit_context,
            )
        
        return checklist
    
    def find_by_booking(self, booking_id: UUID) -> Optional[BookingConversion]:
        """
        Find conversion record for a booking.
        
        Args:
            booking_id: Booking UUID
            
        Returns:
            Conversion record if found
        """
        query = select(BookingConversion).where(
            BookingConversion.booking_id == booking_id
        ).where(
            BookingConversion.deleted_at.is_(None)
        ).options(
            joinedload(BookingConversion.booking),
            joinedload(BookingConversion.student_profile),
            joinedload(BookingConversion.converter),
            selectinload(BookingConversion.checklist).selectinload(
                ConversionChecklist.items
            ),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def find_by_student(self, student_id: UUID) -> Optional[BookingConversion]:
        """
        Find conversion record by student profile.
        
        Args:
            student_id: Student UUID
            
        Returns:
            Conversion record if found
        """
        query = select(BookingConversion).where(
            BookingConversion.student_profile_id == student_id
        ).where(
            BookingConversion.deleted_at.is_(None)
        ).options(
            joinedload(BookingConversion.booking),
            joinedload(BookingConversion.student_profile),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def verify_documents(
        self,
        conversion_id: UUID,
        verified_by: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingConversion:
        """
        Mark documents as verified.
        
        Args:
            conversion_id: Conversion UUID
            verified_by: Admin UUID verifying documents
            audit_context: Audit context
            
        Returns:
            Updated conversion
        """
        conversion = self.find_by_id(conversion_id)
        if not conversion:
            raise EntityNotFoundError(f"Conversion {conversion_id} not found")
        
        conversion.verify_documents(verified_by)
        
        # Update checklist items
        if conversion.checklist:
            checklist_repo = ConversionChecklistRepository(self.session)
            
            if conversion.id_proof_uploaded:
                checklist_repo.complete_item_by_name(
                    conversion.checklist.id,
                    "ID Proof Uploaded",
                    verified_by,
                    "Document verified",
                )
            
            if conversion.photo_uploaded:
                checklist_repo.complete_item_by_name(
                    conversion.checklist.id,
                    "Photo Uploaded",
                    verified_by,
                    "Photo verified",
                )
        
        self.session.flush()
        self.session.refresh(conversion)
        
        return conversion
    
    def mark_payment_received(
        self,
        conversion_id: UUID,
        payment_type: str,
        payment_id: UUID,
        amount: Decimal,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingConversion:
        """
        Mark payment as received.
        
        Args:
            conversion_id: Conversion UUID
            payment_type: "security_deposit" or "first_month_rent"
            payment_id: Payment transaction UUID
            amount: Payment amount
            audit_context: Audit context
            
        Returns:
            Updated conversion
        """
        conversion = self.find_by_id(conversion_id)
        if not conversion:
            raise EntityNotFoundError(f"Conversion {conversion_id} not found")
        
        if payment_type == "security_deposit":
            conversion.security_deposit_paid = True
            conversion.security_deposit_amount = amount
            conversion.security_deposit_payment_id = payment_id
            
            # Update checklist
            if conversion.checklist:
                checklist_repo = ConversionChecklistRepository(self.session)
                checklist_repo.complete_item_by_name(
                    conversion.checklist.id,
                    "Security Deposit Paid",
                    audit_context.user_id if audit_context else None,
                    f"Payment received: {amount}",
                )
        
        elif payment_type == "first_month_rent":
            conversion.first_month_rent_paid = True
            conversion.first_month_rent_amount = amount
            conversion.first_month_rent_payment_id = payment_id
            
            # Update checklist
            if conversion.checklist:
                checklist_repo = ConversionChecklistRepository(self.session)
                checklist_repo.complete_item_by_name(
                    conversion.checklist.id,
                    "First Month Rent Paid",
                    audit_context.user_id if audit_context else None,
                    f"Payment received: {amount}",
                )
        
        else:
            raise ValidationError(f"Invalid payment type: {payment_type}")
        
        self.session.flush()
        self.session.refresh(conversion)
        
        return conversion
    
    def mark_as_failed(
        self,
        conversion_id: UUID,
        errors: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingConversion:
        """
        Mark conversion as failed.
        
        Args:
            conversion_id: Conversion UUID
            errors: Error details
            audit_context: Audit context
            
        Returns:
            Updated conversion
        """
        conversion = self.find_by_id(conversion_id)
        if not conversion:
            raise EntityNotFoundError(f"Conversion {conversion_id} not found")
        
        conversion.mark_as_failed(errors)
        
        self.session.flush()
        self.session.refresh(conversion)
        
        return conversion
    
    def find_pending_conversions(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingConversion]:
        """
        Find conversions that are pending completion.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of pending conversions
        """
        query = select(BookingConversion).join(
            Booking,
            BookingConversion.booking_id == Booking.id
        ).join(
            ConversionChecklist,
            BookingConversion.id == ConversionChecklist.conversion_id
        ).where(
            and_(
                BookingConversion.is_successful == True,
                ConversionChecklist.all_checks_passed == False,
                BookingConversion.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.options(
            joinedload(BookingConversion.booking),
            selectinload(BookingConversion.checklist).selectinload(
                ConversionChecklist.items
            ),
        ).order_by(BookingConversion.created_at.asc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_ready_for_conversion(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingConversion]:
        """
        Find conversions ready to complete (all checks passed).
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of ready conversions
        """
        query = select(BookingConversion).join(
            Booking,
            BookingConversion.booking_id == Booking.id
        ).join(
            ConversionChecklist,
            BookingConversion.id == ConversionChecklist.conversion_id
        ).where(
            and_(
                BookingConversion.is_successful == True,
                ConversionChecklist.can_convert == True,
                BookingConversion.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.options(
            joinedload(BookingConversion.booking),
            selectinload(BookingConversion.checklist),
        ).order_by(BookingConversion.created_at.asc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def get_conversion_statistics(
        self,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, any]:
        """
        Get conversion statistics.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Statistics dictionary
        """
        query = select(BookingConversion).join(
            Booking,
            BookingConversion.booking_id == Booking.id
        ).where(
            BookingConversion.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(BookingConversion.converted_at >= date_from)
        
        if date_to:
            query = query.where(BookingConversion.converted_at <= date_to)
        
        conversions = self.session.execute(query).scalars().all()
        
        total_conversions = len(conversions)
        successful = sum(1 for c in conversions if c.is_successful)
        failed = sum(1 for c in conversions if not c.is_successful)
        
        # Payment statistics
        security_deposit_paid = sum(1 for c in conversions if c.security_deposit_paid)
        first_month_paid = sum(1 for c in conversions if c.first_month_rent_paid)
        all_payments_received = sum(1 for c in conversions if c.all_payments_received)
        
        # Document statistics
        documents_uploaded = sum(1 for c in conversions if c.all_documents_uploaded)
        documents_verified = sum(1 for c in conversions if c.documents_verified)
        
        # Checklist statistics
        avg_completion_rate = (
            sum(c.checklist_completion_rate for c in conversions) / total_conversions
            if total_conversions > 0 else Decimal("0.00")
        )
        
        ready_for_completion = sum(
            1 for c in conversions
            if c.is_ready_for_conversion
        )
        
        # Average days since check-in
        avg_days_since_checkin = (
            sum(c.days_since_check_in for c in conversions) / total_conversions
            if total_conversions > 0 else 0
        )
        
        return {
            "total_conversions": total_conversions,
            "successful_conversions": successful,
            "failed_conversions": failed,
            "success_rate": (successful / total_conversions * 100) if total_conversions > 0 else 0,
            "security_deposit_paid_count": security_deposit_paid,
            "first_month_paid_count": first_month_paid,
            "all_payments_received_count": all_payments_received,
            "payment_completion_rate": (all_payments_received / total_conversions * 100) if total_conversions > 0 else 0,
            "documents_uploaded_count": documents_uploaded,
            "documents_verified_count": documents_verified,
            "document_verification_rate": (documents_verified / total_conversions * 100) if total_conversions > 0 else 0,
            "average_checklist_completion": avg_completion_rate,
            "ready_for_completion": ready_for_completion,
            "average_days_since_checkin": avg_days_since_checkin,
        }


class ConversionChecklistRepository(BaseRepository[ConversionChecklist]):
    """Repository for conversion checklist management."""
    
    def __init__(self, session: Session):
        """Initialize checklist repository."""
        super().__init__(session, ConversionChecklist)
    
    def create_checklist(
        self,
        conversion_id: UUID,
        booking_id: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> ConversionChecklist:
        """
        Create conversion checklist.
        
        Args:
            conversion_id: Conversion UUID
            booking_id: Booking UUID
            audit_context: Audit context
            
        Returns:
            Created checklist
        """
        checklist = ConversionChecklist(
            conversion_id=conversion_id,
            booking_id=booking_id,
            last_checked_by=audit_context.user_id if audit_context else None,
        )
        
        return self.create(checklist, audit_context)
    
    def find_by_conversion(self, conversion_id: UUID) -> Optional[ConversionChecklist]:
        """
        Find checklist for a conversion.
        
        Args:
            conversion_id: Conversion UUID
            
        Returns:
            Checklist if found
        """
        query = select(ConversionChecklist).where(
            ConversionChecklist.conversion_id == conversion_id
        ).where(
            ConversionChecklist.deleted_at.is_(None)
        ).options(
            selectinload(ConversionChecklist.items),
            joinedload(ConversionChecklist.conversion),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def find_by_booking(self, booking_id: UUID) -> Optional[ConversionChecklist]:
        """
        Find checklist for a booking.
        
        Args:
            booking_id: Booking UUID
            
        Returns:
            Checklist if found
        """
        query = select(ConversionChecklist).where(
            ConversionChecklist.booking_id == booking_id
        ).where(
            ConversionChecklist.deleted_at.is_(None)
        ).options(
            selectinload(ConversionChecklist.items),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def add_checklist_item(
        self,
        checklist_id: UUID,
        item_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> ChecklistItem:
        """
        Add item to checklist.
        
        Args:
            checklist_id: Checklist UUID
            item_data: Item data
            audit_context: Audit context
            
        Returns:
            Created item
        """
        item = ChecklistItem(
            checklist_id=checklist_id,
            **item_data,
        )
        
        self.session.add(item)
        self.session.flush()
        
        # Update checklist metrics
        self._update_checklist_metrics(checklist_id, audit_context)
        
        return item
    
    def complete_checklist_item(
        self,
        item_id: UUID,
        completed_by: UUID,
        notes: Optional[str] = None,
        audit_context: Optional[AuditContext] = None,
    ) -> ChecklistItem:
        """
        Mark checklist item as completed.
        
        Args:
            item_id: Item UUID
            completed_by: User UUID completing the item
            notes: Optional notes
            audit_context: Audit context
            
        Returns:
            Updated item
        """
        item = self.session.get(ChecklistItem, item_id)
        if not item:
            raise EntityNotFoundError(f"Checklist item {item_id} not found")
        
        item.mark_completed(completed_by, notes)
        
        self.session.flush()
        
        # Update checklist metrics
        self._update_checklist_metrics(item.checklist_id, audit_context)
        
        return item
    
    def complete_item_by_name(
        self,
        checklist_id: UUID,
        item_name: str,
        completed_by: UUID,
        notes: Optional[str] = None,
    ) -> Optional[ChecklistItem]:
        """
        Complete checklist item by name.
        
        Args:
            checklist_id: Checklist UUID
            item_name: Item name
            completed_by: User completing the item
            notes: Optional notes
            
        Returns:
            Updated item if found
        """
        query = select(ChecklistItem).where(
            and_(
                ChecklistItem.checklist_id == checklist_id,
                ChecklistItem.item_name == item_name,
                ChecklistItem.deleted_at.is_(None),
            )
        )
        
        result = self.session.execute(query)
        item = result.scalar_one_or_none()
        
        if item and not item.is_completed:
            item.mark_completed(completed_by, notes)
            self.session.flush()
            self._update_checklist_metrics(checklist_id, None)
        
        return item
    
    def _update_checklist_metrics(
        self,
        checklist_id: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> None:
        """Update checklist completion metrics."""
        checklist = self.session.get(ConversionChecklist, checklist_id)
        if not checklist:
            return
        
        checklist.evaluate_checklist(
            checked_by=audit_context.user_id if audit_context else None
        )
        
        # Update conversion completion rate
        if checklist.conversion:
            checklist.conversion.update_checklist_completion(
                checklist.completion_percentage,
                checklist.all_checks_passed,
            )
        
        self.session.flush()
    
    def get_incomplete_items(
        self,
        checklist_id: UUID,
        required_only: bool = False,
    ) -> List[ChecklistItem]:
        """
        Get incomplete checklist items.
        
        Args:
            checklist_id: Checklist UUID
            required_only: If True, only return required items
            
        Returns:
            List of incomplete items
        """
        query = select(ChecklistItem).where(
            and_(
                ChecklistItem.checklist_id == checklist_id,
                ChecklistItem.is_completed == False,
                ChecklistItem.deleted_at.is_(None),
            )
        )
        
        if required_only:
            query = query.where(ChecklistItem.is_required == True)
        
        query = query.order_by(ChecklistItem.item_order.asc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())

# --- File: C:\Hostel-Main\app\repositories\booking\booking_guest_repository.py ---
# app/repositories/booking/booking_guest_repository.py
"""
Booking guest repository for guest information management.

Provides guest profile management, document handling, verification,
and contact information tracking.
"""

from datetime import datetime
from typing import Dict, List, Optional
from uuid import UUID

from sqlalchemy import and_, func, or_, select
from sqlalchemy.orm import Session, joinedload, selectinload

from app.core.exceptions import EntityNotFoundError, ValidationError
from app.models.booking.booking_guest import BookingGuest, GuestDocument
from app.models.booking.booking import Booking
from app.repositories.base.base_repository import (
    AuditContext,
    BaseRepository,
    QueryOptions,
)


class BookingGuestRepository(BaseRepository[BookingGuest]):
    """
    Repository for booking guest operations.
    
    Provides:
    - Guest profile management
    - Contact information tracking
    - ID verification
    - Consent management
    - Guest analytics
    """
    
    def __init__(self, session: Session):
        """Initialize guest repository."""
        super().__init__(session, BookingGuest)
    
    # ==================== GUEST OPERATIONS ====================
    
    def create_guest_info(
        self,
        guest_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingGuest:
        """
        Create guest information for a booking.
        
        Args:
            guest_data: Guest information
            audit_context: Audit context
            
        Returns:
            Created guest record
        """
        guest = BookingGuest(**guest_data)
        return self.create(guest, audit_context)
    
    def find_by_booking(self, booking_id: UUID) -> Optional[BookingGuest]:
        """
        Find guest information for a booking.
        
        Args:
            booking_id: Booking UUID
            
        Returns:
            Guest information if found
        """
        query = select(BookingGuest).where(
            BookingGuest.booking_id == booking_id
        ).where(
            BookingGuest.deleted_at.is_(None)
        ).options(
            joinedload(BookingGuest.booking),
            selectinload(BookingGuest.documents),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def find_by_email(
        self,
        email: str,
        limit: Optional[int] = None,
    ) -> List[BookingGuest]:
        """
        Find guests by email address.
        
        Args:
            email: Email address
            limit: Optional result limit
            
        Returns:
            List of matching guests
        """
        query = select(BookingGuest).where(
            BookingGuest.guest_email == email.lower()
        ).where(
            BookingGuest.deleted_at.is_(None)
        ).options(
            joinedload(BookingGuest.booking),
        ).order_by(
            BookingGuest.created_at.desc()
        )
        
        if limit:
            query = query.limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_by_phone(
        self,
        phone: str,
        limit: Optional[int] = None,
    ) -> List[BookingGuest]:
        """
        Find guests by phone number.
        
        Args:
            phone: Phone number
            limit: Optional result limit
            
        Returns:
            List of matching guests
        """
        # Normalize phone number
        normalized_phone = phone.replace(" ", "").replace("-", "").replace("(", "").replace(")", "")
        
        query = select(BookingGuest).where(
            BookingGuest.guest_phone.like(f"%{normalized_phone}%")
        ).where(
            BookingGuest.deleted_at.is_(None)
        ).options(
            joinedload(BookingGuest.booking),
        ).order_by(
            BookingGuest.created_at.desc()
        )
        
        if limit:
            query = query.limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def search_guests(
        self,
        search_term: str,
        hostel_id: Optional[UUID] = None,
        limit: int = 50,
    ) -> List[BookingGuest]:
        """
        Search guests by name, email, or phone.
        
        Args:
            search_term: Search term
            hostel_id: Optional hostel filter
            limit: Result limit
            
        Returns:
            List of matching guests
        """
        query = select(BookingGuest).join(
            Booking,
            BookingGuest.booking_id == Booking.id
        ).where(
            and_(
                or_(
                    BookingGuest.guest_name.ilike(f"%{search_term}%"),
                    BookingGuest.guest_email.ilike(f"%{search_term}%"),
                    BookingGuest.guest_phone.like(f"%{search_term}%"),
                ),
                BookingGuest.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.options(
            joinedload(BookingGuest.booking),
        ).order_by(
            BookingGuest.created_at.desc()
        ).limit(limit)
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def verify_id_proof(
        self,
        guest_id: UUID,
        verified_by: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingGuest:
        """
        Mark guest ID proof as verified.
        
        Args:
            guest_id: Guest UUID
            verified_by: Admin UUID verifying the ID
            audit_context: Audit context
            
        Returns:
            Updated guest
        """
        guest = self.find_by_id(guest_id)
        if not guest:
            raise EntityNotFoundError(f"Guest {guest_id} not found")
        
        guest.verify_id_proof(verified_by)
        
        self.session.flush()
        self.session.refresh(guest)
        
        return guest
    
    def update_consent(
        self,
        guest_id: UUID,
        communication: bool,
        data_sharing: bool,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingGuest:
        """
        Update guest consent preferences.
        
        Args:
            guest_id: Guest UUID
            communication: Consent for communication
            data_sharing: Consent for data sharing
            audit_context: Audit context
            
        Returns:
            Updated guest
        """
        guest = self.find_by_id(guest_id)
        if not guest:
            raise EntityNotFoundError(f"Guest {guest_id} not found")
        
        guest.update_consent(communication, data_sharing)
        
        self.session.flush()
        self.session.refresh(guest)
        
        return guest
    
    def find_incomplete_profiles(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingGuest]:
        """
        Find guests with incomplete profiles.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of guests with incomplete profiles
        """
        query = select(BookingGuest).join(
            Booking,
            BookingGuest.booking_id == Booking.id
        ).where(
            BookingGuest.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        guests = self.session.execute(query).scalars().all()
        
        # Filter for incomplete profiles
        incomplete = [g for g in guests if not g.has_complete_profile]
        
        return incomplete
    
    def find_unverified_ids(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingGuest]:
        """
        Find guests with unverified ID proofs.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of guests with unverified IDs
        """
        query = select(BookingGuest).join(
            Booking,
            BookingGuest.booking_id == Booking.id
        ).where(
            and_(
                BookingGuest.id_proof_verified == False,
                BookingGuest.guest_id_proof_number.isnot(None),
                BookingGuest.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.options(
            joinedload(BookingGuest.booking),
        ).order_by(
            BookingGuest.created_at.asc()
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_minors(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingGuest]:
        """
        Find guests who are minors (under 18).
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of minor guests
        """
        query = select(BookingGuest).join(
            Booking,
            BookingGuest.booking_id == Booking.id
        ).where(
            and_(
                BookingGuest.date_of_birth.isnot(None),
                BookingGuest.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        guests = self.session.execute(query).scalars().all()
        
        # Filter for minors
        minors = [g for g in guests if g.is_minor]
        
        return minors


class GuestDocumentRepository(BaseRepository[GuestDocument]):
    """Repository for guest document management."""
    
    def __init__(self, session: Session):
        """Initialize document repository."""
        super().__init__(session, GuestDocument)
    
    def add_document(
        self,
        guest_id: UUID,
        document_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> GuestDocument:
        """
        Add document for a guest.
        
        Args:
            guest_id: Guest UUID
            document_data: Document information
            audit_context: Audit context
            
        Returns:
            Created document
        """
        document = GuestDocument(
            guest_id=guest_id,
            **document_data,
        )
        
        return self.create(document, audit_context)
    
    def find_by_guest(
        self,
        guest_id: UUID,
        document_type: Optional[str] = None,
    ) -> List[GuestDocument]:
        """
        Find documents for a guest.
        
        Args:
            guest_id: Guest UUID
            document_type: Optional document type filter
            
        Returns:
            List of documents
        """
        query = select(GuestDocument).where(
            and_(
                GuestDocument.guest_id == guest_id,
                GuestDocument.deleted_at.is_(None),
            )
        )
        
        if document_type:
            query = query.where(GuestDocument.document_type == document_type)
        
        query = query.order_by(GuestDocument.created_at.desc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def verify_document(
        self,
        document_id: UUID,
        verified_by: UUID,
        notes: Optional[str] = None,
        audit_context: Optional[AuditContext] = None,
    ) -> GuestDocument:
        """
        Verify a document.
        
        Args:
            document_id: Document UUID
            verified_by: Admin UUID verifying the document
            notes: Optional verification notes
            audit_context: Audit context
            
        Returns:
            Updated document
        """
        document = self.find_by_id(document_id)
        if not document:
            raise EntityNotFoundError(f"Document {document_id} not found")
        
        document.verify(verified_by, notes)
        
        self.session.flush()
        self.session.refresh(document)
        
        return document
    
    def reject_document(
        self,
        document_id: UUID,
        rejected_by: UUID,
        reason: str,
        audit_context: Optional[AuditContext] = None,
    ) -> GuestDocument:
        """
        Reject a document.
        
        Args:
            document_id: Document UUID
            rejected_by: Admin UUID rejecting the document
            reason: Rejection reason
            audit_context: Audit context
            
        Returns:
            Updated document
        """
        document = self.find_by_id(document_id)
        if not document:
            raise EntityNotFoundError(f"Document {document_id} not found")
        
        document.reject(rejected_by, reason)
        
        self.session.flush()
        self.session.refresh(document)
        
        return document
    
    def find_unverified_documents(
        self,
        hostel_id: Optional[UUID] = None,
        document_type: Optional[str] = None,
    ) -> List[GuestDocument]:
        """
        Find unverified documents.
        
        Args:
            hostel_id: Optional hostel filter
            document_type: Optional document type filter
            
        Returns:
            List of unverified documents
        """
        query = select(GuestDocument).join(
            BookingGuest,
            GuestDocument.guest_id == BookingGuest.id
        ).join(
            Booking,
            BookingGuest.booking_id == Booking.id
        ).where(
            and_(
                GuestDocument.is_verified == False,
                GuestDocument.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if document_type:
            query = query.where(GuestDocument.document_type == document_type)
        
        query = query.options(
            joinedload(GuestDocument.guest),
        ).order_by(
            GuestDocument.created_at.asc()
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_expiring_documents(
        self,
        days_ahead: int = 30,
        hostel_id: Optional[UUID] = None,
    ) -> List[GuestDocument]:
        """
        Find documents expiring soon.
        
        Args:
            days_ahead: Days to look ahead
            hostel_id: Optional hostel filter
            
        Returns:
            List of expiring documents
        """
        from datetime import timedelta
        
        expiry_threshold = datetime.utcnow() + timedelta(days=days_ahead)
        
        query = select(GuestDocument).join(
            BookingGuest,
            GuestDocument.guest_id == BookingGuest.id
        ).join(
            Booking,
            BookingGuest.booking_id == Booking.id
        ).where(
            and_(
                GuestDocument.expiry_date.isnot(None),
                GuestDocument.expiry_date <= expiry_threshold,
                GuestDocument.expiry_date > datetime.utcnow(),
                GuestDocument.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.options(
            joinedload(GuestDocument.guest),
        ).order_by(
            GuestDocument.expiry_date.asc()
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())

# --- File: C:\Hostel-Main\app\repositories\booking\booking_modification_repository.py ---
# app/repositories/booking/booking_modification_repository.py
"""
Booking modification repository for modification request management.

Provides modification request tracking, approval workflows, pricing impact
analysis, and modification history.
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional, Tuple
from uuid import UUID

from sqlalchemy import and_, func, or_, select
from sqlalchemy.orm import Session, joinedload

from app.core.exceptions import EntityNotFoundError, ValidationError
from app.models.booking.booking_modification import (
    BookingModification,
    ModificationApprovalRecord,
)
from app.models.booking.booking import Booking
from app.models.base.enums import RoomType
from app.repositories.base.base_repository import (
    AuditContext,
    BaseRepository,
    QueryOptions,
)


class BookingModificationRepository(BaseRepository[BookingModification]):
    """
    Repository for booking modification operations.
    
    Provides:
    - Modification request management
    - Pricing impact calculation
    - Approval workflow tracking
    - Modification analytics
    - Application management
    """
    
    def __init__(self, session: Session):
        """Initialize modification repository."""
        super().__init__(session, BookingModification)
    
    # ==================== MODIFICATION OPERATIONS ====================
    
    def create_modification_request(
        self,
        booking_id: UUID,
        modification_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingModification:
        """
        Create modification request for a booking.
        
        Args:
            booking_id: Booking UUID
            modification_data: Modification information
            audit_context: Audit context
            
        Returns:
            Created modification request
            
        Raises:
            EntityNotFoundError: If booking not found
            ValidationError: If validation fails
        """
        # Get booking
        booking = self.session.get(Booking, booking_id)
        if not booking:
            raise EntityNotFoundError(f"Booking {booking_id} not found")
        
        # Store original values
        if 'original_check_in_date' not in modification_data:
            modification_data['original_check_in_date'] = booking.preferred_check_in_date
        
        if 'original_duration_months' not in modification_data:
            modification_data['original_duration_months'] = booking.stay_duration_months
        
        if 'original_room_type' not in modification_data:
            modification_data['original_room_type'] = booking.room_type_requested
        
        if 'original_total_amount' not in modification_data:
            modification_data['original_total_amount'] = booking.total_amount
        
        # Determine modification type
        modification_types = []
        if modification_data.get('modify_check_in_date'):
            modification_types.append('date')
        if modification_data.get('modify_duration'):
            modification_types.append('duration')
        if modification_data.get('modify_room_type'):
            modification_types.append('room_type')
        
        if not modification_types:
            raise ValidationError("At least one modification type must be specified")
        
        modification_data['modification_type'] = (
            'multiple' if len(modification_types) > 1
            else modification_types[0]
        )
        
        modification = BookingModification(
            booking_id=booking_id,
            requested_by=audit_context.user_id if audit_context else None,
            requested_at=datetime.utcnow(),
            **modification_data,
        )
        
        return self.create(modification, audit_context)
    
    def find_by_booking(
        self,
        booking_id: UUID,
        status: Optional[str] = None,
    ) -> List[BookingModification]:
        """
        Find modification requests for a booking.
        
        Args:
            booking_id: Booking UUID
            status: Optional status filter
            
        Returns:
            List of modification requests
        """
        query = select(BookingModification).where(
            and_(
                BookingModification.booking_id == booking_id,
                BookingModification.deleted_at.is_(None),
            )
        )
        
        if status:
            query = query.where(BookingModification.modification_status == status)
        
        query = query.order_by(
            BookingModification.requested_at.desc()
        ).options(
            joinedload(BookingModification.booking),
            joinedload(BookingModification.requester),
            joinedload(BookingModification.approval_record),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_pending_modifications(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingModification]:
        """
        Find pending modification requests.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of pending modifications
        """
        query = select(BookingModification).join(
            Booking,
            BookingModification.booking_id == Booking.id
        ).where(
            and_(
                BookingModification.modification_status == 'pending',
                BookingModification.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.order_by(
            BookingModification.requested_at.asc()
        ).options(
            joinedload(BookingModification.booking),
            joinedload(BookingModification.requester),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def calculate_price_impact(
        self,
        modification_id: UUID,
        new_monthly_rent: Decimal,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingModification:
        """
        Calculate and update price impact of modification.
        
        Args:
            modification_id: Modification UUID
            new_monthly_rent: New monthly rent amount
            audit_context: Audit context
            
        Returns:
            Updated modification
        """
        modification = self.find_by_id(modification_id)
        if not modification:
            raise EntityNotFoundError(f"Modification {modification_id} not found")
        
        # Calculate price impact
        new_duration = (
            modification.new_duration_months
            if modification.modify_duration
            else modification.original_duration_months
        )
        
        modification.calculate_price_impact(new_monthly_rent, new_duration)
        
        self.session.flush()
        self.session.refresh(modification)
        
        return modification
    
    def approve_modification(
        self,
        modification_id: UUID,
        approved_by: UUID,
        approval_notes: Optional[str] = None,
        adjusted_price: Optional[Decimal] = None,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingModification:
        """
        Approve modification request.
        
        Args:
            modification_id: Modification UUID
            approved_by: Admin UUID approving the modification
            approval_notes: Optional approval notes
            adjusted_price: Optional admin-adjusted price
            audit_context: Audit context
            
        Returns:
            Approved modification
        """
        modification = self.find_by_id(modification_id)
        if not modification:
            raise EntityNotFoundError(f"Modification {modification_id} not found")
        
        modification.approve(approved_by)
        
        # Create approval record
        approval_repo = ModificationApprovalRecordRepository(self.session)
        approval_repo.create_approval_record(
            modification_id=modification_id,
            approved=True,
            approved_by=approved_by,
            admin_notes=approval_notes,
            adjusted_price=adjusted_price,
            audit_context=audit_context,
        )
        
        self.session.flush()
        self.session.refresh(modification)
        
        return modification
    
    def reject_modification(
        self,
        modification_id: UUID,
        rejected_by: UUID,
        reason: str,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingModification:
        """
        Reject modification request.
        
        Args:
            modification_id: Modification UUID
            rejected_by: Admin UUID rejecting the modification
            reason: Rejection reason
            audit_context: Audit context
            
        Returns:
            Rejected modification
        """
        modification = self.find_by_id(modification_id)
        if not modification:
            raise EntityNotFoundError(f"Modification {modification_id} not found")
        
        modification.reject(rejected_by, reason)
        
        # Create approval record
        approval_repo = ModificationApprovalRecordRepository(self.session)
        approval_repo.create_approval_record(
            modification_id=modification_id,
            approved=False,
            approved_by=rejected_by,
            admin_notes=reason,
            audit_context=audit_context,
        )
        
        self.session.flush()
        self.session.refresh(modification)
        
        return modification
    
    def apply_modification(
        self,
        modification_id: UUID,
        applied_by: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> Tuple[BookingModification, Booking]:
        """
        Apply approved modification to booking.
        
        Args:
            modification_id: Modification UUID
            applied_by: Admin UUID applying the modification
            audit_context: Audit context
            
        Returns:
            Tuple of (modification, updated_booking)
            
        Raises:
            ValidationError: If modification cannot be applied
        """
        modification = self.find_by_id(modification_id)
        if not modification:
            raise EntityNotFoundError(f"Modification {modification_id} not found")
        
        if modification.modification_status != 'approved':
            raise ValidationError("Only approved modifications can be applied")
        
        booking = modification.booking
        
        # Apply changes
        if modification.modify_check_in_date and modification.new_check_in_date:
            booking.preferred_check_in_date = modification.new_check_in_date
        
        if modification.modify_duration and modification.new_duration_months:
            booking.stay_duration_months = modification.new_duration_months
        
        if modification.modify_room_type and modification.new_room_type:
            booking.room_type_requested = modification.new_room_type
        
        # Update pricing if changed
        if modification.new_total_amount:
            booking.total_amount = modification.new_total_amount
        
        # Mark modification as applied
        modification.apply_modification(applied_by)
        
        self.session.flush()
        self.session.refresh(modification)
        self.session.refresh(booking)
        
        return modification, booking
    
    def find_by_type(
        self,
        modification_type: str,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> List[BookingModification]:
        """
        Find modifications by type.
        
        Args:
            modification_type: Type of modification
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            List of modifications
        """
        query = select(BookingModification).join(
            Booking,
            BookingModification.booking_id == Booking.id
        ).where(
            and_(
                BookingModification.modification_type == modification_type,
                BookingModification.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(BookingModification.requested_at >= date_from)
        
        if date_to:
            query = query.where(BookingModification.requested_at <= date_to)
        
        query = query.order_by(
            BookingModification.requested_at.desc()
        ).options(
            joinedload(BookingModification.booking),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_with_price_increase(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingModification]:
        """
        Find modifications that result in price increase.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of modifications with price increase
        """
        query = select(BookingModification).join(
            Booking,
            BookingModification.booking_id == Booking.id
        ).where(
            BookingModification.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        modifications = self.session.execute(query).scalars().all()
        
        # Filter for price increases
        with_increase = [m for m in modifications if m.has_price_increase]
        
        return with_increase
    
    def get_modification_statistics(
        self,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, any]:
        """
        Get modification statistics.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Statistics dictionary
        """
        query = select(BookingModification).join(
            Booking,
            BookingModification.booking_id == Booking.id
        ).where(
            BookingModification.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(BookingModification.requested_at >= date_from)
        
        if date_to:
            query = query.where(BookingModification.requested_at <= date_to)
        
        modifications = self.session.execute(query).scalars().all()
        
        total_modifications = len(modifications)
        
        # Count by status
        pending = sum(1 for m in modifications if m.is_pending)
        approved = sum(1 for m in modifications if m.is_approved)
        applied = sum(1 for m in modifications if m.is_applied)
        rejected = sum(1 for m in modifications if m.modification_status == 'rejected')
        
        # Count by type
        by_type = {}
        for mod in modifications:
            by_type[mod.modification_type] = by_type.get(mod.modification_type, 0) + 1
        
        # Price impact
        with_price_increase = sum(1 for m in modifications if m.has_price_increase)
        with_price_decrease = sum(1 for m in modifications if m.has_price_decrease)
        
        avg_price_change = (
            sum(m.price_difference for m in modifications if m.price_difference)
            / total_modifications
            if total_modifications > 0 else Decimal("0.00")
        )
        
        # Acceptance metrics
        total_decided = approved + rejected
        approval_rate = (approved / total_decided * 100) if total_decided > 0 else 0
        application_rate = (applied / approved * 100) if approved > 0 else 0
        
        return {
            "total_modifications": total_modifications,
            "pending_modifications": pending,
            "approved_modifications": approved,
            "applied_modifications": applied,
            "rejected_modifications": rejected,
            "approval_rate": approval_rate,
            "application_rate": application_rate,
            "modifications_by_type": by_type,
            "with_price_increase": with_price_increase,
            "with_price_decrease": with_price_decrease,
            "average_price_change": avg_price_change,
        }


class ModificationApprovalRecordRepository(BaseRepository[ModificationApprovalRecord]):
    """Repository for modification approval record management."""
    
    def __init__(self, session: Session):
        """Initialize approval record repository."""
        super().__init__(session, ModificationApprovalRecord)
    
    def create_approval_record(
        self,
        modification_id: UUID,
        approved: bool,
        approved_by: UUID,
        admin_notes: Optional[str] = None,
        adjusted_price: Optional[Decimal] = None,
        audit_context: Optional[AuditContext] = None,
    ) -> ModificationApprovalRecord:
        """
        Create approval record.
        
        Args:
            modification_id: Modification UUID
            approved: Whether approved or rejected
            approved_by: Admin making decision
            admin_notes: Optional notes
            adjusted_price: Optional adjusted price
            audit_context: Audit context
            
        Returns:
            Created approval record
        """
        record = ModificationApprovalRecord(
            modification_id=modification_id,
            approved=approved,
            decision_made_by=approved_by,
            admin_notes=admin_notes,
            adjusted_price=adjusted_price,
            approval_decision_at=datetime.utcnow(),
        )
        
        return self.create(record, audit_context)
    
    def find_by_modification(
        self,
        modification_id: UUID,
    ) -> Optional[ModificationApprovalRecord]:
        """
        Find approval record for a modification.
        
        Args:
            modification_id: Modification UUID
            
        Returns:
            Approval record if found
        """
        query = select(ModificationApprovalRecord).where(
            ModificationApprovalRecord.modification_id == modification_id
        ).options(
            joinedload(ModificationApprovalRecord.modification),
            joinedload(ModificationApprovalRecord.decision_maker),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()


# --- File: C:\Hostel-Main\app\repositories\booking\booking_repository.py ---
# app/repositories/booking/booking_repository.py
"""
Booking repository for comprehensive booking management.

Provides advanced search, availability checking, booking optimization,
lifecycle management, and analytics for hostel bookings.
"""

from datetime import date, datetime, timedelta
from decimal import Decimal
from typing import Dict, List, Optional, Tuple
from uuid import UUID

from sqlalchemy import and_, func, or_, select
from sqlalchemy.orm import Session, joinedload, selectinload

from app.core.exceptions import EntityNotFoundError, ValidationError
from app.models.booking.booking import Booking, BookingNote, BookingStatusHistory
from app.models.base.enums import BookingSource, BookingStatus, RoomType
from app.repositories.base.base_repository import (
    AuditContext,
    BaseRepository,
    QueryOptions,
)


class BookingSearchCriteria:
    """Advanced search criteria for bookings."""
    
    def __init__(
        self,
        booking_reference: Optional[str] = None,
        visitor_id: Optional[UUID] = None,
        hostel_id: Optional[UUID] = None,
        hostel_ids: Optional[List[UUID]] = None,
        status: Optional[BookingStatus] = None,
        statuses: Optional[List[BookingStatus]] = None,
        source: Optional[BookingSource] = None,
        room_type: Optional[RoomType] = None,
        check_in_date_from: Optional[date] = None,
        check_in_date_to: Optional[date] = None,
        booking_date_from: Optional[datetime] = None,
        booking_date_to: Optional[datetime] = None,
        advance_paid: Optional[bool] = None,
        converted_to_student: Optional[bool] = None,
        min_amount: Optional[Decimal] = None,
        max_amount: Optional[Decimal] = None,
        expiring_within_hours: Optional[int] = None,
        is_expired: Optional[bool] = None,
        referral_code: Optional[str] = None,
        guest_email: Optional[str] = None,
        guest_phone: Optional[str] = None,
    ):
        self.booking_reference = booking_reference
        self.visitor_id = visitor_id
        self.hostel_id = hostel_id
        self.hostel_ids = hostel_ids
        self.status = status
        self.statuses = statuses
        self.source = source
        self.room_type = room_type
        self.check_in_date_from = check_in_date_from
        self.check_in_date_to = check_in_date_to
        self.booking_date_from = booking_date_from
        self.booking_date_to = booking_date_to
        self.advance_paid = advance_paid
        self.converted_to_student = converted_to_student
        self.min_amount = min_amount
        self.max_amount = max_amount
        self.expiring_within_hours = expiring_within_hours
        self.is_expired = is_expired
        self.referral_code = referral_code
        self.guest_email = guest_email
        self.guest_phone = guest_phone


class BookingStatistics:
    """Booking statistics data structure."""
    
    def __init__(self):
        self.total_bookings: int = 0
        self.pending_bookings: int = 0
        self.approved_bookings: int = 0
        self.confirmed_bookings: int = 0
        self.cancelled_bookings: int = 0
        self.completed_bookings: int = 0
        self.total_revenue: Decimal = Decimal("0.00")
        self.average_booking_value: Decimal = Decimal("0.00")
        self.conversion_rate: float = 0.0
        self.cancellation_rate: float = 0.0
        self.advance_payment_rate: float = 0.0


class BookingRepository(BaseRepository[Booking]):
    """
    Repository for booking operations.
    
    Provides:
    - Advanced booking search and filtering
    - Availability checking and conflict resolution
    - Dynamic pricing calculations
    - Booking lifecycle management
    - Status tracking and transitions
    - Analytics and reporting
    - Booking optimization
    """
    
    def __init__(self, session: Session):
        """Initialize booking repository."""
        super().__init__(session, Booking)
    
    # ==================== SEARCH & RETRIEVAL ====================
    
    def search_bookings(
        self,
        criteria: BookingSearchCriteria,
        page: int = 1,
        page_size: int = 50,
        order_by: Optional[List[str]] = None,
        options: Optional[QueryOptions] = None,
    ) -> Tuple[List[Booking], int]:
        """
        Advanced booking search with multiple criteria.
        
        Args:
            criteria: Search criteria
            page: Page number (1-indexed)
            page_size: Results per page
            order_by: List of fields to order by
            options: Query options
            
        Returns:
            Tuple of (bookings list, total count)
        """
        options = options or QueryOptions()
        
        # Build base query
        query = select(Booking)
        count_query = select(func.count(Booking.id))
        
        # Apply filters
        filters = self._build_search_filters(criteria)
        if filters:
            query = query.where(and_(*filters))
            count_query = count_query.where(and_(*filters))
        
        # Apply soft delete filter
        if not options.include_deleted:
            query = query.where(Booking.deleted_at.is_(None))
            count_query = count_query.where(Booking.deleted_at.is_(None))
        
        # Get total count
        total = self.session.execute(count_query).scalar_one()
        
        # Apply ordering
        if order_by:
            for order_field in order_by:
                if order_field.startswith("-"):
                    field_name = order_field[1:]
                    if hasattr(Booking, field_name):
                        query = query.order_by(getattr(Booking, field_name).desc())
                else:
                    if hasattr(Booking, order_field):
                        query = query.order_by(getattr(Booking, order_field).asc())
        else:
            # Default ordering: newest first
            query = query.order_by(Booking.created_at.desc())
        
        # Apply pagination
        offset = (page - 1) * page_size
        query = query.offset(offset).limit(page_size)
        
        # Apply prefetching
        if options.prefetch_relationships:
            query = self._apply_prefetch(query, options.prefetch_relationships)
        else:
            # Default prefetch common relationships
            query = query.options(
                joinedload(Booking.visitor),
                joinedload(Booking.hostel),
                selectinload(Booking.guest_info),
            )
        
        # Execute query
        result = self.session.execute(query)
        bookings = list(result.scalars().all())
        
        return bookings, total
    
    def _build_search_filters(self, criteria: BookingSearchCriteria) -> List:
        """Build SQLAlchemy filters from search criteria."""
        filters = []
        
        if criteria.booking_reference:
            filters.append(Booking.booking_reference == criteria.booking_reference)
        
        if criteria.visitor_id:
            filters.append(Booking.visitor_id == criteria.visitor_id)
        
        if criteria.hostel_id:
            filters.append(Booking.hostel_id == criteria.hostel_id)
        
        if criteria.hostel_ids:
            filters.append(Booking.hostel_id.in_(criteria.hostel_ids))
        
        if criteria.status:
            filters.append(Booking.booking_status == criteria.status)
        
        if criteria.statuses:
            filters.append(Booking.booking_status.in_(criteria.statuses))
        
        if criteria.source:
            filters.append(Booking.source == criteria.source)
        
        if criteria.room_type:
            filters.append(Booking.room_type_requested == criteria.room_type)
        
        if criteria.check_in_date_from:
            filters.append(Booking.preferred_check_in_date >= criteria.check_in_date_from)
        
        if criteria.check_in_date_to:
            filters.append(Booking.preferred_check_in_date <= criteria.check_in_date_to)
        
        if criteria.booking_date_from:
            filters.append(Booking.booking_date >= criteria.booking_date_from)
        
        if criteria.booking_date_to:
            filters.append(Booking.booking_date <= criteria.booking_date_to)
        
        if criteria.advance_paid is not None:
            filters.append(Booking.advance_paid == criteria.advance_paid)
        
        if criteria.converted_to_student is not None:
            filters.append(Booking.converted_to_student == criteria.converted_to_student)
        
        if criteria.min_amount:
            filters.append(Booking.total_amount >= criteria.min_amount)
        
        if criteria.max_amount:
            filters.append(Booking.total_amount <= criteria.max_amount)
        
        if criteria.expiring_within_hours:
            expiry_threshold = datetime.utcnow() + timedelta(hours=criteria.expiring_within_hours)
            filters.append(Booking.expires_at.isnot(None))
            filters.append(Booking.expires_at <= expiry_threshold)
            filters.append(Booking.expires_at > datetime.utcnow())
        
        if criteria.is_expired is not None:
            if criteria.is_expired:
                filters.append(Booking.expires_at.isnot(None))
                filters.append(Booking.expires_at <= datetime.utcnow())
            else:
                filters.append(
                    or_(
                        Booking.expires_at.is_(None),
                        Booking.expires_at > datetime.utcnow()
                    )
                )
        
        if criteria.referral_code:
            filters.append(Booking.referral_code == criteria.referral_code)
        
        # Guest info filters (requires join)
        if criteria.guest_email or criteria.guest_phone:
            from app.models.booking.booking_guest import BookingGuest
            
            if criteria.guest_email:
                filters.append(BookingGuest.guest_email == criteria.guest_email)
            
            if criteria.guest_phone:
                filters.append(BookingGuest.guest_phone == criteria.guest_phone)
        
        return filters
    
    def find_by_reference(self, booking_reference: str) -> Optional[Booking]:
        """
        Find booking by reference number.
        
        Args:
            booking_reference: Booking reference
            
        Returns:
            Booking if found, None otherwise
        """
        query = select(Booking).where(
            Booking.booking_reference == booking_reference
        ).where(
            Booking.deleted_at.is_(None)
        ).options(
            joinedload(Booking.visitor),
            joinedload(Booking.hostel),
            selectinload(Booking.guest_info),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def find_by_visitor(
        self,
        visitor_id: UUID,
        status: Optional[BookingStatus] = None,
        limit: Optional[int] = None,
    ) -> List[Booking]:
        """
        Find bookings for a specific visitor.
        
        Args:
            visitor_id: Visitor UUID
            status: Optional status filter
            limit: Optional result limit
            
        Returns:
            List of visitor's bookings
        """
        query = select(Booking).where(
            Booking.visitor_id == visitor_id
        ).where(
            Booking.deleted_at.is_(None)
        )
        
        if status:
            query = query.where(Booking.booking_status == status)
        
        query = query.order_by(Booking.created_at.desc())
        
        if limit:
            query = query.limit(limit)
        
        query = query.options(
            joinedload(Booking.hostel),
            selectinload(Booking.guest_info),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_by_hostel(
        self,
        hostel_id: UUID,
        status: Optional[BookingStatus] = None,
        check_in_date_from: Optional[date] = None,
        check_in_date_to: Optional[date] = None,
        limit: Optional[int] = None,
    ) -> List[Booking]:
        """
        Find bookings for a specific hostel.
        
        Args:
            hostel_id: Hostel UUID
            status: Optional status filter
            check_in_date_from: Optional check-in date range start
            check_in_date_to: Optional check-in date range end
            limit: Optional result limit
            
        Returns:
            List of hostel bookings
        """
        query = select(Booking).where(
            Booking.hostel_id == hostel_id
        ).where(
            Booking.deleted_at.is_(None)
        )
        
        if status:
            query = query.where(Booking.booking_status == status)
        
        if check_in_date_from:
            query = query.where(Booking.preferred_check_in_date >= check_in_date_from)
        
        if check_in_date_to:
            query = query.where(Booking.preferred_check_in_date <= check_in_date_to)
        
        query = query.order_by(Booking.preferred_check_in_date.asc())
        
        if limit:
            query = query.limit(limit)
        
        query = query.options(
            joinedload(Booking.visitor),
            selectinload(Booking.guest_info),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    # ==================== BOOKING LIFECYCLE ====================
    
    def create_booking_request(
        self,
        booking_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> Booking:
        """
        Create new booking request with validation.
        
        Args:
            booking_data: Booking information
            audit_context: Audit context
            
        Returns:
            Created booking
            
        Raises:
            ValidationError: If validation fails
        """
        # Create booking instance
        booking = Booking(**booking_data)
        
        # Set default status
        if not booking.booking_status:
            booking.booking_status = BookingStatus.PENDING
        
        # Set booking date
        if not booking.booking_date:
            booking.booking_date = datetime.utcnow()
        
        # Calculate total amount if not provided
        if not booking.total_amount and booking.quoted_rent_monthly:
            booking.total_amount = (
                booking.quoted_rent_monthly * booking.stay_duration_months
            )
        
        # Set expiry time for pending bookings
        if booking.booking_status == BookingStatus.PENDING and not booking.expires_at:
            booking.set_expiry(hours=48)  # Default 48-hour expiry
        
        # Create with audit
        created_booking = self.create(booking, audit_context)
        
        # Create initial status history
        self._create_status_history(
            created_booking,
            None,
            BookingStatus.PENDING,
            audit_context,
        )
        
        return created_booking
    
    def approve_booking(
        self,
        booking_id: UUID,
        approved_by_id: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> Booking:
        """
        Approve a pending booking.
        
        Args:
            booking_id: Booking UUID
            approved_by_id: Admin UUID approving the booking
            audit_context: Audit context
            
        Returns:
            Approved booking
            
        Raises:
            EntityNotFoundError: If booking not found
            ValidationError: If booking cannot be approved
        """
        booking = self.find_by_id(booking_id)
        if not booking:
            raise EntityNotFoundError(f"Booking {booking_id} not found")
        
        # Use booking's approve method
        old_status = booking.booking_status
        booking.approve(approved_by_id)
        
        # Update
        self.session.flush()
        self.session.refresh(booking)
        
        # Create status history
        self._create_status_history(
            booking,
            old_status,
            BookingStatus.APPROVED,
            audit_context,
            f"Approved by admin {approved_by_id}",
        )
        
        return booking
    
    def reject_booking(
        self,
        booking_id: UUID,
        rejected_by_id: UUID,
        reason: str,
        audit_context: Optional[AuditContext] = None,
    ) -> Booking:
        """
        Reject a pending booking.
        
        Args:
            booking_id: Booking UUID
            rejected_by_id: Admin UUID rejecting the booking
            reason: Rejection reason
            audit_context: Audit context
            
        Returns:
            Rejected booking
        """
        booking = self.find_by_id(booking_id)
        if not booking:
            raise EntityNotFoundError(f"Booking {booking_id} not found")
        
        old_status = booking.booking_status
        booking.reject(rejected_by_id, reason)
        
        self.session.flush()
        self.session.refresh(booking)
        
        self._create_status_history(
            booking,
            old_status,
            BookingStatus.REJECTED,
            audit_context,
            f"Rejected: {reason}",
        )
        
        return booking
    
    def confirm_booking(
        self,
        booking_id: UUID,
        payment_id: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> Booking:
        """
        Confirm booking after advance payment.
        
        Args:
            booking_id: Booking UUID
            payment_id: Payment transaction UUID
            audit_context: Audit context
            
        Returns:
            Confirmed booking
        """
        booking = self.find_by_id(booking_id)
        if not booking:
            raise EntityNotFoundError(f"Booking {booking_id} not found")
        
        old_status = booking.booking_status
        booking.confirm_payment(payment_id)
        
        self.session.flush()
        self.session.refresh(booking)
        
        self._create_status_history(
            booking,
            old_status,
            BookingStatus.CONFIRMED,
            audit_context,
            f"Payment confirmed: {payment_id}",
        )
        
        return booking
    
    def cancel_booking(
        self,
        booking_id: UUID,
        cancelled_by_id: UUID,
        reason: str,
        audit_context: Optional[AuditContext] = None,
    ) -> Booking:
        """
        Cancel a booking.
        
        Args:
            booking_id: Booking UUID
            cancelled_by_id: User UUID cancelling the booking
            reason: Cancellation reason
            audit_context: Audit context
            
        Returns:
            Cancelled booking
        """
        booking = self.find_by_id(booking_id)
        if not booking:
            raise EntityNotFoundError(f"Booking {booking_id} not found")
        
        old_status = booking.booking_status
        booking.cancel(cancelled_by_id, reason)
        
        self.session.flush()
        self.session.refresh(booking)
        
        self._create_status_history(
            booking,
            old_status,
            BookingStatus.CANCELLED,
            audit_context,
            f"Cancelled: {reason}",
        )
        
        return booking
    
    def mark_as_checked_in(
        self,
        booking_id: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> Booking:
        """
        Mark booking as checked in.
        
        Args:
            booking_id: Booking UUID
            audit_context: Audit context
            
        Returns:
            Updated booking
        """
        booking = self.find_by_id(booking_id)
        if not booking:
            raise EntityNotFoundError(f"Booking {booking_id} not found")
        
        if booking.booking_status != BookingStatus.CONFIRMED:
            raise ValidationError("Only confirmed bookings can be checked in")
        
        old_status = booking.booking_status
        booking.booking_status = BookingStatus.CHECKED_IN
        
        self.session.flush()
        self.session.refresh(booking)
        
        self._create_status_history(
            booking,
            old_status,
            BookingStatus.CHECKED_IN,
            audit_context,
            "Guest checked in",
        )
        
        return booking
    
    def mark_as_completed(
        self,
        booking_id: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> Booking:
        """
        Mark booking as completed.
        
        Args:
            booking_id: Booking UUID
            audit_context: Audit context
            
        Returns:
            Completed booking
        """
        booking = self.find_by_id(booking_id)
        if not booking:
            raise EntityNotFoundError(f"Booking {booking_id} not found")
        
        old_status = booking.booking_status
        booking.mark_as_completed()
        
        self.session.flush()
        self.session.refresh(booking)
        
        self._create_status_history(
            booking,
            old_status,
            BookingStatus.COMPLETED,
            audit_context,
            "Booking completed",
        )
        
        return booking
    
    def mark_as_no_show(
        self,
        booking_id: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> Booking:
        """
        Mark booking as no-show.
        
        Args:
            booking_id: Booking UUID
            audit_context: Audit context
            
        Returns:
            Updated booking
        """
        booking = self.find_by_id(booking_id)
        if not booking:
            raise EntityNotFoundError(f"Booking {booking_id} not found")
        
        old_status = booking.booking_status
        booking.mark_as_no_show()
        
        self.session.flush()
        self.session.refresh(booking)
        
        self._create_status_history(
            booking,
            old_status,
            BookingStatus.NO_SHOW,
            audit_context,
            "Guest did not show up",
        )
        
        return booking
    
    # ==================== STATUS TRACKING ====================
    
    def _create_status_history(
        self,
        booking: Booking,
        from_status: Optional[BookingStatus],
        to_status: BookingStatus,
        audit_context: Optional[AuditContext] = None,
        reason: Optional[str] = None,
    ) -> BookingStatusHistory:
        """Create status history entry."""
        history = BookingStatusHistory(
            booking_id=booking.id,
            from_status=from_status,
            to_status=to_status,
            changed_by=audit_context.user_id if audit_context else None,
            change_reason=reason,
            changed_at=datetime.utcnow(),
        )
        
        self.session.add(history)
        self.session.flush()
        
        return history
    
    def get_status_history(self, booking_id: UUID) -> List[BookingStatusHistory]:
        """
        Get status change history for a booking.
        
        Args:
            booking_id: Booking UUID
            
        Returns:
            List of status changes
        """
        query = select(BookingStatusHistory).where(
            BookingStatusHistory.booking_id == booking_id
        ).order_by(
            BookingStatusHistory.changed_at.desc()
        ).options(
            joinedload(BookingStatusHistory.changer)
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    # ==================== NOTES ====================
    
    def add_note(
        self,
        booking_id: UUID,
        note_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingNote:
        """
        Add note to booking.
        
        Args:
            booking_id: Booking UUID
            note_data: Note information
            audit_context: Audit context
            
        Returns:
            Created note
        """
        note = BookingNote(
            booking_id=booking_id,
            created_by=audit_context.user_id if audit_context else None,
            **note_data,
        )
        
        self.session.add(note)
        self.session.flush()
        
        return note
    
    def get_notes(
        self,
        booking_id: UUID,
        include_deleted: bool = False,
    ) -> List[BookingNote]:
        """
        Get notes for a booking.
        
        Args:
            booking_id: Booking UUID
            include_deleted: Whether to include deleted notes
            
        Returns:
            List of notes
        """
        query = select(BookingNote).where(
            BookingNote.booking_id == booking_id
        )
        
        if not include_deleted:
            query = query.where(BookingNote.deleted_at.is_(None))
        
        query = query.order_by(
            BookingNote.is_pinned.desc(),
            BookingNote.created_at.desc()
        ).options(
            joinedload(BookingNote.creator)
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    # ==================== AVAILABILITY & CONFLICTS ====================
    
    def check_availability(
        self,
        hostel_id: UUID,
        room_type: RoomType,
        check_in_date: date,
        duration_months: int,
    ) -> bool:
        """
        Check if booking is available for given parameters.
        
        Args:
            hostel_id: Hostel UUID
            room_type: Requested room type
            check_in_date: Desired check-in date
            duration_months: Stay duration in months
            
        Returns:
            True if available, False otherwise
        """
        # Calculate check-out date
        check_out_date = check_in_date + timedelta(days=duration_months * 30)
        
        # Query for conflicting bookings
        query = select(func.count(Booking.id)).where(
            and_(
                Booking.hostel_id == hostel_id,
                Booking.room_type_requested == room_type,
                Booking.booking_status.in_([
                    BookingStatus.APPROVED,
                    BookingStatus.CONFIRMED,
                    BookingStatus.CHECKED_IN,
                ]),
                Booking.deleted_at.is_(None),
                or_(
                    # New booking starts during existing booking
                    and_(
                        Booking.preferred_check_in_date <= check_in_date,
                        func.date(
                            Booking.preferred_check_in_date +
                            func.cast(Booking.stay_duration_months * 30, func.text('interval day'))
                        ) > check_in_date
                    ),
                    # New booking ends during existing booking
                    and_(
                        Booking.preferred_check_in_date < check_out_date,
                        func.date(
                            Booking.preferred_check_in_date +
                            func.cast(Booking.stay_duration_months * 30, func.text('interval day'))
                        ) >= check_out_date
                    ),
                    # New booking completely contains existing booking
                    and_(
                        Booking.preferred_check_in_date >= check_in_date,
                        func.date(
                            Booking.preferred_check_in_date +
                            func.cast(Booking.stay_duration_months * 30, func.text('interval day'))
                        ) <= check_out_date
                    )
                )
            )
        )
        
        conflicts = self.session.execute(query).scalar_one()
        return conflicts == 0
    
    def find_conflicting_bookings(
        self,
        hostel_id: UUID,
        room_type: RoomType,
        check_in_date: date,
        duration_months: int,
        exclude_booking_id: Optional[UUID] = None,
    ) -> List[Booking]:
        """
        Find bookings that conflict with given parameters.
        
        Args:
            hostel_id: Hostel UUID
            room_type: Requested room type
            check_in_date: Desired check-in date
            duration_months: Stay duration
            exclude_booking_id: Booking ID to exclude (for modifications)
            
        Returns:
            List of conflicting bookings
        """
        check_out_date = check_in_date + timedelta(days=duration_months * 30)
        
        query = select(Booking).where(
            and_(
                Booking.hostel_id == hostel_id,
                Booking.room_type_requested == room_type,
                Booking.booking_status.in_([
                    BookingStatus.APPROVED,
                    BookingStatus.CONFIRMED,
                    BookingStatus.CHECKED_IN,
                ]),
                Booking.deleted_at.is_(None),
                or_(
                    and_(
                        Booking.preferred_check_in_date <= check_in_date,
                        func.date(
                            Booking.preferred_check_in_date +
                            func.cast(Booking.stay_duration_months * 30, func.text('interval day'))
                        ) > check_in_date
                    ),
                    and_(
                        Booking.preferred_check_in_date < check_out_date,
                        func.date(
                            Booking.preferred_check_in_date +
                            func.cast(Booking.stay_duration_months * 30, func.text('interval day'))
                        ) >= check_out_date
                    ),
                    and_(
                        Booking.preferred_check_in_date >= check_in_date,
                        func.date(
                            Booking.preferred_check_in_date +
                            func.cast(Booking.stay_duration_months * 30, func.text('interval day'))
                        ) <= check_out_date
                    )
                )
            )
        )
        
        if exclude_booking_id:
            query = query.where(Booking.id != exclude_booking_id)
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    # ==================== EXPIRY MANAGEMENT ====================
    
    def find_expiring_bookings(
        self,
        within_hours: int = 24,
        hostel_id: Optional[UUID] = None,
    ) -> List[Booking]:
        """
        Find bookings expiring within specified hours.
        
        Args:
            within_hours: Hours threshold
            hostel_id: Optional hostel filter
            
        Returns:
            List of expiring bookings
        """
        expiry_threshold = datetime.utcnow() + timedelta(hours=within_hours)
        
        query = select(Booking).where(
            and_(
                Booking.booking_status == BookingStatus.PENDING,
                Booking.expires_at.isnot(None),
                Booking.expires_at <= expiry_threshold,
                Booking.expires_at > datetime.utcnow(),
                Booking.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.order_by(Booking.expires_at.asc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_expired_bookings(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[Booking]:
        """
        Find bookings that have expired.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of expired bookings
        """
        query = select(Booking).where(
            and_(
                Booking.booking_status == BookingStatus.PENDING,
                Booking.expires_at.isnot(None),
                Booking.expires_at <= datetime.utcnow(),
                Booking.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.order_by(Booking.expires_at.asc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def expire_pending_bookings(
        self,
        audit_context: Optional[AuditContext] = None,
    ) -> int:
        """
        Automatically expire pending bookings past their expiry time.
        
        Args:
            audit_context: Audit context
            
        Returns:
            Number of expired bookings
        """
        expired_bookings = self.find_expired_bookings()
        count = 0
        
        for booking in expired_bookings:
            old_status = booking.booking_status
            booking.booking_status = BookingStatus.EXPIRED
            
            self._create_status_history(
                booking,
                old_status,
                BookingStatus.EXPIRED,
                audit_context,
                "Booking expired automatically",
            )
            
            count += 1
        
        if count > 0:
            self.session.flush()
        
        return count
    
    # ==================== ANALYTICS ====================
    
    def get_booking_statistics(
        self,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> BookingStatistics:
        """
        Get booking statistics for analysis.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Booking statistics
        """
        stats = BookingStatistics()
        
        # Build base query
        base_query = select(Booking).where(Booking.deleted_at.is_(None))
        
        if hostel_id:
            base_query = base_query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            base_query = base_query.where(Booking.booking_date >= date_from)
        
        if date_to:
            base_query = base_query.where(Booking.booking_date <= date_to)
        
        # Total bookings
        count_query = select(func.count(Booking.id)).select_from(base_query.subquery())
        stats.total_bookings = self.session.execute(count_query).scalar_one()
        
        if stats.total_bookings == 0:
            return stats
        
        # Count by status
        for status in BookingStatus:
            status_query = select(func.count(Booking.id)).select_from(
                base_query.where(Booking.booking_status == status).subquery()
            )
            count = self.session.execute(status_query).scalar_one()
            
            if status == BookingStatus.PENDING:
                stats.pending_bookings = count
            elif status == BookingStatus.APPROVED:
                stats.approved_bookings = count
            elif status == BookingStatus.CONFIRMED:
                stats.confirmed_bookings = count
            elif status == BookingStatus.CANCELLED:
                stats.cancelled_bookings = count
            elif status == BookingStatus.COMPLETED:
                stats.completed_bookings = count
        
        # Total revenue (from confirmed/completed bookings)
        revenue_query = select(func.sum(Booking.total_amount)).select_from(
            base_query.where(
                Booking.booking_status.in_([
                    BookingStatus.CONFIRMED,
                    BookingStatus.CHECKED_IN,
                    BookingStatus.COMPLETED,
                ])
            ).subquery()
        )
        total_revenue = self.session.execute(revenue_query).scalar_one()
        stats.total_revenue = total_revenue or Decimal("0.00")
        
        # Average booking value
        if stats.total_bookings > 0:
            stats.average_booking_value = stats.total_revenue / stats.total_bookings
        
        # Conversion rate (confirmed / total)
        confirmed_count = (
            stats.confirmed_bookings +
            stats.completed_bookings
        )
        if stats.total_bookings > 0:
            stats.conversion_rate = (confirmed_count / stats.total_bookings) * 100
        
        # Cancellation rate
        if stats.total_bookings > 0:
            stats.cancellation_rate = (stats.cancelled_bookings / stats.total_bookings) * 100
        
        # Advance payment rate
        advance_paid_query = select(func.count(Booking.id)).select_from(
            base_query.where(Booking.advance_paid == True).subquery()
        )
        advance_paid_count = self.session.execute(advance_paid_query).scalar_one()
        
        if stats.total_bookings > 0:
            stats.advance_payment_rate = (advance_paid_count / stats.total_bookings) * 100
        
        return stats
    
    def get_bookings_by_source(
        self,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[BookingSource, int]:
        """
        Get booking count by source.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Dictionary of source to count
        """
        query = select(
            Booking.source,
            func.count(Booking.id)
        ).where(
            Booking.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(Booking.booking_date >= date_from)
        
        if date_to:
            query = query.where(Booking.booking_date <= date_to)
        
        query = query.group_by(Booking.source)
        
        result = self.session.execute(query)
        return {source: count for source, count in result.all()}
    
    def get_bookings_by_room_type(
        self,
        hostel_id: UUID,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[RoomType, int]:
        """
        Get booking count by room type.
        
        Args:
            hostel_id: Hostel UUID
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Dictionary of room type to count
        """
        query = select(
            Booking.room_type_requested,
            func.count(Booking.id)
        ).where(
            and_(
                Booking.hostel_id == hostel_id,
                Booking.deleted_at.is_(None),
            )
        )
        
        if date_from:
            query = query.where(Booking.booking_date >= date_from)
        
        if date_to:
            query = query.where(Booking.booking_date <= date_to)
        
        query = query.group_by(Booking.room_type_requested)
        
        result = self.session.execute(query)
        return {room_type: count for room_type, count in result.all()}
    
    # ==================== REFERRAL TRACKING ====================
    
    def find_by_referral_code(
        self,
        referral_code: str,
        hostel_id: Optional[UUID] = None,
    ) -> List[Booking]:
        """
        Find bookings using a specific referral code.
        
        Args:
            referral_code: Referral code
            hostel_id: Optional hostel filter
            
        Returns:
            List of bookings with referral code
        """
        query = select(Booking).where(
            and_(
                Booking.referral_code == referral_code,
                Booking.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.order_by(Booking.created_at.desc())
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def get_referral_statistics(
        self,
        referral_code: str,
        hostel_id: Optional[UUID] = None,
    ) -> Dict[str, any]:
        """
        Get statistics for a referral code.
        
        Args:
            referral_code: Referral code
            hostel_id: Optional hostel filter
            
        Returns:
            Referral statistics
        """
        bookings = self.find_by_referral_code(referral_code, hostel_id)
        
        total_bookings = len(bookings)
        confirmed_bookings = sum(
            1 for b in bookings
            if b.booking_status in [
                BookingStatus.CONFIRMED,
                BookingStatus.CHECKED_IN,
                BookingStatus.COMPLETED,
            ]
        )
        
        total_revenue = sum(
            b.total_amount for b in bookings
            if b.booking_status in [
                BookingStatus.CONFIRMED,
                BookingStatus.CHECKED_IN,
                BookingStatus.COMPLETED,
            ]
        )
        
        return {
            "referral_code": referral_code,
            "total_bookings": total_bookings,
            "confirmed_bookings": confirmed_bookings,
            "conversion_rate": (confirmed_bookings / total_bookings * 100) if total_bookings > 0 else 0,
            "total_revenue": total_revenue,
            "average_booking_value": total_revenue / confirmed_bookings if confirmed_bookings > 0 else Decimal("0.00"),
        }

# --- File: C:\Hostel-Main\app\repositories\booking\booking_waitlist_repository.py ---
```python
# app/repositories/booking/booking_modification_repository.py
"""
Booking modification repository for modification request management.

Provides modification request tracking, approval workflows, pricing impact
analysis, and modification history.
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional, Tuple
from uuid import UUID

from sqlalchemy import and_, func, or_, select
from sqlalchemy.orm import Session, joinedload

from app.core.exceptions import EntityNotFoundError, ValidationError
from app.models.booking.booking_modification import (
    BookingModification,
    ModificationApprovalRecord,
)
from app.models.booking.booking import Booking
from app.models.base.enums import RoomType
from app.repositories.base.base_repository import (
    AuditContext,
    BaseRepository,
    QueryOptions,
)


class BookingModificationRepository(BaseRepository[BookingModification]):
    """
    Repository for booking modification operations.
    
    Provides:
    - Modification request management
    - Pricing impact calculation
    - Approval workflow tracking
    - Modification analytics
    - Application management
    """
    
    def __init__(self, session: Session):
        """Initialize modification repository."""
        super().__init__(session, BookingModification)
    
    # ==================== MODIFICATION OPERATIONS ====================
    
    def create_modification_request(
        self,
        booking_id: UUID,
        modification_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingModification:
        """
        Create modification request for a booking.
        
        Args:
            booking_id: Booking UUID
            modification_data: Modification information
            audit_context: Audit context
            
        Returns:
            Created modification request
            
        Raises:
            EntityNotFoundError: If booking not found
            ValidationError: If validation fails
        """
        # Get booking
        booking = self.session.get(Booking, booking_id)
        if not booking:
            raise EntityNotFoundError(f"Booking {booking_id} not found")
        
        # Store original values
        if 'original_check_in_date' not in modification_data:
            modification_data['original_check_in_date'] = booking.preferred_check_in_date
        
        if 'original_duration_months' not in modification_data:
            modification_data['original_duration_months'] = booking.stay_duration_months
        
        if 'original_room_type' not in modification_data:
            modification_data['original_room_type'] = booking.room_type_requested
        
        if 'original_total_amount' not in modification_data:
            modification_data['original_total_amount'] = booking.total_amount
        
        # Determine modification type
        modification_types = []
        if modification_data.get('modify_check_in_date'):
            modification_types.append('date')
        if modification_data.get('modify_duration'):
            modification_types.append('duration')
        if modification_data.get('modify_room_type'):
            modification_types.append('room_type')
        
        if not modification_types:
            raise ValidationError("At least one modification type must be specified")
        
        modification_data['modification_type'] = (
            'multiple' if len(modification_types) > 1
            else modification_types[0]
        )
        
        modification = BookingModification(
            booking_id=booking_id,
            requested_by=audit_context.user_id if audit_context else None,
            requested_at=datetime.utcnow(),
            **modification_data,
        )
        
        return self.create(modification, audit_context)
    
    def find_by_booking(
        self,
        booking_id: UUID,
        status: Optional[str] = None,
    ) -> List[BookingModification]:
        """
        Find modification requests for a booking.
        
        Args:
            booking_id: Booking UUID
            status: Optional status filter
            
        Returns:
            List of modification requests
        """
        query = select(BookingModification).where(
            and_(
                BookingModification.booking_id == booking_id,
                BookingModification.deleted_at.is_(None),
            )
        )
        
        if status:
            query = query.where(BookingModification.modification_status == status)
        
        query = query.order_by(
            BookingModification.requested_at.desc()
        ).options(
            joinedload(BookingModification.booking),
            joinedload(BookingModification.requester),
            joinedload(BookingModification.approval_record),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_pending_modifications(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingModification]:
        """
        Find pending modification requests.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of pending modifications
        """
        query = select(BookingModification).join(
            Booking,
            BookingModification.booking_id == Booking.id
        ).where(
            and_(
                BookingModification.modification_status == 'pending',
                BookingModification.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        query = query.order_by(
            BookingModification.requested_at.asc()
        ).options(
            joinedload(BookingModification.booking),
            joinedload(BookingModification.requester),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def calculate_price_impact(
        self,
        modification_id: UUID,
        new_monthly_rent: Decimal,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingModification:
        """
        Calculate and update price impact of modification.
        
        Args:
            modification_id: Modification UUID
            new_monthly_rent: New monthly rent amount
            audit_context: Audit context
            
        Returns:
            Updated modification
        """
        modification = self.find_by_id(modification_id)
        if not modification:
            raise EntityNotFoundError(f"Modification {modification_id} not found")
        
        # Calculate price impact
        new_duration = (
            modification.new_duration_months
            if modification.modify_duration
            else modification.original_duration_months
        )
        
        modification.calculate_price_impact(new_monthly_rent, new_duration)
        
        self.session.flush()
        self.session.refresh(modification)
        
        return modification
    
    def approve_modification(
        self,
        modification_id: UUID,
        approved_by: UUID,
        approval_notes: Optional[str] = None,
        adjusted_price: Optional[Decimal] = None,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingModification:
        """
        Approve modification request.
        
        Args:
            modification_id: Modification UUID
            approved_by: Admin UUID approving the modification
            approval_notes: Optional approval notes
            adjusted_price: Optional admin-adjusted price
            audit_context: Audit context
            
        Returns:
            Approved modification
        """
        modification = self.find_by_id(modification_id)
        if not modification:
            raise EntityNotFoundError(f"Modification {modification_id} not found")
        
        modification.approve(approved_by)
        
        # Create approval record
        approval_repo = ModificationApprovalRecordRepository(self.session)
        approval_repo.create_approval_record(
            modification_id=modification_id,
            approved=True,
            approved_by=approved_by,
            admin_notes=approval_notes,
            adjusted_price=adjusted_price,
            audit_context=audit_context,
        )
        
        self.session.flush()
        self.session.refresh(modification)
        
        return modification
    
    def reject_modification(
        self,
        modification_id: UUID,
        rejected_by: UUID,
        reason: str,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingModification:
        """
        Reject modification request.
        
        Args:
            modification_id: Modification UUID
            rejected_by: Admin UUID rejecting the modification
            reason: Rejection reason
            audit_context: Audit context
            
        Returns:
            Rejected modification
        """
        modification = self.find_by_id(modification_id)
        if not modification:
            raise EntityNotFoundError(f"Modification {modification_id} not found")
        
        modification.reject(rejected_by, reason)
        
        # Create approval record
        approval_repo = ModificationApprovalRecordRepository(self.session)
        approval_repo.create_approval_record(
            modification_id=modification_id,
            approved=False,
            approved_by=rejected_by,
            admin_notes=reason,
            audit_context=audit_context,
        )
        
        self.session.flush()
        self.session.refresh(modification)
        
        return modification
    
    def apply_modification(
        self,
        modification_id: UUID,
        applied_by: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> Tuple[BookingModification, Booking]:
        """
        Apply approved modification to booking.
        
        Args:
            modification_id: Modification UUID
            applied_by: Admin UUID applying the modification
            audit_context: Audit context
            
        Returns:
            Tuple of (modification, updated_booking)
            
        Raises:
            ValidationError: If modification cannot be applied
        """
        modification = self.find_by_id(modification_id)
        if not modification:
            raise EntityNotFoundError(f"Modification {modification_id} not found")
        
        if modification.modification_status != 'approved':
            raise ValidationError("Only approved modifications can be applied")
        
        booking = modification.booking
        
        # Apply changes
        if modification.modify_check_in_date and modification.new_check_in_date:
            booking.preferred_check_in_date = modification.new_check_in_date
        
        if modification.modify_duration and modification.new_duration_months:
            booking.stay_duration_months = modification.new_duration_months
        
        if modification.modify_room_type and modification.new_room_type:
            booking.room_type_requested = modification.new_room_type
        
        # Update pricing if changed
        if modification.new_total_amount:
            booking.total_amount = modification.new_total_amount
        
        # Mark modification as applied
        modification.apply_modification(applied_by)
        
        self.session.flush()
        self.session.refresh(modification)
        self.session.refresh(booking)
        
        return modification, booking
    
    def find_by_type(
        self,
        modification_type: str,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> List[BookingModification]:
        """
        Find modifications by type.
        
        Args:
            modification_type: Type of modification
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            List of modifications
        """
        query = select(BookingModification).join(
            Booking,
            BookingModification.booking_id == Booking.id
        ).where(
            and_(
                BookingModification.modification_type == modification_type,
                BookingModification.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(BookingModification.requested_at >= date_from)
        
        if date_to:
            query = query.where(BookingModification.requested_at <= date_to)
        
        query = query.order_by(
            BookingModification.requested_at.desc()
        ).options(
            joinedload(BookingModification.booking),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_with_price_increase(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingModification]:
        """
        Find modifications that result in price increase.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of modifications with price increase
        """
        query = select(BookingModification).join(
            Booking,
            BookingModification.booking_id == Booking.id
        ).where(
            BookingModification.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        modifications = self.session.execute(query).scalars().all()
        
        # Filter for price increases
        with_increase = [m for m in modifications if m.has_price_increase]
        
        return with_increase
    
    def get_modification_statistics(
        self,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, any]:
        """
        Get modification statistics.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Statistics dictionary
        """
        query = select(BookingModification).join(
            Booking,
            BookingModification.booking_id == Booking.id
        ).where(
            BookingModification.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.where(Booking.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(BookingModification.requested_at >= date_from)
        
        if date_to:
            query = query.where(BookingModification.requested_at <= date_to)
        
        modifications = self.session.execute(query).scalars().all()
        
        total_modifications = len(modifications)
        
        # Count by status
        pending = sum(1 for m in modifications if m.is_pending)
        approved = sum(1 for m in modifications if m.is_approved)
        applied = sum(1 for m in modifications if m.is_applied)
        rejected = sum(1 for m in modifications if m.modification_status == 'rejected')
        
        # Count by type
        by_type = {}
        for mod in modifications:
            by_type[mod.modification_type] = by_type.get(mod.modification_type, 0) + 1
        
        # Price impact
        with_price_increase = sum(1 for m in modifications if m.has_price_increase)
        with_price_decrease = sum(1 for m in modifications if m.has_price_decrease)
        
        avg_price_change = (
            sum(m.price_difference for m in modifications if m.price_difference)
            / total_modifications
            if total_modifications > 0 else Decimal("0.00")
        )
        
        # Acceptance metrics
        total_decided = approved + rejected
        approval_rate = (approved / total_decided * 100) if total_decided > 0 else 0
        application_rate = (applied / approved * 100) if approved > 0 else 0
        
        return {
            "total_modifications": total_modifications,
            "pending_modifications": pending,
            "approved_modifications": approved,
            "applied_modifications": applied,
            "rejected_modifications": rejected,
            "approval_rate": approval_rate,
            "application_rate": application_rate,
            "modifications_by_type": by_type,
            "with_price_increase": with_price_increase,
            "with_price_decrease": with_price_decrease,
            "average_price_change": avg_price_change,
        }


class ModificationApprovalRecordRepository(BaseRepository[ModificationApprovalRecord]):
    """Repository for modification approval record management."""
    
    def __init__(self, session: Session):
        """Initialize approval record repository."""
        super().__init__(session, ModificationApprovalRecord)
    
    def create_approval_record(
        self,
        modification_id: UUID,
        approved: bool,
        approved_by: UUID,
        admin_notes: Optional[str] = None,
        adjusted_price: Optional[Decimal] = None,
        audit_context: Optional[AuditContext] = None,
    ) -> ModificationApprovalRecord:
        """
        Create approval record.
        
        Args:
            modification_id: Modification UUID
            approved: Whether approved or rejected
            approved_by: Admin making decision
            admin_notes: Optional notes
            adjusted_price: Optional adjusted price
            audit_context: Audit context
            
        Returns:
            Created approval record
        """
        record = ModificationApprovalRecord(
            modification_id=modification_id,
            approved=approved,
            decision_made_by=approved_by,
            admin_notes=admin_notes,
            adjusted_price=adjusted_price,
            approval_decision_at=datetime.utcnow(),
        )
        
        return self.create(record, audit_context)
    
    def find_by_modification(
        self,
        modification_id: UUID,
    ) -> Optional[ModificationApprovalRecord]:
        """
        Find approval record for a modification.
        
        Args:
            modification_id: Modification UUID
            
        Returns:
            Approval record if found
        """
        query = select(ModificationApprovalRecord).where(
            ModificationApprovalRecord.modification_id == modification_id
        ).options(
            joinedload(ModificationApprovalRecord.modification),
            joinedload(ModificationApprovalRecord.decision_maker),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()


# app/repositories/booking/booking_waitlist_repository.py
"""
Booking waitlist repository for waitlist management.

Provides waitlist entry management, priority tracking, notification handling,
and conversion to bookings.
"""

from datetime import date, datetime, timedelta
from typing import Dict, List, Optional, Tuple
from uuid import UUID

from sqlalchemy import and_, func, or_, select
from sqlalchemy.orm import Session, joinedload

from app.core.exceptions import EntityNotFoundError, ValidationError
from app.models.booking.booking_waitlist import (
    BookingWaitlist,
    WaitlistNotification,
)
from app.models.base.enums import RoomType, WaitlistStatus
from app.repositories.base.base_repository import (
    AuditContext,
    BaseRepository,
    QueryOptions,
)


class BookingWaitlistRepository(BaseRepository[BookingWaitlist]):
    """
    Repository for booking waitlist operations.
    
    Provides:
    - Waitlist entry management
    - Priority queue management
    - Notification tracking
    - Conversion to bookings
    - Waitlist analytics
    """
    
    def __init__(self, session: Session):
        """Initialize waitlist repository."""
        super().__init__(session, BookingWaitlist)
    
    # ==================== WAITLIST OPERATIONS ====================
    
    def add_to_waitlist(
        self,
        waitlist_data: Dict,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingWaitlist:
        """
        Add entry to waitlist.
        
        Args:
            waitlist_data: Waitlist information
            audit_context: Audit context
            
        Returns:
            Created waitlist entry
        """
        # Calculate priority (next in line)
        hostel_id = waitlist_data.get('hostel_id')
        room_type = waitlist_data.get('room_type')
        
        max_priority = self.session.execute(
            select(func.max(BookingWaitlist.priority)).where(
                and_(
                    BookingWaitlist.hostel_id == hostel_id,
                    BookingWaitlist.room_type == room_type,
                    BookingWaitlist.status == WaitlistStatus.WAITING,
                    BookingWaitlist.deleted_at.is_(None),
                )
            )
        ).scalar_one()
        
        next_priority = (max_priority or 0) + 1
        
        waitlist_entry = BookingWaitlist(
            priority=next_priority,
            status=WaitlistStatus.WAITING,
            **waitlist_data,
        )
        
        # Set default expiry (30 days)
        if not waitlist_entry.expires_at:
            waitlist_entry.expires_at = datetime.utcnow() + timedelta(days=30)
        
        return self.create(waitlist_entry, audit_context)
    
    def find_by_hostel_and_room_type(
        self,
        hostel_id: UUID,
        room_type: RoomType,
        status: Optional[WaitlistStatus] = None,
        active_only: bool = True,
    ) -> List[BookingWaitlist]:
        """
        Find waitlist entries for hostel and room type.
        
        Args:
            hostel_id: Hostel UUID
            room_type: Room type
            status: Optional status filter
            active_only: If True, only return active entries
            
        Returns:
            List of waitlist entries ordered by priority
        """
        query = select(BookingWaitlist).where(
            and_(
                BookingWaitlist.hostel_id == hostel_id,
                BookingWaitlist.room_type == room_type,
                BookingWaitlist.deleted_at.is_(None),
            )
        )
        
        if status:
            query = query.where(BookingWaitlist.status == status)
        elif active_only:
            query = query.where(BookingWaitlist.status == WaitlistStatus.WAITING)
        
        query = query.order_by(
            BookingWaitlist.priority.asc()
        ).options(
            joinedload(BookingWaitlist.visitor),
            joinedload(BookingWaitlist.hostel),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_by_visitor(
        self,
        visitor_id: UUID,
        active_only: bool = True,
    ) -> List[BookingWaitlist]:
        """
        Find waitlist entries for a visitor.
        
        Args:
            visitor_id: Visitor UUID
            active_only: If True, only return active entries
            
        Returns:
            List of visitor's waitlist entries
        """
        query = select(BookingWaitlist).where(
            and_(
                BookingWaitlist.visitor_id == visitor_id,
                BookingWaitlist.deleted_at.is_(None),
            )
        )
        
        if active_only:
            query = query.where(BookingWaitlist.status == WaitlistStatus.WAITING)
        
        query = query.order_by(
            BookingWaitlist.created_at.desc()
        ).options(
            joinedload(BookingWaitlist.hostel),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def get_next_in_line(
        self,
        hostel_id: UUID,
        room_type: RoomType,
    ) -> Optional[BookingWaitlist]:
        """
        Get next visitor in line for waitlist.
        
        Args:
            hostel_id: Hostel UUID
            room_type: Room type
            
        Returns:
            Top priority waitlist entry
        """
        query = select(BookingWaitlist).where(
            and_(
                BookingWaitlist.hostel_id == hostel_id,
                BookingWaitlist.room_type == room_type,
                BookingWaitlist.status == WaitlistStatus.WAITING,
                BookingWaitlist.deleted_at.is_(None),
            )
        ).order_by(
            BookingWaitlist.priority.asc()
        ).limit(1).options(
            joinedload(BookingWaitlist.visitor),
        )
        
        result = self.session.execute(query)
        return result.scalar_one_or_none()
    
    def notify_availability(
        self,
        waitlist_id: UUID,
        room_id: UUID,
        bed_id: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> Tuple[BookingWaitlist, WaitlistNotification]:
        """
        Notify waitlist entry about availability.
        
        Args:
            waitlist_id: Waitlist UUID
            room_id: Available room UUID
            bed_id: Available bed UUID
            audit_context: Audit context
            
        Returns:
            Tuple of (waitlist_entry, notification)
        """
        waitlist_entry = self.find_by_id(waitlist_id)
        if not waitlist_entry:
            raise EntityNotFoundError(f"Waitlist entry {waitlist_id} not found")
        
        # Create notification using waitlist method
        notification = waitlist_entry.notify_availability(room_id, bed_id)
        
        # Add notification to session
        self.session.add(notification)
        self.session.flush()
        self.session.refresh(waitlist_entry)
        self.session.refresh(notification)
        
        return waitlist_entry, notification
    
    def convert_to_booking(
        self,
        waitlist_id: UUID,
        booking_id: UUID,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingWaitlist:
        """
        Convert waitlist entry to booking.
        
        Args:
            waitlist_id: Waitlist UUID
            booking_id: Created booking UUID
            audit_context: Audit context
            
        Returns:
            Updated waitlist entry
        """
        waitlist_entry = self.find_by_id(waitlist_id)
        if not waitlist_entry:
            raise EntityNotFoundError(f"Waitlist entry {waitlist_id} not found")
        
        waitlist_entry.convert_to_booking(booking_id)
        
        # Reorder remaining waitlist entries
        self._reorder_priorities(
            waitlist_entry.hostel_id,
            waitlist_entry.room_type,
        )
        
        self.session.flush()
        self.session.refresh(waitlist_entry)
        
        return waitlist_entry
    
    def cancel_waitlist_entry(
        self,
        waitlist_id: UUID,
        reason: Optional[str] = None,
        audit_context: Optional[AuditContext] = None,
    ) -> BookingWaitlist:
        """
        Cancel waitlist entry.
        
        Args:
            waitlist_id: Waitlist UUID
            reason: Optional cancellation reason
            audit_context: Audit context
            
        Returns:
            Cancelled waitlist entry
        """
        waitlist_entry = self.find_by_id(waitlist_id)
        if not waitlist_entry:
            raise EntityNotFoundError(f"Waitlist entry {waitlist_id} not found")
        
        waitlist_entry.cancel(reason)
        
        # Reorder remaining entries
        self._reorder_priorities(
            waitlist_entry.hostel_id,
            waitlist_entry.room_type,
        )
        
        self.session.flush()
        self.session.refresh(waitlist_entry)
        
        return waitlist_entry
    
    def _reorder_priorities(
        self,
        hostel_id: UUID,
        room_type: RoomType,
    ) -> None:
        """Reorder priorities after entry removal."""
        waiting_entries = self.find_by_hostel_and_room_type(
            hostel_id,
            room_type,
            status=WaitlistStatus.WAITING,
        )
        
        for index, entry in enumerate(waiting_entries, start=1):
            if entry.priority != index:
                entry.update_priority(index)
        
        self.session.flush()
    
    def expire_old_entries(
        self,
        audit_context: Optional[AuditContext] = None,
    ) -> int:
        """
        Expire waitlist entries past their expiry date.
        
        Args:
            audit_context: Audit context
            
        Returns:
            Number of expired entries
        """
        query = select(BookingWaitlist).where(
            and_(
                BookingWaitlist.status == WaitlistStatus.WAITING,
                BookingWaitlist.expires_at.isnot(None),
                BookingWaitlist.expires_at <= datetime.utcnow(),
                BookingWaitlist.deleted_at.is_(None),
            )
        )
        
        expired_entries = self.session.execute(query).scalars().all()
        count = 0
        
        for entry in expired_entries:
            entry.mark_expired()
            count += 1
        
        if count > 0:
            self.session.flush()
        
        return count
    
    def find_expiring_soon(
        self,
        within_hours: int = 24,
        hostel_id: Optional[UUID] = None,
    ) -> List[BookingWaitlist]:
        """
        Find waitlist entries expiring soon.
        
        Args:
            within_hours: Hours threshold
            hostel_id: Optional hostel filter
            
        Returns:
            List of expiring entries
        """
        expiry_threshold = datetime.utcnow() + timedelta(hours=within_hours)
        
        query = select(BookingWaitlist).where(
            and_(
                BookingWaitlist.status == WaitlistStatus.WAITING,
                BookingWaitlist.expires_at.isnot(None),
                BookingWaitlist.expires_at <= expiry_threshold,
                BookingWaitlist.expires_at > datetime.utcnow(),
                BookingWaitlist.deleted_at.is_(None),
            )
        )
        
        if hostel_id:
            query = query.where(BookingWaitlist.hostel_id == hostel_id)
        
        query = query.order_by(
            BookingWaitlist.expires_at.asc()
        ).options(
            joinedload(BookingWaitlist.visitor),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def get_waitlist_statistics(
        self,
        hostel_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
    ) -> Dict[str, any]:
        """
        Get waitlist statistics.
        
        Args:
            hostel_id: Optional hostel filter
            date_from: Optional start date
            date_to: Optional end date
            
        Returns:
            Statistics dictionary
        """
        query = select(BookingWaitlist).where(
            BookingWaitlist.deleted_at.is_(None)
        )
        
        if hostel_id:
            query = query.where(BookingWaitlist.hostel_id == hostel_id)
        
        if date_from:
            query = query.where(BookingWaitlist.created_at >= date_from)
        
        if date_to:
            query = query.where(BookingWaitlist.created_at <= date_to)
        
        entries = self.session.execute(query).scalars().all()
        
        total_entries = len(entries)
        
        # Count by status
        by_status = {}
        for status in WaitlistStatus:
            count = sum(1 for e in entries if e.status == status)
            by_status[status.value] = count
        
        # Count by room type
        by_room_type = {}
        for entry in entries:
            room_type = str(entry.room_type)
            by_room_type[room_type] = by_room_type.get(room_type, 0) + 1
        
        # Conversion metrics
        converted = sum(1 for e in entries if e.converted_to_booking)
        conversion_rate = (converted / total_entries * 100) if total_entries > 0 else 0
        
        # Notification metrics
        notified = sum(1 for e in entries if e.status == WaitlistStatus.NOTIFIED)
        avg_notifications = (
            sum(e.notified_count for e in entries) / total_entries
            if total_entries > 0 else 0
        )
        
        # Time metrics
        avg_days_on_waitlist = (
            sum(e.days_on_waitlist for e in entries) / total_entries
            if total_entries > 0 else 0
        )
        
        active_entries = [e for e in entries if e.is_active]
        
        return {
            "total_entries": total_entries,
            "active_entries": len(active_entries),
            "entries_by_status": by_status,
            "entries_by_room_type": by_room_type,
            "converted_count": converted,
            "conversion_rate": conversion_rate,
            "notified_count": notified,
            "average_notifications_per_entry": avg_notifications,
            "average_days_on_waitlist": avg_days_on_waitlist,
        }


class WaitlistNotificationRepository(BaseRepository[WaitlistNotification]):
    """Repository for waitlist notification management."""
    
    def __init__(self, session: Session):
        """Initialize notification repository."""
        super().__init__(session, WaitlistNotification)
    
    def find_by_waitlist(
        self,
        waitlist_id: UUID,
    ) -> List[WaitlistNotification]:
        """
        Find notifications for a waitlist entry.
        
        Args:
            waitlist_id: Waitlist UUID
            
        Returns:
            List of notifications
        """
        query = select(WaitlistNotification).where(
            WaitlistNotification.waitlist_id == waitlist_id
        ).order_by(
            WaitlistNotification.sent_at.desc()
        ).options(
            joinedload(WaitlistNotification.available_room),
            joinedload(WaitlistNotification.available_bed),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def record_response(
        self,
        notification_id: UUID,
        response: str,
        audit_context: Optional[AuditContext] = None,
    ) -> WaitlistNotification:
        """
        Record visitor response to notification.
        
        Args:
            notification_id: Notification UUID
            response: Visitor response (accepted/declined)
            audit_context: Audit context
            
        Returns:
            Updated notification
        """
        notification = self.find_by_id(notification_id)
        if not notification:
            raise EntityNotFoundError(f"Notification {notification_id} not found")
        
        notification.record_response(response)
        
        self.session.flush()
        self.session.refresh(notification)
        
        return notification
    
    def find_pending_responses(
        self,
        hostel_id: Optional[UUID] = None,
    ) -> List[WaitlistNotification]:
        """
        Find notifications awaiting response.
        
        Args:
            hostel_id: Optional hostel filter
            
        Returns:
            List of notifications pending response
        """
        query = select(WaitlistNotification).join(
            BookingWaitlist,
            WaitlistNotification.waitlist_id == BookingWaitlist.id
        ).where(
            and_(
                WaitlistNotification.visitor_response.is_(None),
                WaitlistNotification.response_deadline > datetime.utcnow(),
            )
        )
        
        if hostel_id:
            query = query.where(BookingWaitlist.hostel_id == hostel_id)
        
        query = query.order_by(
            WaitlistNotification.response_deadline.asc()
        ).options(
            joinedload(WaitlistNotification.waitlist),
        )
        
        result = self.session.execute(query)
        return list(result.scalars().all())
    
    def find_expiring_soon(
        self,
        within_hours: int = 6,
        hostel_id: Optional[UUID] = None,
    ) -> List[WaitlistNotification]:
        """
        Find notifications with deadline expiring soon.
        
        Args:
            within_hours: Hours threshold
            hostel_id: Optional hostel filter
            
        Returns:
            List of notifications expiring soon
        """
        query = select(WaitlistNotification).join(
            BookingWaitlist,
            WaitlistNotification.waitlist_id == BookingWaitlist.id
        ).where(
            WaitlistNotification.visitor_response.is_(None)
        )
        
        if hostel_id:
            query = query.where(BookingWaitlist.hostel_id == hostel_id)
        
        notifications = self.session.execute(query).scalars().all()
        
        # Filter for expiring soon
        expiring = [n for n in notifications if n.is_expiring_soon]
        
        return expiring




# --- File: C:\Hostel-Main\app\repositories\booking\__init__.py ---
# app/repositories/booking/__init__.py
"""
Booking repositories package.

Exports all booking-related repositories for easy importing.
"""

from app.repositories.booking.booking_aggregate_repository import (
    BookingAggregateRepository,
)
from app.repositories.booking.booking_approval_repository import (
    ApprovalSettingsRepository,
    BookingApprovalRepository,
    RejectionRecordRepository,
)
from app.repositories.booking.booking_assignment_repository import (
    BookingAssignmentRepository,
)
from app.repositories.booking.booking_calendar_repository import (
    BookingCalendarEventRepository,
    CalendarBlockRepository,
    DayAvailabilityRepository,
)
from app.repositories.booking.booking_cancellation_repository import (
    BookingCancellationRepository,
    CancellationPolicyRepository,
    RefundTransactionRepository,
)
from app.repositories.booking.booking_conversion_repository import (
    BookingConversionRepository,
    ConversionChecklistRepository,
)
from app.repositories.booking.booking_guest_repository import (
    BookingGuestRepository,
    GuestDocumentRepository,
)
from app.repositories.booking.booking_modification_repository import (
    BookingModificationRepository,
    ModificationApprovalRecordRepository,
)
from app.repositories.booking.booking_repository import (
    BookingRepository,
    BookingSearchCriteria,
    BookingStatistics,
)
from app.repositories.booking.booking_waitlist_repository import (
    BookingWaitlistRepository,
    WaitlistNotificationRepository,
)

__all__ = [
    # Main Booking
    "BookingRepository",
    "BookingSearchCriteria",
    "BookingStatistics",
    # Approval
    "BookingApprovalRepository",
    "ApprovalSettingsRepository",
    "RejectionRecordRepository",
    # Assignment
    "BookingAssignmentRepository",
    # Calendar
    "BookingCalendarEventRepository",
    "DayAvailabilityRepository",
    "CalendarBlockRepository",
    # Cancellation
    "BookingCancellationRepository",
    "CancellationPolicyRepository",
    "RefundTransactionRepository",
    # Conversion
    "BookingConversionRepository",
    "ConversionChecklistRepository",
    # Guest
    "BookingGuestRepository",
    "GuestDocumentRepository",
    # Modification
    "BookingModificationRepository",
    "ModificationApprovalRecordRepository",
    # Waitlist
    "BookingWaitlistRepository",
    "WaitlistNotificationRepository",
    # Aggregate
    "BookingAggregateRepository",
]

