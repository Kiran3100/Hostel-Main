### Combined Content from Folder: C:\Hostel-Main\app\repositories\attendance ###



# ===== Folder: C:\Hostel-Main\app\repositories\attendance =====

# --- File: C:\Hostel-Main\app\repositories\attendance\attendance_aggregate_repository.py ---
# --- File: app/repositories/attendance/attendance_aggregate_repository.py ---
"""
Attendance aggregate repository for complex queries and analytics.

Provides advanced aggregation, cross-entity queries, and comprehensive
analytics operations for attendance data.
"""

from datetime import date, datetime, timedelta
from decimal import Decimal
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID

from sqlalchemy import and_, or_, func, case, distinct, extract
from sqlalchemy.orm import Session, joinedload

from app.models.attendance.attendance_record import AttendanceRecord
from app.models.attendance.attendance_policy import (
    AttendancePolicy,
    PolicyViolation,
    PolicyException,
)
from app.models.attendance.attendance_alert import AttendanceAlert, AlertConfiguration
from app.models.attendance.attendance_report import AttendanceSummary, AttendanceTrend
from app.models.base.enums import AttendanceStatus
from app.repositories.base.base_repository import BaseRepository


class AttendanceAggregateRepository:
    """
    Repository for attendance aggregate operations and analytics.
    """

    def __init__(self, session: Session):
        """
        Initialize repository with database session.

        Args:
            session: SQLAlchemy database session
        """
        self.session = session

    # ==================== Dashboard Analytics ====================

    def get_hostel_dashboard_data(
        self,
        hostel_id: UUID,
        reference_date: Optional[date] = None,
    ) -> Dict[str, Any]:
        """
        Get comprehensive dashboard data for hostel.

        Args:
            hostel_id: Hostel identifier
            reference_date: Reference date (defaults to today)

        Returns:
            Dictionary with dashboard metrics
        """
        if reference_date is None:
            reference_date = date.today()

        # Today's attendance
        today_records = self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.hostel_id == hostel_id,
                AttendanceRecord.attendance_date == reference_date,
            )
        ).all()

        total_marked = len(today_records)
        present_today = sum(1 for r in today_records if r.status == AttendanceStatus.PRESENT)
        absent_today = sum(1 for r in today_records if r.status == AttendanceStatus.ABSENT)
        late_today = sum(1 for r in today_records if r.is_late)

        # This month's statistics
        month_start = reference_date.replace(day=1)
        month_end = reference_date

        month_records = self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.hostel_id == hostel_id,
                AttendanceRecord.attendance_date >= month_start,
                AttendanceRecord.attendance_date <= month_end,
            )
        ).all()

        # Calculate monthly average
        monthly_avg = 0.0
        if month_records:
            present_count = sum(1 for r in month_records if r.status == AttendanceStatus.PRESENT)
            monthly_avg = (present_count / len(month_records)) * 100

        # Active alerts
        active_alerts = self.session.query(AttendanceAlert).filter(
            and_(
                AttendanceAlert.hostel_id == hostel_id,
                AttendanceAlert.resolved == False,
            )
        ).count()

        critical_alerts = self.session.query(AttendanceAlert).filter(
            and_(
                AttendanceAlert.hostel_id == hostel_id,
                AttendanceAlert.severity == "critical",
                AttendanceAlert.resolved == False,
            )
        ).count()

        # Unresolved violations
        unresolved_violations = self.session.query(PolicyViolation).join(
            AttendancePolicy
        ).filter(
            and_(
                AttendancePolicy.hostel_id == hostel_id,
                PolicyViolation.resolved == False,
            )
        ).count()

        return {
            "today": {
                "date": reference_date,
                "total_marked": total_marked,
                "present": present_today,
                "absent": absent_today,
                "late": late_today,
                "attendance_percentage": round(
                    (present_today / total_marked * 100) if total_marked > 0 else 0,
                    2,
                ),
            },
            "this_month": {
                "period_start": month_start,
                "period_end": month_end,
                "average_attendance": round(monthly_avg, 2),
                "total_records": len(month_records),
            },
            "alerts": {
                "active": active_alerts,
                "critical": critical_alerts,
            },
            "violations": {
                "unresolved": unresolved_violations,
            },
        }

    def get_student_dashboard_data(
        self,
        student_id: UUID,
        reference_date: Optional[date] = None,
    ) -> Dict[str, Any]:
        """
        Get comprehensive dashboard data for student.

        Args:
            student_id: Student identifier
            reference_date: Reference date (defaults to today)

        Returns:
            Dictionary with student metrics
        """
        if reference_date is None:
            reference_date = date.today()

        # Current month summary
        month_start = reference_date.replace(day=1)
        
        summary = self.session.query(AttendanceSummary).filter(
            and_(
                AttendanceSummary.student_id == student_id,
                AttendanceSummary.period_type == "monthly",
                AttendanceSummary.period_start == month_start,
            )
        ).first()

        # Recent attendance (last 7 days)
        week_ago = reference_date - timedelta(days=6)
        recent_records = self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.student_id == student_id,
                AttendanceRecord.attendance_date >= week_ago,
                AttendanceRecord.attendance_date <= reference_date,
            )
        ).order_by(AttendanceRecord.attendance_date.desc()).all()

        # Active alerts for student
        active_alerts = self.session.query(AttendanceAlert).filter(
            and_(
                AttendanceAlert.student_id == student_id,
                AttendanceAlert.resolved == False,
            )
        ).count()

        # Active policy exceptions
        active_exceptions = self.session.query(PolicyException).filter(
            and_(
                PolicyException.student_id == student_id,
                PolicyException.is_active == True,
                PolicyException.is_approved == True,
                PolicyException.revoked == False,
                PolicyException.valid_from <= reference_date,
                PolicyException.valid_until >= reference_date,
            )
        ).count()

        summary_data = {}
        if summary:
            summary_data = {
                "attendance_percentage": float(summary.attendance_percentage),
                "total_present": summary.total_present,
                "total_absent": summary.total_absent,
                "total_late": summary.total_late,
                "current_streak": summary.current_present_streak,
                "status": summary.attendance_status,
                "meets_requirement": summary.meets_minimum_requirement,
            }

        return {
            "current_month": summary_data,
            "recent_attendance": [
                {
                    "date": r.attendance_date,
                    "status": r.status.value,
                    "is_late": r.is_late,
                    "late_minutes": r.late_minutes,
                }
                for r in recent_records
            ],
            "alerts": {
                "active": active_alerts,
            },
            "exceptions": {
                "active": active_exceptions,
            },
        }

    # ==================== Attendance Patterns ====================

    def analyze_weekly_pattern(
        self,
        student_id: UUID,
        start_date: date,
        end_date: date,
    ) -> Dict[str, Any]:
        """
        Analyze attendance pattern by day of week.

        Args:
            student_id: Student identifier
            start_date: Analysis start date
            end_date: Analysis end date

        Returns:
            Dictionary with weekly pattern analysis
        """
        records = self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.student_id == student_id,
                AttendanceRecord.attendance_date >= start_date,
                AttendanceRecord.attendance_date <= end_date,
            )
        ).all()

        # Group by day of week (0=Monday, 6=Sunday)
        day_stats = {i: {"total": 0, "present": 0, "absent": 0, "late": 0} for i in range(7)}
        
        for record in records:
            day_of_week = record.attendance_date.weekday()
            day_stats[day_of_week]["total"] += 1
            
            if record.status == AttendanceStatus.PRESENT:
                day_stats[day_of_week]["present"] += 1
            elif record.status == AttendanceStatus.ABSENT:
                day_stats[day_of_week]["absent"] += 1
            
            if record.is_late:
                day_stats[day_of_week]["late"] += 1

        # Calculate percentages
        day_names = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
        pattern = {}
        
        for day, stats in day_stats.items():
            if stats["total"] > 0:
                pattern[day_names[day]] = {
                    "total_days": stats["total"],
                    "attendance_rate": round((stats["present"] / stats["total"]) * 100, 2),
                    "late_rate": round((stats["late"] / stats["total"]) * 100, 2),
                    "most_problematic": stats["absent"] > stats["total"] * 0.3,
                }
            else:
                pattern[day_names[day]] = {
                    "total_days": 0,
                    "attendance_rate": 0,
                    "late_rate": 0,
                    "most_problematic": False,
                }

        return pattern

    def detect_absence_patterns(
        self,
        hostel_id: UUID,
        lookback_days: int = 90,
    ) -> List[Dict[str, Any]]:
        """
        Detect patterns in absences across hostel.

        Args:
            hostel_id: Hostel identifier
            lookback_days: Days to look back

        Returns:
            List of detected patterns
        """
        end_date = date.today()
        start_date = end_date - timedelta(days=lookback_days)

        # Get absence records
        absences = self.session.query(
            AttendanceRecord.attendance_date,
            func.count(AttendanceRecord.id).label("absence_count"),
        ).filter(
            and_(
                AttendanceRecord.hostel_id == hostel_id,
                AttendanceRecord.status == AttendanceStatus.ABSENT,
                AttendanceRecord.attendance_date >= start_date,
                AttendanceRecord.attendance_date <= end_date,
            )
        ).group_by(AttendanceRecord.attendance_date).all()

        # Calculate average and threshold
        if not absences:
            return []

        avg_absences = sum(a.absence_count for a in absences) / len(absences)
        threshold = avg_absences * 1.5  # 50% above average

        # Find spike days
        patterns = []
        for absence in absences:
            if absence.absence_count > threshold:
                patterns.append({
                    "date": absence.attendance_date,
                    "day_of_week": absence.attendance_date.strftime("%A"),
                    "absence_count": absence.absence_count,
                    "average": round(avg_absences, 2),
                    "deviation": round(absence.absence_count - avg_absences, 2),
                    "pattern_type": "spike",
                })

        return sorted(patterns, key=lambda x: x["deviation"], reverse=True)

    # ==================== Comparative Analytics ====================

    def compare_student_cohorts(
        self,
        hostel_id: UUID,
        cohort_criteria: Dict[str, Any],
        period_start: date,
        period_end: date,
    ) -> Dict[str, Any]:
        """
        Compare attendance across student cohorts.

        Args:
            hostel_id: Hostel identifier
            cohort_criteria: Criteria for cohort grouping
            period_start: Period start date
            period_end: Period end date

        Returns:
            Dictionary with cohort comparison
        """
        # This is a simplified example - in practice, you'd join with
        # student table and group by cohort criteria
        
        summaries = self.session.query(AttendanceSummary).filter(
            and_(
                AttendanceSummary.hostel_id == hostel_id,
                AttendanceSummary.period_start == period_start,
                AttendanceSummary.period_end == period_end,
            )
        ).all()

        if not summaries:
            return {}

        # Group by status
        status_groups = {}
        for summary in summaries:
            status = summary.attendance_status
            if status not in status_groups:
                status_groups[status] = []
            status_groups[status].append(summary)

        # Calculate statistics per group
        comparison = {}
        for status, group in status_groups.items():
            avg_attendance = sum(s.attendance_percentage for s in group) / len(group)
            avg_late = sum(s.total_late for s in group) / len(group)
            
            comparison[status] = {
                "count": len(group),
                "average_attendance": float(round(avg_attendance, 2)),
                "average_late_entries": round(avg_late, 2),
                "meets_requirement_count": sum(1 for s in group if s.meets_minimum_requirement),
            }

        return comparison

    def get_trend_comparison(
        self,
        hostel_id: UUID,
        trend_type: str,
        periods: int = 6,
    ) -> List[Dict[str, Any]]:
        """
        Get trend comparison over multiple periods.

        Args:
            hostel_id: Hostel identifier
            trend_type: Trend type
            periods: Number of periods to compare

        Returns:
            List of period comparisons
        """
        trends = self.session.query(AttendanceTrend).filter(
            and_(
                AttendanceTrend.hostel_id == hostel_id,
                AttendanceTrend.trend_type == trend_type,
                AttendanceTrend.student_id.is_(None),
            )
        ).order_by(AttendanceTrend.period_start.desc()).limit(periods).all()

        comparison = []
        for trend in reversed(trends):
            comparison.append({
                "period": trend.period_identifier,
                "start_date": trend.period_start,
                "end_date": trend.period_end,
                "average_attendance": float(trend.average_attendance),
                "trend_direction": trend.trend_direction,
                "change_percentage": float(trend.change_percentage) if trend.change_percentage else 0,
                "average_present": float(trend.average_present),
                "average_absent": float(trend.average_absent),
                "average_late": float(trend.average_late),
                "anomaly_detected": trend.anomaly_detected,
            })

        return comparison

    # ==================== Risk Assessment ====================

    def identify_at_risk_students(
        self,
        hostel_id: UUID,
        risk_threshold: Decimal = Decimal("75.00"),
    ) -> List[Dict[str, Any]]:
        """
        Identify students at risk of failing attendance requirements.

        Args:
            hostel_id: Hostel identifier
            risk_threshold: Attendance percentage threshold

        Returns:
            List of at-risk students with details
        """
        current_month_start = date.today().replace(day=1)

        summaries = self.session.query(AttendanceSummary).filter(
            and_(
                AttendanceSummary.hostel_id == hostel_id,
                AttendanceSummary.period_start == current_month_start,
                AttendanceSummary.attendance_percentage < risk_threshold,
            )
        ).options(joinedload(AttendanceSummary.student)).all()

        at_risk = []
        for summary in summaries:
            # Get recent violations
            violations = self.session.query(PolicyViolation).filter(
                and_(
                    PolicyViolation.student_id == summary.student_id,
                    PolicyViolation.resolved == False,
                )
            ).count()

            # Get active alerts
            alerts = self.session.query(AttendanceAlert).filter(
                and_(
                    AttendanceAlert.student_id == summary.student_id,
                    AttendanceAlert.resolved == False,
                )
            ).count()

            risk_score = self._calculate_risk_score(summary, violations, alerts)

            at_risk.append({
                "student_id": summary.student_id,
                "attendance_percentage": float(summary.attendance_percentage),
                "consecutive_absences": summary.current_absent_streak,
                "total_late": summary.total_late,
                "unresolved_violations": violations,
                "active_alerts": alerts,
                "risk_score": risk_score,
                "risk_level": self._get_risk_level(risk_score),
                "status": summary.attendance_status,
            })

        return sorted(at_risk, key=lambda x: x["risk_score"], reverse=True)

    def _calculate_risk_score(
        self,
        summary: AttendanceSummary,
        violations: int,
        alerts: int,
    ) -> float:
        """Calculate risk score for student."""
        score = 0.0

        # Attendance percentage (0-40 points)
        attendance_score = (100 - float(summary.attendance_percentage)) * 0.4
        score += attendance_score

        # Consecutive absences (0-20 points)
        absence_score = min(summary.current_absent_streak * 5, 20)
        score += absence_score

        # Late entries (0-15 points)
        late_score = min(summary.total_late * 1.5, 15)
        score += late_score

        # Violations (0-15 points)
        violation_score = min(violations * 5, 15)
        score += violation_score

        # Active alerts (0-10 points)
        alert_score = min(alerts * 2.5, 10)
        score += alert_score

        return round(score, 2)

    def _get_risk_level(self, risk_score: float) -> str:
        """Get risk level from risk score."""
        if risk_score >= 70:
            return "critical"
        elif risk_score >= 50:
            return "high"
        elif risk_score >= 30:
            return "medium"
        else:
            return "low"

    # ==================== Performance Metrics ====================

    def get_performance_metrics(
        self,
        hostel_id: UUID,
        period_start: date,
        period_end: date,
    ) -> Dict[str, Any]:
        """
        Get comprehensive performance metrics.

        Args:
            hostel_id: Hostel identifier
            period_start: Period start date
            period_end: Period end date

        Returns:
            Dictionary with performance metrics
        """
        # Overall attendance
        records = self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.hostel_id == hostel_id,
                AttendanceRecord.attendance_date >= period_start,
                AttendanceRecord.attendance_date <= period_end,
            )
        ).all()

        total_records = len(records)
        if total_records == 0:
            return {}

        present_count = sum(1 for r in records if r.status == AttendanceStatus.PRESENT)
        absent_count = sum(1 for r in records if r.status == AttendanceStatus.ABSENT)
        late_count = sum(1 for r in records if r.is_late)
        
        # Summaries
        summaries = self.session.query(AttendanceSummary).filter(
            and_(
                AttendanceSummary.hostel_id == hostel_id,
                AttendanceSummary.period_start >= period_start,
                AttendanceSummary.period_end <= period_end,
            )
        ).all()

        avg_percentage = 0.0
        if summaries:
            avg_percentage = sum(s.attendance_percentage for s in summaries) / len(summaries)

        # Policy compliance
        policy = self.session.query(AttendancePolicy).filter(
            AttendancePolicy.hostel_id == hostel_id
        ).first()

        compliance_rate = 0.0
        if policy and summaries:
            compliant = sum(
                1 for s in summaries 
                if s.attendance_percentage >= policy.minimum_attendance_percentage
            )
            compliance_rate = (compliant / len(summaries)) * 100

        return {
            "overall": {
                "total_records": total_records,
                "present_count": present_count,
                "absent_count": absent_count,
                "late_count": late_count,
                "attendance_rate": round((present_count / total_records) * 100, 2),
                "late_rate": round((late_count / total_records) * 100, 2),
            },
            "student_performance": {
                "total_students": len(summaries),
                "average_attendance": float(round(avg_percentage, 2)),
                "compliance_rate": round(compliance_rate, 2),
            },
            "policy": {
                "minimum_required": float(policy.minimum_attendance_percentage) if policy else 0,
                "compliant_students": sum(1 for s in summaries if s.meets_minimum_requirement),
                "non_compliant_students": sum(1 for s in summaries if not s.meets_minimum_requirement),
            },
        }

    # ==================== Forecasting ====================

    def forecast_attendance(
        self,
        student_id: UUID,
        forecast_days: int = 30,
    ) -> Dict[str, Any]:
        """
        Forecast future attendance based on historical patterns.

        Args:
            student_id: Student identifier
            forecast_days: Number of days to forecast

        Returns:
            Dictionary with forecast data
        """
        # Get last 90 days of data
        end_date = date.today()
        start_date = end_date - timedelta(days=90)

        records = self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.student_id == student_id,
                AttendanceRecord.attendance_date >= start_date,
                AttendanceRecord.attendance_date <= end_date,
            )
        ).order_by(AttendanceRecord.attendance_date.asc()).all()

        if not records:
            return {
                "forecast_available": False,
                "message": "Insufficient historical data",
            }

        # Simple forecasting based on recent trend
        total_days = len(records)
        present_days = sum(1 for r in records if r.status == AttendanceStatus.PRESENT)
        current_rate = (present_days / total_days) * 100

        # Calculate trend (last 30 days vs previous 60 days)
        recent_30 = records[-30:] if len(records) >= 30 else records
        previous_60 = records[-90:-30] if len(records) >= 90 else records[:-30]

        recent_rate = (
            sum(1 for r in recent_30 if r.status == AttendanceStatus.PRESENT) / len(recent_30) * 100
        ) if recent_30 else 0

        previous_rate = (
            sum(1 for r in previous_60 if r.status == AttendanceStatus.PRESENT) / len(previous_60) * 100
        ) if previous_60 else 0

        trend = recent_rate - previous_rate

        # Forecast
        forecasted_rate = current_rate + (trend * (forecast_days / 30))
        forecasted_rate = max(0, min(100, forecasted_rate))  # Clamp between 0-100

        confidence = 0.7 if len(records) >= 60 else 0.5

        return {
            "forecast_available": True,
            "current_attendance_rate": round(current_rate, 2),
            "forecasted_attendance_rate": round(forecasted_rate, 2),
            "trend": "improving" if trend > 0 else "declining" if trend < 0 else "stable",
            "trend_magnitude": round(abs(trend), 2),
            "confidence_score": confidence,
            "forecast_period_days": forecast_days,
            "based_on_days": total_days,
        }




# --- File: C:\Hostel-Main\app\repositories\attendance\attendance_alert_repository.py ---
# --- File: app/repositories/attendance/attendance_alert_repository.py ---
"""
Attendance alert repository with comprehensive alert management.

Provides alert creation, tracking, escalation, and notification
management for attendance monitoring.
"""

from datetime import date, datetime, timedelta
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID

from sqlalchemy import and_, or_, func, case
from sqlalchemy.orm import Session, joinedload, selectinload

from app.models.attendance.attendance_alert import (
    AttendanceAlert,
    AlertConfiguration,
    AlertNotification,
)
from app.repositories.base.base_repository import BaseRepository
from app.core.exceptions import ValidationError, NotFoundError, ConflictError


class AttendanceAlertRepository(BaseRepository[AttendanceAlert]):
    """
    Repository for attendance alert operations with comprehensive tracking.
    """

    def __init__(self, session: Session):
        """
        Initialize repository with database session.

        Args:
            session: SQLAlchemy database session
        """
        super().__init__(AttendanceAlert, session)

    # ==================== Core Alert CRUD Operations ====================

    def create_alert(
        self,
        hostel_id: UUID,
        student_id: UUID,
        alert_type: str,
        severity: str,
        message: str,
        details: Dict[str, Any],
        category: str = "attendance",
        recommendation: Optional[str] = None,
        triggered_by_rule: Optional[str] = None,
        auto_generated: bool = True,
        manual_trigger_by: Optional[UUID] = None,
    ) -> AttendanceAlert:
        """
        Create new attendance alert.

        Args:
            hostel_id: Hostel identifier
            student_id: Student identifier
            alert_type: Type of alert
            severity: Severity level (low, medium, high, critical)
            message: Alert message
            details: Alert details as JSON
            category: Alert category
            recommendation: Recommended action
            triggered_by_rule: Rule that triggered alert
            auto_generated: Auto-generated flag
            manual_trigger_by: Manual trigger user ID

        Returns:
            Created alert

        Raises:
            ValidationError: If validation fails
        """
        # Validate severity
        valid_severities = ["low", "medium", "high", "critical"]
        if severity not in valid_severities:
            raise ValidationError(f"Invalid severity. Must be one of: {valid_severities}")

        alert = AttendanceAlert(
            hostel_id=hostel_id,
            student_id=student_id,
            alert_type=alert_type,
            severity=severity,
            message=message,
            details=details,
            category=category,
            recommendation=recommendation,
            triggered_at=datetime.utcnow(),
            triggered_by_rule=triggered_by_rule,
            auto_generated=auto_generated,
            manual_trigger_by=manual_trigger_by,
        )

        self.session.add(alert)
        self.session.flush()
        return alert

    def get_by_id(
        self,
        alert_id: UUID,
        load_relationships: bool = False,
    ) -> Optional[AttendanceAlert]:
        """
        Get alert by ID.

        Args:
            alert_id: Alert identifier
            load_relationships: Whether to load relationships

        Returns:
            Alert if found
        """
        query = self.session.query(AttendanceAlert).filter(
            AttendanceAlert.id == alert_id
        )

        if load_relationships:
            query = query.options(
                joinedload(AttendanceAlert.hostel),
                joinedload(AttendanceAlert.student),
                selectinload(AttendanceAlert.alert_notifications),
            )

        return query.first()

    def update_alert(
        self,
        alert_id: UUID,
        **update_data: Any,
    ) -> AttendanceAlert:
        """
        Update alert.

        Args:
            alert_id: Alert identifier
            **update_data: Fields to update

        Returns:
            Updated alert

        Raises:
            NotFoundError: If alert not found
        """
        alert = self.get_by_id(alert_id)
        if not alert:
            raise NotFoundError(f"Attendance alert {alert_id} not found")

        for key, value in update_data.items():
            if hasattr(alert, key):
                setattr(alert, key, value)

        self.session.flush()
        return alert

    # ==================== Query Operations ====================

    def get_student_alerts(
        self,
        student_id: UUID,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
        alert_type: Optional[str] = None,
        severity: Optional[str] = None,
        acknowledged_only: bool = False,
        unacknowledged_only: bool = False,
        resolved_only: bool = False,
        unresolved_only: bool = False,
    ) -> List[AttendanceAlert]:
        """
        Get alerts for student with filters.

        Args:
            student_id: Student identifier
            start_date: Optional start date
            end_date: Optional end date
            alert_type: Optional type filter
            severity: Optional severity filter
            acknowledged_only: Only acknowledged alerts
            unacknowledged_only: Only unacknowledged alerts
            resolved_only: Only resolved alerts
            unresolved_only: Only unresolved alerts

        Returns:
            List of alerts
        """
        query = self.session.query(AttendanceAlert).filter(
            AttendanceAlert.student_id == student_id
        )

        if start_date:
            query = query.filter(AttendanceAlert.triggered_at >= datetime.combine(start_date, datetime.min.time()))
        if end_date:
            query = query.filter(AttendanceAlert.triggered_at <= datetime.combine(end_date, datetime.max.time()))
        if alert_type:
            query = query.filter(AttendanceAlert.alert_type == alert_type)
        if severity:
            query = query.filter(AttendanceAlert.severity == severity)
        if acknowledged_only:
            query = query.filter(AttendanceAlert.acknowledged == True)
        if unacknowledged_only:
            query = query.filter(AttendanceAlert.acknowledged == False)
        if resolved_only:
            query = query.filter(AttendanceAlert.resolved == True)
        if unresolved_only:
            query = query.filter(AttendanceAlert.resolved == False)

        return query.order_by(AttendanceAlert.triggered_at.desc()).all()

    def get_hostel_alerts(
        self,
        hostel_id: UUID,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
        severity: Optional[str] = None,
        unresolved_only: bool = False,
        page: int = 1,
        page_size: int = 50,
    ) -> Tuple[List[AttendanceAlert], int]:
        """
        Get hostel alerts with pagination.

        Args:
            hostel_id: Hostel identifier
            start_date: Optional start date
            end_date: Optional end date
            severity: Optional severity filter
            unresolved_only: Only unresolved alerts
            page: Page number
            page_size: Records per page

        Returns:
            Tuple of (alerts, total_count)
        """
        query = self.session.query(AttendanceAlert).filter(
            AttendanceAlert.hostel_id == hostel_id
        )

        if start_date:
            query = query.filter(AttendanceAlert.triggered_at >= datetime.combine(start_date, datetime.min.time()))
        if end_date:
            query = query.filter(AttendanceAlert.triggered_at <= datetime.combine(end_date, datetime.max.time()))
        if severity:
            query = query.filter(AttendanceAlert.severity == severity)
        if unresolved_only:
            query = query.filter(AttendanceAlert.resolved == False)

        total_count = query.count()

        alerts = query.order_by(
            AttendanceAlert.triggered_at.desc()
        ).limit(page_size).offset((page - 1) * page_size).all()

        return alerts, total_count

    def get_critical_alerts(
        self,
        hostel_id: Optional[UUID] = None,
        unresolved_only: bool = True,
    ) -> List[AttendanceAlert]:
        """
        Get critical severity alerts.

        Args:
            hostel_id: Optional hostel filter
            unresolved_only: Only unresolved alerts

        Returns:
            List of critical alerts
        """
        query = self.session.query(AttendanceAlert).filter(
            AttendanceAlert.severity == "critical"
        )

        if hostel_id:
            query = query.filter(AttendanceAlert.hostel_id == hostel_id)
        if unresolved_only:
            query = query.filter(AttendanceAlert.resolved == False)

        return query.order_by(AttendanceAlert.triggered_at.desc()).all()

    def get_escalated_alerts(
        self,
        hostel_id: Optional[UUID] = None,
        min_escalation_level: int = 1,
    ) -> List[AttendanceAlert]:
        """
        Get escalated alerts.

        Args:
            hostel_id: Optional hostel filter
            min_escalation_level: Minimum escalation level

        Returns:
            List of escalated alerts
        """
        query = self.session.query(AttendanceAlert).filter(
            and_(
                AttendanceAlert.escalated == True,
                AttendanceAlert.escalation_level >= min_escalation_level,
            )
        )

        if hostel_id:
            query = query.filter(AttendanceAlert.hostel_id == hostel_id)

        return query.order_by(
            AttendanceAlert.escalation_level.desc(),
            AttendanceAlert.escalated_at.desc(),
        ).all()

    def get_unacknowledged_alerts(
        self,
        hostel_id: UUID,
        severity: Optional[str] = None,
        older_than_hours: Optional[int] = None,
    ) -> List[AttendanceAlert]:
        """
        Get unacknowledged alerts.

        Args:
            hostel_id: Hostel identifier
            severity: Optional severity filter
            older_than_hours: Optional age filter in hours

        Returns:
            List of unacknowledged alerts
        """
        query = self.session.query(AttendanceAlert).filter(
            and_(
                AttendanceAlert.hostel_id == hostel_id,
                AttendanceAlert.acknowledged == False,
            )
        )

        if severity:
            query = query.filter(AttendanceAlert.severity == severity)

        if older_than_hours:
            cutoff_time = datetime.utcnow() - timedelta(hours=older_than_hours)
            query = query.filter(AttendanceAlert.triggered_at <= cutoff_time)

        return query.order_by(AttendanceAlert.triggered_at.asc()).all()

    def find_duplicate_alerts(
        self,
        student_id: UUID,
        alert_type: str,
        hours_window: int = 24,
    ) -> List[AttendanceAlert]:
        """
        Find duplicate alerts within time window.

        Args:
            student_id: Student identifier
            alert_type: Alert type
            hours_window: Time window in hours

        Returns:
            List of duplicate alerts
        """
        cutoff_time = datetime.utcnow() - timedelta(hours=hours_window)

        return self.session.query(AttendanceAlert).filter(
            and_(
                AttendanceAlert.student_id == student_id,
                AttendanceAlert.alert_type == alert_type,
                AttendanceAlert.triggered_at >= cutoff_time,
            )
        ).order_by(AttendanceAlert.triggered_at.desc()).all()

    # ==================== Alert Actions ====================

    def acknowledge_alert(
        self,
        alert_id: UUID,
        acknowledged_by: UUID,
        acknowledgment_notes: Optional[str] = None,
    ) -> AttendanceAlert:
        """
        Acknowledge alert.

        Args:
            alert_id: Alert identifier
            acknowledged_by: User acknowledging
            acknowledgment_notes: Optional notes

        Returns:
            Acknowledged alert

        Raises:
            NotFoundError: If alert not found
        """
        alert = self.get_by_id(alert_id)
        if not alert:
            raise NotFoundError(f"Attendance alert {alert_id} not found")

        alert.acknowledged = True
        alert.acknowledged_by = acknowledged_by
        alert.acknowledged_at = datetime.utcnow()
        alert.acknowledgment_notes = acknowledgment_notes

        self.session.flush()
        return alert

    def assign_alert(
        self,
        alert_id: UUID,
        assigned_to: UUID,
    ) -> AttendanceAlert:
        """
        Assign alert to user.

        Args:
            alert_id: Alert identifier
            assigned_to: User to assign to

        Returns:
            Updated alert

        Raises:
            NotFoundError: If alert not found
        """
        alert = self.get_by_id(alert_id)
        if not alert:
            raise NotFoundError(f"Attendance alert {alert_id} not found")

        alert.assigned_to = assigned_to

        self.session.flush()
        return alert

    def add_action_taken(
        self,
        alert_id: UUID,
        action: Dict[str, Any],
    ) -> AttendanceAlert:
        """
        Add action taken to alert.

        Args:
            alert_id: Alert identifier
            action: Action details (timestamp, user, action, notes)

        Returns:
            Updated alert

        Raises:
            NotFoundError: If alert not found
        """
        alert = self.get_by_id(alert_id)
        if not alert:
            raise NotFoundError(f"Attendance alert {alert_id} not found")

        # Add timestamp if not present
        if 'timestamp' not in action:
            action['timestamp'] = datetime.utcnow().isoformat()

        alert.actions_taken.append(action)
        self.session.flush()
        return alert

    def resolve_alert(
        self,
        alert_id: UUID,
        resolved_by: UUID,
        resolution_notes: str,
    ) -> AttendanceAlert:
        """
        Resolve alert.

        Args:
            alert_id: Alert identifier
            resolved_by: User resolving
            resolution_notes: Resolution details

        Returns:
            Resolved alert

        Raises:
            NotFoundError: If alert not found
        """
        alert = self.get_by_id(alert_id)
        if not alert:
            raise NotFoundError(f"Attendance alert {alert_id} not found")

        alert.resolved = True
        alert.resolved_at = datetime.utcnow()
        alert.resolved_by = resolved_by
        alert.resolution_notes = resolution_notes

        self.session.flush()
        return alert

    def escalate_alert(
        self,
        alert_id: UUID,
        escalation_level: Optional[int] = None,
    ) -> AttendanceAlert:
        """
        Escalate alert to higher level.

        Args:
            alert_id: Alert identifier
            escalation_level: Optional specific level (increments by 1 if not provided)

        Returns:
            Escalated alert

        Raises:
            NotFoundError: If alert not found
            ValidationError: If max escalation reached
        """
        alert = self.get_by_id(alert_id)
        if not alert:
            raise NotFoundError(f"Attendance alert {alert_id} not found")

        if escalation_level is not None:
            if escalation_level > 5:
                raise ValidationError("Maximum escalation level is 5")
            alert.escalation_level = escalation_level
        else:
            if alert.escalation_level >= 5:
                raise ValidationError("Alert already at maximum escalation level")
            alert.escalation_level += 1

        alert.escalated = True
        alert.escalated_at = datetime.utcnow()

        self.session.flush()
        return alert

    # ==================== Alert Configuration ====================

    def create_configuration(
        self,
        hostel_id: UUID,
        enable_low_attendance_alerts: bool = True,
        low_attendance_threshold: int = 75,
        low_attendance_check_period: str = "monthly",
        enable_consecutive_absence_alerts: bool = True,
        consecutive_absence_threshold: int = 3,
        enable_late_entry_alerts: bool = True,
        late_entry_count_threshold: int = 5,
        late_entry_evaluation_period: str = "monthly",
        enable_pattern_detection: bool = False,
        pattern_sensitivity: str = "medium",
        enable_absence_spike_alerts: bool = True,
        absence_spike_threshold: int = 3,
        notify_supervisor: bool = True,
        notify_admin: bool = True,
        notify_guardian: bool = True,
        notify_student: bool = True,
        notification_channels: Optional[List[str]] = None,
        auto_escalate_enabled: bool = True,
        auto_escalate_after_days: int = 7,
        max_escalation_level: int = 3,
        suppress_duplicate_alerts: bool = True,
        duplicate_suppression_hours: int = 24,
    ) -> AlertConfiguration:
        """
        Create alert configuration for hostel.

        Args:
            hostel_id: Hostel identifier
            (other parameters match model fields)

        Returns:
            Created configuration

        Raises:
            ConflictError: If configuration already exists
        """
        # Check for existing configuration
        existing = self.get_configuration_by_hostel(hostel_id)
        if existing:
            raise ConflictError(
                f"Alert configuration already exists for hostel {hostel_id}"
            )

        if notification_channels is None:
            notification_channels = ["email", "push"]

        config = AlertConfiguration(
            hostel_id=hostel_id,
            enable_low_attendance_alerts=enable_low_attendance_alerts,
            low_attendance_threshold=low_attendance_threshold,
            low_attendance_check_period=low_attendance_check_period,
            enable_consecutive_absence_alerts=enable_consecutive_absence_alerts,
            consecutive_absence_threshold=consecutive_absence_threshold,
            enable_late_entry_alerts=enable_late_entry_alerts,
            late_entry_count_threshold=late_entry_count_threshold,
            late_entry_evaluation_period=late_entry_evaluation_period,
            enable_pattern_detection=enable_pattern_detection,
            pattern_sensitivity=pattern_sensitivity,
            enable_absence_spike_alerts=enable_absence_spike_alerts,
            absence_spike_threshold=absence_spike_threshold,
            notify_supervisor=notify_supervisor,
            notify_admin=notify_admin,
            notify_guardian=notify_guardian,
            notify_student=notify_student,
            notification_channels=notification_channels,
            auto_escalate_enabled=auto_escalate_enabled,
            auto_escalate_after_days=auto_escalate_after_days,
            max_escalation_level=max_escalation_level,
            suppress_duplicate_alerts=suppress_duplicate_alerts,
            duplicate_suppression_hours=duplicate_suppression_hours,
        )

        self.session.add(config)
        self.session.flush()
        return config

    def get_configuration_by_hostel(
        self,
        hostel_id: UUID,
    ) -> Optional[AlertConfiguration]:
        """
        Get alert configuration for hostel.

        Args:
            hostel_id: Hostel identifier

        Returns:
            Configuration if found
        """
        return self.session.query(AlertConfiguration).filter(
            AlertConfiguration.hostel_id == hostel_id
        ).first()

    def update_configuration(
        self,
        config_id: UUID,
        **update_data: Any,
    ) -> AlertConfiguration:
        """
        Update alert configuration.

        Args:
            config_id: Configuration identifier
            **update_data: Fields to update

        Returns:
            Updated configuration

        Raises:
            NotFoundError: If configuration not found
        """
        config = self.session.query(AlertConfiguration).filter(
            AlertConfiguration.id == config_id
        ).first()

        if not config:
            raise NotFoundError(f"Alert configuration {config_id} not found")

        for key, value in update_data.items():
            if hasattr(config, key):
                setattr(config, key, value)

        self.session.flush()
        return config

    # ==================== Notification Management ====================

    def create_notification(
        self,
        alert_id: UUID,
        recipient_id: UUID,
        channel: str,
        recipient_type: str,
    ) -> AlertNotification:
        """
        Create notification record.

        Args:
            alert_id: Alert identifier
            recipient_id: Recipient user ID
            channel: Notification channel (email, sms, push, etc.)
            recipient_type: Type of recipient (student, guardian, admin, supervisor)

        Returns:
            Created notification

        Raises:
            ValidationError: If validation fails
        """
        valid_channels = ["email", "sms", "push", "in_app"]
        if channel not in valid_channels:
            raise ValidationError(f"Invalid channel. Must be one of: {valid_channels}")

        valid_types = ["student", "guardian", "admin", "supervisor"]
        if recipient_type not in valid_types:
            raise ValidationError(f"Invalid recipient type. Must be one of: {valid_types}")

        notification = AlertNotification(
            alert_id=alert_id,
            recipient_id=recipient_id,
            channel=channel,
            recipient_type=recipient_type,
            sent_at=datetime.utcnow(),
        )

        self.session.add(notification)
        self.session.flush()
        return notification

    def mark_notification_delivered(
        self,
        notification_id: UUID,
    ) -> AlertNotification:
        """
        Mark notification as delivered.

        Args:
            notification_id: Notification identifier

        Returns:
            Updated notification

        Raises:
            NotFoundError: If notification not found
        """
        notification = self.session.query(AlertNotification).filter(
            AlertNotification.id == notification_id
        ).first()

        if not notification:
            raise NotFoundError(f"Alert notification {notification_id} not found")

        notification.delivered = True
        notification.delivered_at = datetime.utcnow()

        self.session.flush()
        return notification

    def mark_notification_read(
        self,
        notification_id: UUID,
    ) -> AlertNotification:
        """
        Mark notification as read.

        Args:
            notification_id: Notification identifier

        Returns:
            Updated notification

        Raises:
            NotFoundError: If notification not found
        """
        notification = self.session.query(AlertNotification).filter(
            AlertNotification.id == notification_id
        ).first()

        if not notification:
            raise NotFoundError(f"Alert notification {notification_id} not found")

        notification.read = True
        notification.read_at = datetime.utcnow()

        self.session.flush()
        return notification

    def mark_notification_failed(
        self,
        notification_id: UUID,
        failure_reason: str,
    ) -> AlertNotification:
        """
        Mark notification as failed.

        Args:
            notification_id: Notification identifier
            failure_reason: Reason for failure

        Returns:
            Updated notification

        Raises:
            NotFoundError: If notification not found
        """
        notification = self.session.query(AlertNotification).filter(
            AlertNotification.id == notification_id
        ).first()

        if not notification:
            raise NotFoundError(f"Alert notification {notification_id} not found")

        notification.failed = True
        notification.failure_reason = failure_reason
        notification.retry_count += 1

        self.session.flush()
        return notification

    def get_alert_notifications(
        self,
        alert_id: UUID,
    ) -> List[AlertNotification]:
        """
        Get all notifications for alert.

        Args:
            alert_id: Alert identifier

        Returns:
            List of notifications
        """
        return self.session.query(AlertNotification).filter(
            AlertNotification.alert_id == alert_id
        ).order_by(AlertNotification.sent_at.desc()).all()

    def get_failed_notifications(
        self,
        max_retry_count: int = 3,
    ) -> List[AlertNotification]:
        """
        Get failed notifications eligible for retry.

        Args:
            max_retry_count: Maximum retry attempts

        Returns:
            List of failed notifications
        """
        return self.session.query(AlertNotification).filter(
            and_(
                AlertNotification.failed == True,
                AlertNotification.retry_count < max_retry_count,
            )
        ).order_by(AlertNotification.sent_at.asc()).all()

    # ==================== Statistics and Analytics ====================

    def get_alert_statistics(
        self,
        hostel_id: UUID,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
    ) -> Dict[str, Any]:
        """
        Get alert statistics for hostel.

        Args:
            hostel_id: Hostel identifier
            start_date: Optional start date
            end_date: Optional end date

        Returns:
            Dictionary with statistics
        """
        query = self.session.query(AttendanceAlert).filter(
            AttendanceAlert.hostel_id == hostel_id
        )

        if start_date:
            query = query.filter(AttendanceAlert.triggered_at >= datetime.combine(start_date, datetime.min.time()))
        if end_date:
            query = query.filter(AttendanceAlert.triggered_at <= datetime.combine(end_date, datetime.max.time()))

        total_alerts = query.count()
        acknowledged_alerts = query.filter(AttendanceAlert.acknowledged == True).count()
        resolved_alerts = query.filter(AttendanceAlert.resolved == True).count()
        escalated_alerts = query.filter(AttendanceAlert.escalated == True).count()

        # Count by severity
        severity_counts = dict(
            self.session.query(
                AttendanceAlert.severity,
                func.count(AttendanceAlert.id),
            ).filter(
                AttendanceAlert.hostel_id == hostel_id
            ).group_by(AttendanceAlert.severity).all()
        )

        # Count by type
        type_counts = dict(
            self.session.query(
                AttendanceAlert.alert_type,
                func.count(AttendanceAlert.id),
            ).filter(
                AttendanceAlert.hostel_id == hostel_id
            ).group_by(AttendanceAlert.alert_type).all()
        )

        # Calculate average resolution time
        resolved_with_times = query.filter(
            and_(
                AttendanceAlert.resolved == True,
                AttendanceAlert.resolved_at.isnot(None),
            )
        ).all()

        avg_resolution_hours = 0
        if resolved_with_times:
            total_seconds = sum(
                (alert.resolved_at - alert.triggered_at).total_seconds()
                for alert in resolved_with_times
            )
            avg_resolution_hours = round(total_seconds / len(resolved_with_times) / 3600, 2)

        return {
            "total_alerts": total_alerts,
            "acknowledged_alerts": acknowledged_alerts,
            "resolved_alerts": resolved_alerts,
            "escalated_alerts": escalated_alerts,
            "unresolved_alerts": total_alerts - resolved_alerts,
            "acknowledgment_rate": round(
                (acknowledged_alerts / total_alerts * 100) if total_alerts > 0 else 0,
                2,
            ),
            "resolution_rate": round(
                (resolved_alerts / total_alerts * 100) if total_alerts > 0 else 0,
                2,
            ),
            "average_resolution_hours": avg_resolution_hours,
            "by_severity": severity_counts,
            "by_type": type_counts,
        }

    def get_notification_statistics(
        self,
        hostel_id: Optional[UUID] = None,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
    ) -> Dict[str, Any]:
        """
        Get notification statistics.

        Args:
            hostel_id: Optional hostel filter
            start_date: Optional start date
            end_date: Optional end date

        Returns:
            Dictionary with statistics
        """
        query = self.session.query(AlertNotification)

        if hostel_id:
            query = query.join(AttendanceAlert).filter(
                AttendanceAlert.hostel_id == hostel_id
            )

        if start_date:
            query = query.filter(AlertNotification.sent_at >= datetime.combine(start_date, datetime.min.time()))
        if end_date:
            query = query.filter(AlertNotification.sent_at <= datetime.combine(end_date, datetime.max.time()))

        total_notifications = query.count()
        delivered_notifications = query.filter(AlertNotification.delivered == True).count()
        read_notifications = query.filter(AlertNotification.read == True).count()
        failed_notifications = query.filter(AlertNotification.failed == True).count()

        # Count by channel
        channel_counts = dict(
            query.with_entities(
                AlertNotification.channel,
                func.count(AlertNotification.id),
            ).group_by(AlertNotification.channel).all()
        )

        return {
            "total_notifications": total_notifications,
            "delivered_notifications": delivered_notifications,
            "read_notifications": read_notifications,
            "failed_notifications": failed_notifications,
            "delivery_rate": round(
                (delivered_notifications / total_notifications * 100) if total_notifications > 0 else 0,
                2,
            ),
            "read_rate": round(
                (read_notifications / delivered_notifications * 100) if delivered_notifications > 0 else 0,
                2,
            ),
            "failure_rate": round(
                (failed_notifications / total_notifications * 100) if total_notifications > 0 else 0,
                2,
            ),
            "by_channel": channel_counts,
        }

# --- File: C:\Hostel-Main\app\repositories\attendance\attendance_policy_repository.py ---
# --- File: app/repositories/attendance/attendance_policy_repository.py ---
"""
Attendance policy repository with comprehensive policy management.

Provides CRUD operations, violation tracking, exception management,
and policy enforcement for attendance policies.
"""

from datetime import date, datetime, timedelta
from decimal import Decimal
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID

from sqlalchemy import and_, or_, func, case
from sqlalchemy.orm import Session, joinedload, selectinload

from app.models.attendance.attendance_policy import (
    AttendancePolicy,
    PolicyViolation,
    PolicyException,
)
from app.repositories.base.base_repository import BaseRepository
from app.core.exceptions import ValidationError, NotFoundError, ConflictError


class AttendancePolicyRepository(BaseRepository[AttendancePolicy]):
    """
    Repository for attendance policy operations with validation.
    """

    def __init__(self, session: Session):
        """
        Initialize repository with database session.

        Args:
            session: SQLAlchemy database session
        """
        super().__init__(AttendancePolicy, session)

    # ==================== Core CRUD Operations ====================

    def create_policy(
        self,
        hostel_id: UUID,
        minimum_attendance_percentage: Decimal = Decimal("75.00"),
        late_entry_threshold_minutes: int = 15,
        grace_period_minutes: int = 5,
        grace_days_per_month: int = 3,
        consecutive_absence_alert_days: int = 3,
        total_absence_alert_threshold: int = 10,
        notify_guardian_on_absence: bool = True,
        notify_admin_on_low_attendance: bool = True,
        notify_student_on_low_attendance: bool = True,
        low_attendance_threshold: Decimal = Decimal("75.00"),
        auto_mark_absent_enabled: bool = False,
        auto_mark_absent_after_time: Optional[datetime] = None,
        track_weekend_attendance: bool = False,
        track_holiday_attendance: bool = False,
        calculation_period: str = "monthly",
        include_weekends: bool = False,
        exclude_holidays: bool = True,
        count_leave_as_absent: bool = False,
        count_leave_as_present: bool = True,
        max_leaves_per_month: int = 3,
        is_active: bool = True,
        effective_from: Optional[date] = None,
        effective_until: Optional[date] = None,
        extended_config: Optional[Dict[str, Any]] = None,
    ) -> AttendancePolicy:
        """
        Create new attendance policy for hostel.

        Args:
            hostel_id: Hostel identifier
            (other parameters match model fields)

        Returns:
            Created attendance policy

        Raises:
            ConflictError: If policy already exists for hostel
            ValidationError: If validation fails
        """
        # Check for existing policy
        existing = self.get_by_hostel(hostel_id)
        if existing:
            raise ConflictError(
                f"Attendance policy already exists for hostel {hostel_id}"
            )

        # Validate percentages
        if not (0 <= minimum_attendance_percentage <= 100):
            raise ValidationError("Minimum attendance percentage must be between 0 and 100")
        
        if not (0 <= low_attendance_threshold <= 100):
            raise ValidationError("Low attendance threshold must be between 0 and 100")

        # Create policy
        policy = AttendancePolicy(
            hostel_id=hostel_id,
            minimum_attendance_percentage=minimum_attendance_percentage,
            late_entry_threshold_minutes=late_entry_threshold_minutes,
            grace_period_minutes=grace_period_minutes,
            grace_days_per_month=grace_days_per_month,
            consecutive_absence_alert_days=consecutive_absence_alert_days,
            total_absence_alert_threshold=total_absence_alert_threshold,
            notify_guardian_on_absence=notify_guardian_on_absence,
            notify_admin_on_low_attendance=notify_admin_on_low_attendance,
            notify_student_on_low_attendance=notify_student_on_low_attendance,
            low_attendance_threshold=low_attendance_threshold,
            auto_mark_absent_enabled=auto_mark_absent_enabled,
            auto_mark_absent_after_time=auto_mark_absent_after_time,
            track_weekend_attendance=track_weekend_attendance,
            track_holiday_attendance=track_holiday_attendance,
            calculation_period=calculation_period,
            include_weekends=include_weekends,
            exclude_holidays=exclude_holidays,
            count_leave_as_absent=count_leave_as_absent,
            count_leave_as_present=count_leave_as_present,
            max_leaves_per_month=max_leaves_per_month,
            is_active=is_active,
            effective_from=effective_from,
            effective_until=effective_until,
            extended_config=extended_config,
        )

        self.session.add(policy)
        self.session.flush()
        return policy

    def update_policy(
        self,
        policy_id: UUID,
        **update_data: Any,
    ) -> AttendancePolicy:
        """
        Update attendance policy.

        Args:
            policy_id: Policy identifier
            **update_data: Fields to update

        Returns:
            Updated policy

        Raises:
            NotFoundError: If policy not found
            ValidationError: If validation fails
        """
        policy = self.get_by_id(policy_id)
        if not policy:
            raise NotFoundError(f"Attendance policy {policy_id} not found")

        # Validate percentages if being updated
        if 'minimum_attendance_percentage' in update_data:
            value = update_data['minimum_attendance_percentage']
            if not (0 <= value <= 100):
                raise ValidationError("Minimum attendance percentage must be between 0 and 100")

        if 'low_attendance_threshold' in update_data:
            value = update_data['low_attendance_threshold']
            if not (0 <= value <= 100):
                raise ValidationError("Low attendance threshold must be between 0 and 100")

        # Update fields
        for key, value in update_data.items():
            if hasattr(policy, key):
                setattr(policy, key, value)

        self.session.flush()
        return policy

    def get_by_id(
        self,
        policy_id: UUID,
        load_relationships: bool = False,
    ) -> Optional[AttendancePolicy]:
        """
        Get policy by ID.

        Args:
            policy_id: Policy identifier
            load_relationships: Whether to load relationships

        Returns:
            Policy if found
        """
        query = self.session.query(AttendancePolicy).filter(
            AttendancePolicy.id == policy_id
        )

        if load_relationships:
            query = query.options(
                joinedload(AttendancePolicy.hostel),
                selectinload(AttendancePolicy.violations),
                selectinload(AttendancePolicy.exceptions),
            )

        return query.first()

    def get_by_hostel(
        self,
        hostel_id: UUID,
        include_inactive: bool = False,
    ) -> Optional[AttendancePolicy]:
        """
        Get active policy for hostel.

        Args:
            hostel_id: Hostel identifier
            include_inactive: Whether to include inactive policies

        Returns:
            Policy if found
        """
        query = self.session.query(AttendancePolicy).filter(
            AttendancePolicy.hostel_id == hostel_id
        )

        if not include_inactive:
            query = query.filter(AttendancePolicy.is_active == True)

        return query.first()

    def get_all_active_policies(self) -> List[AttendancePolicy]:
        """
        Get all active policies.

        Returns:
            List of active policies
        """
        return self.session.query(AttendancePolicy).filter(
            AttendancePolicy.is_active == True
        ).all()

    def deactivate_policy(
        self,
        policy_id: UUID,
    ) -> AttendancePolicy:
        """
        Deactivate policy.

        Args:
            policy_id: Policy identifier

        Returns:
            Deactivated policy

        Raises:
            NotFoundError: If policy not found
        """
        policy = self.get_by_id(policy_id)
        if not policy:
            raise NotFoundError(f"Attendance policy {policy_id} not found")

        policy.is_active = False
        self.session.flush()
        return policy

    # ==================== Policy Validation ====================

    def validate_attendance_percentage(
        self,
        hostel_id: UUID,
        percentage: Decimal,
    ) -> Dict[str, Any]:
        """
        Validate if attendance percentage meets policy requirements.

        Args:
            hostel_id: Hostel identifier
            percentage: Attendance percentage to validate

        Returns:
            Dictionary with validation results
        """
        policy = self.get_by_hostel(hostel_id)
        if not policy:
            return {
                "valid": True,
                "message": "No policy configured",
                "meets_minimum": True,
            }

        meets_minimum = percentage >= policy.minimum_attendance_percentage
        is_low = percentage < policy.low_attendance_threshold

        return {
            "valid": meets_minimum,
            "meets_minimum": meets_minimum,
            "is_low_attendance": is_low,
            "required_percentage": float(policy.minimum_attendance_percentage),
            "low_threshold": float(policy.low_attendance_threshold),
            "current_percentage": float(percentage),
            "message": self._get_validation_message(percentage, policy),
        }

    def check_consecutive_absence_violation(
        self,
        hostel_id: UUID,
        consecutive_days: int,
    ) -> Dict[str, Any]:
        """
        Check if consecutive absences violate policy.

        Args:
            hostel_id: Hostel identifier
            consecutive_days: Number of consecutive absent days

        Returns:
            Dictionary with violation check results
        """
        policy = self.get_by_hostel(hostel_id)
        if not policy:
            return {"violation": False, "message": "No policy configured"}

        violates = consecutive_days >= policy.consecutive_absence_alert_days

        return {
            "violation": violates,
            "consecutive_days": consecutive_days,
            "threshold": policy.consecutive_absence_alert_days,
            "message": f"Consecutive absences: {consecutive_days} (Threshold: {policy.consecutive_absence_alert_days})",
        }

    def check_late_entry_violation(
        self,
        hostel_id: UUID,
        late_minutes: int,
        late_count_this_month: int,
    ) -> Dict[str, Any]:
        """
        Check if late entry violates policy.

        Args:
            hostel_id: Hostel identifier
            late_minutes: Minutes late
            late_count_this_month: Late entries this month

        Returns:
            Dictionary with violation check results
        """
        policy = self.get_by_hostel(hostel_id)
        if not policy:
            return {"violation": False, "message": "No policy configured"}

        # Check if within grace period
        within_grace = late_minutes <= policy.grace_period_minutes
        
        # Check if within grace days
        within_grace_days = late_count_this_month < policy.grace_days_per_month

        is_late = late_minutes > policy.grace_period_minutes
        violates_threshold = late_minutes >= policy.late_entry_threshold_minutes

        return {
            "is_late": is_late,
            "violation": violates_threshold and not (within_grace and within_grace_days),
            "within_grace_period": within_grace,
            "within_grace_days": within_grace_days,
            "late_minutes": late_minutes,
            "threshold_minutes": policy.late_entry_threshold_minutes,
            "grace_period_minutes": policy.grace_period_minutes,
            "late_count_this_month": late_count_this_month,
            "grace_days_per_month": policy.grace_days_per_month,
        }

    # ==================== Policy Violation Management ====================

    def create_violation(
        self,
        policy_id: UUID,
        student_id: UUID,
        violation_type: str,
        severity: str,
        violation_date: date,
        current_attendance_percentage: Optional[Decimal] = None,
        required_attendance_percentage: Optional[Decimal] = None,
        consecutive_absences: Optional[int] = None,
        late_entries_this_month: Optional[int] = None,
        total_absences_this_month: Optional[int] = None,
        first_violation_date: Optional[date] = None,
        notes: Optional[str] = None,
        action_plan: Optional[str] = None,
    ) -> PolicyViolation:
        """
        Create policy violation record.

        Args:
            policy_id: Policy identifier
            student_id: Student identifier
            violation_type: Type of violation
            severity: Severity level
            violation_date: Date of violation
            (other parameters match model fields)

        Returns:
            Created violation record

        Raises:
            NotFoundError: If policy not found
        """
        policy = self.get_by_id(policy_id)
        if not policy:
            raise NotFoundError(f"Attendance policy {policy_id} not found")

        violation = PolicyViolation(
            policy_id=policy_id,
            student_id=student_id,
            violation_type=violation_type,
            severity=severity,
            violation_date=violation_date,
            current_attendance_percentage=current_attendance_percentage,
            required_attendance_percentage=required_attendance_percentage,
            consecutive_absences=consecutive_absences,
            late_entries_this_month=late_entries_this_month,
            total_absences_this_month=total_absences_this_month,
            first_violation_date=first_violation_date or violation_date,
            notes=notes,
            action_plan=action_plan,
        )

        self.session.add(violation)
        self.session.flush()
        return violation

    def get_violation_by_id(
        self,
        violation_id: UUID,
    ) -> Optional[PolicyViolation]:
        """
        Get violation by ID.

        Args:
            violation_id: Violation identifier

        Returns:
            Violation if found
        """
        return self.session.query(PolicyViolation).filter(
            PolicyViolation.id == violation_id
        ).options(
            joinedload(PolicyViolation.policy),
            joinedload(PolicyViolation.student),
        ).first()

    def get_student_violations(
        self,
        student_id: UUID,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
        violation_type: Optional[str] = None,
        resolved_only: bool = False,
        unresolved_only: bool = False,
    ) -> List[PolicyViolation]:
        """
        Get violations for student with optional filters.

        Args:
            student_id: Student identifier
            start_date: Start date filter
            end_date: End date filter
            violation_type: Type filter
            resolved_only: Only resolved violations
            unresolved_only: Only unresolved violations

        Returns:
            List of violations
        """
        query = self.session.query(PolicyViolation).filter(
            PolicyViolation.student_id == student_id
        )

        if start_date:
            query = query.filter(PolicyViolation.violation_date >= start_date)
        if end_date:
            query = query.filter(PolicyViolation.violation_date <= end_date)
        if violation_type:
            query = query.filter(PolicyViolation.violation_type == violation_type)
        if resolved_only:
            query = query.filter(PolicyViolation.resolved == True)
        if unresolved_only:
            query = query.filter(PolicyViolation.resolved == False)

        return query.order_by(PolicyViolation.violation_date.desc()).all()

    def get_policy_violations(
        self,
        policy_id: UUID,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
        severity: Optional[str] = None,
    ) -> List[PolicyViolation]:
        """
        Get violations for policy.

        Args:
            policy_id: Policy identifier
            start_date: Start date filter
            end_date: End date filter
            severity: Severity filter

        Returns:
            List of violations
        """
        query = self.session.query(PolicyViolation).filter(
            PolicyViolation.policy_id == policy_id
        )

        if start_date:
            query = query.filter(PolicyViolation.violation_date >= start_date)
        if end_date:
            query = query.filter(PolicyViolation.violation_date <= end_date)
        if severity:
            query = query.filter(PolicyViolation.severity == severity)

        return query.order_by(PolicyViolation.violation_date.desc()).all()

    def update_violation(
        self,
        violation_id: UUID,
        **update_data: Any,
    ) -> PolicyViolation:
        """
        Update violation record.

        Args:
            violation_id: Violation identifier
            **update_data: Fields to update

        Returns:
            Updated violation

        Raises:
            NotFoundError: If violation not found
        """
        violation = self.get_violation_by_id(violation_id)
        if not violation:
            raise NotFoundError(f"Policy violation {violation_id} not found")

        for key, value in update_data.items():
            if hasattr(violation, key):
                setattr(violation, key, value)

        self.session.flush()
        return violation

    def mark_violation_notified(
        self,
        violation_id: UUID,
        guardian_notified: bool = False,
        admin_notified: bool = False,
        student_notified: bool = False,
        warning_issued: bool = False,
    ) -> PolicyViolation:
        """
        Mark violation as notified.

        Args:
            violation_id: Violation identifier
            guardian_notified: Guardian notification flag
            admin_notified: Admin notification flag
            student_notified: Student notification flag
            warning_issued: Warning issued flag

        Returns:
            Updated violation
        """
        violation = self.get_violation_by_id(violation_id)
        if not violation:
            raise NotFoundError(f"Policy violation {violation_id} not found")

        now = datetime.utcnow()

        if guardian_notified:
            violation.guardian_notified = True
            violation.guardian_notified_at = now
        if admin_notified:
            violation.admin_notified = True
            violation.admin_notified_at = now
        if student_notified:
            violation.student_notified = True
        if warning_issued:
            violation.warning_issued = True
            violation.warning_issued_at = now

        self.session.flush()
        return violation

    def resolve_violation(
        self,
        violation_id: UUID,
        resolution_notes: str,
    ) -> PolicyViolation:
        """
        Resolve violation.

        Args:
            violation_id: Violation identifier
            resolution_notes: Resolution details

        Returns:
            Resolved violation

        Raises:
            NotFoundError: If violation not found
        """
        violation = self.get_violation_by_id(violation_id)
        if not violation:
            raise NotFoundError(f"Policy violation {violation_id} not found")

        violation.resolved = True
        violation.resolved_at = datetime.utcnow()
        violation.resolution_notes = resolution_notes

        self.session.flush()
        return violation

    def get_unresolved_violations(
        self,
        hostel_id: Optional[UUID] = None,
        severity: Optional[str] = None,
    ) -> List[PolicyViolation]:
        """
        Get all unresolved violations.

        Args:
            hostel_id: Optional hostel filter
            severity: Optional severity filter

        Returns:
            List of unresolved violations
        """
        query = self.session.query(PolicyViolation).filter(
            PolicyViolation.resolved == False
        )

        if hostel_id:
            query = query.join(AttendancePolicy).filter(
                AttendancePolicy.hostel_id == hostel_id
            )

        if severity:
            query = query.filter(PolicyViolation.severity == severity)

        return query.order_by(PolicyViolation.violation_date.asc()).all()

    # ==================== Policy Exception Management ====================

    def create_exception(
        self,
        policy_id: UUID,
        student_id: UUID,
        created_by: UUID,
        exception_type: str,
        reason: str,
        valid_from: date,
        valid_until: date,
        is_approved: bool = False,
        approved_by: Optional[UUID] = None,
        approval_notes: Optional[str] = None,
    ) -> PolicyException:
        """
        Create policy exception.

        Args:
            policy_id: Policy identifier
            student_id: Student identifier
            created_by: Creator user ID
            exception_type: Type of exception
            reason: Exception reason
            valid_from: Start date
            valid_until: End date
            is_approved: Approval status
            approved_by: Approver user ID
            approval_notes: Approval notes

        Returns:
            Created exception

        Raises:
            NotFoundError: If policy not found
            ValidationError: If dates invalid
        """
        policy = self.get_by_id(policy_id)
        if not policy:
            raise NotFoundError(f"Attendance policy {policy_id} not found")

        if valid_until < valid_from:
            raise ValidationError("valid_until must be >= valid_from")

        exception = PolicyException(
            policy_id=policy_id,
            student_id=student_id,
            created_by=created_by,
            exception_type=exception_type,
            reason=reason,
            valid_from=valid_from,
            valid_until=valid_until,
            is_approved=is_approved,
            approved_by=approved_by,
            approved_at=datetime.utcnow() if is_approved and approved_by else None,
            approval_notes=approval_notes,
        )

        self.session.add(exception)
        self.session.flush()
        return exception

    def get_exception_by_id(
        self,
        exception_id: UUID,
    ) -> Optional[PolicyException]:
        """
        Get exception by ID.

        Args:
            exception_id: Exception identifier

        Returns:
            Exception if found
        """
        return self.session.query(PolicyException).filter(
            PolicyException.id == exception_id
        ).options(
            joinedload(PolicyException.policy),
            joinedload(PolicyException.student),
        ).first()

    def get_student_exceptions(
        self,
        student_id: UUID,
        active_only: bool = True,
        approved_only: bool = True,
        as_of_date: Optional[date] = None,
    ) -> List[PolicyException]:
        """
        Get exceptions for student.

        Args:
            student_id: Student identifier
            active_only: Only active exceptions
            approved_only: Only approved exceptions
            as_of_date: Check validity as of date

        Returns:
            List of exceptions
        """
        query = self.session.query(PolicyException).filter(
            PolicyException.student_id == student_id
        )

        if active_only:
            query = query.filter(
                and_(
                    PolicyException.is_active == True,
                    PolicyException.revoked == False,
                )
            )

        if approved_only:
            query = query.filter(PolicyException.is_approved == True)

        if as_of_date:
            query = query.filter(
                and_(
                    PolicyException.valid_from <= as_of_date,
                    PolicyException.valid_until >= as_of_date,
                )
            )

        return query.order_by(PolicyException.valid_from.desc()).all()

    def check_active_exception(
        self,
        student_id: UUID,
        exception_type: str,
        check_date: date,
    ) -> Optional[PolicyException]:
        """
        Check if student has active exception of type on date.

        Args:
            student_id: Student identifier
            exception_type: Exception type
            check_date: Date to check

        Returns:
            Active exception if found
        """
        return self.session.query(PolicyException).filter(
            and_(
                PolicyException.student_id == student_id,
                PolicyException.exception_type == exception_type,
                PolicyException.is_active == True,
                PolicyException.is_approved == True,
                PolicyException.revoked == False,
                PolicyException.valid_from <= check_date,
                PolicyException.valid_until >= check_date,
            )
        ).first()

    def approve_exception(
        self,
        exception_id: UUID,
        approved_by: UUID,
        approval_notes: Optional[str] = None,
    ) -> PolicyException:
        """
        Approve exception.

        Args:
            exception_id: Exception identifier
            approved_by: Approver user ID
            approval_notes: Approval notes

        Returns:
            Approved exception

        Raises:
            NotFoundError: If exception not found
        """
        exception = self.get_exception_by_id(exception_id)
        if not exception:
            raise NotFoundError(f"Policy exception {exception_id} not found")

        exception.is_approved = True
        exception.approved_by = approved_by
        exception.approved_at = datetime.utcnow()
        exception.approval_notes = approval_notes

        self.session.flush()
        return exception

    def revoke_exception(
        self,
        exception_id: UUID,
        revoked_by: UUID,
        revocation_reason: str,
    ) -> PolicyException:
        """
        Revoke exception.

        Args:
            exception_id: Exception identifier
            revoked_by: Revoker user ID
            revocation_reason: Revocation reason

        Returns:
            Revoked exception

        Raises:
            NotFoundError: If exception not found
        """
        exception = self.get_exception_by_id(exception_id)
        if not exception:
            raise NotFoundError(f"Policy exception {exception_id} not found")

        exception.revoked = True
        exception.revoked_at = datetime.utcnow()
        exception.revoked_by = revoked_by
        exception.revocation_reason = revocation_reason
        exception.is_active = False

        self.session.flush()
        return exception

    def get_expiring_exceptions(
        self,
        days_before_expiry: int = 7,
    ) -> List[PolicyException]:
        """
        Get exceptions expiring within specified days.

        Args:
            days_before_expiry: Days before expiry to check

        Returns:
            List of expiring exceptions
        """
        expiry_date = date.today() + timedelta(days=days_before_expiry)

        return self.session.query(PolicyException).filter(
            and_(
                PolicyException.is_active == True,
                PolicyException.is_approved == True,
                PolicyException.revoked == False,
                PolicyException.valid_until <= expiry_date,
                PolicyException.valid_until >= date.today(),
            )
        ).order_by(PolicyException.valid_until.asc()).all()

    # ==================== Statistics and Analytics ====================

    def get_violation_statistics(
        self,
        policy_id: Optional[UUID] = None,
        hostel_id: Optional[UUID] = None,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
    ) -> Dict[str, Any]:
        """
        Get violation statistics.

        Args:
            policy_id: Optional policy filter
            hostel_id: Optional hostel filter
            start_date: Optional start date
            end_date: Optional end date

        Returns:
            Dictionary with statistics
        """
        query = self.session.query(PolicyViolation)

        if policy_id:
            query = query.filter(PolicyViolation.policy_id == policy_id)
        elif hostel_id:
            query = query.join(AttendancePolicy).filter(
                AttendancePolicy.hostel_id == hostel_id
            )

        if start_date:
            query = query.filter(PolicyViolation.violation_date >= start_date)
        if end_date:
            query = query.filter(PolicyViolation.violation_date <= end_date)

        total_violations = query.count()
        resolved_violations = query.filter(PolicyViolation.resolved == True).count()
        unresolved_violations = total_violations - resolved_violations

        # Count by severity
        severity_counts = dict(
            self.session.query(
                PolicyViolation.severity,
                func.count(PolicyViolation.id),
            ).filter(
                PolicyViolation.id.in_([v.id for v in query.all()])
            ).group_by(PolicyViolation.severity).all()
        )

        # Count by type
        type_counts = dict(
            self.session.query(
                PolicyViolation.violation_type,
                func.count(PolicyViolation.id),
            ).filter(
                PolicyViolation.id.in_([v.id for v in query.all()])
            ).group_by(PolicyViolation.violation_type).all()
        )

        return {
            "total_violations": total_violations,
            "resolved_violations": resolved_violations,
            "unresolved_violations": unresolved_violations,
            "resolution_rate": round(
                (resolved_violations / total_violations * 100) if total_violations > 0 else 0,
                2,
            ),
            "by_severity": severity_counts,
            "by_type": type_counts,
        }

    def get_exception_statistics(
        self,
        policy_id: Optional[UUID] = None,
        hostel_id: Optional[UUID] = None,
    ) -> Dict[str, Any]:
        """
        Get exception statistics.

        Args:
            policy_id: Optional policy filter
            hostel_id: Optional hostel filter

        Returns:
            Dictionary with statistics
        """
        query = self.session.query(PolicyException)

        if policy_id:
            query = query.filter(PolicyException.policy_id == policy_id)
        elif hostel_id:
            query = query.join(AttendancePolicy).filter(
                AttendancePolicy.hostel_id == hostel_id
            )

        total_exceptions = query.count()
        active_exceptions = query.filter(
            and_(
                PolicyException.is_active == True,
                PolicyException.revoked == False,
            )
        ).count()
        approved_exceptions = query.filter(
            PolicyException.is_approved == True
        ).count()
        pending_approval = query.filter(
            PolicyException.is_approved == False
        ).count()
        revoked_exceptions = query.filter(
            PolicyException.revoked == True
        ).count()

        return {
            "total_exceptions": total_exceptions,
            "active_exceptions": active_exceptions,
            "approved_exceptions": approved_exceptions,
            "pending_approval": pending_approval,
            "revoked_exceptions": revoked_exceptions,
            "approval_rate": round(
                (approved_exceptions / total_exceptions * 100) if total_exceptions > 0 else 0,
                2,
            ),
        }

    # ==================== Helper Methods ====================

    def _get_validation_message(
        self,
        percentage: Decimal,
        policy: AttendancePolicy,
    ) -> str:
        """Generate validation message based on percentage and policy."""
        if percentage >= policy.minimum_attendance_percentage:
            if percentage < policy.low_attendance_threshold:
                return f"Attendance is low ({percentage}%). Minimum required: {policy.minimum_attendance_percentage}%"
            return f"Attendance meets requirements ({percentage}%)"
        else:
            return f"Attendance below minimum ({percentage}%). Required: {policy.minimum_attendance_percentage}%"




# --- File: C:\Hostel-Main\app\repositories\attendance\attendance_record_repository.py ---
# --- File: app/repositories/attendance/attendance_record_repository.py ---
"""
Attendance record repository with comprehensive tracking and analytics.

Provides CRUD operations, bulk operations, corrections management,
and advanced querying for attendance records.
"""

from datetime import date, datetime, time, timedelta
from decimal import Decimal
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID

from sqlalchemy import and_, or_, func, case, distinct, extract
from sqlalchemy.orm import Session, joinedload, selectinload

from app.models.attendance.attendance_record import (
    AttendanceRecord,
    AttendanceCorrection,
    BulkAttendanceLog,
)
from app.models.base.enums import AttendanceStatus, AttendanceMode
from app.repositories.base.base_repository import BaseRepository
from app.repositories.base.query_builder import QueryBuilder
from app.repositories.base.pagination import PaginationManager
from app.core.exceptions import ValidationError, NotFoundError


class AttendanceRecordRepository(BaseRepository[AttendanceRecord]):
    """
    Repository for attendance record operations with advanced querying.
    """

    def __init__(self, session: Session):
        """
        Initialize repository with database session.

        Args:
            session: SQLAlchemy database session
        """
        super().__init__(AttendanceRecord, session)

    # ==================== Core CRUD Operations ====================

    def create_attendance(
        self,
        hostel_id: UUID,
        student_id: UUID,
        attendance_date: date,
        status: AttendanceStatus,
        marked_by: UUID,
        check_in_time: Optional[time] = None,
        check_out_time: Optional[time] = None,
        is_late: bool = False,
        late_minutes: Optional[int] = None,
        attendance_mode: AttendanceMode = AttendanceMode.MANUAL,
        notes: Optional[str] = None,
        location_lat: Optional[Decimal] = None,
        location_lng: Optional[Decimal] = None,
        device_info: Optional[Dict[str, Any]] = None,
        supervisor_id: Optional[UUID] = None,
    ) -> AttendanceRecord:
        """
        Create new attendance record with validation.

        Args:
            hostel_id: Hostel identifier
            student_id: Student identifier
            attendance_date: Date of attendance
            status: Attendance status
            marked_by: User who marked attendance
            check_in_time: Check-in time (optional)
            check_out_time: Check-out time (optional)
            is_late: Late arrival flag
            late_minutes: Minutes late
            attendance_mode: Mode of attendance marking
            notes: Additional notes
            location_lat: Latitude for geolocation
            location_lng: Longitude for geolocation
            device_info: Device information for mobile check-ins
            supervisor_id: Supervisor identifier (optional)

        Returns:
            Created attendance record

        Raises:
            ValidationError: If duplicate record exists or validation fails
        """
        # Check for duplicate
        existing = self._check_duplicate_attendance(student_id, attendance_date)
        if existing:
            raise ValidationError(
                f"Attendance record already exists for student {student_id} "
                f"on {attendance_date}"
            )

        # Validate late minutes
        if is_late and late_minutes is None:
            raise ValidationError("Late minutes must be provided when is_late is True")

        # Create record
        record = AttendanceRecord(
            hostel_id=hostel_id,
            student_id=student_id,
            attendance_date=attendance_date,
            status=status,
            marked_by=marked_by,
            check_in_time=check_in_time,
            check_out_time=check_out_time,
            is_late=is_late,
            late_minutes=late_minutes,
            attendance_mode=attendance_mode,
            notes=notes,
            location_lat=location_lat,
            location_lng=location_lng,
            device_info=device_info,
            supervisor_id=supervisor_id,
        )

        self.session.add(record)
        self.session.flush()
        return record

    def update_attendance(
        self,
        attendance_id: UUID,
        **update_data: Any,
    ) -> AttendanceRecord:
        """
        Update attendance record.

        Args:
            attendance_id: Attendance record identifier
            **update_data: Fields to update

        Returns:
            Updated attendance record

        Raises:
            NotFoundError: If record not found
        """
        record = self.get_by_id(attendance_id)
        if not record:
            raise NotFoundError(f"Attendance record {attendance_id} not found")

        for key, value in update_data.items():
            if hasattr(record, key):
                setattr(record, key, value)

        self.session.flush()
        return record

    def get_by_id(
        self,
        attendance_id: UUID,
        load_relationships: bool = False,
    ) -> Optional[AttendanceRecord]:
        """
        Get attendance record by ID.

        Args:
            attendance_id: Attendance record identifier
            load_relationships: Whether to eager load relationships

        Returns:
            Attendance record if found
        """
        query = self.session.query(AttendanceRecord).filter(
            AttendanceRecord.id == attendance_id
        )

        if load_relationships:
            query = query.options(
                joinedload(AttendanceRecord.hostel),
                joinedload(AttendanceRecord.student),
                joinedload(AttendanceRecord.marked_by_user),
                selectinload(AttendanceRecord.corrections),
            )

        return query.first()

    # ==================== Bulk Operations ====================

    def create_bulk_attendance(
        self,
        hostel_id: UUID,
        attendance_date: date,
        student_ids: List[UUID],
        status: AttendanceStatus,
        marked_by: UUID,
        attendance_mode: AttendanceMode = AttendanceMode.BULK,
        batch_size: int = 100,
    ) -> BulkAttendanceLog:
        """
        Create attendance records in bulk with logging.

        Args:
            hostel_id: Hostel identifier
            attendance_date: Date of attendance
            student_ids: List of student identifiers
            status: Attendance status to set
            marked_by: User marking attendance
            attendance_mode: Mode of attendance marking
            batch_size: Number of records per batch

        Returns:
            Bulk operation log

        Raises:
            ValidationError: If validation fails
        """
        started_at = datetime.utcnow()
        total_students = len(student_ids)
        successful_count = 0
        failed_count = 0
        errors = {}

        try:
            # Process in batches
            for i in range(0, total_students, batch_size):
                batch = student_ids[i:i + batch_size]
                
                for student_id in batch:
                    try:
                        # Check for existing record
                        existing = self._check_duplicate_attendance(
                            student_id, attendance_date
                        )
                        if existing:
                            failed_count += 1
                            errors[str(student_id)] = "Duplicate record"
                            continue

                        # Create record
                        record = AttendanceRecord(
                            hostel_id=hostel_id,
                            student_id=student_id,
                            attendance_date=attendance_date,
                            status=status,
                            marked_by=marked_by,
                            attendance_mode=attendance_mode,
                        )
                        self.session.add(record)
                        successful_count += 1

                    except Exception as e:
                        failed_count += 1
                        errors[str(student_id)] = str(e)

                # Commit batch
                self.session.flush()

            completed_at = datetime.utcnow()
            execution_time_ms = int(
                (completed_at - started_at).total_seconds() * 1000
            )

            # Create log
            log = BulkAttendanceLog(
                hostel_id=hostel_id,
                marked_by=marked_by,
                attendance_date=attendance_date,
                operation_type="bulk_create",
                total_students=total_students,
                successful_count=successful_count,
                failed_count=failed_count,
                errors=errors if errors else None,
                execution_time_ms=execution_time_ms,
                started_at=started_at,
                completed_at=completed_at,
            )
            self.session.add(log)
            self.session.flush()

            return log

        except Exception as e:
            self.session.rollback()
            raise ValidationError(f"Bulk attendance creation failed: {str(e)}")

    def update_bulk_attendance(
        self,
        hostel_id: UUID,
        attendance_date: date,
        student_ids: List[UUID],
        update_data: Dict[str, Any],
        marked_by: UUID,
    ) -> BulkAttendanceLog:
        """
        Update multiple attendance records.

        Args:
            hostel_id: Hostel identifier
            attendance_date: Date of attendance
            student_ids: List of student identifiers
            update_data: Data to update
            marked_by: User performing update

        Returns:
            Bulk operation log
        """
        started_at = datetime.utcnow()
        total_students = len(student_ids)
        successful_count = 0
        failed_count = 0
        errors = {}

        try:
            for student_id in student_ids:
                try:
                    record = self.get_by_student_and_date(
                        student_id, attendance_date
                    )
                    if not record:
                        failed_count += 1
                        errors[str(student_id)] = "Record not found"
                        continue

                    for key, value in update_data.items():
                        if hasattr(record, key):
                            setattr(record, key, value)

                    successful_count += 1

                except Exception as e:
                    failed_count += 1
                    errors[str(student_id)] = str(e)

            self.session.flush()

            completed_at = datetime.utcnow()
            execution_time_ms = int(
                (completed_at - started_at).total_seconds() * 1000
            )

            # Create log
            log = BulkAttendanceLog(
                hostel_id=hostel_id,
                marked_by=marked_by,
                attendance_date=attendance_date,
                operation_type="bulk_update",
                total_students=total_students,
                successful_count=successful_count,
                failed_count=failed_count,
                errors=errors if errors else None,
                execution_time_ms=execution_time_ms,
                started_at=started_at,
                completed_at=completed_at,
            )
            self.session.add(log)
            self.session.flush()

            return log

        except Exception as e:
            self.session.rollback()
            raise ValidationError(f"Bulk attendance update failed: {str(e)}")

    # ==================== Query Operations ====================

    def get_by_student_and_date(
        self,
        student_id: UUID,
        attendance_date: date,
    ) -> Optional[AttendanceRecord]:
        """
        Get attendance record for specific student and date.

        Args:
            student_id: Student identifier
            attendance_date: Date of attendance

        Returns:
            Attendance record if found
        """
        return self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.student_id == student_id,
                AttendanceRecord.attendance_date == attendance_date,
            )
        ).first()

    def get_by_hostel_and_date(
        self,
        hostel_id: UUID,
        attendance_date: date,
        status_filter: Optional[AttendanceStatus] = None,
        include_relationships: bool = False,
    ) -> List[AttendanceRecord]:
        """
        Get all attendance records for hostel on specific date.

        Args:
            hostel_id: Hostel identifier
            attendance_date: Date of attendance
            status_filter: Optional status filter
            include_relationships: Whether to load relationships

        Returns:
            List of attendance records
        """
        query = self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.hostel_id == hostel_id,
                AttendanceRecord.attendance_date == attendance_date,
            )
        )

        if status_filter:
            query = query.filter(AttendanceRecord.status == status_filter)

        if include_relationships:
            query = query.options(
                joinedload(AttendanceRecord.student),
                joinedload(AttendanceRecord.marked_by_user),
            )

        return query.order_by(AttendanceRecord.created_at.desc()).all()

    def get_student_attendance_range(
        self,
        student_id: UUID,
        start_date: date,
        end_date: date,
        status_filter: Optional[List[AttendanceStatus]] = None,
    ) -> List[AttendanceRecord]:
        """
        Get student attendance records for date range.

        Args:
            student_id: Student identifier
            start_date: Start date (inclusive)
            end_date: End date (inclusive)
            status_filter: Optional list of statuses to filter

        Returns:
            List of attendance records
        """
        query = self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.student_id == student_id,
                AttendanceRecord.attendance_date >= start_date,
                AttendanceRecord.attendance_date <= end_date,
            )
        )

        if status_filter:
            query = query.filter(AttendanceRecord.status.in_(status_filter))

        return query.order_by(AttendanceRecord.attendance_date.asc()).all()

    def get_hostel_attendance_range(
        self,
        hostel_id: UUID,
        start_date: date,
        end_date: date,
        page: int = 1,
        page_size: int = 50,
    ) -> Tuple[List[AttendanceRecord], int]:
        """
        Get hostel attendance records for date range with pagination.

        Args:
            hostel_id: Hostel identifier
            start_date: Start date (inclusive)
            end_date: End date (inclusive)
            page: Page number
            page_size: Records per page

        Returns:
            Tuple of (records, total_count)
        """
        query = self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.hostel_id == hostel_id,
                AttendanceRecord.attendance_date >= start_date,
                AttendanceRecord.attendance_date <= end_date,
            )
        )

        total_count = query.count()

        records = query.order_by(
            AttendanceRecord.attendance_date.desc(),
            AttendanceRecord.created_at.desc(),
        ).limit(page_size).offset((page - 1) * page_size).all()

        return records, total_count

    def find_late_entries(
        self,
        hostel_id: UUID,
        start_date: date,
        end_date: date,
        min_late_minutes: int = 1,
    ) -> List[AttendanceRecord]:
        """
        Find all late entry records in date range.

        Args:
            hostel_id: Hostel identifier
            start_date: Start date (inclusive)
            end_date: End date (inclusive)
            min_late_minutes: Minimum late minutes to include

        Returns:
            List of late attendance records
        """
        return self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.hostel_id == hostel_id,
                AttendanceRecord.attendance_date >= start_date,
                AttendanceRecord.attendance_date <= end_date,
                AttendanceRecord.is_late == True,
                AttendanceRecord.late_minutes >= min_late_minutes,
            )
        ).order_by(
            AttendanceRecord.attendance_date.desc(),
            AttendanceRecord.late_minutes.desc(),
        ).all()

    def find_absent_students(
        self,
        hostel_id: UUID,
        attendance_date: date,
    ) -> List[AttendanceRecord]:
        """
        Find all absent students for specific date.

        Args:
            hostel_id: Hostel identifier
            attendance_date: Date of attendance

        Returns:
            List of absent attendance records
        """
        return self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.hostel_id == hostel_id,
                AttendanceRecord.attendance_date == attendance_date,
                AttendanceRecord.status == AttendanceStatus.ABSENT,
            )
        ).options(joinedload(AttendanceRecord.student)).all()

    def find_consecutive_absences(
        self,
        student_id: UUID,
        min_consecutive_days: int = 3,
        end_date: Optional[date] = None,
    ) -> List[List[AttendanceRecord]]:
        """
        Find consecutive absence streaks for student.

        Args:
            student_id: Student identifier
            min_consecutive_days: Minimum consecutive days to report
            end_date: End date for search (default: today)

        Returns:
            List of absence streaks (each streak is a list of records)
        """
        if end_date is None:
            end_date = date.today()

        start_date = end_date - timedelta(days=90)  # Look back 90 days

        records = self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.student_id == student_id,
                AttendanceRecord.attendance_date >= start_date,
                AttendanceRecord.attendance_date <= end_date,
                AttendanceRecord.status == AttendanceStatus.ABSENT,
            )
        ).order_by(AttendanceRecord.attendance_date.asc()).all()

        # Group consecutive absences
        streaks = []
        current_streak = []

        for i, record in enumerate(records):
            if not current_streak:
                current_streak.append(record)
            else:
                last_date = current_streak[-1].attendance_date
                current_date = record.attendance_date
                
                # Check if consecutive
                if (current_date - last_date).days == 1:
                    current_streak.append(record)
                else:
                    # Save streak if meets minimum
                    if len(current_streak) >= min_consecutive_days:
                        streaks.append(current_streak)
                    current_streak = [record]

        # Add last streak if meets minimum
        if len(current_streak) >= min_consecutive_days:
            streaks.append(current_streak)

        return streaks

    def get_by_mode(
        self,
        hostel_id: UUID,
        attendance_mode: AttendanceMode,
        start_date: date,
        end_date: date,
    ) -> List[AttendanceRecord]:
        """
        Get attendance records by marking mode.

        Args:
            hostel_id: Hostel identifier
            attendance_mode: Mode of attendance marking
            start_date: Start date (inclusive)
            end_date: End date (inclusive)

        Returns:
            List of attendance records
        """
        return self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.hostel_id == hostel_id,
                AttendanceRecord.attendance_mode == attendance_mode,
                AttendanceRecord.attendance_date >= start_date,
                AttendanceRecord.attendance_date <= end_date,
            )
        ).order_by(AttendanceRecord.attendance_date.desc()).all()

    def get_corrected_records(
        self,
        hostel_id: UUID,
        start_date: date,
        end_date: date,
    ) -> List[AttendanceRecord]:
        """
        Get all corrected attendance records in date range.

        Args:
            hostel_id: Hostel identifier
            start_date: Start date (inclusive)
            end_date: End date (inclusive)

        Returns:
            List of corrected attendance records
        """
        return self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.hostel_id == hostel_id,
                AttendanceRecord.is_corrected == True,
                AttendanceRecord.attendance_date >= start_date,
                AttendanceRecord.attendance_date <= end_date,
            )
        ).options(selectinload(AttendanceRecord.corrections)).order_by(
            AttendanceRecord.attendance_date.desc()
        ).all()

    # ==================== Statistics and Analytics ====================

    def calculate_attendance_percentage(
        self,
        student_id: UUID,
        start_date: date,
        end_date: date,
        exclude_on_leave: bool = True,
    ) -> Decimal:
        """
        Calculate attendance percentage for student in date range.

        Args:
            student_id: Student identifier
            start_date: Start date (inclusive)
            end_date: End date (inclusive)
            exclude_on_leave: Whether to exclude leave days from calculation

        Returns:
            Attendance percentage
        """
        query = self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.student_id == student_id,
                AttendanceRecord.attendance_date >= start_date,
                AttendanceRecord.attendance_date <= end_date,
            )
        )

        if exclude_on_leave:
            query = query.filter(
                AttendanceRecord.status != AttendanceStatus.ON_LEAVE
            )

        total_days = query.count()
        if total_days == 0:
            return Decimal("0.00")

        present_days = query.filter(
            AttendanceRecord.status == AttendanceStatus.PRESENT
        ).count()

        percentage = (Decimal(present_days) / Decimal(total_days)) * Decimal("100")
        return round(percentage, 2)

    def get_attendance_summary(
        self,
        student_id: UUID,
        start_date: date,
        end_date: date,
    ) -> Dict[str, Any]:
        """
        Get comprehensive attendance summary for student.

        Args:
            student_id: Student identifier
            start_date: Start date (inclusive)
            end_date: End date (inclusive)

        Returns:
            Dictionary containing attendance statistics
        """
        records = self.get_student_attendance_range(
            student_id, start_date, end_date
        )

        total_days = len(records)
        present_count = sum(
            1 for r in records if r.status == AttendanceStatus.PRESENT
        )
        absent_count = sum(
            1 for r in records if r.status == AttendanceStatus.ABSENT
        )
        late_count = sum(1 for r in records if r.is_late)
        on_leave_count = sum(
            1 for r in records if r.status == AttendanceStatus.ON_LEAVE
        )
        half_day_count = sum(
            1 for r in records if r.status == AttendanceStatus.HALF_DAY
        )

        # Calculate percentage
        working_days = total_days - on_leave_count
        percentage = Decimal("0.00")
        if working_days > 0:
            percentage = (Decimal(present_count) / Decimal(working_days)) * Decimal("100")
            percentage = round(percentage, 2)

        # Calculate streaks
        current_streak = self._calculate_current_streak(records)
        longest_present_streak = self._calculate_longest_streak(
            records, AttendanceStatus.PRESENT
        )
        longest_absent_streak = self._calculate_longest_streak(
            records, AttendanceStatus.ABSENT
        )

        return {
            "total_days": total_days,
            "present_count": present_count,
            "absent_count": absent_count,
            "late_count": late_count,
            "on_leave_count": on_leave_count,
            "half_day_count": half_day_count,
            "attendance_percentage": float(percentage),
            "current_streak": current_streak,
            "longest_present_streak": longest_present_streak,
            "longest_absent_streak": longest_absent_streak,
        }

    def get_hostel_daily_summary(
        self,
        hostel_id: UUID,
        attendance_date: date,
    ) -> Dict[str, Any]:
        """
        Get daily attendance summary for hostel.

        Args:
            hostel_id: Hostel identifier
            attendance_date: Date of attendance

        Returns:
            Dictionary containing daily statistics
        """
        records = self.get_by_hostel_and_date(hostel_id, attendance_date)

        total_marked = len(records)
        present_count = sum(
            1 for r in records if r.status == AttendanceStatus.PRESENT
        )
        absent_count = sum(
            1 for r in records if r.status == AttendanceStatus.ABSENT
        )
        late_count = sum(1 for r in records if r.is_late)
        on_leave_count = sum(
            1 for r in records if r.status == AttendanceStatus.ON_LEAVE
        )

        percentage = Decimal("0.00")
        if total_marked > 0:
            percentage = (Decimal(present_count) / Decimal(total_marked)) * Decimal("100")
            percentage = round(percentage, 2)

        return {
            "date": attendance_date,
            "total_marked": total_marked,
            "present_count": present_count,
            "absent_count": absent_count,
            "late_count": late_count,
            "on_leave_count": on_leave_count,
            "attendance_percentage": float(percentage),
        }

    def get_late_entry_statistics(
        self,
        hostel_id: UUID,
        start_date: date,
        end_date: date,
    ) -> Dict[str, Any]:
        """
        Get late entry statistics for hostel.

        Args:
            hostel_id: Hostel identifier
            start_date: Start date (inclusive)
            end_date: End date (inclusive)

        Returns:
            Dictionary containing late entry statistics
        """
        late_records = self.find_late_entries(
            hostel_id, start_date, end_date, min_late_minutes=1
        )

        if not late_records:
            return {
                "total_late_entries": 0,
                "average_late_minutes": 0,
                "max_late_minutes": 0,
                "min_late_minutes": 0,
            }

        total_late = len(late_records)
        late_minutes = [r.late_minutes for r in late_records if r.late_minutes]
        
        avg_late = sum(late_minutes) / len(late_minutes) if late_minutes else 0
        max_late = max(late_minutes) if late_minutes else 0
        min_late = min(late_minutes) if late_minutes else 0

        return {
            "total_late_entries": total_late,
            "average_late_minutes": round(avg_late, 2),
            "max_late_minutes": max_late,
            "min_late_minutes": min_late,
        }

    # ==================== Correction Management ====================

    def create_correction(
        self,
        attendance_id: UUID,
        corrected_by: UUID,
        corrected_status: AttendanceStatus,
        correction_reason: str,
        corrected_check_in_time: Optional[time] = None,
        corrected_check_out_time: Optional[time] = None,
        corrected_is_late: bool = False,
        corrected_late_minutes: Optional[int] = None,
        approved_by: Optional[UUID] = None,
    ) -> AttendanceCorrection:
        """
        Create correction record for attendance.

        Args:
            attendance_id: Attendance record identifier
            corrected_by: User making correction
            corrected_status: Corrected status
            correction_reason: Reason for correction
            corrected_check_in_time: Corrected check-in time
            corrected_check_out_time: Corrected check-out time
            corrected_is_late: Corrected late flag
            corrected_late_minutes: Corrected late minutes
            approved_by: Approver identifier

        Returns:
            Created correction record

        Raises:
            NotFoundError: If attendance record not found
            ValidationError: If correction validation fails
        """
        # Get original record
        original = self.get_by_id(attendance_id)
        if not original:
            raise NotFoundError(f"Attendance record {attendance_id} not found")

        # Create correction record
        correction = AttendanceCorrection(
            attendance_id=attendance_id,
            corrected_by=corrected_by,
            original_status=original.status,
            original_check_in_time=original.check_in_time,
            original_check_out_time=original.check_out_time,
            original_is_late=original.is_late,
            original_late_minutes=original.late_minutes,
            corrected_status=corrected_status,
            corrected_check_in_time=corrected_check_in_time,
            corrected_check_out_time=corrected_check_out_time,
            corrected_is_late=corrected_is_late,
            corrected_late_minutes=corrected_late_minutes,
            correction_reason=correction_reason,
            correction_timestamp=datetime.utcnow(),
            approved_by=approved_by,
            approved_at=datetime.utcnow() if approved_by else None,
        )

        self.session.add(correction)

        # Update original record
        original.status = corrected_status
        original.check_in_time = corrected_check_in_time
        original.check_out_time = corrected_check_out_time
        original.is_late = corrected_is_late
        original.late_minutes = corrected_late_minutes
        original.is_corrected = True
        original.correction_count += 1

        self.session.flush()
        return correction

    def get_correction_history(
        self,
        attendance_id: UUID,
    ) -> List[AttendanceCorrection]:
        """
        Get all corrections for attendance record.

        Args:
            attendance_id: Attendance record identifier

        Returns:
            List of corrections ordered by timestamp
        """
        return self.session.query(AttendanceCorrection).filter(
            AttendanceCorrection.attendance_id == attendance_id
        ).order_by(AttendanceCorrection.correction_timestamp.desc()).all()

    # ==================== Bulk Operation Logs ====================

    def get_bulk_operation_logs(
        self,
        hostel_id: UUID,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
        operation_type: Optional[str] = None,
    ) -> List[BulkAttendanceLog]:
        """
        Get bulk operation logs with optional filters.

        Args:
            hostel_id: Hostel identifier
            start_date: Start date filter (optional)
            end_date: End date filter (optional)
            operation_type: Operation type filter (optional)

        Returns:
            List of bulk operation logs
        """
        query = self.session.query(BulkAttendanceLog).filter(
            BulkAttendanceLog.hostel_id == hostel_id
        )

        if start_date:
            query = query.filter(BulkAttendanceLog.attendance_date >= start_date)
        if end_date:
            query = query.filter(BulkAttendanceLog.attendance_date <= end_date)
        if operation_type:
            query = query.filter(BulkAttendanceLog.operation_type == operation_type)

        return query.order_by(BulkAttendanceLog.started_at.desc()).all()

    # ==================== Helper Methods ====================

    def _check_duplicate_attendance(
        self,
        student_id: UUID,
        attendance_date: date,
    ) -> Optional[AttendanceRecord]:
        """Check if attendance record already exists."""
        return self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.student_id == student_id,
                AttendanceRecord.attendance_date == attendance_date,
            )
        ).first()

    def _calculate_current_streak(
        self,
        records: List[AttendanceRecord],
    ) -> int:
        """Calculate current attendance streak."""
        if not records:
            return 0

        # Sort by date descending
        sorted_records = sorted(
            records, key=lambda x: x.attendance_date, reverse=True
        )

        streak = 0
        for i, record in enumerate(sorted_records):
            if record.status != AttendanceStatus.PRESENT:
                break

            if i > 0:
                # Check if consecutive
                prev_date = sorted_records[i - 1].attendance_date
                curr_date = record.attendance_date
                if (prev_date - curr_date).days != 1:
                    break

            streak += 1

        return streak

    def _calculate_longest_streak(
        self,
        records: List[AttendanceRecord],
        status: AttendanceStatus,
    ) -> int:
        """Calculate longest streak for given status."""
        if not records:
            return 0

        # Sort by date ascending
        sorted_records = sorted(records, key=lambda x: x.attendance_date)

        max_streak = 0
        current_streak = 0

        for i, record in enumerate(sorted_records):
            if record.status == status:
                if i == 0:
                    current_streak = 1
                else:
                    # Check if consecutive
                    prev_date = sorted_records[i - 1].attendance_date
                    curr_date = record.attendance_date
                    if (curr_date - prev_date).days == 1 and \
                       sorted_records[i - 1].status == status:
                        current_streak += 1
                    else:
                        current_streak = 1
                
                max_streak = max(max_streak, current_streak)
            else:
                current_streak = 0

        return max_streak

    def count_unmarked_students(
        self,
        hostel_id: UUID,
        attendance_date: date,
        total_students: int,
    ) -> int:
        """
        Count students without attendance record for date.

        Args:
            hostel_id: Hostel identifier
            attendance_date: Date of attendance
            total_students: Total active students in hostel

        Returns:
            Count of unmarked students
        """
        marked_count = self.session.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.hostel_id == hostel_id,
                AttendanceRecord.attendance_date == attendance_date,
            )
        ).count()

        return total_students - marked_count

# --- File: C:\Hostel-Main\app\repositories\attendance\attendance_report_repository.py ---
# --- File: app/repositories/attendance/attendance_report_repository.py ---
"""
Attendance report repository with caching and analytics.

Provides report generation, caching, retrieval, and summary
operations for attendance analytics and reporting.
"""

from datetime import date, datetime, timedelta
from decimal import Decimal
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID

from sqlalchemy import and_, or_, func, case, distinct
from sqlalchemy.orm import Session, joinedload, selectinload

from app.models.attendance.attendance_report import (
    AttendanceReport,
    AttendanceSummary,
    AttendanceTrend,
)
from app.models.base.enums import AttendanceStatus
from app.repositories.base.base_repository import BaseRepository
from app.core.exceptions import ValidationError, NotFoundError


class AttendanceReportRepository(BaseRepository[AttendanceReport]):
    """
    Repository for attendance report operations with caching.
    """

    def __init__(self, session: Session):
        """
        Initialize repository with database session.

        Args:
            session: SQLAlchemy database session
        """
        super().__init__(AttendanceReport, session)

    # ==================== Report CRUD Operations ====================

    def create_report(
        self,
        hostel_id: Optional[UUID],
        generated_by: UUID,
        report_type: str,
        report_title: str,
        period_start: date,
        period_end: date,
        summary_data: Dict[str, Any],
        student_id: Optional[UUID] = None,
        report_format: str = "json",
        detailed_data: Optional[Dict[str, Any]] = None,
        analytics_data: Optional[Dict[str, Any]] = None,
        is_cached: bool = True,
        cache_expires_at: Optional[datetime] = None,
        cache_key: Optional[str] = None,
        file_path: Optional[str] = None,
        file_size_bytes: Optional[int] = None,
    ) -> AttendanceReport:
        """
        Create attendance report.

        Args:
            hostel_id: Optional hostel identifier
            generated_by: User who generated report
            report_type: Type of report
            report_title: Report title
            period_start: Report period start date
            period_end: Report period end date
            summary_data: Summary data as JSON
            student_id: Optional student identifier
            report_format: Report format (json, pdf, excel, csv)
            detailed_data: Detailed data as JSON
            analytics_data: Analytics data as JSON
            is_cached: Whether report is cached
            cache_expires_at: Cache expiration datetime
            cache_key: Unique cache key
            file_path: Path to generated file
            file_size_bytes: File size in bytes

        Returns:
            Created report

        Raises:
            ValidationError: If validation fails
        """
        if period_end < period_start:
            raise ValidationError("period_end must be >= period_start")

        valid_formats = ["json", "pdf", "excel", "csv", "html"]
        if report_format not in valid_formats:
            raise ValidationError(f"Invalid report format. Must be one of: {valid_formats}")

        # Set default cache expiration if caching enabled
        if is_cached and cache_expires_at is None:
            cache_expires_at = datetime.utcnow() + timedelta(hours=24)

        report = AttendanceReport(
            hostel_id=hostel_id,
            student_id=student_id,
            generated_by=generated_by,
            report_type=report_type,
            report_title=report_title,
            report_format=report_format,
            period_start=period_start,
            period_end=period_end,
            summary_data=summary_data,
            detailed_data=detailed_data,
            analytics_data=analytics_data,
            generated_at=datetime.utcnow(),
            is_cached=is_cached,
            cache_expires_at=cache_expires_at,
            cache_key=cache_key,
            file_path=file_path,
            file_size_bytes=file_size_bytes,
        )

        self.session.add(report)
        self.session.flush()
        return report

    def get_by_id(
        self,
        report_id: UUID,
        increment_view_count: bool = True,
    ) -> Optional[AttendanceReport]:
        """
        Get report by ID.

        Args:
            report_id: Report identifier
            increment_view_count: Whether to increment view count

        Returns:
            Report if found
        """
        report = self.session.query(AttendanceReport).filter(
            AttendanceReport.id == report_id
        ).first()

        if report and increment_view_count:
            report.view_count += 1
            report.last_viewed_at = datetime.utcnow()
            self.session.flush()

        return report

    def get_by_cache_key(
        self,
        cache_key: str,
    ) -> Optional[AttendanceReport]:
        """
        Get report by cache key.

        Args:
            cache_key: Cache key

        Returns:
            Report if found and not expired
        """
        now = datetime.utcnow()
        
        return self.session.query(AttendanceReport).filter(
            and_(
                AttendanceReport.cache_key == cache_key,
                AttendanceReport.is_cached == True,
                or_(
                    AttendanceReport.cache_expires_at.is_(None),
                    AttendanceReport.cache_expires_at > now,
                ),
            )
        ).first()

    def get_reports(
        self,
        hostel_id: Optional[UUID] = None,
        student_id: Optional[UUID] = None,
        report_type: Optional[str] = None,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
        page: int = 1,
        page_size: int = 20,
    ) -> Tuple[List[AttendanceReport], int]:
        """
        Get reports with filters and pagination.

        Args:
            hostel_id: Optional hostel filter
            student_id: Optional student filter
            report_type: Optional report type filter
            start_date: Optional start date filter
            end_date: Optional end date filter
            page: Page number
            page_size: Records per page

        Returns:
            Tuple of (reports, total_count)
        """
        query = self.session.query(AttendanceReport)

        if hostel_id:
            query = query.filter(AttendanceReport.hostel_id == hostel_id)
        if student_id:
            query = query.filter(AttendanceReport.student_id == student_id)
        if report_type:
            query = query.filter(AttendanceReport.report_type == report_type)
        if start_date:
            query = query.filter(AttendanceReport.generated_at >= datetime.combine(start_date, datetime.min.time()))
        if end_date:
            query = query.filter(AttendanceReport.generated_at <= datetime.combine(end_date, datetime.max.time()))

        total_count = query.count()

        reports = query.order_by(
            AttendanceReport.generated_at.desc()
        ).limit(page_size).offset((page - 1) * page_size).all()

        return reports, total_count

    def delete_expired_cache(self) -> int:
        """
        Delete expired cached reports.

        Returns:
            Number of reports deleted
        """
        now = datetime.utcnow()

        count = self.session.query(AttendanceReport).filter(
            and_(
                AttendanceReport.is_cached == True,
                AttendanceReport.cache_expires_at.isnot(None),
                AttendanceReport.cache_expires_at <= now,
            )
        ).delete(synchronize_session=False)

        self.session.flush()
        return count

    def update_report_generation_time(
        self,
        report_id: UUID,
        generation_time_ms: int,
    ) -> AttendanceReport:
        """
        Update report generation time.

        Args:
            report_id: Report identifier
            generation_time_ms: Generation time in milliseconds

        Returns:
            Updated report

        Raises:
            NotFoundError: If report not found
        """
        report = self.get_by_id(report_id, increment_view_count=False)
        if not report:
            raise NotFoundError(f"Attendance report {report_id} not found")

        report.generation_time_ms = generation_time_ms
        self.session.flush()
        return report

    # ==================== Summary Operations ====================

    def create_summary(
        self,
        student_id: UUID,
        hostel_id: UUID,
        period_type: str,
        period_start: date,
        period_end: date,
        total_days: int,
        total_present: int,
        total_absent: int,
        total_late: int,
        total_on_leave: int,
        total_half_day: int,
        attendance_percentage: Decimal,
        late_percentage: Decimal,
        current_present_streak: int = 0,
        longest_present_streak: int = 0,
        current_absent_streak: int = 0,
        longest_absent_streak: int = 0,
        attendance_status: str = "good",
        meets_minimum_requirement: bool = True,
    ) -> AttendanceSummary:
        """
        Create attendance summary.

        Args:
            student_id: Student identifier
            hostel_id: Hostel identifier
            period_type: Period type (daily, weekly, monthly, quarterly, yearly)
            period_start: Period start date
            period_end: Period end date
            total_days: Total days in period
            total_present: Total present days
            total_absent: Total absent days
            total_late: Total late entries
            total_on_leave: Total leave days
            total_half_day: Total half days
            attendance_percentage: Attendance percentage
            late_percentage: Late percentage
            current_present_streak: Current present streak
            longest_present_streak: Longest present streak
            current_absent_streak: Current absent streak
            longest_absent_streak: Longest absent streak
            attendance_status: Status (excellent, good, warning, critical)
            meets_minimum_requirement: Meets minimum requirement flag

        Returns:
            Created summary

        Raises:
            ValidationError: If validation fails
        """
        if period_end < period_start:
            raise ValidationError("period_end must be >= period_start")

        valid_types = ["daily", "weekly", "monthly", "quarterly", "yearly", "custom"]
        if period_type not in valid_types:
            raise ValidationError(f"Invalid period type. Must be one of: {valid_types}")

        valid_statuses = ["excellent", "good", "warning", "critical"]
        if attendance_status not in valid_statuses:
            raise ValidationError(f"Invalid status. Must be one of: {valid_statuses}")

        summary = AttendanceSummary(
            student_id=student_id,
            hostel_id=hostel_id,
            period_type=period_type,
            period_start=period_start,
            period_end=period_end,
            total_days=total_days,
            total_present=total_present,
            total_absent=total_absent,
            total_late=total_late,
            total_on_leave=total_on_leave,
            total_half_day=total_half_day,
            attendance_percentage=attendance_percentage,
            late_percentage=late_percentage,
            current_present_streak=current_present_streak,
            longest_present_streak=longest_present_streak,
            current_absent_streak=current_absent_streak,
            longest_absent_streak=longest_absent_streak,
            attendance_status=attendance_status,
            meets_minimum_requirement=meets_minimum_requirement,
            last_calculated_at=datetime.utcnow(),
        )

        self.session.add(summary)
        self.session.flush()
        return summary

    def get_summary_by_id(
        self,
        summary_id: UUID,
    ) -> Optional[AttendanceSummary]:
        """
        Get summary by ID.

        Args:
            summary_id: Summary identifier

        Returns:
            Summary if found
        """
        return self.session.query(AttendanceSummary).filter(
            AttendanceSummary.id == summary_id
        ).options(joinedload(AttendanceSummary.student)).first()

    def get_student_summary(
        self,
        student_id: UUID,
        period_type: str,
        period_start: date,
        period_end: date,
    ) -> Optional[AttendanceSummary]:
        """
        Get summary for student and period.

        Args:
            student_id: Student identifier
            period_type: Period type
            period_start: Period start date
            period_end: Period end date

        Returns:
            Summary if found
        """
        return self.session.query(AttendanceSummary).filter(
            and_(
                AttendanceSummary.student_id == student_id,
                AttendanceSummary.period_type == period_type,
                AttendanceSummary.period_start == period_start,
                AttendanceSummary.period_end == period_end,
            )
        ).first()

    def get_student_summaries(
        self,
        student_id: UUID,
        period_type: Optional[str] = None,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
    ) -> List[AttendanceSummary]:
        """
        Get all summaries for student.

        Args:
            student_id: Student identifier
            period_type: Optional period type filter
            start_date: Optional start date filter
            end_date: Optional end date filter

        Returns:
            List of summaries
        """
        query = self.session.query(AttendanceSummary).filter(
            AttendanceSummary.student_id == student_id
        )

        if period_type:
            query = query.filter(AttendanceSummary.period_type == period_type)
        if start_date:
            query = query.filter(AttendanceSummary.period_start >= start_date)
        if end_date:
            query = query.filter(AttendanceSummary.period_end <= end_date)

        return query.order_by(AttendanceSummary.period_start.desc()).all()

    def get_hostel_summaries(
        self,
        hostel_id: UUID,
        period_type: str,
        period_start: date,
        period_end: date,
        status_filter: Optional[str] = None,
    ) -> List[AttendanceSummary]:
        """
        Get all summaries for hostel in period.

        Args:
            hostel_id: Hostel identifier
            period_type: Period type
            period_start: Period start date
            period_end: Period end date
            status_filter: Optional status filter

        Returns:
            List of summaries
        """
        query = self.session.query(AttendanceSummary).filter(
            and_(
                AttendanceSummary.hostel_id == hostel_id,
                AttendanceSummary.period_type == period_type,
                AttendanceSummary.period_start == period_start,
                AttendanceSummary.period_end == period_end,
            )
        ).options(joinedload(AttendanceSummary.student))

        if status_filter:
            query = query.filter(AttendanceSummary.attendance_status == status_filter)

        return query.order_by(AttendanceSummary.attendance_percentage.desc()).all()

    def get_low_attendance_summaries(
        self,
        hostel_id: UUID,
        threshold_percentage: Decimal,
        period_type: str = "monthly",
    ) -> List[AttendanceSummary]:
        """
        Get summaries with low attendance.

        Args:
            hostel_id: Hostel identifier
            threshold_percentage: Threshold percentage
            period_type: Period type

        Returns:
            List of low attendance summaries
        """
        return self.session.query(AttendanceSummary).filter(
            and_(
                AttendanceSummary.hostel_id == hostel_id,
                AttendanceSummary.period_type == period_type,
                AttendanceSummary.attendance_percentage < threshold_percentage,
            )
        ).options(joinedload(AttendanceSummary.student)).order_by(
            AttendanceSummary.attendance_percentage.asc()
        ).all()

    def update_summary(
        self,
        summary_id: UUID,
        **update_data: Any,
    ) -> AttendanceSummary:
        """
        Update summary.

        Args:
            summary_id: Summary identifier
            **update_data: Fields to update

        Returns:
            Updated summary

        Raises:
            NotFoundError: If summary not found
        """
        summary = self.get_summary_by_id(summary_id)
        if not summary:
            raise NotFoundError(f"Attendance summary {summary_id} not found")

        for key, value in update_data.items():
            if hasattr(summary, key):
                setattr(summary, key, value)

        summary.last_calculated_at = datetime.utcnow()
        summary.calculation_version += 1

        self.session.flush()
        return summary

    def recalculate_summary(
        self,
        summary_id: UUID,
        new_metrics: Dict[str, Any],
    ) -> AttendanceSummary:
        """
        Recalculate summary with new metrics.

        Args:
            summary_id: Summary identifier
            new_metrics: New metric values

        Returns:
            Updated summary

        Raises:
            NotFoundError: If summary not found
        """
        return self.update_summary(summary_id, **new_metrics)

    # ==================== Trend Operations ====================

    def create_trend(
        self,
        hostel_id: UUID,
        trend_type: str,
        period_identifier: str,
        period_start: date,
        period_end: date,
        average_attendance: Decimal,
        trend_direction: str = "stable",
        change_percentage: Optional[Decimal] = None,
        student_id: Optional[UUID] = None,
        total_students: Optional[int] = None,
        average_present: Decimal = Decimal("0.00"),
        average_absent: Decimal = Decimal("0.00"),
        average_late: Decimal = Decimal("0.00"),
        forecasted_attendance: Optional[Decimal] = None,
        confidence_score: Optional[Decimal] = None,
        anomaly_detected: bool = False,
        anomaly_details: Optional[Dict[str, Any]] = None,
    ) -> AttendanceTrend:
        """
        Create attendance trend.

        Args:
            hostel_id: Hostel identifier
            trend_type: Trend type (daily, weekly, monthly, quarterly)
            period_identifier: Period identifier (e.g., "2024-01", "2024-W01")
            period_start: Period start date
            period_end: Period end date
            average_attendance: Average attendance percentage
            trend_direction: Trend direction (improving, declining, stable)
            change_percentage: Percentage change from previous period
            student_id: Optional student identifier
            total_students: Total students in calculation
            average_present: Average present count
            average_absent: Average absent count
            average_late: Average late count
            forecasted_attendance: Forecasted attendance
            confidence_score: Forecast confidence score
            anomaly_detected: Anomaly detection flag
            anomaly_details: Anomaly details

        Returns:
            Created trend

        Raises:
            ValidationError: If validation fails
        """
        if period_end < period_start:
            raise ValidationError("period_end must be >= period_start")

        valid_types = ["daily", "weekly", "monthly", "quarterly", "yearly"]
        if trend_type not in valid_types:
            raise ValidationError(f"Invalid trend type. Must be one of: {valid_types}")

        valid_directions = ["improving", "declining", "stable"]
        if trend_direction not in valid_directions:
            raise ValidationError(f"Invalid trend direction. Must be one of: {valid_directions}")

        trend = AttendanceTrend(
            hostel_id=hostel_id,
            student_id=student_id,
            trend_type=trend_type,
            period_identifier=period_identifier,
            period_start=period_start,
            period_end=period_end,
            average_attendance=average_attendance,
            trend_direction=trend_direction,
            change_percentage=change_percentage,
            total_students=total_students,
            average_present=average_present,
            average_absent=average_absent,
            average_late=average_late,
            forecasted_attendance=forecasted_attendance,
            confidence_score=confidence_score,
            anomaly_detected=anomaly_detected,
            anomaly_details=anomaly_details,
            calculated_at=datetime.utcnow(),
        )

        self.session.add(trend)
        self.session.flush()
        return trend

    def get_trend_by_id(
        self,
        trend_id: UUID,
    ) -> Optional[AttendanceTrend]:
        """
        Get trend by ID.

        Args:
            trend_id: Trend identifier

        Returns:
            Trend if found
        """
        return self.session.query(AttendanceTrend).filter(
            AttendanceTrend.id == trend_id
        ).first()

    def get_hostel_trends(
        self,
        hostel_id: UUID,
        trend_type: str,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
        limit: int = 12,
    ) -> List[AttendanceTrend]:
        """
        Get hostel trends.

        Args:
            hostel_id: Hostel identifier
            trend_type: Trend type
            start_date: Optional start date
            end_date: Optional end date
            limit: Maximum number of trends to return

        Returns:
            List of trends
        """
        query = self.session.query(AttendanceTrend).filter(
            and_(
                AttendanceTrend.hostel_id == hostel_id,
                AttendanceTrend.trend_type == trend_type,
                AttendanceTrend.student_id.is_(None),  # Hostel-level trends
            )
        )

        if start_date:
            query = query.filter(AttendanceTrend.period_start >= start_date)
        if end_date:
            query = query.filter(AttendanceTrend.period_end <= end_date)

        return query.order_by(
            AttendanceTrend.period_start.desc()
        ).limit(limit).all()

    def get_student_trends(
        self,
        student_id: UUID,
        trend_type: str,
        limit: int = 12,
    ) -> List[AttendanceTrend]:
        """
        Get student trends.

        Args:
            student_id: Student identifier
            trend_type: Trend type
            limit: Maximum number of trends to return

        Returns:
            List of trends
        """
        return self.session.query(AttendanceTrend).filter(
            and_(
                AttendanceTrend.student_id == student_id,
                AttendanceTrend.trend_type == trend_type,
            )
        ).order_by(
            AttendanceTrend.period_start.desc()
        ).limit(limit).all()

    def get_trend_by_period(
        self,
        hostel_id: UUID,
        trend_type: str,
        period_identifier: str,
        student_id: Optional[UUID] = None,
    ) -> Optional[AttendanceTrend]:
        """
        Get trend for specific period.

        Args:
            hostel_id: Hostel identifier
            trend_type: Trend type
            period_identifier: Period identifier
            student_id: Optional student identifier

        Returns:
            Trend if found
        """
        query = self.session.query(AttendanceTrend).filter(
            and_(
                AttendanceTrend.hostel_id == hostel_id,
                AttendanceTrend.trend_type == trend_type,
                AttendanceTrend.period_identifier == period_identifier,
            )
        )

        if student_id:
            query = query.filter(AttendanceTrend.student_id == student_id)
        else:
            query = query.filter(AttendanceTrend.student_id.is_(None))

        return query.first()

    def get_anomaly_trends(
        self,
        hostel_id: UUID,
        trend_type: Optional[str] = None,
    ) -> List[AttendanceTrend]:
        """
        Get trends with detected anomalies.

        Args:
            hostel_id: Hostel identifier
            trend_type: Optional trend type filter

        Returns:
            List of anomalous trends
        """
        query = self.session.query(AttendanceTrend).filter(
            and_(
                AttendanceTrend.hostel_id == hostel_id,
                AttendanceTrend.anomaly_detected == True,
            )
        )

        if trend_type:
            query = query.filter(AttendanceTrend.trend_type == trend_type)

        return query.order_by(AttendanceTrend.calculated_at.desc()).all()

    def update_trend(
        self,
        trend_id: UUID,
        **update_data: Any,
    ) -> AttendanceTrend:
        """
        Update trend.

        Args:
            trend_id: Trend identifier
            **update_data: Fields to update

        Returns:
            Updated trend

        Raises:
            NotFoundError: If trend not found
        """
        trend = self.get_trend_by_id(trend_id)
        if not trend:
            raise NotFoundError(f"Attendance trend {trend_id} not found")

        for key, value in update_data.items():
            if hasattr(trend, key):
                setattr(trend, key, value)

        trend.calculated_at = datetime.utcnow()
        self.session.flush()
        return trend

    # ==================== Analytics and Statistics ====================

    def get_hostel_overview(
        self,
        hostel_id: UUID,
        period_start: date,
        period_end: date,
    ) -> Dict[str, Any]:
        """
        Get comprehensive hostel attendance overview.

        Args:
            hostel_id: Hostel identifier
            period_start: Period start date
            period_end: Period end date

        Returns:
            Dictionary with overview statistics
        """
        summaries = self.get_hostel_summaries(
            hostel_id=hostel_id,
            period_type="monthly",
            period_start=period_start,
            period_end=period_end,
        )

        if not summaries:
            return {
                "total_students": 0,
                "average_attendance": 0.0,
                "excellent_count": 0,
                "good_count": 0,
                "warning_count": 0,
                "critical_count": 0,
            }

        total_students = len(summaries)
        avg_attendance = sum(s.attendance_percentage for s in summaries) / total_students

        status_counts = {
            "excellent": sum(1 for s in summaries if s.attendance_status == "excellent"),
            "good": sum(1 for s in summaries if s.attendance_status == "good"),
            "warning": sum(1 for s in summaries if s.attendance_status == "warning"),
            "critical": sum(1 for s in summaries if s.attendance_status == "critical"),
        }

        return {
            "total_students": total_students,
            "average_attendance": float(round(avg_attendance, 2)),
            "excellent_count": status_counts["excellent"],
            "good_count": status_counts["good"],
            "warning_count": status_counts["warning"],
            "critical_count": status_counts["critical"],
            "meets_requirement_count": sum(1 for s in summaries if s.meets_minimum_requirement),
            "below_requirement_count": sum(1 for s in summaries if not s.meets_minimum_requirement),
        }

    def get_comparative_analysis(
        self,
        hostel_id: UUID,
        current_period_start: date,
        current_period_end: date,
        previous_period_start: date,
        previous_period_end: date,
    ) -> Dict[str, Any]:
        """
        Get comparative analysis between two periods.

        Args:
            hostel_id: Hostel identifier
            current_period_start: Current period start
            current_period_end: Current period end
            previous_period_start: Previous period start
            previous_period_end: Previous period end

        Returns:
            Dictionary with comparative statistics
        """
        current_summaries = self.get_hostel_summaries(
            hostel_id=hostel_id,
            period_type="monthly",
            period_start=current_period_start,
            period_end=current_period_end,
        )

        previous_summaries = self.get_hostel_summaries(
            hostel_id=hostel_id,
            period_type="monthly",
            period_start=previous_period_start,
            period_end=previous_period_end,
        )

        current_avg = 0.0
        if current_summaries:
            current_avg = sum(s.attendance_percentage for s in current_summaries) / len(current_summaries)

        previous_avg = 0.0
        if previous_summaries:
            previous_avg = sum(s.attendance_percentage for s in previous_summaries) / len(previous_summaries)

        change = current_avg - previous_avg
        change_percentage = (change / previous_avg * 100) if previous_avg > 0 else 0

        return {
            "current_period": {
                "start": current_period_start,
                "end": current_period_end,
                "average_attendance": float(round(current_avg, 2)),
                "total_students": len(current_summaries),
            },
            "previous_period": {
                "start": previous_period_start,
                "end": previous_period_end,
                "average_attendance": float(round(previous_avg, 2)),
                "total_students": len(previous_summaries),
            },
            "change": {
                "absolute": float(round(change, 2)),
                "percentage": float(round(change_percentage, 2)),
                "trend": "improving" if change > 0 else "declining" if change < 0 else "stable",
            },
        }

    def get_top_performers(
        self,
        hostel_id: UUID,
        period_type: str,
        period_start: date,
        period_end: date,
        limit: int = 10,
    ) -> List[AttendanceSummary]:
        """
        Get top performing students by attendance.

        Args:
            hostel_id: Hostel identifier
            period_type: Period type
            period_start: Period start date
            period_end: Period end date
            limit: Number of top performers to return

        Returns:
            List of top performer summaries
        """
        return self.session.query(AttendanceSummary).filter(
            and_(
                AttendanceSummary.hostel_id == hostel_id,
                AttendanceSummary.period_type == period_type,
                AttendanceSummary.period_start == period_start,
                AttendanceSummary.period_end == period_end,
            )
        ).options(joinedload(AttendanceSummary.student)).order_by(
            AttendanceSummary.attendance_percentage.desc(),
            AttendanceSummary.longest_present_streak.desc(),
        ).limit(limit).all()

    def get_bottom_performers(
        self,
        hostel_id: UUID,
        period_type: str,
        period_start: date,
        period_end: date,
        limit: int = 10,
    ) -> List[AttendanceSummary]:
        """
        Get bottom performing students by attendance.

        Args:
            hostel_id: Hostel identifier
            period_type: Period type
            period_start: Period start date
            period_end: Period end date
            limit: Number of bottom performers to return

        Returns:
            List of bottom performer summaries
        """
        return self.session.query(AttendanceSummary).filter(
            and_(
                AttendanceSummary.hostel_id == hostel_id,
                AttendanceSummary.period_type == period_type,
                AttendanceSummary.period_start == period_start,
                AttendanceSummary.period_end == period_end,
            )
        ).options(joinedload(AttendanceSummary.student)).order_by(
            AttendanceSummary.attendance_percentage.asc(),
            AttendanceSummary.longest_absent_streak.desc(),
        ).limit(limit).all()




# --- File: C:\Hostel-Main\app\repositories\attendance\__init__.py ---
# --- File: app/repositories/attendance/__init__.py ---
"""
Attendance repositories package.

Comprehensive repository implementations for attendance management
with advanced querying, analytics, and reporting capabilities.
"""

from app.repositories.attendance.attendance_record_repository import (
    AttendanceRecordRepository,
)
from app.repositories.attendance.attendance_policy_repository import (
    AttendancePolicyRepository,
)
from app.repositories.attendance.attendance_alert_repository import (
    AttendanceAlertRepository,
)
from app.repositories.attendance.attendance_report_repository import (
    AttendanceReportRepository,
)
from app.repositories.attendance.attendance_aggregate_repository import (
    AttendanceAggregateRepository,
)

__all__ = [
    "AttendanceRecordRepository",
    "AttendancePolicyRepository",
    "AttendanceAlertRepository",
    "AttendanceReportRepository",
    "AttendanceAggregateRepository",
]
